import require$$0$3 from 'os';
import require$$0$4 from 'crypto';
import require$$0$5 from 'fs';
import require$$1$6 from 'path';
import * as require$$2$3 from 'http';
import require$$2__default from 'http';
import * as https from 'https';
import https__default from 'https';
import require$$0$a from 'net';
import require$$4$2 from 'tls';
import require$$0$6 from 'events';
import require$$0$8 from 'assert';
import require$$0$7 from 'util';
import require$$0$9, { Readable } from 'stream';
import require$$7 from 'buffer';
import require$$8 from 'querystring';
import require$$14 from 'stream/web';
import require$$0$c from 'node:stream';
import require$$1$2 from 'node:util';
import require$$0$b from 'node:events';
import require$$0$d from 'worker_threads';
import require$$2$4, { performance as performance$1 } from 'perf_hooks';
import require$$5$1 from 'util/types';
import require$$1$3 from 'async_hooks';
import require$$1$4 from 'console';
import require$$1$5 from 'url';
import * as require$$3$2 from 'zlib';
import require$$3__default from 'zlib';
import require$$6$1 from 'string_decoder';
import require$$0$e from 'diagnostics_channel';
import require$$1$7 from 'child_process';
import require$$6$2 from 'timers';
import process$1 from 'process';
import require$$0$f from 'http2';
import require$$1$8 from 'dns';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var core = {};

var command = {};

var utils$3 = {};

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1;
	// We use any as a valid input type
	/* eslint-disable @typescript-eslint/no-explicit-any */
	Object.defineProperty(utils$3, "__esModule", { value: true });
	utils$3.toCommandProperties = utils$3.toCommandValue = undefined;
	/**
	 * Sanitizes an input into a string so it can be passed into issueCommand safely
	 * @param input input to sanitize into a string
	 */
	function toCommandValue(input) {
	    if (input === null || input === undefined) {
	        return '';
	    }
	    else if (typeof input === 'string' || input instanceof String) {
	        return input;
	    }
	    return JSON.stringify(input);
	}
	utils$3.toCommandValue = toCommandValue;
	/**
	 *
	 * @param annotationProperties
	 * @returns The command properties to send with the actual annotation command
	 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	 */
	function toCommandProperties(annotationProperties) {
	    if (!Object.keys(annotationProperties).length) {
	        return {};
	    }
	    return {
	        title: annotationProperties.title,
	        file: annotationProperties.file,
	        line: annotationProperties.startLine,
	        endLine: annotationProperties.endLine,
	        col: annotationProperties.startColumn,
	        endColumn: annotationProperties.endColumn
	    };
	}
	utils$3.toCommandProperties = toCommandProperties;
	
	return utils$3;
}

var hasRequiredCommand;

function requireCommand () {
	if (hasRequiredCommand) return command;
	hasRequiredCommand = 1;
	var __createBinding = (command.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (command.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (command.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(command, "__esModule", { value: true });
	command.issue = command.issueCommand = undefined;
	const os = __importStar(require$$0$3);
	const utils_1 = requireUtils$3();
	/**
	 * Commands
	 *
	 * Command Format:
	 *   ::name key=value,key=value::message
	 *
	 * Examples:
	 *   ::warning::This is the message
	 *   ::set-env name=MY_VAR::some value
	 */
	function issueCommand(command, properties, message) {
	    const cmd = new Command(command, properties, message);
	    process.stdout.write(cmd.toString() + os.EOL);
	}
	command.issueCommand = issueCommand;
	function issue(name, message = '') {
	    issueCommand(name, {}, message);
	}
	command.issue = issue;
	const CMD_STRING = '::';
	class Command {
	    constructor(command, properties, message) {
	        if (!command) {
	            command = 'missing.command';
	        }
	        this.command = command;
	        this.properties = properties;
	        this.message = message;
	    }
	    toString() {
	        let cmdStr = CMD_STRING + this.command;
	        if (this.properties && Object.keys(this.properties).length > 0) {
	            cmdStr += ' ';
	            let first = true;
	            for (const key in this.properties) {
	                if (this.properties.hasOwnProperty(key)) {
	                    const val = this.properties[key];
	                    if (val) {
	                        if (first) {
	                            first = false;
	                        }
	                        else {
	                            cmdStr += ',';
	                        }
	                        cmdStr += `${key}=${escapeProperty(val)}`;
	                    }
	                }
	            }
	        }
	        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
	        return cmdStr;
	    }
	}
	function escapeData(s) {
	    return (0, utils_1.toCommandValue)(s)
	        .replace(/%/g, '%25')
	        .replace(/\r/g, '%0D')
	        .replace(/\n/g, '%0A');
	}
	function escapeProperty(s) {
	    return (0, utils_1.toCommandValue)(s)
	        .replace(/%/g, '%25')
	        .replace(/\r/g, '%0D')
	        .replace(/\n/g, '%0A')
	        .replace(/:/g, '%3A')
	        .replace(/,/g, '%2C');
	}
	
	return command;
}

var fileCommand = {};

var hasRequiredFileCommand;

function requireFileCommand () {
	if (hasRequiredFileCommand) return fileCommand;
	hasRequiredFileCommand = 1;
	// For internal use, subject to change.
	var __createBinding = (fileCommand.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (fileCommand.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (fileCommand.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(fileCommand, "__esModule", { value: true });
	fileCommand.prepareKeyValueMessage = fileCommand.issueFileCommand = undefined;
	// We use any as a valid input type
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const crypto = __importStar(require$$0$4);
	const fs = __importStar(require$$0$5);
	const os = __importStar(require$$0$3);
	const utils_1 = requireUtils$3();
	function issueFileCommand(command, message) {
	    const filePath = process.env[`GITHUB_${command}`];
	    if (!filePath) {
	        throw new Error(`Unable to find environment variable for file command ${command}`);
	    }
	    if (!fs.existsSync(filePath)) {
	        throw new Error(`Missing file at path: ${filePath}`);
	    }
	    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
	        encoding: 'utf8'
	    });
	}
	fileCommand.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
	    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
	    const convertedValue = (0, utils_1.toCommandValue)(value);
	    // These should realistically never happen, but just in case someone finds a
	    // way to exploit uuid generation let's not allow keys or values that contain
	    // the delimiter.
	    if (key.includes(delimiter)) {
	        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
	    }
	    if (convertedValue.includes(delimiter)) {
	        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
	    }
	    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
	}
	fileCommand.prepareKeyValueMessage = prepareKeyValueMessage;
	
	return fileCommand;
}

var oidcUtils = {};

var lib = {};

var proxy = {};

var hasRequiredProxy;

function requireProxy () {
	if (hasRequiredProxy) return proxy;
	hasRequiredProxy = 1;
	Object.defineProperty(proxy, "__esModule", { value: true });
	proxy.checkBypass = proxy.getProxyUrl = undefined;
	function getProxyUrl(reqUrl) {
	    const usingSsl = reqUrl.protocol === 'https:';
	    if (checkBypass(reqUrl)) {
	        return undefined;
	    }
	    const proxyVar = (() => {
	        if (usingSsl) {
	            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
	        }
	        else {
	            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
	        }
	    })();
	    if (proxyVar) {
	        try {
	            return new URL(proxyVar);
	        }
	        catch (_a) {
	            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
	                return new URL(`http://${proxyVar}`);
	        }
	    }
	    else {
	        return undefined;
	    }
	}
	proxy.getProxyUrl = getProxyUrl;
	function checkBypass(reqUrl) {
	    if (!reqUrl.hostname) {
	        return false;
	    }
	    const reqHost = reqUrl.hostname;
	    if (isLoopbackAddress(reqHost)) {
	        return true;
	    }
	    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
	    if (!noProxy) {
	        return false;
	    }
	    // Determine the request port
	    let reqPort;
	    if (reqUrl.port) {
	        reqPort = Number(reqUrl.port);
	    }
	    else if (reqUrl.protocol === 'http:') {
	        reqPort = 80;
	    }
	    else if (reqUrl.protocol === 'https:') {
	        reqPort = 443;
	    }
	    // Format the request hostname and hostname with port
	    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
	    if (typeof reqPort === 'number') {
	        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
	    }
	    // Compare request host against noproxy
	    for (const upperNoProxyItem of noProxy
	        .split(',')
	        .map(x => x.trim().toUpperCase())
	        .filter(x => x)) {
	        if (upperNoProxyItem === '*' ||
	            upperReqHosts.some(x => x === upperNoProxyItem ||
	                x.endsWith(`.${upperNoProxyItem}`) ||
	                (upperNoProxyItem.startsWith('.') &&
	                    x.endsWith(`${upperNoProxyItem}`)))) {
	            return true;
	        }
	    }
	    return false;
	}
	proxy.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
	    const hostLower = host.toLowerCase();
	    return (hostLower === 'localhost' ||
	        hostLower.startsWith('127.') ||
	        hostLower.startsWith('[::1]') ||
	        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
	}
	
	return proxy;
}

var tunnel$1 = {};

var hasRequiredTunnel$1;

function requireTunnel$1 () {
	if (hasRequiredTunnel$1) return tunnel$1;
	hasRequiredTunnel$1 = 1;
	var tls = require$$4$2;
	var http = require$$2__default;
	var https = https__default;
	var events = require$$0$6;
	var util = require$$0$7;


	tunnel$1.httpOverHttp = httpOverHttp;
	tunnel$1.httpsOverHttp = httpsOverHttp;
	tunnel$1.httpOverHttps = httpOverHttps;
	tunnel$1.httpsOverHttps = httpsOverHttps;


	function httpOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  return agent;
	}

	function httpsOverHttp(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = http.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent;
	}

	function httpOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  return agent;
	}

	function httpsOverHttps(options) {
	  var agent = new TunnelingAgent(options);
	  agent.request = https.request;
	  agent.createSocket = createSecureSocket;
	  agent.defaultPort = 443;
	  return agent;
	}


	function TunnelingAgent(options) {
	  var self = this;
	  self.options = options || {};
	  self.proxyOptions = self.options.proxy || {};
	  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
	  self.requests = [];
	  self.sockets = [];

	  self.on('free', function onFree(socket, host, port, localAddress) {
	    var options = toOptions(host, port, localAddress);
	    for (var i = 0, len = self.requests.length; i < len; ++i) {
	      var pending = self.requests[i];
	      if (pending.host === options.host && pending.port === options.port) {
	        // Detect the request to connect same origin server,
	        // reuse the connection.
	        self.requests.splice(i, 1);
	        pending.request.onSocket(socket);
	        return;
	      }
	    }
	    socket.destroy();
	    self.removeSocket(socket);
	  });
	}
	util.inherits(TunnelingAgent, events.EventEmitter);

	TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
	  var self = this;
	  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

	  if (self.sockets.length >= this.maxSockets) {
	    // We are over limit so we'll add it to the queue.
	    self.requests.push(options);
	    return;
	  }

	  // If we are under maxSockets create a new one.
	  self.createSocket(options, function(socket) {
	    socket.on('free', onFree);
	    socket.on('close', onCloseOrRemove);
	    socket.on('agentRemove', onCloseOrRemove);
	    req.onSocket(socket);

	    function onFree() {
	      self.emit('free', socket, options);
	    }

	    function onCloseOrRemove(err) {
	      self.removeSocket(socket);
	      socket.removeListener('free', onFree);
	      socket.removeListener('close', onCloseOrRemove);
	      socket.removeListener('agentRemove', onCloseOrRemove);
	    }
	  });
	};

	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
	  var self = this;
	  var placeholder = {};
	  self.sockets.push(placeholder);

	  var connectOptions = mergeOptions({}, self.proxyOptions, {
	    method: 'CONNECT',
	    path: options.host + ':' + options.port,
	    agent: false,
	    headers: {
	      host: options.host + ':' + options.port
	    }
	  });
	  if (options.localAddress) {
	    connectOptions.localAddress = options.localAddress;
	  }
	  if (connectOptions.proxyAuth) {
	    connectOptions.headers = connectOptions.headers || {};
	    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
	        new Buffer(connectOptions.proxyAuth).toString('base64');
	  }

	  debug('making CONNECT request');
	  var connectReq = self.request(connectOptions);
	  connectReq.useChunkedEncodingByDefault = false; // for v0.6
	  connectReq.once('response', onResponse); // for v0.6
	  connectReq.once('upgrade', onUpgrade);   // for v0.6
	  connectReq.once('connect', onConnect);   // for v0.7 or later
	  connectReq.once('error', onError);
	  connectReq.end();

	  function onResponse(res) {
	    // Very hacky. This is necessary to avoid http-parser leaks.
	    res.upgrade = true;
	  }

	  function onUpgrade(res, socket, head) {
	    // Hacky.
	    process.nextTick(function() {
	      onConnect(res, socket, head);
	    });
	  }

	  function onConnect(res, socket, head) {
	    connectReq.removeAllListeners();
	    socket.removeAllListeners();

	    if (res.statusCode !== 200) {
	      debug('tunneling socket could not be established, statusCode=%d',
	        res.statusCode);
	      socket.destroy();
	      var error = new Error('tunneling socket could not be established, ' +
	        'statusCode=' + res.statusCode);
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	      return;
	    }
	    if (head.length > 0) {
	      debug('got illegal response body from proxy');
	      socket.destroy();
	      var error = new Error('got illegal response body from proxy');
	      error.code = 'ECONNRESET';
	      options.request.emit('error', error);
	      self.removeSocket(placeholder);
	      return;
	    }
	    debug('tunneling connection has established');
	    self.sockets[self.sockets.indexOf(placeholder)] = socket;
	    return cb(socket);
	  }

	  function onError(cause) {
	    connectReq.removeAllListeners();

	    debug('tunneling socket could not be established, cause=%s\n',
	          cause.message, cause.stack);
	    var error = new Error('tunneling socket could not be established, ' +
	                          'cause=' + cause.message);
	    error.code = 'ECONNRESET';
	    options.request.emit('error', error);
	    self.removeSocket(placeholder);
	  }
	};

	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
	  var pos = this.sockets.indexOf(socket);
	  if (pos === -1) {
	    return;
	  }
	  this.sockets.splice(pos, 1);

	  var pending = this.requests.shift();
	  if (pending) {
	    // If we have pending requests and a socket gets closed a new one
	    // needs to be created to take over in the pool for the one that closed.
	    this.createSocket(pending, function(socket) {
	      pending.request.onSocket(socket);
	    });
	  }
	};

	function createSecureSocket(options, cb) {
	  var self = this;
	  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
	    var hostHeader = options.request.getHeader('host');
	    var tlsOptions = mergeOptions({}, self.options, {
	      socket: socket,
	      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
	    });

	    // 0 is dummy port for v0.6
	    var secureSocket = tls.connect(0, tlsOptions);
	    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
	    cb(secureSocket);
	  });
	}


	function toOptions(host, port, localAddress) {
	  if (typeof host === 'string') { // since v0.10
	    return {
	      host: host,
	      port: port,
	      localAddress: localAddress
	    };
	  }
	  return host; // for v0.11 or later
	}

	function mergeOptions(target) {
	  for (var i = 1, len = arguments.length; i < len; ++i) {
	    var overrides = arguments[i];
	    if (typeof overrides === 'object') {
	      var keys = Object.keys(overrides);
	      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
	        var k = keys[j];
	        if (overrides[k] !== undefined) {
	          target[k] = overrides[k];
	        }
	      }
	    }
	  }
	  return target;
	}


	var debug;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
	  debug = function() {
	    var args = Array.prototype.slice.call(arguments);
	    if (typeof args[0] === 'string') {
	      args[0] = 'TUNNEL: ' + args[0];
	    } else {
	      args.unshift('TUNNEL:');
	    }
	    console.error.apply(console, args);
	  };
	} else {
	  debug = function() {};
	}
	tunnel$1.debug = debug; // for test
	return tunnel$1;
}

var tunnel;
var hasRequiredTunnel;

function requireTunnel () {
	if (hasRequiredTunnel) return tunnel;
	hasRequiredTunnel = 1;
	tunnel = requireTunnel$1();
	return tunnel;
}

var undici = {};

var symbols$4;
var hasRequiredSymbols$4;

function requireSymbols$4 () {
	if (hasRequiredSymbols$4) return symbols$4;
	hasRequiredSymbols$4 = 1;
	symbols$4 = {
	  kClose: Symbol('close'),
	  kDestroy: Symbol('destroy'),
	  kDispatch: Symbol('dispatch'),
	  kUrl: Symbol('url'),
	  kWriting: Symbol('writing'),
	  kResuming: Symbol('resuming'),
	  kQueue: Symbol('queue'),
	  kConnect: Symbol('connect'),
	  kConnecting: Symbol('connecting'),
	  kHeadersList: Symbol('headers list'),
	  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
	  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
	  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
	  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
	  kKeepAlive: Symbol('keep alive'),
	  kHeadersTimeout: Symbol('headers timeout'),
	  kBodyTimeout: Symbol('body timeout'),
	  kServerName: Symbol('server name'),
	  kLocalAddress: Symbol('local address'),
	  kHost: Symbol('host'),
	  kNoRef: Symbol('no ref'),
	  kBodyUsed: Symbol('used'),
	  kRunning: Symbol('running'),
	  kBlocking: Symbol('blocking'),
	  kPending: Symbol('pending'),
	  kSize: Symbol('size'),
	  kBusy: Symbol('busy'),
	  kQueued: Symbol('queued'),
	  kFree: Symbol('free'),
	  kConnected: Symbol('connected'),
	  kClosed: Symbol('closed'),
	  kNeedDrain: Symbol('need drain'),
	  kReset: Symbol('reset'),
	  kDestroyed: Symbol.for('nodejs.stream.destroyed'),
	  kMaxHeadersSize: Symbol('max headers size'),
	  kRunningIdx: Symbol('running index'),
	  kPendingIdx: Symbol('pending index'),
	  kError: Symbol('error'),
	  kClients: Symbol('clients'),
	  kClient: Symbol('client'),
	  kParser: Symbol('parser'),
	  kOnDestroyed: Symbol('destroy callbacks'),
	  kPipelining: Symbol('pipelining'),
	  kSocket: Symbol('socket'),
	  kHostHeader: Symbol('host header'),
	  kConnector: Symbol('connector'),
	  kStrictContentLength: Symbol('strict content length'),
	  kMaxRedirections: Symbol('maxRedirections'),
	  kMaxRequests: Symbol('maxRequestsPerClient'),
	  kProxy: Symbol('proxy agent options'),
	  kCounter: Symbol('socket request counter'),
	  kInterceptors: Symbol('dispatch interceptors'),
	  kMaxResponseSize: Symbol('max response size'),
	  kHTTP2Session: Symbol('http2Session'),
	  kHTTP2SessionState: Symbol('http2Session state'),
	  kHTTP2BuildRequest: Symbol('http2 build request'),
	  kHTTP1BuildRequest: Symbol('http1 build request'),
	  kHTTP2CopyHeaders: Symbol('http2 copy headers'),
	  kHTTPConnVersion: Symbol('http connection version'),
	  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),
	  kConstruct: Symbol('constructable')
	};
	return symbols$4;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	class UndiciError extends Error {
	  constructor (message) {
	    super(message);
	    this.name = 'UndiciError';
	    this.code = 'UND_ERR';
	  }
	}

	class ConnectTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ConnectTimeoutError);
	    this.name = 'ConnectTimeoutError';
	    this.message = message || 'Connect Timeout Error';
	    this.code = 'UND_ERR_CONNECT_TIMEOUT';
	  }
	}

	class HeadersTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, HeadersTimeoutError);
	    this.name = 'HeadersTimeoutError';
	    this.message = message || 'Headers Timeout Error';
	    this.code = 'UND_ERR_HEADERS_TIMEOUT';
	  }
	}

	class HeadersOverflowError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, HeadersOverflowError);
	    this.name = 'HeadersOverflowError';
	    this.message = message || 'Headers Overflow Error';
	    this.code = 'UND_ERR_HEADERS_OVERFLOW';
	  }
	}

	class BodyTimeoutError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, BodyTimeoutError);
	    this.name = 'BodyTimeoutError';
	    this.message = message || 'Body Timeout Error';
	    this.code = 'UND_ERR_BODY_TIMEOUT';
	  }
	}

	class ResponseStatusCodeError extends UndiciError {
	  constructor (message, statusCode, headers, body) {
	    super(message);
	    Error.captureStackTrace(this, ResponseStatusCodeError);
	    this.name = 'ResponseStatusCodeError';
	    this.message = message || 'Response Status Code Error';
	    this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
	    this.body = body;
	    this.status = statusCode;
	    this.statusCode = statusCode;
	    this.headers = headers;
	  }
	}

	class InvalidArgumentError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InvalidArgumentError);
	    this.name = 'InvalidArgumentError';
	    this.message = message || 'Invalid Argument Error';
	    this.code = 'UND_ERR_INVALID_ARG';
	  }
	}

	class InvalidReturnValueError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InvalidReturnValueError);
	    this.name = 'InvalidReturnValueError';
	    this.message = message || 'Invalid Return Value Error';
	    this.code = 'UND_ERR_INVALID_RETURN_VALUE';
	  }
	}

	class RequestAbortedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, RequestAbortedError);
	    this.name = 'AbortError';
	    this.message = message || 'Request aborted';
	    this.code = 'UND_ERR_ABORTED';
	  }
	}

	class InformationalError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, InformationalError);
	    this.name = 'InformationalError';
	    this.message = message || 'Request information';
	    this.code = 'UND_ERR_INFO';
	  }
	}

	class RequestContentLengthMismatchError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, RequestContentLengthMismatchError);
	    this.name = 'RequestContentLengthMismatchError';
	    this.message = message || 'Request body length does not match content-length header';
	    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
	  }
	}

	class ResponseContentLengthMismatchError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ResponseContentLengthMismatchError);
	    this.name = 'ResponseContentLengthMismatchError';
	    this.message = message || 'Response body length does not match content-length header';
	    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
	  }
	}

	class ClientDestroyedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ClientDestroyedError);
	    this.name = 'ClientDestroyedError';
	    this.message = message || 'The client is destroyed';
	    this.code = 'UND_ERR_DESTROYED';
	  }
	}

	class ClientClosedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ClientClosedError);
	    this.name = 'ClientClosedError';
	    this.message = message || 'The client is closed';
	    this.code = 'UND_ERR_CLOSED';
	  }
	}

	class SocketError extends UndiciError {
	  constructor (message, socket) {
	    super(message);
	    Error.captureStackTrace(this, SocketError);
	    this.name = 'SocketError';
	    this.message = message || 'Socket error';
	    this.code = 'UND_ERR_SOCKET';
	    this.socket = socket;
	  }
	}

	class NotSupportedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, NotSupportedError);
	    this.name = 'NotSupportedError';
	    this.message = message || 'Not supported error';
	    this.code = 'UND_ERR_NOT_SUPPORTED';
	  }
	}

	class BalancedPoolMissingUpstreamError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, NotSupportedError);
	    this.name = 'MissingUpstreamError';
	    this.message = message || 'No upstream has been added to the BalancedPool';
	    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
	  }
	}

	class HTTPParserError extends Error {
	  constructor (message, code, data) {
	    super(message);
	    Error.captureStackTrace(this, HTTPParserError);
	    this.name = 'HTTPParserError';
	    this.code = code ? `HPE_${code}` : undefined;
	    this.data = data ? data.toString() : undefined;
	  }
	}

	class ResponseExceededMaxSizeError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, ResponseExceededMaxSizeError);
	    this.name = 'ResponseExceededMaxSizeError';
	    this.message = message || 'Response content exceeded max size';
	    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
	  }
	}

	class RequestRetryError extends UndiciError {
	  constructor (message, code, { headers, data }) {
	    super(message);
	    Error.captureStackTrace(this, RequestRetryError);
	    this.name = 'RequestRetryError';
	    this.message = message || 'Request retry error';
	    this.code = 'UND_ERR_REQ_RETRY';
	    this.statusCode = code;
	    this.data = data;
	    this.headers = headers;
	  }
	}

	errors = {
	  HTTPParserError,
	  UndiciError,
	  HeadersTimeoutError,
	  HeadersOverflowError,
	  BodyTimeoutError,
	  RequestContentLengthMismatchError,
	  ConnectTimeoutError,
	  ResponseStatusCodeError,
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError,
	  ClientDestroyedError,
	  ClientClosedError,
	  InformationalError,
	  SocketError,
	  NotSupportedError,
	  ResponseContentLengthMismatchError,
	  BalancedPoolMissingUpstreamError,
	  ResponseExceededMaxSizeError,
	  RequestRetryError
	};
	return errors;
}

var constants$5;
var hasRequiredConstants$5;

function requireConstants$5 () {
	if (hasRequiredConstants$5) return constants$5;
	hasRequiredConstants$5 = 1;

	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord = {};

	// https://developer.mozilla.org/docs/Web/HTTP/Headers
	const wellknownHeaderNames = [
	  'Accept',
	  'Accept-Encoding',
	  'Accept-Language',
	  'Accept-Ranges',
	  'Access-Control-Allow-Credentials',
	  'Access-Control-Allow-Headers',
	  'Access-Control-Allow-Methods',
	  'Access-Control-Allow-Origin',
	  'Access-Control-Expose-Headers',
	  'Access-Control-Max-Age',
	  'Access-Control-Request-Headers',
	  'Access-Control-Request-Method',
	  'Age',
	  'Allow',
	  'Alt-Svc',
	  'Alt-Used',
	  'Authorization',
	  'Cache-Control',
	  'Clear-Site-Data',
	  'Connection',
	  'Content-Disposition',
	  'Content-Encoding',
	  'Content-Language',
	  'Content-Length',
	  'Content-Location',
	  'Content-Range',
	  'Content-Security-Policy',
	  'Content-Security-Policy-Report-Only',
	  'Content-Type',
	  'Cookie',
	  'Cross-Origin-Embedder-Policy',
	  'Cross-Origin-Opener-Policy',
	  'Cross-Origin-Resource-Policy',
	  'Date',
	  'Device-Memory',
	  'Downlink',
	  'ECT',
	  'ETag',
	  'Expect',
	  'Expect-CT',
	  'Expires',
	  'Forwarded',
	  'From',
	  'Host',
	  'If-Match',
	  'If-Modified-Since',
	  'If-None-Match',
	  'If-Range',
	  'If-Unmodified-Since',
	  'Keep-Alive',
	  'Last-Modified',
	  'Link',
	  'Location',
	  'Max-Forwards',
	  'Origin',
	  'Permissions-Policy',
	  'Pragma',
	  'Proxy-Authenticate',
	  'Proxy-Authorization',
	  'RTT',
	  'Range',
	  'Referer',
	  'Referrer-Policy',
	  'Refresh',
	  'Retry-After',
	  'Sec-WebSocket-Accept',
	  'Sec-WebSocket-Extensions',
	  'Sec-WebSocket-Key',
	  'Sec-WebSocket-Protocol',
	  'Sec-WebSocket-Version',
	  'Server',
	  'Server-Timing',
	  'Service-Worker-Allowed',
	  'Service-Worker-Navigation-Preload',
	  'Set-Cookie',
	  'SourceMap',
	  'Strict-Transport-Security',
	  'Supports-Loading-Mode',
	  'TE',
	  'Timing-Allow-Origin',
	  'Trailer',
	  'Transfer-Encoding',
	  'Upgrade',
	  'Upgrade-Insecure-Requests',
	  'User-Agent',
	  'Vary',
	  'Via',
	  'WWW-Authenticate',
	  'X-Content-Type-Options',
	  'X-DNS-Prefetch-Control',
	  'X-Frame-Options',
	  'X-Permitted-Cross-Domain-Policies',
	  'X-Powered-By',
	  'X-Requested-With',
	  'X-XSS-Protection'
	];

	for (let i = 0; i < wellknownHeaderNames.length; ++i) {
	  const key = wellknownHeaderNames[i];
	  const lowerCasedKey = key.toLowerCase();
	  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =
	    lowerCasedKey;
	}

	// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
	Object.setPrototypeOf(headerNameLowerCasedRecord, null);

	constants$5 = {
	  wellknownHeaderNames,
	  headerNameLowerCasedRecord
	};
	return constants$5;
}

var util$8;
var hasRequiredUtil$8;

function requireUtil$8 () {
	if (hasRequiredUtil$8) return util$8;
	hasRequiredUtil$8 = 1;

	const assert = require$$0$8;
	const { kDestroyed, kBodyUsed } = requireSymbols$4();
	const { IncomingMessage } = require$$2__default;
	const stream = require$$0$9;
	const net = require$$0$a;
	const { InvalidArgumentError } = requireErrors();
	const { Blob } = require$$7;
	const nodeUtil = require$$0$7;
	const { stringify } = require$$8;
	const { headerNameLowerCasedRecord } = requireConstants$5();

	const [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v));

	function nop () {}

	function isStream (obj) {
	  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'
	}

	// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
	function isBlobLike (object) {
	  return (Blob && object instanceof Blob) || (
	    object &&
	    typeof object === 'object' &&
	    (typeof object.stream === 'function' ||
	      typeof object.arrayBuffer === 'function') &&
	    /^(Blob|File)$/.test(object[Symbol.toStringTag])
	  )
	}

	function buildURL (url, queryParams) {
	  if (url.includes('?') || url.includes('#')) {
	    throw new Error('Query params cannot be passed when url already contains "?" or "#".')
	  }

	  const stringified = stringify(queryParams);

	  if (stringified) {
	    url += '?' + stringified;
	  }

	  return url
	}

	function parseURL (url) {
	  if (typeof url === 'string') {
	    url = new URL(url);

	    if (!/^https?:/.test(url.origin || url.protocol)) {
	      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
	    }

	    return url
	  }

	  if (!url || typeof url !== 'object') {
	    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')
	  }

	  if (!/^https?:/.test(url.origin || url.protocol)) {
	    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')
	  }

	  if (!(url instanceof URL)) {
	    if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
	      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')
	    }

	    if (url.path != null && typeof url.path !== 'string') {
	      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')
	    }

	    if (url.pathname != null && typeof url.pathname !== 'string') {
	      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')
	    }

	    if (url.hostname != null && typeof url.hostname !== 'string') {
	      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')
	    }

	    if (url.origin != null && typeof url.origin !== 'string') {
	      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')
	    }

	    const port = url.port != null
	      ? url.port
	      : (url.protocol === 'https:' ? 443 : 80);
	    let origin = url.origin != null
	      ? url.origin
	      : `${url.protocol}//${url.hostname}:${port}`;
	    let path = url.path != null
	      ? url.path
	      : `${url.pathname || ''}${url.search || ''}`;

	    if (origin.endsWith('/')) {
	      origin = origin.substring(0, origin.length - 1);
	    }

	    if (path && !path.startsWith('/')) {
	      path = `/${path}`;
	    }
	    // new URL(path, origin) is unsafe when `path` contains an absolute URL
	    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:
	    // If first parameter is a relative URL, second param is required, and will be used as the base URL.
	    // If first parameter is an absolute URL, a given second param will be ignored.
	    url = new URL(origin + path);
	  }

	  return url
	}

	function parseOrigin (url) {
	  url = parseURL(url);

	  if (url.pathname !== '/' || url.search || url.hash) {
	    throw new InvalidArgumentError('invalid url')
	  }

	  return url
	}

	function getHostname (host) {
	  if (host[0] === '[') {
	    const idx = host.indexOf(']');

	    assert(idx !== -1);
	    return host.substring(1, idx)
	  }

	  const idx = host.indexOf(':');
	  if (idx === -1) return host

	  return host.substring(0, idx)
	}

	// IP addresses are not valid server names per RFC6066
	// > Currently, the only server names supported are DNS hostnames
	function getServerName (host) {
	  if (!host) {
	    return null
	  }

	  assert.strictEqual(typeof host, 'string');

	  const servername = getHostname(host);
	  if (net.isIP(servername)) {
	    return ''
	  }

	  return servername
	}

	function deepClone (obj) {
	  return JSON.parse(JSON.stringify(obj))
	}

	function isAsyncIterable (obj) {
	  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')
	}

	function isIterable (obj) {
	  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))
	}

	function bodyLength (body) {
	  if (body == null) {
	    return 0
	  } else if (isStream(body)) {
	    const state = body._readableState;
	    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)
	      ? state.length
	      : null
	  } else if (isBlobLike(body)) {
	    return body.size != null ? body.size : null
	  } else if (isBuffer(body)) {
	    return body.byteLength
	  }

	  return null
	}

	function isDestroyed (stream) {
	  return !stream || !!(stream.destroyed || stream[kDestroyed])
	}

	function isReadableAborted (stream) {
	  const state = stream && stream._readableState;
	  return isDestroyed(stream) && state && !state.endEmitted
	}

	function destroy (stream, err) {
	  if (stream == null || !isStream(stream) || isDestroyed(stream)) {
	    return
	  }

	  if (typeof stream.destroy === 'function') {
	    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
	      // See: https://github.com/nodejs/node/pull/38505/files
	      stream.socket = null;
	    }

	    stream.destroy(err);
	  } else if (err) {
	    process.nextTick((stream, err) => {
	      stream.emit('error', err);
	    }, stream, err);
	  }

	  if (stream.destroyed !== true) {
	    stream[kDestroyed] = true;
	  }
	}

	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout (val) {
	  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
	  return m ? parseInt(m[1], 10) * 1000 : null
	}

	/**
	 * Retrieves a header name and returns its lowercase value.
	 * @param {string | Buffer} value Header name
	 * @returns {string}
	 */
	function headerNameToString (value) {
	  return headerNameLowerCasedRecord[value] || value.toLowerCase()
	}

	function parseHeaders (headers, obj = {}) {
	  // For H2 support
	  if (!Array.isArray(headers)) return headers

	  for (let i = 0; i < headers.length; i += 2) {
	    const key = headers[i].toString().toLowerCase();
	    let val = obj[key];

	    if (!val) {
	      if (Array.isArray(headers[i + 1])) {
	        obj[key] = headers[i + 1].map(x => x.toString('utf8'));
	      } else {
	        obj[key] = headers[i + 1].toString('utf8');
	      }
	    } else {
	      if (!Array.isArray(val)) {
	        val = [val];
	        obj[key] = val;
	      }
	      val.push(headers[i + 1].toString('utf8'));
	    }
	  }

	  // See https://github.com/nodejs/node/pull/46528
	  if ('content-length' in obj && 'content-disposition' in obj) {
	    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1');
	  }

	  return obj
	}

	function parseRawHeaders (headers) {
	  const ret = [];
	  let hasContentLength = false;
	  let contentDispositionIdx = -1;

	  for (let n = 0; n < headers.length; n += 2) {
	    const key = headers[n + 0].toString();
	    const val = headers[n + 1].toString('utf8');

	    if (key.length === 14 && (key === 'content-length' || key.toLowerCase() === 'content-length')) {
	      ret.push(key, val);
	      hasContentLength = true;
	    } else if (key.length === 19 && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {
	      contentDispositionIdx = ret.push(key, val) - 1;
	    } else {
	      ret.push(key, val);
	    }
	  }

	  // See https://github.com/nodejs/node/pull/46528
	  if (hasContentLength && contentDispositionIdx !== -1) {
	    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1');
	  }

	  return ret
	}

	function isBuffer (buffer) {
	  // See, https://github.com/mcollina/undici/pull/319
	  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)
	}

	function validateHandler (handler, method, upgrade) {
	  if (!handler || typeof handler !== 'object') {
	    throw new InvalidArgumentError('handler must be an object')
	  }

	  if (typeof handler.onConnect !== 'function') {
	    throw new InvalidArgumentError('invalid onConnect method')
	  }

	  if (typeof handler.onError !== 'function') {
	    throw new InvalidArgumentError('invalid onError method')
	  }

	  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {
	    throw new InvalidArgumentError('invalid onBodySent method')
	  }

	  if (upgrade || method === 'CONNECT') {
	    if (typeof handler.onUpgrade !== 'function') {
	      throw new InvalidArgumentError('invalid onUpgrade method')
	    }
	  } else {
	    if (typeof handler.onHeaders !== 'function') {
	      throw new InvalidArgumentError('invalid onHeaders method')
	    }

	    if (typeof handler.onData !== 'function') {
	      throw new InvalidArgumentError('invalid onData method')
	    }

	    if (typeof handler.onComplete !== 'function') {
	      throw new InvalidArgumentError('invalid onComplete method')
	    }
	  }
	}

	// A body is disturbed if it has been read from and it cannot
	// be re-used without losing state or data.
	function isDisturbed (body) {
	  return !!(body && (
	    stream.isDisturbed
	      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?
	      : body[kBodyUsed] ||
	        body.readableDidRead ||
	        (body._readableState && body._readableState.dataEmitted) ||
	        isReadableAborted(body)
	  ))
	}

	function isErrored (body) {
	  return !!(body && (
	    stream.isErrored
	      ? stream.isErrored(body)
	      : /state: 'errored'/.test(nodeUtil.inspect(body)
	      )))
	}

	function isReadable (body) {
	  return !!(body && (
	    stream.isReadable
	      ? stream.isReadable(body)
	      : /state: 'readable'/.test(nodeUtil.inspect(body)
	      )))
	}

	function getSocketInfo (socket) {
	  return {
	    localAddress: socket.localAddress,
	    localPort: socket.localPort,
	    remoteAddress: socket.remoteAddress,
	    remotePort: socket.remotePort,
	    remoteFamily: socket.remoteFamily,
	    timeout: socket.timeout,
	    bytesWritten: socket.bytesWritten,
	    bytesRead: socket.bytesRead
	  }
	}

	async function * convertIterableToBuffer (iterable) {
	  for await (const chunk of iterable) {
	    yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	  }
	}

	let ReadableStream;
	function ReadableStreamFrom (iterable) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  if (ReadableStream.from) {
	    return ReadableStream.from(convertIterableToBuffer(iterable))
	  }

	  let iterator;
	  return new ReadableStream(
	    {
	      async start () {
	        iterator = iterable[Symbol.asyncIterator]();
	      },
	      async pull (controller) {
	        const { done, value } = await iterator.next();
	        if (done) {
	          queueMicrotask(() => {
	            controller.close();
	          });
	        } else {
	          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
	          controller.enqueue(new Uint8Array(buf));
	        }
	        return controller.desiredSize > 0
	      },
	      async cancel (reason) {
	        await iterator.return();
	      }
	    },
	    0
	  )
	}

	// The chunk should be a FormData instance and contains
	// all the required methods.
	function isFormDataLike (object) {
	  return (
	    object &&
	    typeof object === 'object' &&
	    typeof object.append === 'function' &&
	    typeof object.delete === 'function' &&
	    typeof object.get === 'function' &&
	    typeof object.getAll === 'function' &&
	    typeof object.has === 'function' &&
	    typeof object.set === 'function' &&
	    object[Symbol.toStringTag] === 'FormData'
	  )
	}

	function throwIfAborted (signal) {
	  if (!signal) { return }
	  if (typeof signal.throwIfAborted === 'function') {
	    signal.throwIfAborted();
	  } else {
	    if (signal.aborted) {
	      // DOMException not available < v17.0.0
	      const err = new Error('The operation was aborted');
	      err.name = 'AbortError';
	      throw err
	    }
	  }
	}

	function addAbortListener (signal, listener) {
	  if ('addEventListener' in signal) {
	    signal.addEventListener('abort', listener, { once: true });
	    return () => signal.removeEventListener('abort', listener)
	  }
	  signal.addListener('abort', listener);
	  return () => signal.removeListener('abort', listener)
	}

	const hasToWellFormed = !!String.prototype.toWellFormed;

	/**
	 * @param {string} val
	 */
	function toUSVString (val) {
	  if (hasToWellFormed) {
	    return `${val}`.toWellFormed()
	  } else if (nodeUtil.toUSVString) {
	    return nodeUtil.toUSVString(val)
	  }

	  return `${val}`
	}

	// Parsed accordingly to RFC 9110
	// https://www.rfc-editor.org/rfc/rfc9110#field.content-range
	function parseRangeHeader (range) {
	  if (range == null || range === '') return { start: 0, end: null, size: null }

	  const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
	  return m
	    ? {
	        start: parseInt(m[1]),
	        end: m[2] ? parseInt(m[2]) : null,
	        size: m[3] ? parseInt(m[3]) : null
	      }
	    : null
	}

	const kEnumerableProperty = Object.create(null);
	kEnumerableProperty.enumerable = true;

	util$8 = {
	  kEnumerableProperty,
	  nop,
	  isDisturbed,
	  isErrored,
	  isReadable,
	  toUSVString,
	  isReadableAborted,
	  isBlobLike,
	  parseOrigin,
	  parseURL,
	  getServerName,
	  isStream,
	  isIterable,
	  isAsyncIterable,
	  isDestroyed,
	  headerNameToString,
	  parseRawHeaders,
	  parseHeaders,
	  parseKeepAliveTimeout,
	  destroy,
	  bodyLength,
	  deepClone,
	  ReadableStreamFrom,
	  isBuffer,
	  validateHandler,
	  getSocketInfo,
	  isFormDataLike,
	  buildURL,
	  throwIfAborted,
	  addAbortListener,
	  parseRangeHeader,
	  nodeMajor,
	  nodeMinor,
	  nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
	  safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE']
	};
	return util$8;
}

var timers;
var hasRequiredTimers;

function requireTimers () {
	if (hasRequiredTimers) return timers;
	hasRequiredTimers = 1;

	let fastNow = Date.now();
	let fastNowTimeout;

	const fastTimers = [];

	function onTimeout () {
	  fastNow = Date.now();

	  let len = fastTimers.length;
	  let idx = 0;
	  while (idx < len) {
	    const timer = fastTimers[idx];

	    if (timer.state === 0) {
	      timer.state = fastNow + timer.delay;
	    } else if (timer.state > 0 && fastNow >= timer.state) {
	      timer.state = -1;
	      timer.callback(timer.opaque);
	    }

	    if (timer.state === -1) {
	      timer.state = -2;
	      if (idx !== len - 1) {
	        fastTimers[idx] = fastTimers.pop();
	      } else {
	        fastTimers.pop();
	      }
	      len -= 1;
	    } else {
	      idx += 1;
	    }
	  }

	  if (fastTimers.length > 0) {
	    refreshTimeout();
	  }
	}

	function refreshTimeout () {
	  if (fastNowTimeout && fastNowTimeout.refresh) {
	    fastNowTimeout.refresh();
	  } else {
	    clearTimeout(fastNowTimeout);
	    fastNowTimeout = setTimeout(onTimeout, 1e3);
	    if (fastNowTimeout.unref) {
	      fastNowTimeout.unref();
	    }
	  }
	}

	class Timeout {
	  constructor (callback, delay, opaque) {
	    this.callback = callback;
	    this.delay = delay;
	    this.opaque = opaque;

	    //  -2 not in timer list
	    //  -1 in timer list but inactive
	    //   0 in timer list waiting for time
	    // > 0 in timer list waiting for time to expire
	    this.state = -2;

	    this.refresh();
	  }

	  refresh () {
	    if (this.state === -2) {
	      fastTimers.push(this);
	      if (!fastNowTimeout || fastTimers.length === 1) {
	        refreshTimeout();
	      }
	    }

	    this.state = 0;
	  }

	  clear () {
	    this.state = -1;
	  }
	}

	timers = {
	  setTimeout (callback, delay, opaque) {
	    return delay < 1e3
	      ? setTimeout(callback, delay, opaque)
	      : new Timeout(callback, delay, opaque)
	  },
	  clearTimeout (timeout) {
	    if (timeout instanceof Timeout) {
	      timeout.clear();
	    } else {
	      clearTimeout(timeout);
	    }
	  }
	};
	return timers;
}

var main$1 = {exports: {}};

var sbmh;
var hasRequiredSbmh;

function requireSbmh () {
	if (hasRequiredSbmh) return sbmh;
	hasRequiredSbmh = 1;

	/**
	 * Copyright Brian White. All rights reserved.
	 *
	 * @see https://github.com/mscdex/streamsearch
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to
	 * deal in the Software without restriction, including without limitation the
	 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	 * sell copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	 * IN THE SOFTWARE.
	 *
	 * Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	 * by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	 */
	const EventEmitter = require$$0$b.EventEmitter;
	const inherits = require$$1$2.inherits;

	function SBMH (needle) {
	  if (typeof needle === 'string') {
	    needle = Buffer.from(needle);
	  }

	  if (!Buffer.isBuffer(needle)) {
	    throw new TypeError('The needle has to be a String or a Buffer.')
	  }

	  const needleLength = needle.length;

	  if (needleLength === 0) {
	    throw new Error('The needle cannot be an empty String/Buffer.')
	  }

	  if (needleLength > 256) {
	    throw new Error('The needle cannot have a length bigger than 256.')
	  }

	  this.maxMatches = Infinity;
	  this.matches = 0;

	  this._occ = new Array(256)
	    .fill(needleLength); // Initialize occurrence table.
	  this._lookbehind_size = 0;
	  this._needle = needle;
	  this._bufpos = 0;

	  this._lookbehind = Buffer.alloc(needleLength);

	  // Populate occurrence table with analysis of the needle,
	  // ignoring last letter.
	  for (var i = 0; i < needleLength - 1; ++i) { // eslint-disable-line no-var
	    this._occ[needle[i]] = needleLength - 1 - i;
	  }
	}
	inherits(SBMH, EventEmitter);

	SBMH.prototype.reset = function () {
	  this._lookbehind_size = 0;
	  this.matches = 0;
	  this._bufpos = 0;
	};

	SBMH.prototype.push = function (chunk, pos) {
	  if (!Buffer.isBuffer(chunk)) {
	    chunk = Buffer.from(chunk, 'binary');
	  }
	  const chlen = chunk.length;
	  this._bufpos = pos || 0;
	  let r;
	  while (r !== chlen && this.matches < this.maxMatches) { r = this._sbmh_feed(chunk); }
	  return r
	};

	SBMH.prototype._sbmh_feed = function (data) {
	  const len = data.length;
	  const needle = this._needle;
	  const needleLength = needle.length;
	  const lastNeedleChar = needle[needleLength - 1];

	  // Positive: points to a position in `data`
	  //           pos == 3 points to data[3]
	  // Negative: points to a position in the lookbehind buffer
	  //           pos == -2 points to lookbehind[lookbehind_size - 2]
	  let pos = -this._lookbehind_size;
	  let ch;

	  if (pos < 0) {
	    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool
	    // search with character lookup code that considers both the
	    // lookbehind buffer and the current round's haystack data.
	    //
	    // Loop until
	    //   there is a match.
	    // or until
	    //   we've moved past the position that requires the
	    //   lookbehind buffer. In this case we switch to the
	    //   optimized loop.
	    // or until
	    //   the character to look at lies outside the haystack.
	    while (pos < 0 && pos <= len - needleLength) {
	      ch = this._sbmh_lookup_char(data, pos + needleLength - 1);

	      if (
	        ch === lastNeedleChar &&
	        this._sbmh_memcmp(data, pos, needleLength - 1)
	      ) {
	        this._lookbehind_size = 0;
	        ++this.matches;
	        this.emit('info', true);

	        return (this._bufpos = pos + needleLength)
	      }
	      pos += this._occ[ch];
	    }

	    // No match.

	    if (pos < 0) {
	      // There's too few data for Boyer-Moore-Horspool to run,
	      // so let's use a different algorithm to skip as much as
	      // we can.
	      // Forward pos until
	      //   the trailing part of lookbehind + data
	      //   looks like the beginning of the needle
	      // or until
	      //   pos == 0
	      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) { ++pos; }
	    }

	    if (pos >= 0) {
	      // Discard lookbehind buffer.
	      this.emit('info', false, this._lookbehind, 0, this._lookbehind_size);
	      this._lookbehind_size = 0;
	    } else {
	      // Cut off part of the lookbehind buffer that has
	      // been processed and append the entire haystack
	      // into it.
	      const bytesToCutOff = this._lookbehind_size + pos;
	      if (bytesToCutOff > 0) {
	        // The cut off data is guaranteed not to contain the needle.
	        this.emit('info', false, this._lookbehind, 0, bytesToCutOff);
	      }

	      this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff,
	        this._lookbehind_size - bytesToCutOff);
	      this._lookbehind_size -= bytesToCutOff;

	      data.copy(this._lookbehind, this._lookbehind_size);
	      this._lookbehind_size += len;

	      this._bufpos = len;
	      return len
	    }
	  }

	  pos += (pos >= 0) * this._bufpos;

	  // Lookbehind buffer is now empty. We only need to check if the
	  // needle is in the haystack.
	  if (data.indexOf(needle, pos) !== -1) {
	    pos = data.indexOf(needle, pos);
	    ++this.matches;
	    if (pos > 0) { this.emit('info', true, data, this._bufpos, pos); } else { this.emit('info', true); }

	    return (this._bufpos = pos + needleLength)
	  } else {
	    pos = len - needleLength;
	  }

	  // There was no match. If there's trailing haystack data that we cannot
	  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing
	  // data is less than the needle size) then match using a modified
	  // algorithm that starts matching from the beginning instead of the end.
	  // Whatever trailing data is left after running this algorithm is added to
	  // the lookbehind buffer.
	  while (
	    pos < len &&
	    (
	      data[pos] !== needle[0] ||
	      (
	        (Buffer.compare(
	          data.subarray(pos, pos + len - pos),
	          needle.subarray(0, len - pos)
	        ) !== 0)
	      )
	    )
	  ) {
	    ++pos;
	  }
	  if (pos < len) {
	    data.copy(this._lookbehind, 0, pos, pos + (len - pos));
	    this._lookbehind_size = len - pos;
	  }

	  // Everything until pos is guaranteed not to contain needle data.
	  if (pos > 0) { this.emit('info', false, data, this._bufpos, pos < len ? pos : len); }

	  this._bufpos = len;
	  return len
	};

	SBMH.prototype._sbmh_lookup_char = function (data, pos) {
	  return (pos < 0)
	    ? this._lookbehind[this._lookbehind_size + pos]
	    : data[pos]
	};

	SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) { return false }
	  }
	  return true
	};

	sbmh = SBMH;
	return sbmh;
}

var PartStream_1;
var hasRequiredPartStream;

function requirePartStream () {
	if (hasRequiredPartStream) return PartStream_1;
	hasRequiredPartStream = 1;

	const inherits = require$$1$2.inherits;
	const ReadableStream = require$$0$c.Readable;

	function PartStream (opts) {
	  ReadableStream.call(this, opts);
	}
	inherits(PartStream, ReadableStream);

	PartStream.prototype._read = function (n) {};

	PartStream_1 = PartStream;
	return PartStream_1;
}

var getLimit;
var hasRequiredGetLimit;

function requireGetLimit () {
	if (hasRequiredGetLimit) return getLimit;
	hasRequiredGetLimit = 1;

	getLimit = function getLimit (limits, name, defaultLimit) {
	  if (
	    !limits ||
	    limits[name] === undefined ||
	    limits[name] === null
	  ) { return defaultLimit }

	  if (
	    typeof limits[name] !== 'number' ||
	    isNaN(limits[name])
	  ) { throw new TypeError('Limit ' + name + ' is not a valid number') }

	  return limits[name]
	};
	return getLimit;
}

var HeaderParser_1;
var hasRequiredHeaderParser;

function requireHeaderParser () {
	if (hasRequiredHeaderParser) return HeaderParser_1;
	hasRequiredHeaderParser = 1;

	const EventEmitter = require$$0$b.EventEmitter;
	const inherits = require$$1$2.inherits;
	const getLimit = requireGetLimit();

	const StreamSearch = requireSbmh();

	const B_DCRLF = Buffer.from('\r\n\r\n');
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/; // eslint-disable-line no-control-regex

	function HeaderParser (cfg) {
	  EventEmitter.call(this);

	  cfg = cfg || {};
	  const self = this;
	  this.nread = 0;
	  this.maxed = false;
	  this.npairs = 0;
	  this.maxHeaderPairs = getLimit(cfg, 'maxHeaderPairs', 2000);
	  this.maxHeaderSize = getLimit(cfg, 'maxHeaderSize', 80 * 1024);
	  this.buffer = '';
	  this.header = {};
	  this.finished = false;
	  this.ss = new StreamSearch(B_DCRLF);
	  this.ss.on('info', function (isMatch, data, start, end) {
	    if (data && !self.maxed) {
	      if (self.nread + end - start >= self.maxHeaderSize) {
	        end = self.maxHeaderSize - self.nread + start;
	        self.nread = self.maxHeaderSize;
	        self.maxed = true;
	      } else { self.nread += (end - start); }

	      self.buffer += data.toString('binary', start, end);
	    }
	    if (isMatch) { self._finish(); }
	  });
	}
	inherits(HeaderParser, EventEmitter);

	HeaderParser.prototype.push = function (data) {
	  const r = this.ss.push(data);
	  if (this.finished) { return r }
	};

	HeaderParser.prototype.reset = function () {
	  this.finished = false;
	  this.buffer = '';
	  this.header = {};
	  this.ss.reset();
	};

	HeaderParser.prototype._finish = function () {
	  if (this.buffer) { this._parseHeader(); }
	  this.ss.matches = this.ss.maxMatches;
	  const header = this.header;
	  this.header = {};
	  this.buffer = '';
	  this.finished = true;
	  this.nread = this.npairs = 0;
	  this.maxed = false;
	  this.emit('header', header);
	};

	HeaderParser.prototype._parseHeader = function () {
	  if (this.npairs === this.maxHeaderPairs) { return }

	  const lines = this.buffer.split(RE_CRLF);
	  const len = lines.length;
	  let m, h;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    if (lines[i].length === 0) { continue }
	    if (lines[i][0] === '\t' || lines[i][0] === ' ') {
	      // folded header content
	      // RFC2822 says to just remove the CRLF and not the whitespace following
	      // it, so we follow the RFC and include the leading whitespace ...
	      if (h) {
	        this.header[h][this.header[h].length - 1] += lines[i];
	        continue
	      }
	    }

	    const posColon = lines[i].indexOf(':');
	    if (
	      posColon === -1 ||
	      posColon === 0
	    ) {
	      return
	    }
	    m = RE_HDR.exec(lines[i]);
	    h = m[1].toLowerCase();
	    this.header[h] = this.header[h] || [];
	    this.header[h].push((m[2] || ''));
	    if (++this.npairs === this.maxHeaderPairs) { break }
	  }
	};

	HeaderParser_1 = HeaderParser;
	return HeaderParser_1;
}

var Dicer_1;
var hasRequiredDicer;

function requireDicer () {
	if (hasRequiredDicer) return Dicer_1;
	hasRequiredDicer = 1;

	const WritableStream = require$$0$c.Writable;
	const inherits = require$$1$2.inherits;

	const StreamSearch = requireSbmh();

	const PartStream = requirePartStream();
	const HeaderParser = requireHeaderParser();

	const DASH = 45;
	const B_ONEDASH = Buffer.from('-');
	const B_CRLF = Buffer.from('\r\n');
	const EMPTY_FN = function () {};

	function Dicer (cfg) {
	  if (!(this instanceof Dicer)) { return new Dicer(cfg) }
	  WritableStream.call(this, cfg);

	  if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== 'string')) { throw new TypeError('Boundary required') }

	  if (typeof cfg.boundary === 'string') { this.setBoundary(cfg.boundary); } else { this._bparser = undefined; }

	  this._headerFirst = cfg.headerFirst;

	  this._dashes = 0;
	  this._parts = 0;
	  this._finished = false;
	  this._realFinish = false;
	  this._isPreamble = true;
	  this._justMatched = false;
	  this._firstWrite = true;
	  this._inHeader = true;
	  this._part = undefined;
	  this._cb = undefined;
	  this._ignoreData = false;
	  this._partOpts = { highWaterMark: cfg.partHwm };
	  this._pause = false;

	  const self = this;
	  this._hparser = new HeaderParser(cfg);
	  this._hparser.on('header', function (header) {
	    self._inHeader = false;
	    self._part.emit('header', header);
	  });
	}
	inherits(Dicer, WritableStream);

	Dicer.prototype.emit = function (ev) {
	  if (ev === 'finish' && !this._realFinish) {
	    if (!this._finished) {
	      const self = this;
	      process.nextTick(function () {
	        self.emit('error', new Error('Unexpected end of multipart data'));
	        if (self._part && !self._ignoreData) {
	          const type = (self._isPreamble ? 'Preamble' : 'Part');
	          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));
	          self._part.push(null);
	          process.nextTick(function () {
	            self._realFinish = true;
	            self.emit('finish');
	            self._realFinish = false;
	          });
	          return
	        }
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      });
	    }
	  } else { WritableStream.prototype.emit.apply(this, arguments); }
	};

	Dicer.prototype._write = function (data, encoding, cb) {
	  // ignore unexpected data (e.g. extra trailer data after finished)
	  if (!this._hparser && !this._bparser) { return cb() }

	  if (this._headerFirst && this._isPreamble) {
	    if (!this._part) {
	      this._part = new PartStream(this._partOpts);
	      if (this.listenerCount('preamble') !== 0) { this.emit('preamble', this._part); } else { this._ignore(); }
	    }
	    const r = this._hparser.push(data);
	    if (!this._inHeader && r !== undefined && r < data.length) { data = data.slice(r); } else { return cb() }
	  }

	  // allows for "easier" testing
	  if (this._firstWrite) {
	    this._bparser.push(B_CRLF);
	    this._firstWrite = false;
	  }

	  this._bparser.push(data);

	  if (this._pause) { this._cb = cb; } else { cb(); }
	};

	Dicer.prototype.reset = function () {
	  this._part = undefined;
	  this._bparser = undefined;
	  this._hparser = undefined;
	};

	Dicer.prototype.setBoundary = function (boundary) {
	  const self = this;
	  this._bparser = new StreamSearch('\r\n--' + boundary);
	  this._bparser.on('info', function (isMatch, data, start, end) {
	    self._oninfo(isMatch, data, start, end);
	  });
	};

	Dicer.prototype._ignore = function () {
	  if (this._part && !this._ignoreData) {
	    this._ignoreData = true;
	    this._part.on('error', EMPTY_FN);
	    // we must perform some kind of read on the stream even though we are
	    // ignoring the data, otherwise node's Readable stream will not emit 'end'
	    // after pushing null to the stream
	    this._part.resume();
	  }
	};

	Dicer.prototype._oninfo = function (isMatch, data, start, end) {
	  let buf; const self = this; let i = 0; let r; let shouldWriteMore = true;

	  if (!this._part && this._justMatched && data) {
	    while (this._dashes < 2 && (start + i) < end) {
	      if (data[start + i] === DASH) {
	        ++i;
	        ++this._dashes;
	      } else {
	        if (this._dashes) { buf = B_ONEDASH; }
	        this._dashes = 0;
	        break
	      }
	    }
	    if (this._dashes === 2) {
	      if ((start + i) < end && this.listenerCount('trailer') !== 0) { this.emit('trailer', data.slice(start + i, end)); }
	      this.reset();
	      this._finished = true;
	      // no more parts will be added
	      if (self._parts === 0) {
	        self._realFinish = true;
	        self.emit('finish');
	        self._realFinish = false;
	      }
	    }
	    if (this._dashes) { return }
	  }
	  if (this._justMatched) { this._justMatched = false; }
	  if (!this._part) {
	    this._part = new PartStream(this._partOpts);
	    this._part._read = function (n) {
	      self._unpause();
	    };
	    if (this._isPreamble && this.listenerCount('preamble') !== 0) {
	      this.emit('preamble', this._part);
	    } else if (this._isPreamble !== true && this.listenerCount('part') !== 0) {
	      this.emit('part', this._part);
	    } else {
	      this._ignore();
	    }
	    if (!this._isPreamble) { this._inHeader = true; }
	  }
	  if (data && start < end && !this._ignoreData) {
	    if (this._isPreamble || !this._inHeader) {
	      if (buf) { shouldWriteMore = this._part.push(buf); }
	      shouldWriteMore = this._part.push(data.slice(start, end));
	      if (!shouldWriteMore) { this._pause = true; }
	    } else if (!this._isPreamble && this._inHeader) {
	      if (buf) { this._hparser.push(buf); }
	      r = this._hparser.push(data.slice(start, end));
	      if (!this._inHeader && r !== undefined && r < end) { this._oninfo(false, data, start + r, end); }
	    }
	  }
	  if (isMatch) {
	    this._hparser.reset();
	    if (this._isPreamble) { this._isPreamble = false; } else {
	      if (start !== end) {
	        ++this._parts;
	        this._part.on('end', function () {
	          if (--self._parts === 0) {
	            if (self._finished) {
	              self._realFinish = true;
	              self.emit('finish');
	              self._realFinish = false;
	            } else {
	              self._unpause();
	            }
	          }
	        });
	      }
	    }
	    this._part.push(null);
	    this._part = undefined;
	    this._ignoreData = false;
	    this._justMatched = true;
	    this._dashes = 0;
	  }
	};

	Dicer.prototype._unpause = function () {
	  if (!this._pause) { return }

	  this._pause = false;
	  if (this._cb) {
	    const cb = this._cb;
	    this._cb = undefined;
	    cb();
	  }
	};

	Dicer_1 = Dicer;
	return Dicer_1;
}

var decodeText_1;
var hasRequiredDecodeText;

function requireDecodeText () {
	if (hasRequiredDecodeText) return decodeText_1;
	hasRequiredDecodeText = 1;

	// Node has always utf-8
	const utf8Decoder = new TextDecoder('utf-8');
	const textDecoders = new Map([
	  ['utf-8', utf8Decoder],
	  ['utf8', utf8Decoder]
	]);

	function getDecoder (charset) {
	  let lc;
	  while (true) {
	    switch (charset) {
	      case 'utf-8':
	      case 'utf8':
	        return decoders.utf8
	      case 'latin1':
	      case 'ascii': // TODO: Make these a separate, strict decoder?
	      case 'us-ascii':
	      case 'iso-8859-1':
	      case 'iso8859-1':
	      case 'iso88591':
	      case 'iso_8859-1':
	      case 'windows-1252':
	      case 'iso_8859-1:1987':
	      case 'cp1252':
	      case 'x-cp1252':
	        return decoders.latin1
	      case 'utf16le':
	      case 'utf-16le':
	      case 'ucs2':
	      case 'ucs-2':
	        return decoders.utf16le
	      case 'base64':
	        return decoders.base64
	      default:
	        if (lc === undefined) {
	          lc = true;
	          charset = charset.toLowerCase();
	          continue
	        }
	        return decoders.other.bind(charset)
	    }
	  }
	}

	const decoders = {
	  utf8: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.utf8Slice(0, data.length)
	  },

	  latin1: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      return data
	    }
	    return data.latin1Slice(0, data.length)
	  },

	  utf16le: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.ucs2Slice(0, data.length)
	  },

	  base64: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }
	    return data.base64Slice(0, data.length)
	  },

	  other: (data, sourceEncoding) => {
	    if (data.length === 0) {
	      return ''
	    }
	    if (typeof data === 'string') {
	      data = Buffer.from(data, sourceEncoding);
	    }

	    if (textDecoders.has(this.toString())) {
	      try {
	        return textDecoders.get(this).decode(data)
	      } catch {}
	    }
	    return typeof data === 'string'
	      ? data
	      : data.toString()
	  }
	};

	function decodeText (text, sourceEncoding, destEncoding) {
	  if (text) {
	    return getDecoder(destEncoding)(text, sourceEncoding)
	  }
	  return text
	}

	decodeText_1 = decodeText;
	return decodeText_1;
}

/* eslint-disable object-property-newline */

var parseParams_1;
var hasRequiredParseParams;

function requireParseParams () {
	if (hasRequiredParseParams) return parseParams_1;
	hasRequiredParseParams = 1;

	const decodeText = requireDecodeText();

	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;

	const EncodedLookup = {
	  '%00': '\x00', '%01': '\x01', '%02': '\x02', '%03': '\x03', '%04': '\x04',
	  '%05': '\x05', '%06': '\x06', '%07': '\x07', '%08': '\x08', '%09': '\x09',
	  '%0a': '\x0a', '%0A': '\x0a', '%0b': '\x0b', '%0B': '\x0b', '%0c': '\x0c',
	  '%0C': '\x0c', '%0d': '\x0d', '%0D': '\x0d', '%0e': '\x0e', '%0E': '\x0e',
	  '%0f': '\x0f', '%0F': '\x0f', '%10': '\x10', '%11': '\x11', '%12': '\x12',
	  '%13': '\x13', '%14': '\x14', '%15': '\x15', '%16': '\x16', '%17': '\x17',
	  '%18': '\x18', '%19': '\x19', '%1a': '\x1a', '%1A': '\x1a', '%1b': '\x1b',
	  '%1B': '\x1b', '%1c': '\x1c', '%1C': '\x1c', '%1d': '\x1d', '%1D': '\x1d',
	  '%1e': '\x1e', '%1E': '\x1e', '%1f': '\x1f', '%1F': '\x1f', '%20': '\x20',
	  '%21': '\x21', '%22': '\x22', '%23': '\x23', '%24': '\x24', '%25': '\x25',
	  '%26': '\x26', '%27': '\x27', '%28': '\x28', '%29': '\x29', '%2a': '\x2a',
	  '%2A': '\x2a', '%2b': '\x2b', '%2B': '\x2b', '%2c': '\x2c', '%2C': '\x2c',
	  '%2d': '\x2d', '%2D': '\x2d', '%2e': '\x2e', '%2E': '\x2e', '%2f': '\x2f',
	  '%2F': '\x2f', '%30': '\x30', '%31': '\x31', '%32': '\x32', '%33': '\x33',
	  '%34': '\x34', '%35': '\x35', '%36': '\x36', '%37': '\x37', '%38': '\x38',
	  '%39': '\x39', '%3a': '\x3a', '%3A': '\x3a', '%3b': '\x3b', '%3B': '\x3b',
	  '%3c': '\x3c', '%3C': '\x3c', '%3d': '\x3d', '%3D': '\x3d', '%3e': '\x3e',
	  '%3E': '\x3e', '%3f': '\x3f', '%3F': '\x3f', '%40': '\x40', '%41': '\x41',
	  '%42': '\x42', '%43': '\x43', '%44': '\x44', '%45': '\x45', '%46': '\x46',
	  '%47': '\x47', '%48': '\x48', '%49': '\x49', '%4a': '\x4a', '%4A': '\x4a',
	  '%4b': '\x4b', '%4B': '\x4b', '%4c': '\x4c', '%4C': '\x4c', '%4d': '\x4d',
	  '%4D': '\x4d', '%4e': '\x4e', '%4E': '\x4e', '%4f': '\x4f', '%4F': '\x4f',
	  '%50': '\x50', '%51': '\x51', '%52': '\x52', '%53': '\x53', '%54': '\x54',
	  '%55': '\x55', '%56': '\x56', '%57': '\x57', '%58': '\x58', '%59': '\x59',
	  '%5a': '\x5a', '%5A': '\x5a', '%5b': '\x5b', '%5B': '\x5b', '%5c': '\x5c',
	  '%5C': '\x5c', '%5d': '\x5d', '%5D': '\x5d', '%5e': '\x5e', '%5E': '\x5e',
	  '%5f': '\x5f', '%5F': '\x5f', '%60': '\x60', '%61': '\x61', '%62': '\x62',
	  '%63': '\x63', '%64': '\x64', '%65': '\x65', '%66': '\x66', '%67': '\x67',
	  '%68': '\x68', '%69': '\x69', '%6a': '\x6a', '%6A': '\x6a', '%6b': '\x6b',
	  '%6B': '\x6b', '%6c': '\x6c', '%6C': '\x6c', '%6d': '\x6d', '%6D': '\x6d',
	  '%6e': '\x6e', '%6E': '\x6e', '%6f': '\x6f', '%6F': '\x6f', '%70': '\x70',
	  '%71': '\x71', '%72': '\x72', '%73': '\x73', '%74': '\x74', '%75': '\x75',
	  '%76': '\x76', '%77': '\x77', '%78': '\x78', '%79': '\x79', '%7a': '\x7a',
	  '%7A': '\x7a', '%7b': '\x7b', '%7B': '\x7b', '%7c': '\x7c', '%7C': '\x7c',
	  '%7d': '\x7d', '%7D': '\x7d', '%7e': '\x7e', '%7E': '\x7e', '%7f': '\x7f',
	  '%7F': '\x7f', '%80': '\x80', '%81': '\x81', '%82': '\x82', '%83': '\x83',
	  '%84': '\x84', '%85': '\x85', '%86': '\x86', '%87': '\x87', '%88': '\x88',
	  '%89': '\x89', '%8a': '\x8a', '%8A': '\x8a', '%8b': '\x8b', '%8B': '\x8b',
	  '%8c': '\x8c', '%8C': '\x8c', '%8d': '\x8d', '%8D': '\x8d', '%8e': '\x8e',
	  '%8E': '\x8e', '%8f': '\x8f', '%8F': '\x8f', '%90': '\x90', '%91': '\x91',
	  '%92': '\x92', '%93': '\x93', '%94': '\x94', '%95': '\x95', '%96': '\x96',
	  '%97': '\x97', '%98': '\x98', '%99': '\x99', '%9a': '\x9a', '%9A': '\x9a',
	  '%9b': '\x9b', '%9B': '\x9b', '%9c': '\x9c', '%9C': '\x9c', '%9d': '\x9d',
	  '%9D': '\x9d', '%9e': '\x9e', '%9E': '\x9e', '%9f': '\x9f', '%9F': '\x9f',
	  '%a0': '\xa0', '%A0': '\xa0', '%a1': '\xa1', '%A1': '\xa1', '%a2': '\xa2',
	  '%A2': '\xa2', '%a3': '\xa3', '%A3': '\xa3', '%a4': '\xa4', '%A4': '\xa4',
	  '%a5': '\xa5', '%A5': '\xa5', '%a6': '\xa6', '%A6': '\xa6', '%a7': '\xa7',
	  '%A7': '\xa7', '%a8': '\xa8', '%A8': '\xa8', '%a9': '\xa9', '%A9': '\xa9',
	  '%aa': '\xaa', '%Aa': '\xaa', '%aA': '\xaa', '%AA': '\xaa', '%ab': '\xab',
	  '%Ab': '\xab', '%aB': '\xab', '%AB': '\xab', '%ac': '\xac', '%Ac': '\xac',
	  '%aC': '\xac', '%AC': '\xac', '%ad': '\xad', '%Ad': '\xad', '%aD': '\xad',
	  '%AD': '\xad', '%ae': '\xae', '%Ae': '\xae', '%aE': '\xae', '%AE': '\xae',
	  '%af': '\xaf', '%Af': '\xaf', '%aF': '\xaf', '%AF': '\xaf', '%b0': '\xb0',
	  '%B0': '\xb0', '%b1': '\xb1', '%B1': '\xb1', '%b2': '\xb2', '%B2': '\xb2',
	  '%b3': '\xb3', '%B3': '\xb3', '%b4': '\xb4', '%B4': '\xb4', '%b5': '\xb5',
	  '%B5': '\xb5', '%b6': '\xb6', '%B6': '\xb6', '%b7': '\xb7', '%B7': '\xb7',
	  '%b8': '\xb8', '%B8': '\xb8', '%b9': '\xb9', '%B9': '\xb9', '%ba': '\xba',
	  '%Ba': '\xba', '%bA': '\xba', '%BA': '\xba', '%bb': '\xbb', '%Bb': '\xbb',
	  '%bB': '\xbb', '%BB': '\xbb', '%bc': '\xbc', '%Bc': '\xbc', '%bC': '\xbc',
	  '%BC': '\xbc', '%bd': '\xbd', '%Bd': '\xbd', '%bD': '\xbd', '%BD': '\xbd',
	  '%be': '\xbe', '%Be': '\xbe', '%bE': '\xbe', '%BE': '\xbe', '%bf': '\xbf',
	  '%Bf': '\xbf', '%bF': '\xbf', '%BF': '\xbf', '%c0': '\xc0', '%C0': '\xc0',
	  '%c1': '\xc1', '%C1': '\xc1', '%c2': '\xc2', '%C2': '\xc2', '%c3': '\xc3',
	  '%C3': '\xc3', '%c4': '\xc4', '%C4': '\xc4', '%c5': '\xc5', '%C5': '\xc5',
	  '%c6': '\xc6', '%C6': '\xc6', '%c7': '\xc7', '%C7': '\xc7', '%c8': '\xc8',
	  '%C8': '\xc8', '%c9': '\xc9', '%C9': '\xc9', '%ca': '\xca', '%Ca': '\xca',
	  '%cA': '\xca', '%CA': '\xca', '%cb': '\xcb', '%Cb': '\xcb', '%cB': '\xcb',
	  '%CB': '\xcb', '%cc': '\xcc', '%Cc': '\xcc', '%cC': '\xcc', '%CC': '\xcc',
	  '%cd': '\xcd', '%Cd': '\xcd', '%cD': '\xcd', '%CD': '\xcd', '%ce': '\xce',
	  '%Ce': '\xce', '%cE': '\xce', '%CE': '\xce', '%cf': '\xcf', '%Cf': '\xcf',
	  '%cF': '\xcf', '%CF': '\xcf', '%d0': '\xd0', '%D0': '\xd0', '%d1': '\xd1',
	  '%D1': '\xd1', '%d2': '\xd2', '%D2': '\xd2', '%d3': '\xd3', '%D3': '\xd3',
	  '%d4': '\xd4', '%D4': '\xd4', '%d5': '\xd5', '%D5': '\xd5', '%d6': '\xd6',
	  '%D6': '\xd6', '%d7': '\xd7', '%D7': '\xd7', '%d8': '\xd8', '%D8': '\xd8',
	  '%d9': '\xd9', '%D9': '\xd9', '%da': '\xda', '%Da': '\xda', '%dA': '\xda',
	  '%DA': '\xda', '%db': '\xdb', '%Db': '\xdb', '%dB': '\xdb', '%DB': '\xdb',
	  '%dc': '\xdc', '%Dc': '\xdc', '%dC': '\xdc', '%DC': '\xdc', '%dd': '\xdd',
	  '%Dd': '\xdd', '%dD': '\xdd', '%DD': '\xdd', '%de': '\xde', '%De': '\xde',
	  '%dE': '\xde', '%DE': '\xde', '%df': '\xdf', '%Df': '\xdf', '%dF': '\xdf',
	  '%DF': '\xdf', '%e0': '\xe0', '%E0': '\xe0', '%e1': '\xe1', '%E1': '\xe1',
	  '%e2': '\xe2', '%E2': '\xe2', '%e3': '\xe3', '%E3': '\xe3', '%e4': '\xe4',
	  '%E4': '\xe4', '%e5': '\xe5', '%E5': '\xe5', '%e6': '\xe6', '%E6': '\xe6',
	  '%e7': '\xe7', '%E7': '\xe7', '%e8': '\xe8', '%E8': '\xe8', '%e9': '\xe9',
	  '%E9': '\xe9', '%ea': '\xea', '%Ea': '\xea', '%eA': '\xea', '%EA': '\xea',
	  '%eb': '\xeb', '%Eb': '\xeb', '%eB': '\xeb', '%EB': '\xeb', '%ec': '\xec',
	  '%Ec': '\xec', '%eC': '\xec', '%EC': '\xec', '%ed': '\xed', '%Ed': '\xed',
	  '%eD': '\xed', '%ED': '\xed', '%ee': '\xee', '%Ee': '\xee', '%eE': '\xee',
	  '%EE': '\xee', '%ef': '\xef', '%Ef': '\xef', '%eF': '\xef', '%EF': '\xef',
	  '%f0': '\xf0', '%F0': '\xf0', '%f1': '\xf1', '%F1': '\xf1', '%f2': '\xf2',
	  '%F2': '\xf2', '%f3': '\xf3', '%F3': '\xf3', '%f4': '\xf4', '%F4': '\xf4',
	  '%f5': '\xf5', '%F5': '\xf5', '%f6': '\xf6', '%F6': '\xf6', '%f7': '\xf7',
	  '%F7': '\xf7', '%f8': '\xf8', '%F8': '\xf8', '%f9': '\xf9', '%F9': '\xf9',
	  '%fa': '\xfa', '%Fa': '\xfa', '%fA': '\xfa', '%FA': '\xfa', '%fb': '\xfb',
	  '%Fb': '\xfb', '%fB': '\xfb', '%FB': '\xfb', '%fc': '\xfc', '%Fc': '\xfc',
	  '%fC': '\xfc', '%FC': '\xfc', '%fd': '\xfd', '%Fd': '\xfd', '%fD': '\xfd',
	  '%FD': '\xfd', '%fe': '\xfe', '%Fe': '\xfe', '%fE': '\xfe', '%FE': '\xfe',
	  '%ff': '\xff', '%Ff': '\xff', '%fF': '\xff', '%FF': '\xff'
	};

	function encodedReplacer (match) {
	  return EncodedLookup[match]
	}

	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;

	function parseParams (str) {
	  const res = [];
	  let state = STATE_KEY;
	  let charset = '';
	  let inquote = false;
	  let escaping = false;
	  let p = 0;
	  let tmp = '';
	  const len = str.length;

	  for (var i = 0; i < len; ++i) { // eslint-disable-line no-var
	    const char = str[i];
	    if (char === '\\' && inquote) {
	      if (escaping) { escaping = false; } else {
	        escaping = true;
	        continue
	      }
	    } else if (char === '"') {
	      if (!escaping) {
	        if (inquote) {
	          inquote = false;
	          state = STATE_KEY;
	        } else { inquote = true; }
	        continue
	      } else { escaping = false; }
	    } else {
	      if (escaping && inquote) { tmp += '\\'; }
	      escaping = false;
	      if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
	        if (state === STATE_CHARSET) {
	          state = STATE_LANG;
	          charset = tmp.substring(1);
	        } else { state = STATE_VALUE; }
	        tmp = '';
	        continue
	      } else if (state === STATE_KEY &&
	        (char === '*' || char === '=') &&
	        res.length) {
	        state = char === '*'
	          ? STATE_CHARSET
	          : STATE_VALUE;
	        res[p] = [tmp, undefined];
	        tmp = '';
	        continue
	      } else if (!inquote && char === ';') {
	        state = STATE_KEY;
	        if (charset) {
	          if (tmp.length) {
	            tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	              'binary',
	              charset);
	          }
	          charset = '';
	        } else if (tmp.length) {
	          tmp = decodeText(tmp, 'binary', 'utf8');
	        }
	        if (res[p] === undefined) { res[p] = tmp; } else { res[p][1] = tmp; }
	        tmp = '';
	        ++p;
	        continue
	      } else if (!inquote && (char === ' ' || char === '\t')) { continue }
	    }
	    tmp += char;
	  }
	  if (charset && tmp.length) {
	    tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer),
	      'binary',
	      charset);
	  } else if (tmp) {
	    tmp = decodeText(tmp, 'binary', 'utf8');
	  }

	  if (res[p] === undefined) {
	    if (tmp) { res[p] = tmp; }
	  } else { res[p][1] = tmp; }

	  return res
	}

	parseParams_1 = parseParams;
	return parseParams_1;
}

var basename;
var hasRequiredBasename;

function requireBasename () {
	if (hasRequiredBasename) return basename;
	hasRequiredBasename = 1;

	basename = function basename (path) {
	  if (typeof path !== 'string') { return '' }
	  for (var i = path.length - 1; i >= 0; --i) { // eslint-disable-line no-var
	    switch (path.charCodeAt(i)) {
	      case 0x2F: // '/'
	      case 0x5C: // '\'
	        path = path.slice(i + 1);
	        return (path === '..' || path === '.' ? '' : path)
	    }
	  }
	  return (path === '..' || path === '.' ? '' : path)
	};
	return basename;
}

var multipart;
var hasRequiredMultipart;

function requireMultipart () {
	if (hasRequiredMultipart) return multipart;
	hasRequiredMultipart = 1;

	// TODO:
	//  * support 1 nested multipart level
	//    (see second multipart example here:
	//     http://www.w3.org/TR/html401/interact/forms.html#didx-multipartform-data)
	//  * support limits.fieldNameSize
	//     -- this will require modifications to utils.parseParams

	const { Readable } = require$$0$c;
	const { inherits } = require$$1$2;

	const Dicer = requireDicer();

	const parseParams = requireParseParams();
	const decodeText = requireDecodeText();
	const basename = requireBasename();
	const getLimit = requireGetLimit();

	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;

	Multipart.detect = /^multipart\/form-data/i;
	function Multipart (boy, cfg) {
	  let i;
	  let len;
	  const self = this;
	  let boundary;
	  const limits = cfg.limits;
	  const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => (contentType === 'application/octet-stream' || fileName !== undefined));
	  const parsedConType = cfg.parsedConType || [];
	  const defCharset = cfg.defCharset || 'utf8';
	  const preservePath = cfg.preservePath;
	  const fileOpts = { highWaterMark: cfg.fileHwm };

	  for (i = 0, len = parsedConType.length; i < len; ++i) {
	    if (Array.isArray(parsedConType[i]) &&
	      RE_BOUNDARY.test(parsedConType[i][0])) {
	      boundary = parsedConType[i][1];
	      break
	    }
	  }

	  function checkFinished () {
	    if (nends === 0 && finished && !boy._done) {
	      finished = false;
	      self.end();
	    }
	  }

	  if (typeof boundary !== 'string') { throw new Error('Multipart: Boundary not found') }

	  const fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  const fileSizeLimit = getLimit(limits, 'fileSize', Infinity);
	  const filesLimit = getLimit(limits, 'files', Infinity);
	  const fieldsLimit = getLimit(limits, 'fields', Infinity);
	  const partsLimit = getLimit(limits, 'parts', Infinity);
	  const headerPairsLimit = getLimit(limits, 'headerPairs', 2000);
	  const headerSizeLimit = getLimit(limits, 'headerSize', 80 * 1024);

	  let nfiles = 0;
	  let nfields = 0;
	  let nends = 0;
	  let curFile;
	  let curField;
	  let finished = false;

	  this._needDrain = false;
	  this._pause = false;
	  this._cb = undefined;
	  this._nparts = 0;
	  this._boy = boy;

	  const parserCfg = {
	    boundary,
	    maxHeaderPairs: headerPairsLimit,
	    maxHeaderSize: headerSizeLimit,
	    partHwm: fileOpts.highWaterMark,
	    highWaterMark: cfg.highWaterMark
	  };

	  this.parser = new Dicer(parserCfg);
	  this.parser.on('drain', function () {
	    self._needDrain = false;
	    if (self._cb && !self._pause) {
	      const cb = self._cb;
	      self._cb = undefined;
	      cb();
	    }
	  }).on('part', function onPart (part) {
	    if (++self._nparts > partsLimit) {
	      self.parser.removeListener('part', onPart);
	      self.parser.on('part', skipPart);
	      boy.hitPartsLimit = true;
	      boy.emit('partsLimit');
	      return skipPart(part)
	    }

	    // hack because streams2 _always_ doesn't emit 'end' until nextTick, so let
	    // us emit 'end' early since we know the part has ended if we are already
	    // seeing the next part
	    if (curField) {
	      const field = curField;
	      field.emit('end');
	      field.removeAllListeners('end');
	    }

	    part.on('header', function (header) {
	      let contype;
	      let fieldname;
	      let parsed;
	      let charset;
	      let encoding;
	      let filename;
	      let nsize = 0;

	      if (header['content-type']) {
	        parsed = parseParams(header['content-type'][0]);
	        if (parsed[0]) {
	          contype = parsed[0].toLowerCase();
	          for (i = 0, len = parsed.length; i < len; ++i) {
	            if (RE_CHARSET.test(parsed[i][0])) {
	              charset = parsed[i][1].toLowerCase();
	              break
	            }
	          }
	        }
	      }

	      if (contype === undefined) { contype = 'text/plain'; }
	      if (charset === undefined) { charset = defCharset; }

	      if (header['content-disposition']) {
	        parsed = parseParams(header['content-disposition'][0]);
	        if (!RE_FIELD.test(parsed[0])) { return skipPart(part) }
	        for (i = 0, len = parsed.length; i < len; ++i) {
	          if (RE_NAME.test(parsed[i][0])) {
	            fieldname = parsed[i][1];
	          } else if (RE_FILENAME.test(parsed[i][0])) {
	            filename = parsed[i][1];
	            if (!preservePath) { filename = basename(filename); }
	          }
	        }
	      } else { return skipPart(part) }

	      if (header['content-transfer-encoding']) { encoding = header['content-transfer-encoding'][0].toLowerCase(); } else { encoding = '7bit'; }

	      let onData,
	        onEnd;

	      if (isPartAFile(fieldname, contype, filename)) {
	        // file/binary field
	        if (nfiles === filesLimit) {
	          if (!boy.hitFilesLimit) {
	            boy.hitFilesLimit = true;
	            boy.emit('filesLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfiles;

	        if (boy.listenerCount('file') === 0) {
	          self.parser._ignore();
	          return
	        }

	        ++nends;
	        const file = new FileStream(fileOpts);
	        curFile = file;
	        file.on('end', function () {
	          --nends;
	          self._pause = false;
	          checkFinished();
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        });
	        file._read = function (n) {
	          if (!self._pause) { return }
	          self._pause = false;
	          if (self._cb && !self._needDrain) {
	            const cb = self._cb;
	            self._cb = undefined;
	            cb();
	          }
	        };
	        boy.emit('file', fieldname, file, filename, encoding, contype);

	        onData = function (data) {
	          if ((nsize += data.length) > fileSizeLimit) {
	            const extralen = fileSizeLimit - nsize + data.length;
	            if (extralen > 0) { file.push(data.slice(0, extralen)); }
	            file.truncated = true;
	            file.bytesRead = fileSizeLimit;
	            part.removeAllListeners('data');
	            file.emit('limit');
	            return
	          } else if (!file.push(data)) { self._pause = true; }

	          file.bytesRead = nsize;
	        };

	        onEnd = function () {
	          curFile = undefined;
	          file.push(null);
	        };
	      } else {
	        // non-file field
	        if (nfields === fieldsLimit) {
	          if (!boy.hitFieldsLimit) {
	            boy.hitFieldsLimit = true;
	            boy.emit('fieldsLimit');
	          }
	          return skipPart(part)
	        }

	        ++nfields;
	        ++nends;
	        let buffer = '';
	        let truncated = false;
	        curField = part;

	        onData = function (data) {
	          if ((nsize += data.length) > fieldSizeLimit) {
	            const extralen = (fieldSizeLimit - (nsize - data.length));
	            buffer += data.toString('binary', 0, extralen);
	            truncated = true;
	            part.removeAllListeners('data');
	          } else { buffer += data.toString('binary'); }
	        };

	        onEnd = function () {
	          curField = undefined;
	          if (buffer.length) { buffer = decodeText(buffer, 'binary', charset); }
	          boy.emit('field', fieldname, buffer, false, truncated, encoding, contype);
	          --nends;
	          checkFinished();
	        };
	      }

	      /* As of node@2efe4ab761666 (v0.10.29+/v0.11.14+), busboy had become
	         broken. Streams2/streams3 is a huge black box of confusion, but
	         somehow overriding the sync state seems to fix things again (and still
	         seems to work for previous node versions).
	      */
	      part._readableState.sync = false;

	      part.on('data', onData);
	      part.on('end', onEnd);
	    }).on('error', function (err) {
	      if (curFile) { curFile.emit('error', err); }
	    });
	  }).on('error', function (err) {
	    boy.emit('error', err);
	  }).on('finish', function () {
	    finished = true;
	    checkFinished();
	  });
	}

	Multipart.prototype.write = function (chunk, cb) {
	  const r = this.parser.write(chunk);
	  if (r && !this._pause) {
	    cb();
	  } else {
	    this._needDrain = !r;
	    this._cb = cb;
	  }
	};

	Multipart.prototype.end = function () {
	  const self = this;

	  if (self.parser.writable) {
	    self.parser.end();
	  } else if (!self._boy._done) {
	    process.nextTick(function () {
	      self._boy._done = true;
	      self._boy.emit('finish');
	    });
	  }
	};

	function skipPart (part) {
	  part.resume();
	}

	function FileStream (opts) {
	  Readable.call(this, opts);

	  this.bytesRead = 0;

	  this.truncated = false;
	}

	inherits(FileStream, Readable);

	FileStream.prototype._read = function (n) {};

	multipart = Multipart;
	return multipart;
}

var Decoder_1;
var hasRequiredDecoder$1;

function requireDecoder$1 () {
	if (hasRequiredDecoder$1) return Decoder_1;
	hasRequiredDecoder$1 = 1;

	const RE_PLUS = /\+/g;

	const HEX = [
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
	];

	function Decoder () {
	  this.buffer = undefined;
	}
	Decoder.prototype.write = function (str) {
	  // Replace '+' with ' ' before decoding
	  str = str.replace(RE_PLUS, ' ');
	  let res = '';
	  let i = 0; let p = 0; const len = str.length;
	  for (; i < len; ++i) {
	    if (this.buffer !== undefined) {
	      if (!HEX[str.charCodeAt(i)]) {
	        res += '%' + this.buffer;
	        this.buffer = undefined;
	        --i; // retry character
	      } else {
	        this.buffer += str[i];
	        ++p;
	        if (this.buffer.length === 2) {
	          res += String.fromCharCode(parseInt(this.buffer, 16));
	          this.buffer = undefined;
	        }
	      }
	    } else if (str[i] === '%') {
	      if (i > p) {
	        res += str.substring(p, i);
	        p = i;
	      }
	      this.buffer = '';
	      ++p;
	    }
	  }
	  if (p < len && this.buffer === undefined) { res += str.substring(p); }
	  return res
	};
	Decoder.prototype.reset = function () {
	  this.buffer = undefined;
	};

	Decoder_1 = Decoder;
	return Decoder_1;
}

var urlencoded;
var hasRequiredUrlencoded;

function requireUrlencoded () {
	if (hasRequiredUrlencoded) return urlencoded;
	hasRequiredUrlencoded = 1;

	const Decoder = requireDecoder$1();
	const decodeText = requireDecodeText();
	const getLimit = requireGetLimit();

	const RE_CHARSET = /^charset$/i;

	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded (boy, cfg) {
	  const limits = cfg.limits;
	  const parsedConType = cfg.parsedConType;
	  this.boy = boy;

	  this.fieldSizeLimit = getLimit(limits, 'fieldSize', 1 * 1024 * 1024);
	  this.fieldNameSizeLimit = getLimit(limits, 'fieldNameSize', 100);
	  this.fieldsLimit = getLimit(limits, 'fields', Infinity);

	  let charset;
	  for (var i = 0, len = parsedConType.length; i < len; ++i) { // eslint-disable-line no-var
	    if (Array.isArray(parsedConType[i]) &&
	        RE_CHARSET.test(parsedConType[i][0])) {
	      charset = parsedConType[i][1].toLowerCase();
	      break
	    }
	  }

	  if (charset === undefined) { charset = cfg.defCharset || 'utf8'; }

	  this.decoder = new Decoder();
	  this.charset = charset;
	  this._fields = 0;
	  this._state = 'key';
	  this._checkingBytes = true;
	  this._bytesKey = 0;
	  this._bytesVal = 0;
	  this._key = '';
	  this._val = '';
	  this._keyTrunc = false;
	  this._valTrunc = false;
	  this._hitLimit = false;
	}

	UrlEncoded.prototype.write = function (data, cb) {
	  if (this._fields === this.fieldsLimit) {
	    if (!this.boy.hitFieldsLimit) {
	      this.boy.hitFieldsLimit = true;
	      this.boy.emit('fieldsLimit');
	    }
	    return cb()
	  }

	  let idxeq; let idxamp; let i; let p = 0; const len = data.length;

	  while (p < len) {
	    if (this._state === 'key') {
	      idxeq = idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x3D/* = */) {
	          idxeq = i;
	          break
	        } else if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesKey; }
	      }

	      if (idxeq !== undefined) {
	        // key with assignment
	        if (idxeq > p) { this._key += this.decoder.write(data.toString('binary', p, idxeq)); }
	        this._state = 'val';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._val = '';
	        this._bytesVal = 0;
	        this._valTrunc = false;
	        this.decoder.reset();

	        p = idxeq + 1;
	      } else if (idxamp !== undefined) {
	        // key with no assignment
	        ++this._fields;
	        let key; const keyTrunc = this._keyTrunc;
	        if (idxamp > p) { key = (this._key += this.decoder.write(data.toString('binary', p, idxamp))); } else { key = this._key; }

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        if (key.length) {
	          this.boy.emit('field', decodeText(key, 'binary', this.charset),
	            '',
	            keyTrunc,
	            false);
	        }

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._key += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._keyTrunc = true;
	        }
	      } else {
	        if (p < len) { this._key += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    } else {
	      idxamp = undefined;
	      for (i = p; i < len; ++i) {
	        if (!this._checkingBytes) { ++p; }
	        if (data[i] === 0x26/* & */) {
	          idxamp = i;
	          break
	        }
	        if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
	          this._hitLimit = true;
	          break
	        } else if (this._checkingBytes) { ++this._bytesVal; }
	      }

	      if (idxamp !== undefined) {
	        ++this._fields;
	        if (idxamp > p) { this._val += this.decoder.write(data.toString('binary', p, idxamp)); }
	        this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	          decodeText(this._val, 'binary', this.charset),
	          this._keyTrunc,
	          this._valTrunc);
	        this._state = 'key';

	        this._hitLimit = false;
	        this._checkingBytes = true;
	        this._key = '';
	        this._bytesKey = 0;
	        this._keyTrunc = false;
	        this.decoder.reset();

	        p = idxamp + 1;
	        if (this._fields === this.fieldsLimit) { return cb() }
	      } else if (this._hitLimit) {
	        // we may not have hit the actual limit if there are encoded bytes...
	        if (i > p) { this._val += this.decoder.write(data.toString('binary', p, i)); }
	        p = i;
	        if ((this._val === '' && this.fieldSizeLimit === 0) ||
	            (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
	          // yep, we actually did hit the limit
	          this._checkingBytes = false;
	          this._valTrunc = true;
	        }
	      } else {
	        if (p < len) { this._val += this.decoder.write(data.toString('binary', p)); }
	        p = len;
	      }
	    }
	  }
	  cb();
	};

	UrlEncoded.prototype.end = function () {
	  if (this.boy._done) { return }

	  if (this._state === 'key' && this._key.length > 0) {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      '',
	      this._keyTrunc,
	      false);
	  } else if (this._state === 'val') {
	    this.boy.emit('field', decodeText(this._key, 'binary', this.charset),
	      decodeText(this._val, 'binary', this.charset),
	      this._keyTrunc,
	      this._valTrunc);
	  }
	  this.boy._done = true;
	  this.boy.emit('finish');
	};

	urlencoded = UrlEncoded;
	return urlencoded;
}

var hasRequiredMain;

function requireMain () {
	if (hasRequiredMain) return main$1.exports;
	hasRequiredMain = 1;

	const WritableStream = require$$0$c.Writable;
	const { inherits } = require$$1$2;
	const Dicer = requireDicer();

	const MultipartParser = requireMultipart();
	const UrlencodedParser = requireUrlencoded();
	const parseParams = requireParseParams();

	function Busboy (opts) {
	  if (!(this instanceof Busboy)) { return new Busboy(opts) }

	  if (typeof opts !== 'object') {
	    throw new TypeError('Busboy expected an options-Object.')
	  }
	  if (typeof opts.headers !== 'object') {
	    throw new TypeError('Busboy expected an options-Object with headers-attribute.')
	  }
	  if (typeof opts.headers['content-type'] !== 'string') {
	    throw new TypeError('Missing Content-Type-header.')
	  }

	  const {
	    headers,
	    ...streamOptions
	  } = opts;

	  this.opts = {
	    autoDestroy: false,
	    ...streamOptions
	  };
	  WritableStream.call(this, this.opts);

	  this._done = false;
	  this._parser = this.getParserByHeaders(headers);
	  this._finished = false;
	}
	inherits(Busboy, WritableStream);

	Busboy.prototype.emit = function (ev) {
	  if (ev === 'finish') {
	    if (!this._done) {
	      this._parser?.end();
	      return
	    } else if (this._finished) {
	      return
	    }
	    this._finished = true;
	  }
	  WritableStream.prototype.emit.apply(this, arguments);
	};

	Busboy.prototype.getParserByHeaders = function (headers) {
	  const parsed = parseParams(headers['content-type']);

	  const cfg = {
	    defCharset: this.opts.defCharset,
	    fileHwm: this.opts.fileHwm,
	    headers,
	    highWaterMark: this.opts.highWaterMark,
	    isPartAFile: this.opts.isPartAFile,
	    limits: this.opts.limits,
	    parsedConType: parsed,
	    preservePath: this.opts.preservePath
	  };

	  if (MultipartParser.detect.test(parsed[0])) {
	    return new MultipartParser(this, cfg)
	  }
	  if (UrlencodedParser.detect.test(parsed[0])) {
	    return new UrlencodedParser(this, cfg)
	  }
	  throw new Error('Unsupported Content-Type.')
	};

	Busboy.prototype._write = function (chunk, encoding, cb) {
	  this._parser.write(chunk, cb);
	};

	main$1.exports = Busboy;
	main$1.exports.default = Busboy;
	main$1.exports.Busboy = Busboy;

	main$1.exports.Dicer = Dicer;
	return main$1.exports;
}

var constants$4;
var hasRequiredConstants$4;

function requireConstants$4 () {
	if (hasRequiredConstants$4) return constants$4;
	hasRequiredConstants$4 = 1;

	const { MessageChannel, receiveMessageOnPort } = require$$0$d;

	const corsSafeListedMethods = ['GET', 'HEAD', 'POST'];
	const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);

	const nullBodyStatus = [101, 204, 205, 304];

	const redirectStatus = [301, 302, 303, 307, 308];
	const redirectStatusSet = new Set(redirectStatus);

	// https://fetch.spec.whatwg.org/#block-bad-port
	const badPorts = [
	  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',
	  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',
	  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',
	  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',
	  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',
	  '10080'
	];

	const badPortsSet = new Set(badPorts);

	// https://w3c.github.io/webappsec-referrer-policy/#referrer-policies
	const referrerPolicy = [
	  '',
	  'no-referrer',
	  'no-referrer-when-downgrade',
	  'same-origin',
	  'origin',
	  'strict-origin',
	  'origin-when-cross-origin',
	  'strict-origin-when-cross-origin',
	  'unsafe-url'
	];
	const referrerPolicySet = new Set(referrerPolicy);

	const requestRedirect = ['follow', 'manual', 'error'];

	const safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE'];
	const safeMethodsSet = new Set(safeMethods);

	const requestMode = ['navigate', 'same-origin', 'no-cors', 'cors'];

	const requestCredentials = ['omit', 'same-origin', 'include'];

	const requestCache = [
	  'default',
	  'no-store',
	  'reload',
	  'no-cache',
	  'force-cache',
	  'only-if-cached'
	];

	// https://fetch.spec.whatwg.org/#request-body-header-name
	const requestBodyHeader = [
	  'content-encoding',
	  'content-language',
	  'content-location',
	  'content-type',
	  // See https://github.com/nodejs/undici/issues/2021
	  // 'Content-Length' is a forbidden header name, which is typically
	  // removed in the Headers implementation. However, undici doesn't
	  // filter out headers, so we add it here.
	  'content-length'
	];

	// https://fetch.spec.whatwg.org/#enumdef-requestduplex
	const requestDuplex = [
	  'half'
	];

	// http://fetch.spec.whatwg.org/#forbidden-method
	const forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK'];
	const forbiddenMethodsSet = new Set(forbiddenMethods);

	const subresource = [
	  'audio',
	  'audioworklet',
	  'font',
	  'image',
	  'manifest',
	  'paintworklet',
	  'script',
	  'style',
	  'track',
	  'video',
	  'xslt',
	  ''
	];
	const subresourceSet = new Set(subresource);

	/** @type {globalThis['DOMException']} */
	const DOMException = globalThis.DOMException ?? (() => {
	  // DOMException was only made a global in Node v17.0.0,
	  // but fetch supports >= v16.8.
	  try {
	    atob('~');
	  } catch (err) {
	    return Object.getPrototypeOf(err).constructor
	  }
	})();

	let channel;

	/** @type {globalThis['structuredClone']} */
	const structuredClone =
	  globalThis.structuredClone ??
	  // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
	  // structuredClone was added in v17.0.0, but fetch supports v16.8
	  function structuredClone (value, options = undefined) {
	    if (arguments.length === 0) {
	      throw new TypeError('missing argument')
	    }

	    if (!channel) {
	      channel = new MessageChannel();
	    }
	    channel.port1.unref();
	    channel.port2.unref();
	    channel.port1.postMessage(value, options?.transfer);
	    return receiveMessageOnPort(channel.port2).message
	  };

	constants$4 = {
	  DOMException,
	  structuredClone,
	  subresource,
	  forbiddenMethods,
	  requestBodyHeader,
	  referrerPolicy,
	  requestRedirect,
	  requestMode,
	  requestCredentials,
	  requestCache,
	  redirectStatus,
	  corsSafeListedMethods,
	  nullBodyStatus,
	  safeMethods,
	  badPorts,
	  requestDuplex,
	  subresourceSet,
	  badPortsSet,
	  redirectStatusSet,
	  corsSafeListedMethodsSet,
	  safeMethodsSet,
	  forbiddenMethodsSet,
	  referrerPolicySet
	};
	return constants$4;
}

var global$2;
var hasRequiredGlobal$1;

function requireGlobal$1 () {
	if (hasRequiredGlobal$1) return global$2;
	hasRequiredGlobal$1 = 1;

	// In case of breaking changes, increase the version
	// number to avoid conflicts.
	const globalOrigin = Symbol.for('undici.globalOrigin.1');

	function getGlobalOrigin () {
	  return globalThis[globalOrigin]
	}

	function setGlobalOrigin (newOrigin) {
	  if (newOrigin === undefined) {
	    Object.defineProperty(globalThis, globalOrigin, {
	      value: undefined,
	      writable: true,
	      enumerable: false,
	      configurable: false
	    });

	    return
	  }

	  const parsedURL = new URL(newOrigin);

	  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {
	    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)
	  }

	  Object.defineProperty(globalThis, globalOrigin, {
	    value: parsedURL,
	    writable: true,
	    enumerable: false,
	    configurable: false
	  });
	}

	global$2 = {
	  getGlobalOrigin,
	  setGlobalOrigin
	};
	return global$2;
}

var util$7;
var hasRequiredUtil$7;

function requireUtil$7 () {
	if (hasRequiredUtil$7) return util$7;
	hasRequiredUtil$7 = 1;

	const { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = requireConstants$4();
	const { getGlobalOrigin } = requireGlobal$1();
	const { performance } = require$$2$4;
	const { isBlobLike, toUSVString, ReadableStreamFrom } = requireUtil$8();
	const assert = require$$0$8;
	const { isUint8Array } = require$$5$1;

	let supportedHashes = [];

	// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable
	/** @type {import('crypto')|undefined} */
	let crypto;

	try {
	  crypto = require('crypto');
	  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512'];
	  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	/* c8 ignore next 3 */
	} catch {
	}

	function responseURL (response) {
	  // https://fetch.spec.whatwg.org/#responses
	  // A response has an associated URL. It is a pointer to the last URL
	  // in responses URL list and null if responses URL list is empty.
	  const urlList = response.urlList;
	  const length = urlList.length;
	  return length === 0 ? null : urlList[length - 1].toString()
	}

	// https://fetch.spec.whatwg.org/#concept-response-location-url
	function responseLocationURL (response, requestFragment) {
	  // 1. If responses status is not a redirect status, then return null.
	  if (!redirectStatusSet.has(response.status)) {
	    return null
	  }

	  // 2. Let location be the result of extracting header list values given
	  // `Location` and responses header list.
	  let location = response.headersList.get('location');

	  // 3. If location is a header value, then set location to the result of
	  //    parsing location with responses URL.
	  if (location !== null && isValidHeaderValue(location)) {
	    location = new URL(location, responseURL(response));
	  }

	  // 4. If location is a URL whose fragment is null, then set locations
	  // fragment to requestFragment.
	  if (location && !location.hash) {
	    location.hash = requestFragment;
	  }

	  // 5. Return location.
	  return location
	}

	/** @returns {URL} */
	function requestCurrentURL (request) {
	  return request.urlList[request.urlList.length - 1]
	}

	function requestBadPort (request) {
	  // 1. Let url be requests current URL.
	  const url = requestCurrentURL(request);

	  // 2. If urls scheme is an HTTP(S) scheme and urls port is a bad port,
	  // then return blocked.
	  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
	    return 'blocked'
	  }

	  // 3. Return allowed.
	  return 'allowed'
	}

	function isErrorLike (object) {
	  return object instanceof Error || (
	    object?.constructor?.name === 'Error' ||
	    object?.constructor?.name === 'DOMException'
	  )
	}

	// Check whether |statusText| is a ByteString and
	// matches the Reason-Phrase token production.
	// RFC 2616: https://tools.ietf.org/html/rfc2616
	// RFC 7230: https://tools.ietf.org/html/rfc7230
	// "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
	// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
	function isValidReasonPhrase (statusText) {
	  for (let i = 0; i < statusText.length; ++i) {
	    const c = statusText.charCodeAt(i);
	    if (
	      !(
	        (
	          c === 0x09 || // HTAB
	          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR
	          (c >= 0x80 && c <= 0xff)
	        ) // obs-text
	      )
	    ) {
	      return false
	    }
	  }
	  return true
	}

	/**
	 * @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	 * @param {number} c
	 */
	function isTokenCharCode (c) {
	  switch (c) {
	    case 0x22:
	    case 0x28:
	    case 0x29:
	    case 0x2c:
	    case 0x2f:
	    case 0x3a:
	    case 0x3b:
	    case 0x3c:
	    case 0x3d:
	    case 0x3e:
	    case 0x3f:
	    case 0x40:
	    case 0x5b:
	    case 0x5c:
	    case 0x5d:
	    case 0x7b:
	    case 0x7d:
	      // DQUOTE and "(),/:;<=>?@[\]{}"
	      return false
	    default:
	      // VCHAR %x21-7E
	      return c >= 0x21 && c <= 0x7e
	  }
	}

	/**
	 * @param {string} characters
	 */
	function isValidHTTPToken (characters) {
	  if (characters.length === 0) {
	    return false
	  }
	  for (let i = 0; i < characters.length; ++i) {
	    if (!isTokenCharCode(characters.charCodeAt(i))) {
	      return false
	    }
	  }
	  return true
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#header-name
	 * @param {string} potentialValue
	 */
	function isValidHeaderName (potentialValue) {
	  return isValidHTTPToken(potentialValue)
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#header-value
	 * @param {string} potentialValue
	 */
	function isValidHeaderValue (potentialValue) {
	  // - Has no leading or trailing HTTP tab or space bytes.
	  // - Contains no 0x00 (NUL) or HTTP newline bytes.
	  if (
	    potentialValue.startsWith('\t') ||
	    potentialValue.startsWith(' ') ||
	    potentialValue.endsWith('\t') ||
	    potentialValue.endsWith(' ')
	  ) {
	    return false
	  }

	  if (
	    potentialValue.includes('\0') ||
	    potentialValue.includes('\r') ||
	    potentialValue.includes('\n')
	  ) {
	    return false
	  }

	  return true
	}

	// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
	function setRequestReferrerPolicyOnRedirect (request, actualResponse) {
	  //  Given a request request and a response actualResponse, this algorithm
	  //  updates requests referrer policy according to the Referrer-Policy
	  //  header (if any) in actualResponse.

	  // 1. Let policy be the result of executing  8.1 Parse a referrer policy
	  // from a Referrer-Policy header on actualResponse.

	  // 8.1 Parse a referrer policy from a Referrer-Policy header
	  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and responses header list.
	  const { headersList } = actualResponse;
	  // 2. Let policy be the empty string.
	  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.
	  // 4. Return policy.
	  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');

	  // Note: As the referrer-policy can contain multiple policies
	  // separated by comma, we need to loop through all of them
	  // and pick the first valid one.
	  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy
	  let policy = '';
	  if (policyHeader.length > 0) {
	    // The right-most policy takes precedence.
	    // The left-most policy is the fallback.
	    for (let i = policyHeader.length; i !== 0; i--) {
	      const token = policyHeader[i - 1].trim();
	      if (referrerPolicyTokens.has(token)) {
	        policy = token;
	        break
	      }
	    }
	  }

	  // 2. If policy is not the empty string, then set requests referrer policy to policy.
	  if (policy !== '') {
	    request.referrerPolicy = policy;
	  }
	}

	// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
	function crossOriginResourcePolicyCheck () {
	  // TODO
	  return 'allowed'
	}

	// https://fetch.spec.whatwg.org/#concept-cors-check
	function corsCheck () {
	  // TODO
	  return 'success'
	}

	// https://fetch.spec.whatwg.org/#concept-tao-check
	function TAOCheck () {
	  // TODO
	  return 'success'
	}

	function appendFetchMetadata (httpRequest) {
	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
	  //  TODO

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

	  //  1. Assert: rs url is a potentially trustworthy URL.
	  //  TODO

	  //  2. Let header be a Structured Header whose value is a token.
	  let header = null;

	  //  3. Set headers value to rs mode.
	  header = httpRequest.mode;

	  //  4. Set a structured field value `Sec-Fetch-Mode`/header in rs header list.
	  httpRequest.headersList.set('sec-fetch-mode', header);

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
	  //  TODO

	  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
	  //  TODO
	}

	// https://fetch.spec.whatwg.org/#append-a-request-origin-header
	function appendRequestOriginHeader (request) {
	  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
	  let serializedOrigin = request.origin;

	  // 2. If requests response tainting is "cors" or requests mode is "websocket", then append (`Origin`, serializedOrigin) to requests header list.
	  if (request.responseTainting === 'cors' || request.mode === 'websocket') {
	    if (serializedOrigin) {
	      request.headersList.append('origin', serializedOrigin);
	    }

	  // 3. Otherwise, if requests method is neither `GET` nor `HEAD`, then:
	  } else if (request.method !== 'GET' && request.method !== 'HEAD') {
	    // 1. Switch on requests referrer policy:
	    switch (request.referrerPolicy) {
	      case 'no-referrer':
	        // Set serializedOrigin to `null`.
	        serializedOrigin = null;
	        break
	      case 'no-referrer-when-downgrade':
	      case 'strict-origin':
	      case 'strict-origin-when-cross-origin':
	        // If requests origin is a tuple origin, its scheme is "https", and requests current URLs scheme is not "https", then set serializedOrigin to `null`.
	        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
	          serializedOrigin = null;
	        }
	        break
	      case 'same-origin':
	        // If requests origin is not same origin with requests current URLs origin, then set serializedOrigin to `null`.
	        if (!sameOrigin(request, requestCurrentURL(request))) {
	          serializedOrigin = null;
	        }
	        break
	        // Do nothing.
	    }

	    if (serializedOrigin) {
	      // 2. Append (`Origin`, serializedOrigin) to requests header list.
	      request.headersList.append('origin', serializedOrigin);
	    }
	  }
	}

	function coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {
	  // TODO
	  return performance.now()
	}

	// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
	function createOpaqueTimingInfo (timingInfo) {
	  return {
	    startTime: timingInfo.startTime ?? 0,
	    redirectStartTime: 0,
	    redirectEndTime: 0,
	    postRedirectStartTime: timingInfo.startTime ?? 0,
	    finalServiceWorkerStartTime: 0,
	    finalNetworkResponseStartTime: 0,
	    finalNetworkRequestStartTime: 0,
	    endTime: 0,
	    encodedBodySize: 0,
	    decodedBodySize: 0,
	    finalConnectionTimingInfo: null
	  }
	}

	// https://html.spec.whatwg.org/multipage/origin.html#policy-container
	function makePolicyContainer () {
	  // Note: the fetch spec doesn't make use of embedder policy or CSP list
	  return {
	    referrerPolicy: 'strict-origin-when-cross-origin'
	  }
	}

	// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
	function clonePolicyContainer (policyContainer) {
	  return {
	    referrerPolicy: policyContainer.referrerPolicy
	  }
	}

	// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
	function determineRequestsReferrer (request) {
	  // 1. Let policy be request's referrer policy.
	  const policy = request.referrerPolicy;

	  // Note: policy cannot (shouldn't) be null or an empty string.
	  assert(policy);

	  // 2. Let environment be requests client.

	  let referrerSource = null;

	  // 3. Switch on requests referrer:
	  if (request.referrer === 'client') {
	    // Note: node isn't a browser and doesn't implement document/iframes,
	    // so we bypass this step and replace it with our own.

	    const globalOrigin = getGlobalOrigin();

	    if (!globalOrigin || globalOrigin.origin === 'null') {
	      return 'no-referrer'
	    }

	    // note: we need to clone it as it's mutated
	    referrerSource = new URL(globalOrigin);
	  } else if (request.referrer instanceof URL) {
	    // Let referrerSource be requests referrer.
	    referrerSource = request.referrer;
	  }

	  // 4. Let requests referrerURL be the result of stripping referrerSource for
	  //    use as a referrer.
	  let referrerURL = stripURLForReferrer(referrerSource);

	  // 5. Let referrerOrigin be the result of stripping referrerSource for use as
	  //    a referrer, with the origin-only flag set to true.
	  const referrerOrigin = stripURLForReferrer(referrerSource, true);

	  // 6. If the result of serializing referrerURL is a string whose length is
	  //    greater than 4096, set referrerURL to referrerOrigin.
	  if (referrerURL.toString().length > 4096) {
	    referrerURL = referrerOrigin;
	  }

	  const areSameOrigin = sameOrigin(request, referrerURL);
	  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&
	    !isURLPotentiallyTrustworthy(request.url);

	  // 8. Execute the switch statements corresponding to the value of policy:
	  switch (policy) {
	    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)
	    case 'unsafe-url': return referrerURL
	    case 'same-origin':
	      return areSameOrigin ? referrerOrigin : 'no-referrer'
	    case 'origin-when-cross-origin':
	      return areSameOrigin ? referrerURL : referrerOrigin
	    case 'strict-origin-when-cross-origin': {
	      const currentURL = requestCurrentURL(request);

	      // 1. If the origin of referrerURL and the origin of requests current
	      //    URL are the same, then return referrerURL.
	      if (sameOrigin(referrerURL, currentURL)) {
	        return referrerURL
	      }

	      // 2. If referrerURL is a potentially trustworthy URL and requests
	      //    current URL is not a potentially trustworthy URL, then return no
	      //    referrer.
	      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
	        return 'no-referrer'
	      }

	      // 3. Return referrerOrigin.
	      return referrerOrigin
	    }
	    case 'strict-origin': // eslint-disable-line
	      /**
	         * 1. If referrerURL is a potentially trustworthy URL and
	         * requests current URL is not a potentially trustworthy URL,
	         * then return no referrer.
	         * 2. Return referrerOrigin
	        */
	    case 'no-referrer-when-downgrade': // eslint-disable-line
	      /**
	       * 1. If referrerURL is a potentially trustworthy URL and
	       * requests current URL is not a potentially trustworthy URL,
	       * then return no referrer.
	       * 2. Return referrerOrigin
	      */

	    default: // eslint-disable-line
	      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin
	  }
	}

	/**
	 * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	 * @param {URL} url
	 * @param {boolean|undefined} originOnly
	 */
	function stripURLForReferrer (url, originOnly) {
	  // 1. Assert: url is a URL.
	  assert(url instanceof URL);

	  // 2. If urls scheme is a local scheme, then return no referrer.
	  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {
	    return 'no-referrer'
	  }

	  // 3. Set urls username to the empty string.
	  url.username = '';

	  // 4. Set urls password to the empty string.
	  url.password = '';

	  // 5. Set urls fragment to null.
	  url.hash = '';

	  // 6. If the origin-only flag is true, then:
	  if (originOnly) {
	    // 1. Set urls path to  the empty string .
	    url.pathname = '';

	    // 2. Set urls query to null.
	    url.search = '';
	  }

	  // 7. Return url.
	  return url
	}

	function isURLPotentiallyTrustworthy (url) {
	  if (!(url instanceof URL)) {
	    return false
	  }

	  // If child of about, return true
	  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {
	    return true
	  }

	  // If scheme is data, return true
	  if (url.protocol === 'data:') return true

	  // If file, return true
	  if (url.protocol === 'file:') return true

	  return isOriginPotentiallyTrustworthy(url.origin)

	  function isOriginPotentiallyTrustworthy (origin) {
	    // If origin is explicitly null, return false
	    if (origin == null || origin === 'null') return false

	    const originAsURL = new URL(origin);

	    // If secure, return true
	    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {
	      return true
	    }

	    // If localhost or variants, return true
	    if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) ||
	     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||
	     (originAsURL.hostname.endsWith('.localhost'))) {
	      return true
	    }

	    // If any other, return false
	    return false
	  }
	}

	/**
	 * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	 * @param {Uint8Array} bytes
	 * @param {string} metadataList
	 */
	function bytesMatch (bytes, metadataList) {
	  // If node is not built with OpenSSL support, we cannot check
	  // a request's integrity, so allow it by default (the spec will
	  // allow requests if an invalid hash is given, as precedence).
	  /* istanbul ignore if: only if node is built with --without-ssl */
	  if (crypto === undefined) {
	    return true
	  }

	  // 1. Let parsedMetadata be the result of parsing metadataList.
	  const parsedMetadata = parseMetadata(metadataList);

	  // 2. If parsedMetadata is no metadata, return true.
	  if (parsedMetadata === 'no metadata') {
	    return true
	  }

	  // 3. If response is not eligible for integrity validation, return false.
	  // TODO

	  // 4. If parsedMetadata is the empty set, return true.
	  if (parsedMetadata.length === 0) {
	    return true
	  }

	  // 5. Let metadata be the result of getting the strongest
	  //    metadata from parsedMetadata.
	  const strongest = getStrongestMetadata(parsedMetadata);
	  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);

	  // 6. For each item in metadata:
	  for (const item of metadata) {
	    // 1. Let algorithm be the alg component of item.
	    const algorithm = item.algo;

	    // 2. Let expectedValue be the val component of item.
	    const expectedValue = item.hash;

	    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e
	    // "be liberal with padding". This is annoying, and it's not even in the spec.

	    // 3. Let actualValue be the result of applying algorithm to bytes.
	    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');

	    if (actualValue[actualValue.length - 1] === '=') {
	      if (actualValue[actualValue.length - 2] === '=') {
	        actualValue = actualValue.slice(0, -2);
	      } else {
	        actualValue = actualValue.slice(0, -1);
	      }
	    }

	    // 4. If actualValue is a case-sensitive match for expectedValue,
	    //    return true.
	    if (compareBase64Mixed(actualValue, expectedValue)) {
	      return true
	    }
	  }

	  // 7. Return false.
	  return false
	}

	// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options
	// https://www.w3.org/TR/CSP2/#source-list-syntax
	// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;

	/**
	 * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	 * @param {string} metadata
	 */
	function parseMetadata (metadata) {
	  // 1. Let result be the empty set.
	  /** @type {{ algo: string, hash: string }[]} */
	  const result = [];

	  // 2. Let empty be equal to true.
	  let empty = true;

	  // 3. For each token returned by splitting metadata on spaces:
	  for (const token of metadata.split(' ')) {
	    // 1. Set empty to false.
	    empty = false;

	    // 2. Parse token as a hash-with-options.
	    const parsedToken = parseHashWithOptions.exec(token);

	    // 3. If token does not parse, continue to the next token.
	    if (
	      parsedToken === null ||
	      parsedToken.groups === undefined ||
	      parsedToken.groups.algo === undefined
	    ) {
	      // Note: Chromium blocks the request at this point, but Firefox
	      // gives a warning that an invalid integrity was given. The
	      // correct behavior is to ignore these, and subsequently not
	      // check the integrity of the resource.
	      continue
	    }

	    // 4. Let algorithm be the hash-algo component of token.
	    const algorithm = parsedToken.groups.algo.toLowerCase();

	    // 5. If algorithm is a hash function recognized by the user
	    //    agent, add the parsed token to result.
	    if (supportedHashes.includes(algorithm)) {
	      result.push(parsedToken.groups);
	    }
	  }

	  // 4. Return no metadata if empty is true, otherwise return result.
	  if (empty === true) {
	    return 'no metadata'
	  }

	  return result
	}

	/**
	 * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	 */
	function getStrongestMetadata (metadataList) {
	  // Let algorithm be the algo component of the first item in metadataList.
	  // Can be sha256
	  let algorithm = metadataList[0].algo;
	  // If the algorithm is sha512, then it is the strongest
	  // and we can return immediately
	  if (algorithm[3] === '5') {
	    return algorithm
	  }

	  for (let i = 1; i < metadataList.length; ++i) {
	    const metadata = metadataList[i];
	    // If the algorithm is sha512, then it is the strongest
	    // and we can break the loop immediately
	    if (metadata.algo[3] === '5') {
	      algorithm = 'sha512';
	      break
	    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored
	    } else if (algorithm[3] === '3') {
	      continue
	    // algorithm is sha256, check if algorithm is sha384 and if so, set it as
	    // the strongest
	    } else if (metadata.algo[3] === '3') {
	      algorithm = 'sha384';
	    }
	  }
	  return algorithm
	}

	function filterMetadataListByAlgorithm (metadataList, algorithm) {
	  if (metadataList.length === 1) {
	    return metadataList
	  }

	  let pos = 0;
	  for (let i = 0; i < metadataList.length; ++i) {
	    if (metadataList[i].algo === algorithm) {
	      metadataList[pos++] = metadataList[i];
	    }
	  }

	  metadataList.length = pos;

	  return metadataList
	}

	/**
	 * Compares two base64 strings, allowing for base64url
	 * in the second string.
	 *
	* @param {string} actualValue always base64
	 * @param {string} expectedValue base64 or base64url
	 * @returns {boolean}
	 */
	function compareBase64Mixed (actualValue, expectedValue) {
	  if (actualValue.length !== expectedValue.length) {
	    return false
	  }
	  for (let i = 0; i < actualValue.length; ++i) {
	    if (actualValue[i] !== expectedValue[i]) {
	      if (
	        (actualValue[i] === '+' && expectedValue[i] === '-') ||
	        (actualValue[i] === '/' && expectedValue[i] === '_')
	      ) {
	        continue
	      }
	      return false
	    }
	  }

	  return true
	}

	// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
	function tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {
	  // TODO
	}

	/**
	 * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	 * @param {URL} A
	 * @param {URL} B
	 */
	function sameOrigin (A, B) {
	  // 1. If A and B are the same opaque origin, then return true.
	  if (A.origin === B.origin && A.origin === 'null') {
	    return true
	  }

	  // 2. If A and B are both tuple origins and their schemes,
	  //    hosts, and port are identical, then return true.
	  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
	    return true
	  }

	  // 3. Return false.
	  return false
	}

	function createDeferredPromise () {
	  let res;
	  let rej;
	  const promise = new Promise((resolve, reject) => {
	    res = resolve;
	    rej = reject;
	  });

	  return { promise, resolve: res, reject: rej }
	}

	function isAborted (fetchParams) {
	  return fetchParams.controller.state === 'aborted'
	}

	function isCancelled (fetchParams) {
	  return fetchParams.controller.state === 'aborted' ||
	    fetchParams.controller.state === 'terminated'
	}

	const normalizeMethodRecord = {
	  delete: 'DELETE',
	  DELETE: 'DELETE',
	  get: 'GET',
	  GET: 'GET',
	  head: 'HEAD',
	  HEAD: 'HEAD',
	  options: 'OPTIONS',
	  OPTIONS: 'OPTIONS',
	  post: 'POST',
	  POST: 'POST',
	  put: 'PUT',
	  PUT: 'PUT'
	};

	// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.
	Object.setPrototypeOf(normalizeMethodRecord, null);

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-method-normalize
	 * @param {string} method
	 */
	function normalizeMethod (method) {
	  return normalizeMethodRecord[method.toLowerCase()] ?? method
	}

	// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
	function serializeJavascriptValueToJSONString (value) {
	  // 1. Let result be ? Call(%JSON.stringify%, undefined,  value ).
	  const result = JSON.stringify(value);

	  // 2. If result is undefined, then throw a TypeError.
	  if (result === undefined) {
	    throw new TypeError('Value is not JSON serializable')
	  }

	  // 3. Assert: result is a string.
	  assert(typeof result === 'string');

	  // 4. Return result.
	  return result
	}

	// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));

	/**
	 * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	 * @param {() => unknown[]} iterator
	 * @param {string} name name of the instance
	 * @param {'key'|'value'|'key+value'} kind
	 */
	function makeIterator (iterator, name, kind) {
	  const object = {
	    index: 0,
	    kind,
	    target: iterator
	  };

	  const i = {
	    next () {
	      // 1. Let interface be the interface for which the iterator prototype object exists.

	      // 2. Let thisValue be the this value.

	      // 3. Let object be ? ToObject(thisValue).

	      // 4. If object is a platform object, then perform a security
	      //    check, passing:

	      // 5. If object is not a default iterator object for interface,
	      //    then throw a TypeError.
	      if (Object.getPrototypeOf(this) !== i) {
	        throw new TypeError(
	          `'next' called on an object that does not implement interface ${name} Iterator.`
	        )
	      }

	      // 6. Let index be objects index.
	      // 7. Let kind be objects kind.
	      // 8. Let values be objects target's value pairs to iterate over.
	      const { index, kind, target } = object;
	      const values = target();

	      // 9. Let len be the length of values.
	      const len = values.length;

	      // 10. If index is greater than or equal to len, then return
	      //     CreateIterResultObject(undefined, true).
	      if (index >= len) {
	        return { value: undefined, done: true }
	      }

	      // 11. Let pair be the entry in values at index index.
	      const pair = values[index];

	      // 12. Set objects index to index + 1.
	      object.index = index + 1;

	      // 13. Return the iterator result for pair and kind.
	      return iteratorResult(pair, kind)
	    },
	    // The class string of an iterator prototype object for a given interface is the
	    // result of concatenating the identifier of the interface and the string " Iterator".
	    [Symbol.toStringTag]: `${name} Iterator`
	  };

	  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
	  Object.setPrototypeOf(i, esIteratorPrototype);
	  // esIteratorPrototype needs to be the prototype of i
	  // which is the prototype of an empty object. Yes, it's confusing.
	  return Object.setPrototypeOf({}, i)
	}

	// https://webidl.spec.whatwg.org/#iterator-result
	function iteratorResult (pair, kind) {
	  let result;

	  // 1. Let result be a value determined by the value of kind:
	  switch (kind) {
	    case 'key': {
	      // 1. Let idlKey be pairs key.
	      // 2. Let key be the result of converting idlKey to an
	      //    ECMAScript value.
	      // 3. result is key.
	      result = pair[0];
	      break
	    }
	    case 'value': {
	      // 1. Let idlValue be pairs value.
	      // 2. Let value be the result of converting idlValue to
	      //    an ECMAScript value.
	      // 3. result is value.
	      result = pair[1];
	      break
	    }
	    case 'key+value': {
	      // 1. Let idlKey be pairs key.
	      // 2. Let idlValue be pairs value.
	      // 3. Let key be the result of converting idlKey to an
	      //    ECMAScript value.
	      // 4. Let value be the result of converting idlValue to
	      //    an ECMAScript value.
	      // 5. Let array be ! ArrayCreate(2).
	      // 6. Call ! CreateDataProperty(array, "0", key).
	      // 7. Call ! CreateDataProperty(array, "1", value).
	      // 8. result is array.
	      result = pair;
	      break
	    }
	  }

	  // 2. Return CreateIterResultObject(result, false).
	  return { value: result, done: false }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#body-fully-read
	 */
	async function fullyReadBody (body, processBody, processBodyError) {
	  // 1. If taskDestination is null, then set taskDestination to
	  //    the result of starting a new parallel queue.

	  // 2. Let successSteps given a byte sequence bytes be to queue a
	  //    fetch task to run processBody given bytes, with taskDestination.
	  const successSteps = processBody;

	  // 3. Let errorSteps be to queue a fetch task to run processBodyError,
	  //    with taskDestination.
	  const errorSteps = processBodyError;

	  // 4. Let reader be the result of getting a reader for bodys stream.
	  //    If that threw an exception, then run errorSteps with that
	  //    exception and return.
	  let reader;

	  try {
	    reader = body.stream.getReader();
	  } catch (e) {
	    errorSteps(e);
	    return
	  }

	  // 5. Read all bytes from reader, given successSteps and errorSteps.
	  try {
	    const result = await readAllBytes(reader);
	    successSteps(result);
	  } catch (e) {
	    errorSteps(e);
	  }
	}

	/** @type {ReadableStream} */
	let ReadableStream = globalThis.ReadableStream;

	function isReadableStreamLike (stream) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  return stream instanceof ReadableStream || (
	    stream[Symbol.toStringTag] === 'ReadableStream' &&
	    typeof stream.tee === 'function'
	  )
	}

	const MAXIMUM_ARGUMENT_LENGTH = 65535;

	/**
	 * @see https://infra.spec.whatwg.org/#isomorphic-decode
	 * @param {number[]|Uint8Array} input
	 */
	function isomorphicDecode (input) {
	  // 1. To isomorphic decode a byte sequence input, return a string whose code point
	  //    length is equal to inputs length and whose code points have the same values
	  //    as the values of inputs bytes, in the same order.

	  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
	    return String.fromCharCode(...input)
	  }

	  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')
	}

	/**
	 * @param {ReadableStreamController<Uint8Array>} controller
	 */
	function readableStreamClose (controller) {
	  try {
	    controller.close();
	  } catch (err) {
	    // TODO: add comment explaining why this error occurs.
	    if (!err.message.includes('Controller is already closed')) {
	      throw err
	    }
	  }
	}

	/**
	 * @see https://infra.spec.whatwg.org/#isomorphic-encode
	 * @param {string} input
	 */
	function isomorphicEncode (input) {
	  // 1. Assert: input contains no code points greater than U+00FF.
	  for (let i = 0; i < input.length; i++) {
	    assert(input.charCodeAt(i) <= 0xFF);
	  }

	  // 2. Return a byte sequence whose length is equal to inputs code
	  //    point length and whose bytes have the same values as the
	  //    values of inputs code points, in the same order
	  return input
	}

	/**
	 * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	 * @see https://streams.spec.whatwg.org/#read-loop
	 * @param {ReadableStreamDefaultReader} reader
	 */
	async function readAllBytes (reader) {
	  const bytes = [];
	  let byteLength = 0;

	  while (true) {
	    const { done, value: chunk } = await reader.read();

	    if (done) {
	      // 1. Call successSteps with bytes.
	      return Buffer.concat(bytes, byteLength)
	    }

	    // 1. If chunk is not a Uint8Array object, call failureSteps
	    //    with a TypeError and abort these steps.
	    if (!isUint8Array(chunk)) {
	      throw new TypeError('Received non-Uint8Array chunk')
	    }

	    // 2. Append the bytes represented by chunk to bytes.
	    bytes.push(chunk);
	    byteLength += chunk.length;

	    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.
	  }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#is-local
	 * @param {URL} url
	 */
	function urlIsLocal (url) {
	  assert('protocol' in url); // ensure it's a url object

	  const protocol = url.protocol;

	  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'
	}

	/**
	 * @param {string|URL} url
	 */
	function urlHasHttpsScheme (url) {
	  if (typeof url === 'string') {
	    return url.startsWith('https:')
	  }

	  return url.protocol === 'https:'
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-scheme
	 * @param {URL} url
	 */
	function urlIsHttpHttpsScheme (url) {
	  assert('protocol' in url); // ensure it's a url object

	  const protocol = url.protocol;

	  return protocol === 'http:' || protocol === 'https:'
	}

	/**
	 * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	 */
	const hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));

	util$7 = {
	  isAborted,
	  isCancelled,
	  createDeferredPromise,
	  ReadableStreamFrom,
	  toUSVString,
	  tryUpgradeRequestToAPotentiallyTrustworthyURL,
	  coarsenedSharedCurrentTime,
	  determineRequestsReferrer,
	  makePolicyContainer,
	  clonePolicyContainer,
	  appendFetchMetadata,
	  appendRequestOriginHeader,
	  TAOCheck,
	  corsCheck,
	  crossOriginResourcePolicyCheck,
	  createOpaqueTimingInfo,
	  setRequestReferrerPolicyOnRedirect,
	  isValidHTTPToken,
	  requestBadPort,
	  requestCurrentURL,
	  responseURL,
	  responseLocationURL,
	  isBlobLike,
	  isURLPotentiallyTrustworthy,
	  isValidReasonPhrase,
	  sameOrigin,
	  normalizeMethod,
	  serializeJavascriptValueToJSONString,
	  makeIterator,
	  isValidHeaderName,
	  isValidHeaderValue,
	  hasOwn,
	  isErrorLike,
	  fullyReadBody,
	  bytesMatch,
	  isReadableStreamLike,
	  readableStreamClose,
	  isomorphicEncode,
	  isomorphicDecode,
	  urlIsLocal,
	  urlHasHttpsScheme,
	  urlIsHttpHttpsScheme,
	  readAllBytes,
	  normalizeMethodRecord,
	  parseMetadata
	};
	return util$7;
}

var symbols$3;
var hasRequiredSymbols$3;

function requireSymbols$3 () {
	if (hasRequiredSymbols$3) return symbols$3;
	hasRequiredSymbols$3 = 1;

	symbols$3 = {
	  kUrl: Symbol('url'),
	  kHeaders: Symbol('headers'),
	  kSignal: Symbol('signal'),
	  kState: Symbol('state'),
	  kGuard: Symbol('guard'),
	  kRealm: Symbol('realm')
	};
	return symbols$3;
}

var webidl_1;
var hasRequiredWebidl;

function requireWebidl () {
	if (hasRequiredWebidl) return webidl_1;
	hasRequiredWebidl = 1;

	const { types } = require$$0$7;
	const { hasOwn, toUSVString } = requireUtil$7();

	/** @type {import('../../types/webidl').Webidl} */
	const webidl = {};
	webidl.converters = {};
	webidl.util = {};
	webidl.errors = {};

	webidl.errors.exception = function (message) {
	  return new TypeError(`${message.header}: ${message.message}`)
	};

	webidl.errors.conversionFailed = function (context) {
	  const plural = context.types.length === 1 ? '' : ' one of';
	  const message =
	    `${context.argument} could not be converted to` +
	    `${plural}: ${context.types.join(', ')}.`;

	  return webidl.errors.exception({
	    header: context.prefix,
	    message
	  })
	};

	webidl.errors.invalidArgument = function (context) {
	  return webidl.errors.exception({
	    header: context.prefix,
	    message: `"${context.value}" is an invalid ${context.type}.`
	  })
	};

	// https://webidl.spec.whatwg.org/#implements
	webidl.brandCheck = function (V, I, opts = undefined) {
	  if (opts?.strict !== false && !(V instanceof I)) {
	    throw new TypeError('Illegal invocation')
	  } else {
	    return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag]
	  }
	};

	webidl.argumentLengthCheck = function ({ length }, min, ctx) {
	  if (length < min) {
	    throw webidl.errors.exception({
	      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +
	               `but${length ? ' only' : ''} ${length} found.`,
	      ...ctx
	    })
	  }
	};

	webidl.illegalConstructor = function () {
	  throw webidl.errors.exception({
	    header: 'TypeError',
	    message: 'Illegal constructor'
	  })
	};

	// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
	webidl.util.Type = function (V) {
	  switch (typeof V) {
	    case 'undefined': return 'Undefined'
	    case 'boolean': return 'Boolean'
	    case 'string': return 'String'
	    case 'symbol': return 'Symbol'
	    case 'number': return 'Number'
	    case 'bigint': return 'BigInt'
	    case 'function':
	    case 'object': {
	      if (V === null) {
	        return 'Null'
	      }

	      return 'Object'
	    }
	  }
	};

	// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
	webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
	  let upperBound;
	  let lowerBound;

	  // 1. If bitLength is 64, then:
	  if (bitLength === 64) {
	    // 1. Let upperBound be 2^53  1.
	    upperBound = Math.pow(2, 53) - 1;

	    // 2. If signedness is "unsigned", then let lowerBound be 0.
	    if (signedness === 'unsigned') {
	      lowerBound = 0;
	    } else {
	      // 3. Otherwise let lowerBound be 2^53 + 1.
	      lowerBound = Math.pow(-2, 53) + 1;
	    }
	  } else if (signedness === 'unsigned') {
	    // 2. Otherwise, if signedness is "unsigned", then:

	    // 1. Let lowerBound be 0.
	    lowerBound = 0;

	    // 2. Let upperBound be 2^bitLength  1.
	    upperBound = Math.pow(2, bitLength) - 1;
	  } else {
	    // 3. Otherwise:

	    // 1. Let lowerBound be -2^bitLength  1.
	    lowerBound = Math.pow(-2, bitLength) - 1;

	    // 2. Let upperBound be 2^bitLength  1  1.
	    upperBound = Math.pow(2, bitLength - 1) - 1;
	  }

	  // 4. Let x be ? ToNumber(V).
	  let x = Number(V);

	  // 5. If x is 0, then set x to +0.
	  if (x === 0) {
	    x = 0;
	  }

	  // 6. If the conversion is to an IDL type associated
	  //    with the [EnforceRange] extended attribute, then:
	  if (opts.enforceRange === true) {
	    // 1. If x is NaN, +, or , then throw a TypeError.
	    if (
	      Number.isNaN(x) ||
	      x === Number.POSITIVE_INFINITY ||
	      x === Number.NEGATIVE_INFINITY
	    ) {
	      throw webidl.errors.exception({
	        header: 'Integer conversion',
	        message: `Could not convert ${V} to an integer.`
	      })
	    }

	    // 2. Set x to IntegerPart(x).
	    x = webidl.util.IntegerPart(x);

	    // 3. If x < lowerBound or x > upperBound, then
	    //    throw a TypeError.
	    if (x < lowerBound || x > upperBound) {
	      throw webidl.errors.exception({
	        header: 'Integer conversion',
	        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
	      })
	    }

	    // 4. Return x.
	    return x
	  }

	  // 7. If x is not NaN and the conversion is to an IDL
	  //    type associated with the [Clamp] extended
	  //    attribute, then:
	  if (!Number.isNaN(x) && opts.clamp === true) {
	    // 1. Set x to min(max(x, lowerBound), upperBound).
	    x = Math.min(Math.max(x, lowerBound), upperBound);

	    // 2. Round x to the nearest integer, choosing the
	    //    even integer if it lies halfway between two,
	    //    and choosing +0 rather than 0.
	    if (Math.floor(x) % 2 === 0) {
	      x = Math.floor(x);
	    } else {
	      x = Math.ceil(x);
	    }

	    // 3. Return x.
	    return x
	  }

	  // 8. If x is NaN, +0, +, or , then return +0.
	  if (
	    Number.isNaN(x) ||
	    (x === 0 && Object.is(0, x)) ||
	    x === Number.POSITIVE_INFINITY ||
	    x === Number.NEGATIVE_INFINITY
	  ) {
	    return 0
	  }

	  // 9. Set x to IntegerPart(x).
	  x = webidl.util.IntegerPart(x);

	  // 10. Set x to x modulo 2^bitLength.
	  x = x % Math.pow(2, bitLength);

	  // 11. If signedness is "signed" and x  2^bitLength  1,
	  //    then return x  2^bitLength.
	  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
	    return x - Math.pow(2, bitLength)
	  }

	  // 12. Otherwise, return x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
	webidl.util.IntegerPart = function (n) {
	  // 1. Let r be floor(abs(n)).
	  const r = Math.floor(Math.abs(n));

	  // 2. If n < 0, then return -1  r.
	  if (n < 0) {
	    return -1 * r
	  }

	  // 3. Otherwise, return r.
	  return r
	};

	// https://webidl.spec.whatwg.org/#es-sequence
	webidl.sequenceConverter = function (converter) {
	  return (V) => {
	    // 1. If Type(V) is not Object, throw a TypeError.
	    if (webidl.util.Type(V) !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Sequence',
	        message: `Value of type ${webidl.util.Type(V)} is not an Object.`
	      })
	    }

	    // 2. Let method be ? GetMethod(V, @@iterator).
	    /** @type {Generator} */
	    const method = V?.[Symbol.iterator]?.();
	    const seq = [];

	    // 3. If method is undefined, throw a TypeError.
	    if (
	      method === undefined ||
	      typeof method.next !== 'function'
	    ) {
	      throw webidl.errors.exception({
	        header: 'Sequence',
	        message: 'Object is not an iterator.'
	      })
	    }

	    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable
	    while (true) {
	      const { done, value } = method.next();

	      if (done) {
	        break
	      }

	      seq.push(converter(value));
	    }

	    return seq
	  }
	};

	// https://webidl.spec.whatwg.org/#es-to-record
	webidl.recordConverter = function (keyConverter, valueConverter) {
	  return (O) => {
	    // 1. If Type(O) is not Object, throw a TypeError.
	    if (webidl.util.Type(O) !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Record',
	        message: `Value of type ${webidl.util.Type(O)} is not an Object.`
	      })
	    }

	    // 2. Let result be a new empty instance of record<K, V>.
	    const result = {};

	    if (!types.isProxy(O)) {
	      // Object.keys only returns enumerable properties
	      const keys = Object.keys(O);

	      for (const key of keys) {
	        // 1. Let typedKey be key converted to an IDL value of type K.
	        const typedKey = keyConverter(key);

	        // 2. Let value be ? Get(O, key).
	        // 3. Let typedValue be value converted to an IDL value of type V.
	        const typedValue = valueConverter(O[key]);

	        // 4. Set result[typedKey] to typedValue.
	        result[typedKey] = typedValue;
	      }

	      // 5. Return result.
	      return result
	    }

	    // 3. Let keys be ? O.[[OwnPropertyKeys]]().
	    const keys = Reflect.ownKeys(O);

	    // 4. For each key of keys.
	    for (const key of keys) {
	      // 1. Let desc be ? O.[[GetOwnProperty]](key).
	      const desc = Reflect.getOwnPropertyDescriptor(O, key);

	      // 2. If desc is not undefined and desc.[[Enumerable]] is true:
	      if (desc?.enumerable) {
	        // 1. Let typedKey be key converted to an IDL value of type K.
	        const typedKey = keyConverter(key);

	        // 2. Let value be ? Get(O, key).
	        // 3. Let typedValue be value converted to an IDL value of type V.
	        const typedValue = valueConverter(O[key]);

	        // 4. Set result[typedKey] to typedValue.
	        result[typedKey] = typedValue;
	      }
	    }

	    // 5. Return result.
	    return result
	  }
	};

	webidl.interfaceConverter = function (i) {
	  return (V, opts = {}) => {
	    if (opts.strict !== false && !(V instanceof i)) {
	      throw webidl.errors.exception({
	        header: i.name,
	        message: `Expected ${V} to be an instance of ${i.name}.`
	      })
	    }

	    return V
	  }
	};

	webidl.dictionaryConverter = function (converters) {
	  return (dictionary) => {
	    const type = webidl.util.Type(dictionary);
	    const dict = {};

	    if (type === 'Null' || type === 'Undefined') {
	      return dict
	    } else if (type !== 'Object') {
	      throw webidl.errors.exception({
	        header: 'Dictionary',
	        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
	      })
	    }

	    for (const options of converters) {
	      const { key, defaultValue, required, converter } = options;

	      if (required === true) {
	        if (!hasOwn(dictionary, key)) {
	          throw webidl.errors.exception({
	            header: 'Dictionary',
	            message: `Missing required key "${key}".`
	          })
	        }
	      }

	      let value = dictionary[key];
	      const hasDefault = hasOwn(options, 'defaultValue');

	      // Only use defaultValue if value is undefined and
	      // a defaultValue options was provided.
	      if (hasDefault && value !== null) {
	        value = value ?? defaultValue;
	      }

	      // A key can be optional and have no default value.
	      // When this happens, do not perform a conversion,
	      // and do not assign the key a value.
	      if (required || hasDefault || value !== undefined) {
	        value = converter(value);

	        if (
	          options.allowedValues &&
	          !options.allowedValues.includes(value)
	        ) {
	          throw webidl.errors.exception({
	            header: 'Dictionary',
	            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
	          })
	        }

	        dict[key] = value;
	      }
	    }

	    return dict
	  }
	};

	webidl.nullableConverter = function (converter) {
	  return (V) => {
	    if (V === null) {
	      return V
	    }

	    return converter(V)
	  }
	};

	// https://webidl.spec.whatwg.org/#es-DOMString
	webidl.converters.DOMString = function (V, opts = {}) {
	  // 1. If V is null and the conversion is to an IDL type
	  //    associated with the [LegacyNullToEmptyString]
	  //    extended attribute, then return the DOMString value
	  //    that represents the empty string.
	  if (V === null && opts.legacyNullToEmptyString) {
	    return ''
	  }

	  // 2. Let x be ? ToString(V).
	  if (typeof V === 'symbol') {
	    throw new TypeError('Could not convert argument of type symbol to string.')
	  }

	  // 3. Return the IDL DOMString value that represents the
	  //    same sequence of code units as the one the
	  //    ECMAScript String value x represents.
	  return String(V)
	};

	// https://webidl.spec.whatwg.org/#es-ByteString
	webidl.converters.ByteString = function (V) {
	  // 1. Let x be ? ToString(V).
	  // Note: DOMString converter perform ? ToString(V)
	  const x = webidl.converters.DOMString(V);

	  // 2. If the value of any element of x is greater than
	  //    255, then throw a TypeError.
	  for (let index = 0; index < x.length; index++) {
	    if (x.charCodeAt(index) > 255) {
	      throw new TypeError(
	        'Cannot convert argument to a ByteString because the character at ' +
	        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
	      )
	    }
	  }

	  // 3. Return an IDL ByteString value whose length is the
	  //    length of x, and where the value of each element is
	  //    the value of the corresponding element of x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-USVString
	webidl.converters.USVString = toUSVString;

	// https://webidl.spec.whatwg.org/#es-boolean
	webidl.converters.boolean = function (V) {
	  // 1. Let x be the result of computing ToBoolean(V).
	  const x = Boolean(V);

	  // 2. Return the IDL boolean value that is the one that represents
	  //    the same truth value as the ECMAScript Boolean value x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-any
	webidl.converters.any = function (V) {
	  return V
	};

	// https://webidl.spec.whatwg.org/#es-long-long
	webidl.converters['long long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 64, "signed").
	  const x = webidl.util.ConvertToInt(V, 64, 'signed');

	  // 2. Return the IDL long long value that represents
	  //    the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-long-long
	webidl.converters['unsigned long long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 64, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 64, 'unsigned');

	  // 2. Return the IDL unsigned long long value that
	  //    represents the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-long
	webidl.converters['unsigned long'] = function (V) {
	  // 1. Let x be ? ConvertToInt(V, 32, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 32, 'unsigned');

	  // 2. Return the IDL unsigned long value that
	  //    represents the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#es-unsigned-short
	webidl.converters['unsigned short'] = function (V, opts) {
	  // 1. Let x be ? ConvertToInt(V, 16, "unsigned").
	  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts);

	  // 2. Return the IDL unsigned short value that represents
	  //    the same numeric value as x.
	  return x
	};

	// https://webidl.spec.whatwg.org/#idl-ArrayBuffer
	webidl.converters.ArrayBuffer = function (V, opts = {}) {
	  // 1. If Type(V) is not Object, or V does not have an
	  //    [[ArrayBufferData]] internal slot, then throw a
	  //    TypeError.
	  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
	  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
	  if (
	    webidl.util.Type(V) !== 'Object' ||
	    !types.isAnyArrayBuffer(V)
	  ) {
	    throw webidl.errors.conversionFailed({
	      prefix: `${V}`,
	      argument: `${V}`,
	      types: ['ArrayBuffer']
	    })
	  }

	  // 2. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V) is true, then throw a
	  //    TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V) is true, then throw a
	  //    TypeError.
	  // Note: resizable ArrayBuffers are currently a proposal.

	  // 4. Return the IDL ArrayBuffer value that is a
	  //    reference to the same object as V.
	  return V
	};

	webidl.converters.TypedArray = function (V, T, opts = {}) {
	  // 1. Let T be the IDL type V is being converted to.

	  // 2. If Type(V) is not Object, or V does not have a
	  //    [[TypedArrayName]] internal slot with a value
	  //    equal to Ts name, then throw a TypeError.
	  if (
	    webidl.util.Type(V) !== 'Object' ||
	    !types.isTypedArray(V) ||
	    V.constructor.name !== T.name
	  ) {
	    throw webidl.errors.conversionFailed({
	      prefix: `${T.name}`,
	      argument: `${V}`,
	      types: [T.name]
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 4. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  // Note: resizable array buffers are currently a proposal

	  // 5. Return the IDL value of type T that is a reference
	  //    to the same object as V.
	  return V
	};

	webidl.converters.DataView = function (V, opts = {}) {
	  // 1. If Type(V) is not Object, or V does not have a
	  //    [[DataView]] internal slot, then throw a TypeError.
	  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
	    throw webidl.errors.exception({
	      header: 'DataView',
	      message: 'Object is not a DataView.'
	    })
	  }

	  // 2. If the conversion is not to an IDL type associated
	  //    with the [AllowShared] extended attribute, and
	  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
	  //    then throw a TypeError.
	  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
	    throw webidl.errors.exception({
	      header: 'ArrayBuffer',
	      message: 'SharedArrayBuffer is not allowed.'
	    })
	  }

	  // 3. If the conversion is not to an IDL type associated
	  //    with the [AllowResizable] extended attribute, and
	  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
	  //    true, then throw a TypeError.
	  // Note: resizable ArrayBuffers are currently a proposal

	  // 4. Return the IDL DataView value that is a reference
	  //    to the same object as V.
	  return V
	};

	// https://webidl.spec.whatwg.org/#BufferSource
	webidl.converters.BufferSource = function (V, opts = {}) {
	  if (types.isAnyArrayBuffer(V)) {
	    return webidl.converters.ArrayBuffer(V, opts)
	  }

	  if (types.isTypedArray(V)) {
	    return webidl.converters.TypedArray(V, V.constructor)
	  }

	  if (types.isDataView(V)) {
	    return webidl.converters.DataView(V, opts)
	  }

	  throw new TypeError(`Could not convert ${V} to a BufferSource.`)
	};

	webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(
	  webidl.converters.ByteString
	);

	webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(
	  webidl.converters['sequence<ByteString>']
	);

	webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(
	  webidl.converters.ByteString,
	  webidl.converters.ByteString
	);

	webidl_1 = {
	  webidl
	};
	return webidl_1;
}

var dataURL;
var hasRequiredDataURL;

function requireDataURL () {
	if (hasRequiredDataURL) return dataURL;
	hasRequiredDataURL = 1;
	const assert = require$$0$8;
	const { atob } = require$$7;
	const { isomorphicDecode } = requireUtil$7();

	const encoder = new TextEncoder();

	/**
	 * @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	 */
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/; // eslint-disable-line
	/**
	 * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	 */
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/; // eslint-disable-line

	// https://fetch.spec.whatwg.org/#data-url-processor
	/** @param {URL} dataURL */
	function dataURLProcessor (dataURL) {
	  // 1. Assert: dataURLs scheme is "data".
	  assert(dataURL.protocol === 'data:');

	  // 2. Let input be the result of running the URL
	  // serializer on dataURL with exclude fragment
	  // set to true.
	  let input = URLSerializer(dataURL, true);

	  // 3. Remove the leading "data:" string from input.
	  input = input.slice(5);

	  // 4. Let position point at the start of input.
	  const position = { position: 0 };

	  // 5. Let mimeType be the result of collecting a
	  // sequence of code points that are not equal
	  // to U+002C (,), given position.
	  let mimeType = collectASequenceOfCodePointsFast(
	    ',',
	    input,
	    position
	  );

	  // 6. Strip leading and trailing ASCII whitespace
	  // from mimeType.
	  // Undici implementation note: we need to store the
	  // length because if the mimetype has spaces removed,
	  // the wrong amount will be sliced from the input in
	  // step #9
	  const mimeTypeLength = mimeType.length;
	  mimeType = removeASCIIWhitespace(mimeType, true, true);

	  // 7. If position is past the end of input, then
	  // return failure
	  if (position.position >= input.length) {
	    return 'failure'
	  }

	  // 8. Advance position by 1.
	  position.position++;

	  // 9. Let encodedBody be the remainder of input.
	  const encodedBody = input.slice(mimeTypeLength + 1);

	  // 10. Let body be the percent-decoding of encodedBody.
	  let body = stringPercentDecode(encodedBody);

	  // 11. If mimeType ends with U+003B (;), followed by
	  // zero or more U+0020 SPACE, followed by an ASCII
	  // case-insensitive match for "base64", then:
	  if (/;(\u0020){0,}base64$/i.test(mimeType)) {
	    // 1. Let stringBody be the isomorphic decode of body.
	    const stringBody = isomorphicDecode(body);

	    // 2. Set body to the forgiving-base64 decode of
	    // stringBody.
	    body = forgivingBase64(stringBody);

	    // 3. If body is failure, then return failure.
	    if (body === 'failure') {
	      return 'failure'
	    }

	    // 4. Remove the last 6 code points from mimeType.
	    mimeType = mimeType.slice(0, -6);

	    // 5. Remove trailing U+0020 SPACE code points from mimeType,
	    // if any.
	    mimeType = mimeType.replace(/(\u0020)+$/, '');

	    // 6. Remove the last U+003B (;) code point from mimeType.
	    mimeType = mimeType.slice(0, -1);
	  }

	  // 12. If mimeType starts with U+003B (;), then prepend
	  // "text/plain" to mimeType.
	  if (mimeType.startsWith(';')) {
	    mimeType = 'text/plain' + mimeType;
	  }

	  // 13. Let mimeTypeRecord be the result of parsing
	  // mimeType.
	  let mimeTypeRecord = parseMIMEType(mimeType);

	  // 14. If mimeTypeRecord is failure, then set
	  // mimeTypeRecord to text/plain;charset=US-ASCII.
	  if (mimeTypeRecord === 'failure') {
	    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
	  }

	  // 15. Return a new data: URL struct whose MIME
	  // type is mimeTypeRecord and body is body.
	  // https://fetch.spec.whatwg.org/#data-url-struct
	  return { mimeType: mimeTypeRecord, body }
	}

	// https://url.spec.whatwg.org/#concept-url-serializer
	/**
	 * @param {URL} url
	 * @param {boolean} excludeFragment
	 */
	function URLSerializer (url, excludeFragment = false) {
	  if (!excludeFragment) {
	    return url.href
	  }

	  const href = url.href;
	  const hashLength = url.hash.length;

	  return hashLength === 0 ? href : href.substring(0, href.length - hashLength)
	}

	// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
	/**
	 * @param {(char: string) => boolean} condition
	 * @param {string} input
	 * @param {{ position: number }} position
	 */
	function collectASequenceOfCodePoints (condition, input, position) {
	  // 1. Let result be the empty string.
	  let result = '';

	  // 2. While position doesnt point past the end of input and the
	  // code point at position within input meets the condition condition:
	  while (position.position < input.length && condition(input[position.position])) {
	    // 1. Append that code point to the end of result.
	    result += input[position.position];

	    // 2. Advance position by 1.
	    position.position++;
	  }

	  // 3. Return result.
	  return result
	}

	/**
	 * A faster collectASequenceOfCodePoints that only works when comparing a single character.
	 * @param {string} char
	 * @param {string} input
	 * @param {{ position: number }} position
	 */
	function collectASequenceOfCodePointsFast (char, input, position) {
	  const idx = input.indexOf(char, position.position);
	  const start = position.position;

	  if (idx === -1) {
	    position.position = input.length;
	    return input.slice(start)
	  }

	  position.position = idx;
	  return input.slice(start, position.position)
	}

	// https://url.spec.whatwg.org/#string-percent-decode
	/** @param {string} input */
	function stringPercentDecode (input) {
	  // 1. Let bytes be the UTF-8 encoding of input.
	  const bytes = encoder.encode(input);

	  // 2. Return the percent-decoding of bytes.
	  return percentDecode(bytes)
	}

	// https://url.spec.whatwg.org/#percent-decode
	/** @param {Uint8Array} input */
	function percentDecode (input) {
	  // 1. Let output be an empty byte sequence.
	  /** @type {number[]} */
	  const output = [];

	  // 2. For each byte byte in input:
	  for (let i = 0; i < input.length; i++) {
	    const byte = input[i];

	    // 1. If byte is not 0x25 (%), then append byte to output.
	    if (byte !== 0x25) {
	      output.push(byte);

	    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes
	    // after byte in input are not in the ranges
	    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
	    // and 0x61 (a) to 0x66 (f), all inclusive, append byte
	    // to output.
	    } else if (
	      byte === 0x25 &&
	      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))
	    ) {
	      output.push(0x25);

	    // 3. Otherwise:
	    } else {
	      // 1. Let bytePoint be the two bytes after byte in input,
	      // decoded, and then interpreted as hexadecimal number.
	      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
	      const bytePoint = Number.parseInt(nextTwoBytes, 16);

	      // 2. Append a byte whose value is bytePoint to output.
	      output.push(bytePoint);

	      // 3. Skip the next two bytes in input.
	      i += 2;
	    }
	  }

	  // 3. Return output.
	  return Uint8Array.from(output)
	}

	// https://mimesniff.spec.whatwg.org/#parse-a-mime-type
	/** @param {string} input */
	function parseMIMEType (input) {
	  // 1. Remove any leading and trailing HTTP whitespace
	  // from input.
	  input = removeHTTPWhitespace(input, true, true);

	  // 2. Let position be a position variable for input,
	  // initially pointing at the start of input.
	  const position = { position: 0 };

	  // 3. Let type be the result of collecting a sequence
	  // of code points that are not U+002F (/) from
	  // input, given position.
	  const type = collectASequenceOfCodePointsFast(
	    '/',
	    input,
	    position
	  );

	  // 4. If type is the empty string or does not solely
	  // contain HTTP token code points, then return failure.
	  // https://mimesniff.spec.whatwg.org/#http-token-code-point
	  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
	    return 'failure'
	  }

	  // 5. If position is past the end of input, then return
	  // failure
	  if (position.position > input.length) {
	    return 'failure'
	  }

	  // 6. Advance position by 1. (This skips past U+002F (/).)
	  position.position++;

	  // 7. Let subtype be the result of collecting a sequence of
	  // code points that are not U+003B (;) from input, given
	  // position.
	  let subtype = collectASequenceOfCodePointsFast(
	    ';',
	    input,
	    position
	  );

	  // 8. Remove any trailing HTTP whitespace from subtype.
	  subtype = removeHTTPWhitespace(subtype, false, true);

	  // 9. If subtype is the empty string or does not solely
	  // contain HTTP token code points, then return failure.
	  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
	    return 'failure'
	  }

	  const typeLowercase = type.toLowerCase();
	  const subtypeLowercase = subtype.toLowerCase();

	  // 10. Let mimeType be a new MIME type record whose type
	  // is type, in ASCII lowercase, and subtype is subtype,
	  // in ASCII lowercase.
	  // https://mimesniff.spec.whatwg.org/#mime-type
	  const mimeType = {
	    type: typeLowercase,
	    subtype: subtypeLowercase,
	    /** @type {Map<string, string>} */
	    parameters: new Map(),
	    // https://mimesniff.spec.whatwg.org/#mime-type-essence
	    essence: `${typeLowercase}/${subtypeLowercase}`
	  };

	  // 11. While position is not past the end of input:
	  while (position.position < input.length) {
	    // 1. Advance position by 1. (This skips past U+003B (;).)
	    position.position++;

	    // 2. Collect a sequence of code points that are HTTP
	    // whitespace from input given position.
	    collectASequenceOfCodePoints(
	      // https://fetch.spec.whatwg.org/#http-whitespace
	      char => HTTP_WHITESPACE_REGEX.test(char),
	      input,
	      position
	    );

	    // 3. Let parameterName be the result of collecting a
	    // sequence of code points that are not U+003B (;)
	    // or U+003D (=) from input, given position.
	    let parameterName = collectASequenceOfCodePoints(
	      (char) => char !== ';' && char !== '=',
	      input,
	      position
	    );

	    // 4. Set parameterName to parameterName, in ASCII
	    // lowercase.
	    parameterName = parameterName.toLowerCase();

	    // 5. If position is not past the end of input, then:
	    if (position.position < input.length) {
	      // 1. If the code point at position within input is
	      // U+003B (;), then continue.
	      if (input[position.position] === ';') {
	        continue
	      }

	      // 2. Advance position by 1. (This skips past U+003D (=).)
	      position.position++;
	    }

	    // 6. If position is past the end of input, then break.
	    if (position.position > input.length) {
	      break
	    }

	    // 7. Let parameterValue be null.
	    let parameterValue = null;

	    // 8. If the code point at position within input is
	    // U+0022 ("), then:
	    if (input[position.position] === '"') {
	      // 1. Set parameterValue to the result of collecting
	      // an HTTP quoted string from input, given position
	      // and the extract-value flag.
	      parameterValue = collectAnHTTPQuotedString(input, position, true);

	      // 2. Collect a sequence of code points that are not
	      // U+003B (;) from input, given position.
	      collectASequenceOfCodePointsFast(
	        ';',
	        input,
	        position
	      );

	    // 9. Otherwise:
	    } else {
	      // 1. Set parameterValue to the result of collecting
	      // a sequence of code points that are not U+003B (;)
	      // from input, given position.
	      parameterValue = collectASequenceOfCodePointsFast(
	        ';',
	        input,
	        position
	      );

	      // 2. Remove any trailing HTTP whitespace from parameterValue.
	      parameterValue = removeHTTPWhitespace(parameterValue, false, true);

	      // 3. If parameterValue is the empty string, then continue.
	      if (parameterValue.length === 0) {
	        continue
	      }
	    }

	    // 10. If all of the following are true
	    // - parameterName is not the empty string
	    // - parameterName solely contains HTTP token code points
	    // - parameterValue solely contains HTTP quoted-string token code points
	    // - mimeTypes parameters[parameterName] does not exist
	    // then set mimeTypes parameters[parameterName] to parameterValue.
	    if (
	      parameterName.length !== 0 &&
	      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
	      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
	      !mimeType.parameters.has(parameterName)
	    ) {
	      mimeType.parameters.set(parameterName, parameterValue);
	    }
	  }

	  // 12. Return mimeType.
	  return mimeType
	}

	// https://infra.spec.whatwg.org/#forgiving-base64-decode
	/** @param {string} data */
	function forgivingBase64 (data) {
	  // 1. Remove all ASCII whitespace from data.
	  data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '');  // eslint-disable-line

	  // 2. If datas code point length divides by 4 leaving
	  // no remainder, then:
	  if (data.length % 4 === 0) {
	    // 1. If data ends with one or two U+003D (=) code points,
	    // then remove them from data.
	    data = data.replace(/=?=$/, '');
	  }

	  // 3. If datas code point length divides by 4 leaving
	  // a remainder of 1, then return failure.
	  if (data.length % 4 === 1) {
	    return 'failure'
	  }

	  // 4. If data contains a code point that is not one of
	  //  U+002B (+)
	  //  U+002F (/)
	  //  ASCII alphanumeric
	  // then return failure.
	  if (/[^+/0-9A-Za-z]/.test(data)) {
	    return 'failure'
	  }

	  const binary = atob(data);
	  const bytes = new Uint8Array(binary.length);

	  for (let byte = 0; byte < binary.length; byte++) {
	    bytes[byte] = binary.charCodeAt(byte);
	  }

	  return bytes
	}

	// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
	// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
	/**
	 * @param {string} input
	 * @param {{ position: number }} position
	 * @param {boolean?} extractValue
	 */
	function collectAnHTTPQuotedString (input, position, extractValue) {
	  // 1. Let positionStart be position.
	  const positionStart = position.position;

	  // 2. Let value be the empty string.
	  let value = '';

	  // 3. Assert: the code point at position within input
	  // is U+0022 (").
	  assert(input[position.position] === '"');

	  // 4. Advance position by 1.
	  position.position++;

	  // 5. While true:
	  while (true) {
	    // 1. Append the result of collecting a sequence of code points
	    // that are not U+0022 (") or U+005C (\) from input, given
	    // position, to value.
	    value += collectASequenceOfCodePoints(
	      (char) => char !== '"' && char !== '\\',
	      input,
	      position
	    );

	    // 2. If position is past the end of input, then break.
	    if (position.position >= input.length) {
	      break
	    }

	    // 3. Let quoteOrBackslash be the code point at position within
	    // input.
	    const quoteOrBackslash = input[position.position];

	    // 4. Advance position by 1.
	    position.position++;

	    // 5. If quoteOrBackslash is U+005C (\), then:
	    if (quoteOrBackslash === '\\') {
	      // 1. If position is past the end of input, then append
	      // U+005C (\) to value and break.
	      if (position.position >= input.length) {
	        value += '\\';
	        break
	      }

	      // 2. Append the code point at position within input to value.
	      value += input[position.position];

	      // 3. Advance position by 1.
	      position.position++;

	    // 6. Otherwise:
	    } else {
	      // 1. Assert: quoteOrBackslash is U+0022 (").
	      assert(quoteOrBackslash === '"');

	      // 2. Break.
	      break
	    }
	  }

	  // 6. If the extract-value flag is set, then return value.
	  if (extractValue) {
	    return value
	  }

	  // 7. Return the code points from positionStart to position,
	  // inclusive, within input.
	  return input.slice(positionStart, position.position)
	}

	/**
	 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	 */
	function serializeAMimeType (mimeType) {
	  assert(mimeType !== 'failure');
	  const { parameters, essence } = mimeType;

	  // 1. Let serialization be the concatenation of mimeTypes
	  //    type, U+002F (/), and mimeTypes subtype.
	  let serialization = essence;

	  // 2. For each name  value of mimeTypes parameters:
	  for (let [name, value] of parameters.entries()) {
	    // 1. Append U+003B (;) to serialization.
	    serialization += ';';

	    // 2. Append name to serialization.
	    serialization += name;

	    // 3. Append U+003D (=) to serialization.
	    serialization += '=';

	    // 4. If value does not solely contain HTTP token code
	    //    points or value is the empty string, then:
	    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
	      // 1. Precede each occurence of U+0022 (") or
	      //    U+005C (\) in value with U+005C (\).
	      value = value.replace(/(\\|")/g, '\\$1');

	      // 2. Prepend U+0022 (") to value.
	      value = '"' + value;

	      // 3. Append U+0022 (") to value.
	      value += '"';
	    }

	    // 5. Append value to serialization.
	    serialization += value;
	  }

	  // 3. Return serialization.
	  return serialization
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-whitespace
	 * @param {string} char
	 */
	function isHTTPWhiteSpace (char) {
	  return char === '\r' || char === '\n' || char === '\t' || char === ' '
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#http-whitespace
	 * @param {string} str
	 */
	function removeHTTPWhitespace (str, leading = true, trailing = true) {
	  let lead = 0;
	  let trail = str.length - 1;

	  if (leading) {
	    for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
	  }

	  if (trailing) {
	    for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
	  }

	  return str.slice(lead, trail + 1)
	}

	/**
	 * @see https://infra.spec.whatwg.org/#ascii-whitespace
	 * @param {string} char
	 */
	function isASCIIWhitespace (char) {
	  return char === '\r' || char === '\n' || char === '\t' || char === '\f' || char === ' '
	}

	/**
	 * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	 */
	function removeASCIIWhitespace (str, leading = true, trailing = true) {
	  let lead = 0;
	  let trail = str.length - 1;

	  if (leading) {
	    for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
	  }

	  if (trailing) {
	    for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
	  }

	  return str.slice(lead, trail + 1)
	}

	dataURL = {
	  dataURLProcessor,
	  URLSerializer,
	  collectASequenceOfCodePoints,
	  collectASequenceOfCodePointsFast,
	  stringPercentDecode,
	  parseMIMEType,
	  collectAnHTTPQuotedString,
	  serializeAMimeType
	};
	return dataURL;
}

var file;
var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;

	const { Blob, File: NativeFile } = require$$7;
	const { types } = require$$0$7;
	const { kState } = requireSymbols$3();
	const { isBlobLike } = requireUtil$7();
	const { webidl } = requireWebidl();
	const { parseMIMEType, serializeAMimeType } = requireDataURL();
	const { kEnumerableProperty } = requireUtil$8();
	const encoder = new TextEncoder();

	class File extends Blob {
	  constructor (fileBits, fileName, options = {}) {
	    // The File constructor is invoked with two or three parameters, depending
	    // on whether the optional dictionary parameter is used. When the File()
	    // constructor is invoked, user agents must run the following steps:
	    webidl.argumentLengthCheck(arguments, 2, { header: 'File constructor' });

	    fileBits = webidl.converters['sequence<BlobPart>'](fileBits);
	    fileName = webidl.converters.USVString(fileName);
	    options = webidl.converters.FilePropertyBag(options);

	    // 1. Let bytes be the result of processing blob parts given fileBits and
	    // options.
	    // Note: Blob handles this for us

	    // 2. Let n be the fileName argument to the constructor.
	    const n = fileName;

	    // 3. Process FilePropertyBag dictionary argument by running the following
	    // substeps:

	    //    1. If the type member is provided and is not the empty string, let t
	    //    be set to the type dictionary member. If t contains any characters
	    //    outside the range U+0020 to U+007E, then set t to the empty string
	    //    and return from these substeps.
	    //    2. Convert every character in t to ASCII lowercase.
	    let t = options.type;
	    let d;

	    // eslint-disable-next-line no-labels
	    substep: {
	      if (t) {
	        t = parseMIMEType(t);

	        if (t === 'failure') {
	          t = '';
	          // eslint-disable-next-line no-labels
	          break substep
	        }

	        t = serializeAMimeType(t).toLowerCase();
	      }

	      //    3. If the lastModified member is provided, let d be set to the
	      //    lastModified dictionary member. If it is not provided, set d to the
	      //    current date and time represented as the number of milliseconds since
	      //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
	      d = options.lastModified;
	    }

	    // 4. Return a new File object F such that:
	    // F refers to the bytes byte sequence.
	    // F.size is set to the number of total bytes in bytes.
	    // F.name is set to n.
	    // F.type is set to t.
	    // F.lastModified is set to d.

	    super(processBlobParts(fileBits, options), { type: t });
	    this[kState] = {
	      name: n,
	      lastModified: d,
	      type: t
	    };
	  }

	  get name () {
	    webidl.brandCheck(this, File);

	    return this[kState].name
	  }

	  get lastModified () {
	    webidl.brandCheck(this, File);

	    return this[kState].lastModified
	  }

	  get type () {
	    webidl.brandCheck(this, File);

	    return this[kState].type
	  }
	}

	class FileLike {
	  constructor (blobLike, fileName, options = {}) {
	    // TODO: argument idl type check

	    // The File constructor is invoked with two or three parameters, depending
	    // on whether the optional dictionary parameter is used. When the File()
	    // constructor is invoked, user agents must run the following steps:

	    // 1. Let bytes be the result of processing blob parts given fileBits and
	    // options.

	    // 2. Let n be the fileName argument to the constructor.
	    const n = fileName;

	    // 3. Process FilePropertyBag dictionary argument by running the following
	    // substeps:

	    //    1. If the type member is provided and is not the empty string, let t
	    //    be set to the type dictionary member. If t contains any characters
	    //    outside the range U+0020 to U+007E, then set t to the empty string
	    //    and return from these substeps.
	    //    TODO
	    const t = options.type;

	    //    2. Convert every character in t to ASCII lowercase.
	    //    TODO

	    //    3. If the lastModified member is provided, let d be set to the
	    //    lastModified dictionary member. If it is not provided, set d to the
	    //    current date and time represented as the number of milliseconds since
	    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
	    const d = options.lastModified ?? Date.now();

	    // 4. Return a new File object F such that:
	    // F refers to the bytes byte sequence.
	    // F.size is set to the number of total bytes in bytes.
	    // F.name is set to n.
	    // F.type is set to t.
	    // F.lastModified is set to d.

	    this[kState] = {
	      blobLike,
	      name: n,
	      type: t,
	      lastModified: d
	    };
	  }

	  stream (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.stream(...args)
	  }

	  arrayBuffer (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.arrayBuffer(...args)
	  }

	  slice (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.slice(...args)
	  }

	  text (...args) {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.text(...args)
	  }

	  get size () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.size
	  }

	  get type () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].blobLike.type
	  }

	  get name () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].name
	  }

	  get lastModified () {
	    webidl.brandCheck(this, FileLike);

	    return this[kState].lastModified
	  }

	  get [Symbol.toStringTag] () {
	    return 'File'
	  }
	}

	Object.defineProperties(File.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'File',
	    configurable: true
	  },
	  name: kEnumerableProperty,
	  lastModified: kEnumerableProperty
	});

	webidl.converters.Blob = webidl.interfaceConverter(Blob);

	webidl.converters.BlobPart = function (V, opts) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (isBlobLike(V)) {
	      return webidl.converters.Blob(V, { strict: false })
	    }

	    if (
	      ArrayBuffer.isView(V) ||
	      types.isAnyArrayBuffer(V)
	    ) {
	      return webidl.converters.BufferSource(V, opts)
	    }
	  }

	  return webidl.converters.USVString(V, opts)
	};

	webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(
	  webidl.converters.BlobPart
	);

	// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
	webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
	  {
	    key: 'lastModified',
	    converter: webidl.converters['long long'],
	    get defaultValue () {
	      return Date.now()
	    }
	  },
	  {
	    key: 'type',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'endings',
	    converter: (value) => {
	      value = webidl.converters.DOMString(value);
	      value = value.toLowerCase();

	      if (value !== 'native') {
	        value = 'transparent';
	      }

	      return value
	    },
	    defaultValue: 'transparent'
	  }
	]);

	/**
	 * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	 * @param {(NodeJS.TypedArray|Blob|string)[]} parts
	 * @param {{ type: string, endings: string }} options
	 */
	function processBlobParts (parts, options) {
	  // 1. Let bytes be an empty sequence of bytes.
	  /** @type {NodeJS.TypedArray[]} */
	  const bytes = [];

	  // 2. For each element in parts:
	  for (const element of parts) {
	    // 1. If element is a USVString, run the following substeps:
	    if (typeof element === 'string') {
	      // 1. Let s be element.
	      let s = element;

	      // 2. If the endings member of options is "native", set s
	      //    to the result of converting line endings to native
	      //    of element.
	      if (options.endings === 'native') {
	        s = convertLineEndingsNative(s);
	      }

	      // 3. Append the result of UTF-8 encoding s to bytes.
	      bytes.push(encoder.encode(s));
	    } else if (
	      types.isAnyArrayBuffer(element) ||
	      types.isTypedArray(element)
	    ) {
	      // 2. If element is a BufferSource, get a copy of the
	      //    bytes held by the buffer source, and append those
	      //    bytes to bytes.
	      if (!element.buffer) { // ArrayBuffer
	        bytes.push(new Uint8Array(element));
	      } else {
	        bytes.push(
	          new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
	        );
	      }
	    } else if (isBlobLike(element)) {
	      // 3. If element is a Blob, append the bytes it represents
	      //    to bytes.
	      bytes.push(element);
	    }
	  }

	  // 3. Return bytes.
	  return bytes
	}

	/**
	 * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	 * @param {string} s
	 */
	function convertLineEndingsNative (s) {
	  // 1. Let native line ending be be the code point U+000A LF.
	  let nativeLineEnding = '\n';

	  // 2. If the underlying platforms conventions are to
	  //    represent newlines as a carriage return and line feed
	  //    sequence, set native line ending to the code point
	  //    U+000D CR followed by the code point U+000A LF.
	  if (process.platform === 'win32') {
	    nativeLineEnding = '\r\n';
	  }

	  return s.replace(/\r?\n/g, nativeLineEnding)
	}

	// If this function is moved to ./util.js, some tools (such as
	// rollup) will warn about circular dependencies. See:
	// https://github.com/nodejs/undici/issues/1629
	function isFileLike (object) {
	  return (
	    (NativeFile && object instanceof NativeFile) ||
	    object instanceof File || (
	      object &&
	      (typeof object.stream === 'function' ||
	      typeof object.arrayBuffer === 'function') &&
	      object[Symbol.toStringTag] === 'File'
	    )
	  )
	}

	file = { File, FileLike, isFileLike };
	return file;
}

var formdata;
var hasRequiredFormdata;

function requireFormdata () {
	if (hasRequiredFormdata) return formdata;
	hasRequiredFormdata = 1;

	const { isBlobLike, toUSVString, makeIterator } = requireUtil$7();
	const { kState } = requireSymbols$3();
	const { File: UndiciFile, FileLike, isFileLike } = requireFile();
	const { webidl } = requireWebidl();
	const { Blob, File: NativeFile } = require$$7;

	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;

	// https://xhr.spec.whatwg.org/#formdata
	class FormData {
	  constructor (form) {
	    if (form !== undefined) {
	      throw webidl.errors.conversionFailed({
	        prefix: 'FormData constructor',
	        argument: 'Argument 1',
	        types: ['undefined']
	      })
	    }

	    this[kState] = [];
	  }

	  append (name, value, filename = undefined) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.append' });

	    if (arguments.length === 3 && !isBlobLike(value)) {
	      throw new TypeError(
	        "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
	      )
	    }

	    // 1. Let value be value if given; otherwise blobValue.

	    name = webidl.converters.USVString(name);
	    value = isBlobLike(value)
	      ? webidl.converters.Blob(value, { strict: false })
	      : webidl.converters.USVString(value);
	    filename = arguments.length === 3
	      ? webidl.converters.USVString(filename)
	      : undefined;

	    // 2. Let entry be the result of creating an entry with
	    // name, value, and filename if given.
	    const entry = makeEntry(name, value, filename);

	    // 3. Append entry to thiss entry list.
	    this[kState].push(entry);
	  }

	  delete (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.delete' });

	    name = webidl.converters.USVString(name);

	    // The delete(name) method steps are to remove all entries whose name
	    // is name from thiss entry list.
	    this[kState] = this[kState].filter(entry => entry.name !== name);
	  }

	  get (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.get' });

	    name = webidl.converters.USVString(name);

	    // 1. If there is no entry whose name is name in thiss entry list,
	    // then return null.
	    const idx = this[kState].findIndex((entry) => entry.name === name);
	    if (idx === -1) {
	      return null
	    }

	    // 2. Return the value of the first entry whose name is name from
	    // thiss entry list.
	    return this[kState][idx].value
	  }

	  getAll (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.getAll' });

	    name = webidl.converters.USVString(name);

	    // 1. If there is no entry whose name is name in thiss entry list,
	    // then return the empty list.
	    // 2. Return the values of all entries whose name is name, in order,
	    // from thiss entry list.
	    return this[kState]
	      .filter((entry) => entry.name === name)
	      .map((entry) => entry.value)
	  }

	  has (name) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.has' });

	    name = webidl.converters.USVString(name);

	    // The has(name) method steps are to return true if there is an entry
	    // whose name is name in thiss entry list; otherwise false.
	    return this[kState].findIndex((entry) => entry.name === name) !== -1
	  }

	  set (name, value, filename = undefined) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'FormData.set' });

	    if (arguments.length === 3 && !isBlobLike(value)) {
	      throw new TypeError(
	        "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
	      )
	    }

	    // The set(name, value) and set(name, blobValue, filename) method steps
	    // are:

	    // 1. Let value be value if given; otherwise blobValue.

	    name = webidl.converters.USVString(name);
	    value = isBlobLike(value)
	      ? webidl.converters.Blob(value, { strict: false })
	      : webidl.converters.USVString(value);
	    filename = arguments.length === 3
	      ? toUSVString(filename)
	      : undefined;

	    // 2. Let entry be the result of creating an entry with name, value, and
	    // filename if given.
	    const entry = makeEntry(name, value, filename);

	    // 3. If there are entries in thiss entry list whose name is name, then
	    // replace the first such entry with entry and remove the others.
	    const idx = this[kState].findIndex((entry) => entry.name === name);
	    if (idx !== -1) {
	      this[kState] = [
	        ...this[kState].slice(0, idx),
	        entry,
	        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)
	      ];
	    } else {
	      // 4. Otherwise, append entry to thiss entry list.
	      this[kState].push(entry);
	    }
	  }

	  entries () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'key+value'
	    )
	  }

	  keys () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'key'
	    )
	  }

	  values () {
	    webidl.brandCheck(this, FormData);

	    return makeIterator(
	      () => this[kState].map(pair => [pair.name, pair.value]),
	      'FormData',
	      'value'
	    )
	  }

	  /**
	   * @param {(value: string, key: string, self: FormData) => void} callbackFn
	   * @param {unknown} thisArg
	   */
	  forEach (callbackFn, thisArg = globalThis) {
	    webidl.brandCheck(this, FormData);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FormData.forEach' });

	    if (typeof callbackFn !== 'function') {
	      throw new TypeError(
	        "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
	      )
	    }

	    for (const [key, value] of this) {
	      callbackFn.apply(thisArg, [value, key, this]);
	    }
	  }
	}

	FormData.prototype[Symbol.iterator] = FormData.prototype.entries;

	Object.defineProperties(FormData.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'FormData',
	    configurable: true
	  }
	});

	/**
	 * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	 * @param {string} name
	 * @param {string|Blob} value
	 * @param {?string} filename
	 * @returns
	 */
	function makeEntry (name, value, filename) {
	  // 1. Set name to the result of converting name into a scalar value string.
	  // "To convert a string into a scalar value string, replace any surrogates
	  //  with U+FFFD."
	  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end
	  name = Buffer.from(name).toString('utf8');

	  // 2. If value is a string, then set value to the result of converting
	  //    value into a scalar value string.
	  if (typeof value === 'string') {
	    value = Buffer.from(value).toString('utf8');
	  } else {
	    // 3. Otherwise:

	    // 1. If value is not a File object, then set value to a new File object,
	    //    representing the same bytes, whose name attribute value is "blob"
	    if (!isFileLike(value)) {
	      value = value instanceof Blob
	        ? new File([value], 'blob', { type: value.type })
	        : new FileLike(value, 'blob', { type: value.type });
	    }

	    // 2. If filename is given, then set value to a new File object,
	    //    representing the same bytes, whose name attribute is filename.
	    if (filename !== undefined) {
	      /** @type {FilePropertyBag} */
	      const options = {
	        type: value.type,
	        lastModified: value.lastModified
	      };

	      value = (NativeFile && value instanceof NativeFile) || value instanceof UndiciFile
	        ? new File([value], filename, options)
	        : new FileLike(value, filename, options);
	    }
	  }

	  // 4. Return an entry whose name is name and whose value is value.
	  return { name, value }
	}

	formdata = { FormData };
	return formdata;
}

var body;
var hasRequiredBody;

function requireBody () {
	if (hasRequiredBody) return body;
	hasRequiredBody = 1;

	const Busboy = requireMain();
	const util = requireUtil$8();
	const {
	  ReadableStreamFrom,
	  isBlobLike,
	  isReadableStreamLike,
	  readableStreamClose,
	  createDeferredPromise,
	  fullyReadBody
	} = requireUtil$7();
	const { FormData } = requireFormdata();
	const { kState } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { DOMException, structuredClone } = requireConstants$4();
	const { Blob, File: NativeFile } = require$$7;
	const { kBodyUsed } = requireSymbols$4();
	const assert = require$$0$8;
	const { isErrored } = requireUtil$8();
	const { isUint8Array, isArrayBuffer } = require$$5$1;
	const { File: UndiciFile } = requireFile();
	const { parseMIMEType, serializeAMimeType } = requireDataURL();

	let random;
	try {
	  const crypto = require('node:crypto');
	  random = (max) => crypto.randomInt(0, max);
	} catch {
	  random = (max) => Math.floor(Math.random(max));
	}

	let ReadableStream = globalThis.ReadableStream;

	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;
	const textEncoder = new TextEncoder();
	const textDecoder = new TextDecoder();

	// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
	function extractBody (object, keepalive = false) {
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  // 1. Let stream be null.
	  let stream = null;

	  // 2. If object is a ReadableStream object, then set stream to object.
	  if (object instanceof ReadableStream) {
	    stream = object;
	  } else if (isBlobLike(object)) {
	    // 3. Otherwise, if object is a Blob object, set stream to the
	    //    result of running objects get stream.
	    stream = object.stream();
	  } else {
	    // 4. Otherwise, set stream to a new ReadableStream object, and set
	    //    up stream.
	    stream = new ReadableStream({
	      async pull (controller) {
	        controller.enqueue(
	          typeof source === 'string' ? textEncoder.encode(source) : source
	        );
	        queueMicrotask(() => readableStreamClose(controller));
	      },
	      start () {},
	      type: undefined
	    });
	  }

	  // 5. Assert: stream is a ReadableStream object.
	  assert(isReadableStreamLike(stream));

	  // 6. Let action be null.
	  let action = null;

	  // 7. Let source be null.
	  let source = null;

	  // 8. Let length be null.
	  let length = null;

	  // 9. Let type be null.
	  let type = null;

	  // 10. Switch on object:
	  if (typeof object === 'string') {
	    // Set source to the UTF-8 encoding of object.
	    // Note: setting source to a Uint8Array here breaks some mocking assumptions.
	    source = object;

	    // Set type to `text/plain;charset=UTF-8`.
	    type = 'text/plain;charset=UTF-8';
	  } else if (object instanceof URLSearchParams) {
	    // URLSearchParams

	    // spec says to run application/x-www-form-urlencoded on body.list
	    // this is implemented in Node.js as apart of an URLSearchParams instance toString method
	    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
	    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

	    // Set source to the result of running the application/x-www-form-urlencoded serializer with objects list.
	    source = object.toString();

	    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
	    type = 'application/x-www-form-urlencoded;charset=UTF-8';
	  } else if (isArrayBuffer(object)) {
	    // BufferSource/ArrayBuffer

	    // Set source to a copy of the bytes held by object.
	    source = new Uint8Array(object.slice());
	  } else if (ArrayBuffer.isView(object)) {
	    // BufferSource/ArrayBufferView

	    // Set source to a copy of the bytes held by object.
	    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
	  } else if (util.isFormDataLike(object)) {
	    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`;
	    const prefix = `--${boundary}\r\nContent-Disposition: form-data`;

	    /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
	    const escape = (str) =>
	      str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
	    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');

	    // Set action to this step: run the multipart/form-data
	    // encoding algorithm, with objects entry list and UTF-8.
	    // - This ensures that the body is immutable and can't be changed afterwords
	    // - That the content-length is calculated in advance.
	    // - And that all parts are pre-encoded and ready to be sent.

	    const blobParts = [];
	    const rn = new Uint8Array([13, 10]); // '\r\n'
	    length = 0;
	    let hasUnknownSizeValue = false;

	    for (const [name, value] of object) {
	      if (typeof value === 'string') {
	        const chunk = textEncoder.encode(prefix +
	          `; name="${escape(normalizeLinefeeds(name))}"` +
	          `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
	        blobParts.push(chunk);
	        length += chunk.byteLength;
	      } else {
	        const chunk = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
	          (value.name ? `; filename="${escape(value.name)}"` : '') + '\r\n' +
	          `Content-Type: ${
	            value.type || 'application/octet-stream'
	          }\r\n\r\n`);
	        blobParts.push(chunk, value, rn);
	        if (typeof value.size === 'number') {
	          length += chunk.byteLength + value.size + rn.byteLength;
	        } else {
	          hasUnknownSizeValue = true;
	        }
	      }
	    }

	    const chunk = textEncoder.encode(`--${boundary}--`);
	    blobParts.push(chunk);
	    length += chunk.byteLength;
	    if (hasUnknownSizeValue) {
	      length = null;
	    }

	    // Set source to object.
	    source = object;

	    action = async function * () {
	      for (const part of blobParts) {
	        if (part.stream) {
	          yield * part.stream();
	        } else {
	          yield part;
	        }
	      }
	    };

	    // Set type to `multipart/form-data; boundary=`,
	    // followed by the multipart/form-data boundary string generated
	    // by the multipart/form-data encoding algorithm.
	    type = 'multipart/form-data; boundary=' + boundary;
	  } else if (isBlobLike(object)) {
	    // Blob

	    // Set source to object.
	    source = object;

	    // Set length to objects size.
	    length = object.size;

	    // If objects type attribute is not the empty byte sequence, set
	    // type to its value.
	    if (object.type) {
	      type = object.type;
	    }
	  } else if (typeof object[Symbol.asyncIterator] === 'function') {
	    // If keepalive is true, then throw a TypeError.
	    if (keepalive) {
	      throw new TypeError('keepalive')
	    }

	    // If object is disturbed or locked, then throw a TypeError.
	    if (util.isDisturbed(object) || object.locked) {
	      throw new TypeError(
	        'Response body object should not be disturbed or locked'
	      )
	    }

	    stream =
	      object instanceof ReadableStream ? object : ReadableStreamFrom(object);
	  }

	  // 11. If source is a byte sequence, then set action to a
	  // step that returns source and length to sources length.
	  if (typeof source === 'string' || util.isBuffer(source)) {
	    length = Buffer.byteLength(source);
	  }

	  // 12. If action is non-null, then run these steps in in parallel:
	  if (action != null) {
	    // Run action.
	    let iterator;
	    stream = new ReadableStream({
	      async start () {
	        iterator = action(object)[Symbol.asyncIterator]();
	      },
	      async pull (controller) {
	        const { value, done } = await iterator.next();
	        if (done) {
	          // When running action is done, close stream.
	          queueMicrotask(() => {
	            controller.close();
	          });
	        } else {
	          // Whenever one or more bytes are available and stream is not errored,
	          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available
	          // bytes into stream.
	          if (!isErrored(stream)) {
	            controller.enqueue(new Uint8Array(value));
	          }
	        }
	        return controller.desiredSize > 0
	      },
	      async cancel (reason) {
	        await iterator.return();
	      },
	      type: undefined
	    });
	  }

	  // 13. Let body be a body whose stream is stream, source is source,
	  // and length is length.
	  const body = { stream, source, length };

	  // 14. Return (body, type).
	  return [body, type]
	}

	// https://fetch.spec.whatwg.org/#bodyinit-safely-extract
	function safelyExtractBody (object, keepalive = false) {
	  if (!ReadableStream) {
	    // istanbul ignore next
	    ReadableStream = require$$14.ReadableStream;
	  }

	  // To safely extract a body and a `Content-Type` value from
	  // a byte sequence or BodyInit object object, run these steps:

	  // 1. If object is a ReadableStream object, then:
	  if (object instanceof ReadableStream) {
	    // Assert: object is neither disturbed nor locked.
	    // istanbul ignore next
	    assert(!util.isDisturbed(object), 'The body has already been consumed.');
	    // istanbul ignore next
	    assert(!object.locked, 'The stream is locked.');
	  }

	  // 2. Return the results of extracting object.
	  return extractBody(object, keepalive)
	}

	function cloneBody (body) {
	  // To clone a body body, run these steps:

	  // https://fetch.spec.whatwg.org/#concept-body-clone

	  // 1. Let  out1, out2  be the result of teeing bodys stream.
	  const [out1, out2] = body.stream.tee();
	  const out2Clone = structuredClone(out2, { transfer: [out2] });
	  // This, for whatever reasons, unrefs out2Clone which allows
	  // the process to exit by itself.
	  const [, finalClone] = out2Clone.tee();

	  // 2. Set bodys stream to out1.
	  body.stream = out1;

	  // 3. Return a body whose stream is out2 and other members are copied from body.
	  return {
	    stream: finalClone,
	    length: body.length,
	    source: body.source
	  }
	}

	async function * consumeBody (body) {
	  if (body) {
	    if (isUint8Array(body)) {
	      yield body;
	    } else {
	      const stream = body.stream;

	      if (util.isDisturbed(stream)) {
	        throw new TypeError('The body has already been consumed.')
	      }

	      if (stream.locked) {
	        throw new TypeError('The stream is locked.')
	      }

	      // Compat.
	      stream[kBodyUsed] = true;

	      yield * stream;
	    }
	  }
	}

	function throwIfAborted (state) {
	  if (state.aborted) {
	    throw new DOMException('The operation was aborted.', 'AbortError')
	  }
	}

	function bodyMixinMethods (instance) {
	  const methods = {
	    blob () {
	      // The blob() method steps are to return the result of
	      // running consume body with this and the following step
	      // given a byte sequence bytes: return a Blob whose
	      // contents are bytes and whose type attribute is thiss
	      // MIME type.
	      return specConsumeBody(this, (bytes) => {
	        let mimeType = bodyMimeType(this);

	        if (mimeType === 'failure') {
	          mimeType = '';
	        } else if (mimeType) {
	          mimeType = serializeAMimeType(mimeType);
	        }

	        // Return a Blob whose contents are bytes and type attribute
	        // is mimeType.
	        return new Blob([bytes], { type: mimeType })
	      }, instance)
	    },

	    arrayBuffer () {
	      // The arrayBuffer() method steps are to return the result
	      // of running consume body with this and the following step
	      // given a byte sequence bytes: return a new ArrayBuffer
	      // whose contents are bytes.
	      return specConsumeBody(this, (bytes) => {
	        return new Uint8Array(bytes).buffer
	      }, instance)
	    },

	    text () {
	      // The text() method steps are to return the result of running
	      // consume body with this and UTF-8 decode.
	      return specConsumeBody(this, utf8DecodeBytes, instance)
	    },

	    json () {
	      // The json() method steps are to return the result of running
	      // consume body with this and parse JSON from bytes.
	      return specConsumeBody(this, parseJSONFromBytes, instance)
	    },

	    async formData () {
	      webidl.brandCheck(this, instance);

	      throwIfAborted(this[kState]);

	      const contentType = this.headers.get('Content-Type');

	      // If mimeTypes essence is "multipart/form-data", then:
	      if (/multipart\/form-data/.test(contentType)) {
	        const headers = {};
	        for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;

	        const responseFormData = new FormData();

	        let busboy;

	        try {
	          busboy = new Busboy({
	            headers,
	            preservePath: true
	          });
	        } catch (err) {
	          throw new DOMException(`${err}`, 'AbortError')
	        }

	        busboy.on('field', (name, value) => {
	          responseFormData.append(name, value);
	        });
	        busboy.on('file', (name, value, filename, encoding, mimeType) => {
	          const chunks = [];

	          if (encoding === 'base64' || encoding.toLowerCase() === 'base64') {
	            let base64chunk = '';

	            value.on('data', (chunk) => {
	              base64chunk += chunk.toString().replace(/[\r\n]/gm, '');

	              const end = base64chunk.length - base64chunk.length % 4;
	              chunks.push(Buffer.from(base64chunk.slice(0, end), 'base64'));

	              base64chunk = base64chunk.slice(end);
	            });
	            value.on('end', () => {
	              chunks.push(Buffer.from(base64chunk, 'base64'));
	              responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
	            });
	          } else {
	            value.on('data', (chunk) => {
	              chunks.push(chunk);
	            });
	            value.on('end', () => {
	              responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
	            });
	          }
	        });

	        const busboyResolve = new Promise((resolve, reject) => {
	          busboy.on('finish', resolve);
	          busboy.on('error', (err) => reject(new TypeError(err)));
	        });

	        if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
	        busboy.end();
	        await busboyResolve;

	        return responseFormData
	      } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
	        // Otherwise, if mimeTypes essence is "application/x-www-form-urlencoded", then:

	        // 1. Let entries be the result of parsing bytes.
	        let entries;
	        try {
	          let text = '';
	          // application/x-www-form-urlencoded parser will keep the BOM.
	          // https://url.spec.whatwg.org/#concept-urlencoded-parser
	          // Note that streaming decoder is stateful and cannot be reused
	          const streamingDecoder = new TextDecoder('utf-8', { ignoreBOM: true });

	          for await (const chunk of consumeBody(this[kState].body)) {
	            if (!isUint8Array(chunk)) {
	              throw new TypeError('Expected Uint8Array chunk')
	            }
	            text += streamingDecoder.decode(chunk, { stream: true });
	          }
	          text += streamingDecoder.decode();
	          entries = new URLSearchParams(text);
	        } catch (err) {
	          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
	          // 2. If entries is failure, then throw a TypeError.
	          throw Object.assign(new TypeError(), { cause: err })
	        }

	        // 3. Return a new FormData object whose entries are entries.
	        const formData = new FormData();
	        for (const [name, value] of entries) {
	          formData.append(name, value);
	        }
	        return formData
	      } else {
	        // Wait a tick before checking if the request has been aborted.
	        // Otherwise, a TypeError can be thrown when an AbortError should.
	        await Promise.resolve();

	        throwIfAborted(this[kState]);

	        // Otherwise, throw a TypeError.
	        throw webidl.errors.exception({
	          header: `${instance.name}.formData`,
	          message: 'Could not parse content as FormData.'
	        })
	      }
	    }
	  };

	  return methods
	}

	function mixinBody (prototype) {
	  Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	 * @param {Response|Request} object
	 * @param {(value: unknown) => unknown} convertBytesToJSValue
	 * @param {Response|Request} instance
	 */
	async function specConsumeBody (object, convertBytesToJSValue, instance) {
	  webidl.brandCheck(object, instance);

	  throwIfAborted(object[kState]);

	  // 1. If object is unusable, then return a promise rejected
	  //    with a TypeError.
	  if (bodyUnusable(object[kState].body)) {
	    throw new TypeError('Body is unusable')
	  }

	  // 2. Let promise be a new promise.
	  const promise = createDeferredPromise();

	  // 3. Let errorSteps given error be to reject promise with error.
	  const errorSteps = (error) => promise.reject(error);

	  // 4. Let successSteps given a byte sequence data be to resolve
	  //    promise with the result of running convertBytesToJSValue
	  //    with data. If that threw an exception, then run errorSteps
	  //    with that exception.
	  const successSteps = (data) => {
	    try {
	      promise.resolve(convertBytesToJSValue(data));
	    } catch (e) {
	      errorSteps(e);
	    }
	  };

	  // 5. If objects body is null, then run successSteps with an
	  //    empty byte sequence.
	  if (object[kState].body == null) {
	    successSteps(new Uint8Array());
	    return promise.promise
	  }

	  // 6. Otherwise, fully read objects body given successSteps,
	  //    errorSteps, and objects relevant global object.
	  await fullyReadBody(object[kState].body, successSteps, errorSteps);

	  // 7. Return promise.
	  return promise.promise
	}

	// https://fetch.spec.whatwg.org/#body-unusable
	function bodyUnusable (body) {
	  // An object including the Body interface mixin is
	  // said to be unusable if its body is non-null and
	  // its bodys stream is disturbed or locked.
	  return body != null && (body.stream.locked || util.isDisturbed(body.stream))
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#utf-8-decode
	 * @param {Buffer} buffer
	 */
	function utf8DecodeBytes (buffer) {
	  if (buffer.length === 0) {
	    return ''
	  }

	  // 1. Let buffer be the result of peeking three bytes from
	  //    ioQueue, converted to a byte sequence.

	  // 2. If buffer is 0xEF 0xBB 0xBF, then read three
	  //    bytes from ioQueue. (Do nothing with those bytes.)
	  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
	    buffer = buffer.subarray(3);
	  }

	  // 3. Process a queue with an instance of UTF-8s
	  //    decoder, ioQueue, output, and "replacement".
	  const output = textDecoder.decode(buffer);

	  // 4. Return output.
	  return output
	}

	/**
	 * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	 * @param {Uint8Array} bytes
	 */
	function parseJSONFromBytes (bytes) {
	  return JSON.parse(utf8DecodeBytes(bytes))
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	 * @param {import('./response').Response|import('./request').Request} object
	 */
	function bodyMimeType (object) {
	  const { headersList } = object[kState];
	  const contentType = headersList.get('content-type');

	  if (contentType === null) {
	    return 'failure'
	  }

	  return parseMIMEType(contentType)
	}

	body = {
	  extractBody,
	  safelyExtractBody,
	  cloneBody,
	  mixinBody
	};
	return body;
}

var request$2;
var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request$2;
	hasRequiredRequest$1 = 1;

	const {
	  InvalidArgumentError,
	  NotSupportedError
	} = requireErrors();
	const assert = require$$0$8;
	const { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = requireSymbols$4();
	const util = requireUtil$8();

	// tokenRegExp and headerCharRegex have been lifted from
	// https://github.com/nodejs/node/blob/main/lib/_http_common.js

	/**
	 * Verifies that the given val is a valid HTTP token
	 * per the rules defined in RFC 7230
	 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
	 */
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;

	/**
	 * Matches if val contains an invalid field-vchar
	 *  field-value    = *( field-content / obs-fold )
	 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 *  field-vchar    = VCHAR / obs-text
	 */
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

	// Verifies that a given path is valid does not contain control chars \x00 to \x20
	const invalidPathRegex = /[^\u0021-\u00ff]/;

	const kHandler = Symbol('handler');

	const channels = {};

	let extractBody;

	try {
	  const diagnosticsChannel = require('diagnostics_channel');
	  channels.create = diagnosticsChannel.channel('undici:request:create');
	  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent');
	  channels.headers = diagnosticsChannel.channel('undici:request:headers');
	  channels.trailers = diagnosticsChannel.channel('undici:request:trailers');
	  channels.error = diagnosticsChannel.channel('undici:request:error');
	} catch {
	  channels.create = { hasSubscribers: false };
	  channels.bodySent = { hasSubscribers: false };
	  channels.headers = { hasSubscribers: false };
	  channels.trailers = { hasSubscribers: false };
	  channels.error = { hasSubscribers: false };
	}

	class Request {
	  constructor (origin, {
	    path,
	    method,
	    body,
	    headers,
	    query,
	    idempotent,
	    blocking,
	    upgrade,
	    headersTimeout,
	    bodyTimeout,
	    reset,
	    throwOnError,
	    expectContinue
	  }, handler) {
	    if (typeof path !== 'string') {
	      throw new InvalidArgumentError('path must be a string')
	    } else if (
	      path[0] !== '/' &&
	      !(path.startsWith('http://') || path.startsWith('https://')) &&
	      method !== 'CONNECT'
	    ) {
	      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')
	    } else if (invalidPathRegex.exec(path) !== null) {
	      throw new InvalidArgumentError('invalid request path')
	    }

	    if (typeof method !== 'string') {
	      throw new InvalidArgumentError('method must be a string')
	    } else if (tokenRegExp.exec(method) === null) {
	      throw new InvalidArgumentError('invalid request method')
	    }

	    if (upgrade && typeof upgrade !== 'string') {
	      throw new InvalidArgumentError('upgrade must be a string')
	    }

	    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
	      throw new InvalidArgumentError('invalid headersTimeout')
	    }

	    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
	      throw new InvalidArgumentError('invalid bodyTimeout')
	    }

	    if (reset != null && typeof reset !== 'boolean') {
	      throw new InvalidArgumentError('invalid reset')
	    }

	    if (expectContinue != null && typeof expectContinue !== 'boolean') {
	      throw new InvalidArgumentError('invalid expectContinue')
	    }

	    this.headersTimeout = headersTimeout;

	    this.bodyTimeout = bodyTimeout;

	    this.throwOnError = throwOnError === true;

	    this.method = method;

	    this.abort = null;

	    if (body == null) {
	      this.body = null;
	    } else if (util.isStream(body)) {
	      this.body = body;

	      const rState = this.body._readableState;
	      if (!rState || !rState.autoDestroy) {
	        this.endHandler = function autoDestroy () {
	          util.destroy(this);
	        };
	        this.body.on('end', this.endHandler);
	      }

	      this.errorHandler = err => {
	        if (this.abort) {
	          this.abort(err);
	        } else {
	          this.error = err;
	        }
	      };
	      this.body.on('error', this.errorHandler);
	    } else if (util.isBuffer(body)) {
	      this.body = body.byteLength ? body : null;
	    } else if (ArrayBuffer.isView(body)) {
	      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
	    } else if (body instanceof ArrayBuffer) {
	      this.body = body.byteLength ? Buffer.from(body) : null;
	    } else if (typeof body === 'string') {
	      this.body = body.length ? Buffer.from(body) : null;
	    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
	      this.body = body;
	    } else {
	      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')
	    }

	    this.completed = false;

	    this.aborted = false;

	    this.upgrade = upgrade || null;

	    this.path = query ? util.buildURL(path, query) : path;

	    this.origin = origin;

	    this.idempotent = idempotent == null
	      ? method === 'HEAD' || method === 'GET'
	      : idempotent;

	    this.blocking = blocking == null ? false : blocking;

	    this.reset = reset == null ? null : reset;

	    this.host = null;

	    this.contentLength = null;

	    this.contentType = null;

	    this.headers = '';

	    // Only for H2
	    this.expectContinue = expectContinue != null ? expectContinue : false;

	    if (Array.isArray(headers)) {
	      if (headers.length % 2 !== 0) {
	        throw new InvalidArgumentError('headers array must be even')
	      }
	      for (let i = 0; i < headers.length; i += 2) {
	        processHeader(this, headers[i], headers[i + 1]);
	      }
	    } else if (headers && typeof headers === 'object') {
	      const keys = Object.keys(headers);
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        processHeader(this, key, headers[key]);
	      }
	    } else if (headers != null) {
	      throw new InvalidArgumentError('headers must be an object or an array')
	    }

	    if (util.isFormDataLike(this.body)) {
	      if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {
	        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.')
	      }

	      if (!extractBody) {
	        extractBody = requireBody().extractBody;
	      }

	      const [bodyStream, contentType] = extractBody(body);
	      if (this.contentType == null) {
	        this.contentType = contentType;
	        this.headers += `content-type: ${contentType}\r\n`;
	      }
	      this.body = bodyStream.stream;
	      this.contentLength = bodyStream.length;
	    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
	      this.contentType = body.type;
	      this.headers += `content-type: ${body.type}\r\n`;
	    }

	    util.validateHandler(handler, method, upgrade);

	    this.servername = util.getServerName(this.host);

	    this[kHandler] = handler;

	    if (channels.create.hasSubscribers) {
	      channels.create.publish({ request: this });
	    }
	  }

	  onBodySent (chunk) {
	    if (this[kHandler].onBodySent) {
	      try {
	        return this[kHandler].onBodySent(chunk)
	      } catch (err) {
	        this.abort(err);
	      }
	    }
	  }

	  onRequestSent () {
	    if (channels.bodySent.hasSubscribers) {
	      channels.bodySent.publish({ request: this });
	    }

	    if (this[kHandler].onRequestSent) {
	      try {
	        return this[kHandler].onRequestSent()
	      } catch (err) {
	        this.abort(err);
	      }
	    }
	  }

	  onConnect (abort) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    if (this.error) {
	      abort(this.error);
	    } else {
	      this.abort = abort;
	      return this[kHandler].onConnect(abort)
	    }
	  }

	  onHeaders (statusCode, headers, resume, statusText) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    if (channels.headers.hasSubscribers) {
	      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
	    }

	    try {
	      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)
	    } catch (err) {
	      this.abort(err);
	    }
	  }

	  onData (chunk) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    try {
	      return this[kHandler].onData(chunk)
	    } catch (err) {
	      this.abort(err);
	      return false
	    }
	  }

	  onUpgrade (statusCode, headers, socket) {
	    assert(!this.aborted);
	    assert(!this.completed);

	    return this[kHandler].onUpgrade(statusCode, headers, socket)
	  }

	  onComplete (trailers) {
	    this.onFinally();

	    assert(!this.aborted);

	    this.completed = true;
	    if (channels.trailers.hasSubscribers) {
	      channels.trailers.publish({ request: this, trailers });
	    }

	    try {
	      return this[kHandler].onComplete(trailers)
	    } catch (err) {
	      // TODO (fix): This might be a bad idea?
	      this.onError(err);
	    }
	  }

	  onError (error) {
	    this.onFinally();

	    if (channels.error.hasSubscribers) {
	      channels.error.publish({ request: this, error });
	    }

	    if (this.aborted) {
	      return
	    }
	    this.aborted = true;

	    return this[kHandler].onError(error)
	  }

	  onFinally () {
	    if (this.errorHandler) {
	      this.body.off('error', this.errorHandler);
	      this.errorHandler = null;
	    }

	    if (this.endHandler) {
	      this.body.off('end', this.endHandler);
	      this.endHandler = null;
	    }
	  }

	  // TODO: adjust to support H2
	  addHeader (key, value) {
	    processHeader(this, key, value);
	    return this
	  }

	  static [kHTTP1BuildRequest] (origin, opts, handler) {
	    // TODO: Migrate header parsing here, to make Requests
	    // HTTP agnostic
	    return new Request(origin, opts, handler)
	  }

	  static [kHTTP2BuildRequest] (origin, opts, handler) {
	    const headers = opts.headers;
	    opts = { ...opts, headers: null };

	    const request = new Request(origin, opts, handler);

	    request.headers = {};

	    if (Array.isArray(headers)) {
	      if (headers.length % 2 !== 0) {
	        throw new InvalidArgumentError('headers array must be even')
	      }
	      for (let i = 0; i < headers.length; i += 2) {
	        processHeader(request, headers[i], headers[i + 1], true);
	      }
	    } else if (headers && typeof headers === 'object') {
	      const keys = Object.keys(headers);
	      for (let i = 0; i < keys.length; i++) {
	        const key = keys[i];
	        processHeader(request, key, headers[key], true);
	      }
	    } else if (headers != null) {
	      throw new InvalidArgumentError('headers must be an object or an array')
	    }

	    return request
	  }

	  static [kHTTP2CopyHeaders] (raw) {
	    const rawHeaders = raw.split('\r\n');
	    const headers = {};

	    for (const header of rawHeaders) {
	      const [key, value] = header.split(': ');

	      if (value == null || value.length === 0) continue

	      if (headers[key]) headers[key] += `,${value}`;
	      else headers[key] = value;
	    }

	    return headers
	  }
	}

	function processHeaderValue (key, val, skipAppend) {
	  if (val && typeof val === 'object') {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  }

	  val = val != null ? `${val}` : '';

	  if (headerCharRegex.exec(val) !== null) {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  }

	  return skipAppend ? val : `${key}: ${val}\r\n`
	}

	function processHeader (request, key, val, skipAppend = false) {
	  if (val && (typeof val === 'object' && !Array.isArray(val))) {
	    throw new InvalidArgumentError(`invalid ${key} header`)
	  } else if (val === undefined) {
	    return
	  }

	  if (
	    request.host === null &&
	    key.length === 4 &&
	    key.toLowerCase() === 'host'
	  ) {
	    if (headerCharRegex.exec(val) !== null) {
	      throw new InvalidArgumentError(`invalid ${key} header`)
	    }
	    // Consumed by Client
	    request.host = val;
	  } else if (
	    request.contentLength === null &&
	    key.length === 14 &&
	    key.toLowerCase() === 'content-length'
	  ) {
	    request.contentLength = parseInt(val, 10);
	    if (!Number.isFinite(request.contentLength)) {
	      throw new InvalidArgumentError('invalid content-length header')
	    }
	  } else if (
	    request.contentType === null &&
	    key.length === 12 &&
	    key.toLowerCase() === 'content-type'
	  ) {
	    request.contentType = val;
	    if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
	    else request.headers += processHeaderValue(key, val);
	  } else if (
	    key.length === 17 &&
	    key.toLowerCase() === 'transfer-encoding'
	  ) {
	    throw new InvalidArgumentError('invalid transfer-encoding header')
	  } else if (
	    key.length === 10 &&
	    key.toLowerCase() === 'connection'
	  ) {
	    const value = typeof val === 'string' ? val.toLowerCase() : null;
	    if (value !== 'close' && value !== 'keep-alive') {
	      throw new InvalidArgumentError('invalid connection header')
	    } else if (value === 'close') {
	      request.reset = true;
	    }
	  } else if (
	    key.length === 10 &&
	    key.toLowerCase() === 'keep-alive'
	  ) {
	    throw new InvalidArgumentError('invalid keep-alive header')
	  } else if (
	    key.length === 7 &&
	    key.toLowerCase() === 'upgrade'
	  ) {
	    throw new InvalidArgumentError('invalid upgrade header')
	  } else if (
	    key.length === 6 &&
	    key.toLowerCase() === 'expect'
	  ) {
	    throw new NotSupportedError('expect header not supported')
	  } else if (tokenRegExp.exec(key) === null) {
	    throw new InvalidArgumentError('invalid header key')
	  } else {
	    if (Array.isArray(val)) {
	      for (let i = 0; i < val.length; i++) {
	        if (skipAppend) {
	          if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
	          else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
	        } else {
	          request.headers += processHeaderValue(key, val[i]);
	        }
	      }
	    } else {
	      if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
	      else request.headers += processHeaderValue(key, val);
	    }
	  }
	}

	request$2 = Request;
	return request$2;
}

var dispatcher;
var hasRequiredDispatcher;

function requireDispatcher () {
	if (hasRequiredDispatcher) return dispatcher;
	hasRequiredDispatcher = 1;

	const EventEmitter = require$$0$6;

	class Dispatcher extends EventEmitter {
	  dispatch () {
	    throw new Error('not implemented')
	  }

	  close () {
	    throw new Error('not implemented')
	  }

	  destroy () {
	    throw new Error('not implemented')
	  }
	}

	dispatcher = Dispatcher;
	return dispatcher;
}

var dispatcherBase;
var hasRequiredDispatcherBase;

function requireDispatcherBase () {
	if (hasRequiredDispatcherBase) return dispatcherBase;
	hasRequiredDispatcherBase = 1;

	const Dispatcher = requireDispatcher();
	const {
	  ClientDestroyedError,
	  ClientClosedError,
	  InvalidArgumentError
	} = requireErrors();
	const { kDestroy, kClose, kDispatch, kInterceptors } = requireSymbols$4();

	const kDestroyed = Symbol('destroyed');
	const kClosed = Symbol('closed');
	const kOnDestroyed = Symbol('onDestroyed');
	const kOnClosed = Symbol('onClosed');
	const kInterceptedDispatch = Symbol('Intercepted Dispatch');

	class DispatcherBase extends Dispatcher {
	  constructor () {
	    super();

	    this[kDestroyed] = false;
	    this[kOnDestroyed] = null;
	    this[kClosed] = false;
	    this[kOnClosed] = [];
	  }

	  get destroyed () {
	    return this[kDestroyed]
	  }

	  get closed () {
	    return this[kClosed]
	  }

	  get interceptors () {
	    return this[kInterceptors]
	  }

	  set interceptors (newInterceptors) {
	    if (newInterceptors) {
	      for (let i = newInterceptors.length - 1; i >= 0; i--) {
	        const interceptor = this[kInterceptors][i];
	        if (typeof interceptor !== 'function') {
	          throw new InvalidArgumentError('interceptor must be an function')
	        }
	      }
	    }

	    this[kInterceptors] = newInterceptors;
	  }

	  close (callback) {
	    if (callback === undefined) {
	      return new Promise((resolve, reject) => {
	        this.close((err, data) => {
	          return err ? reject(err) : resolve(data)
	        });
	      })
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    if (this[kDestroyed]) {
	      queueMicrotask(() => callback(new ClientDestroyedError(), null));
	      return
	    }

	    if (this[kClosed]) {
	      if (this[kOnClosed]) {
	        this[kOnClosed].push(callback);
	      } else {
	        queueMicrotask(() => callback(null, null));
	      }
	      return
	    }

	    this[kClosed] = true;
	    this[kOnClosed].push(callback);

	    const onClosed = () => {
	      const callbacks = this[kOnClosed];
	      this[kOnClosed] = null;
	      for (let i = 0; i < callbacks.length; i++) {
	        callbacks[i](null, null);
	      }
	    };

	    // Should not error.
	    this[kClose]()
	      .then(() => this.destroy())
	      .then(() => {
	        queueMicrotask(onClosed);
	      });
	  }

	  destroy (err, callback) {
	    if (typeof err === 'function') {
	      callback = err;
	      err = null;
	    }

	    if (callback === undefined) {
	      return new Promise((resolve, reject) => {
	        this.destroy(err, (err, data) => {
	          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)
	        });
	      })
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    if (this[kDestroyed]) {
	      if (this[kOnDestroyed]) {
	        this[kOnDestroyed].push(callback);
	      } else {
	        queueMicrotask(() => callback(null, null));
	      }
	      return
	    }

	    if (!err) {
	      err = new ClientDestroyedError();
	    }

	    this[kDestroyed] = true;
	    this[kOnDestroyed] = this[kOnDestroyed] || [];
	    this[kOnDestroyed].push(callback);

	    const onDestroyed = () => {
	      const callbacks = this[kOnDestroyed];
	      this[kOnDestroyed] = null;
	      for (let i = 0; i < callbacks.length; i++) {
	        callbacks[i](null, null);
	      }
	    };

	    // Should not error.
	    this[kDestroy](err).then(() => {
	      queueMicrotask(onDestroyed);
	    });
	  }

	  [kInterceptedDispatch] (opts, handler) {
	    if (!this[kInterceptors] || this[kInterceptors].length === 0) {
	      this[kInterceptedDispatch] = this[kDispatch];
	      return this[kDispatch](opts, handler)
	    }

	    let dispatch = this[kDispatch].bind(this);
	    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
	      dispatch = this[kInterceptors][i](dispatch);
	    }
	    this[kInterceptedDispatch] = dispatch;
	    return dispatch(opts, handler)
	  }

	  dispatch (opts, handler) {
	    if (!handler || typeof handler !== 'object') {
	      throw new InvalidArgumentError('handler must be an object')
	    }

	    try {
	      if (!opts || typeof opts !== 'object') {
	        throw new InvalidArgumentError('opts must be an object.')
	      }

	      if (this[kDestroyed] || this[kOnDestroyed]) {
	        throw new ClientDestroyedError()
	      }

	      if (this[kClosed]) {
	        throw new ClientClosedError()
	      }

	      return this[kInterceptedDispatch](opts, handler)
	    } catch (err) {
	      if (typeof handler.onError !== 'function') {
	        throw new InvalidArgumentError('invalid onError method')
	      }

	      handler.onError(err);

	      return false
	    }
	  }
	}

	dispatcherBase = DispatcherBase;
	return dispatcherBase;
}

var connect;
var hasRequiredConnect;

function requireConnect () {
	if (hasRequiredConnect) return connect;
	hasRequiredConnect = 1;

	const net = require$$0$a;
	const assert = require$$0$8;
	const util = requireUtil$8();
	const { InvalidArgumentError, ConnectTimeoutError } = requireErrors();

	let tls; // include tls conditionally since it is not always available

	// TODO: session re-use does not wait for the first
	// connection to resolve the session and might therefore
	// resolve the same servername multiple times even when
	// re-use is enabled.

	let SessionCache;
	// FIXME: remove workaround when the Node bug is fixed
	// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
	if (commonjsGlobal.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
	  SessionCache = class WeakSessionCache {
	    constructor (maxCachedSessions) {
	      this._maxCachedSessions = maxCachedSessions;
	      this._sessionCache = new Map();
	      this._sessionRegistry = new commonjsGlobal.FinalizationRegistry((key) => {
	        if (this._sessionCache.size < this._maxCachedSessions) {
	          return
	        }

	        const ref = this._sessionCache.get(key);
	        if (ref !== undefined && ref.deref() === undefined) {
	          this._sessionCache.delete(key);
	        }
	      });
	    }

	    get (sessionKey) {
	      const ref = this._sessionCache.get(sessionKey);
	      return ref ? ref.deref() : null
	    }

	    set (sessionKey, session) {
	      if (this._maxCachedSessions === 0) {
	        return
	      }

	      this._sessionCache.set(sessionKey, new WeakRef(session));
	      this._sessionRegistry.register(session, sessionKey);
	    }
	  };
	} else {
	  SessionCache = class SimpleSessionCache {
	    constructor (maxCachedSessions) {
	      this._maxCachedSessions = maxCachedSessions;
	      this._sessionCache = new Map();
	    }

	    get (sessionKey) {
	      return this._sessionCache.get(sessionKey)
	    }

	    set (sessionKey, session) {
	      if (this._maxCachedSessions === 0) {
	        return
	      }

	      if (this._sessionCache.size >= this._maxCachedSessions) {
	        // remove the oldest session
	        const { value: oldestKey } = this._sessionCache.keys().next();
	        this._sessionCache.delete(oldestKey);
	      }

	      this._sessionCache.set(sessionKey, session);
	    }
	  };
	}

	function buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
	  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
	    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')
	  }

	  const options = { path: socketPath, ...opts };
	  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
	  timeout = timeout == null ? 10e3 : timeout;
	  allowH2 = allowH2 != null ? allowH2 : false;
	  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
	    let socket;
	    if (protocol === 'https:') {
	      if (!tls) {
	        tls = require$$4$2;
	      }
	      servername = servername || options.servername || util.getServerName(host) || null;

	      const sessionKey = servername || hostname;
	      const session = sessionCache.get(sessionKey) || null;

	      assert(sessionKey);

	      socket = tls.connect({
	        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
	        ...options,
	        servername,
	        session,
	        localAddress,
	        // TODO(HTTP/2): Add support for h2c
	        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],
	        socket: httpSocket, // upgrade socket connection
	        port: port || 443,
	        host: hostname
	      });

	      socket
	        .on('session', function (session) {
	          // TODO (fix): Can a session become invalid once established? Don't think so?
	          sessionCache.set(sessionKey, session);
	        });
	    } else {
	      assert(!httpSocket, 'httpSocket can only be sent on TLS update');
	      socket = net.connect({
	        highWaterMark: 64 * 1024, // Same as nodejs fs streams.
	        ...options,
	        localAddress,
	        port: port || 80,
	        host: hostname
	      });
	    }

	    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket
	    if (options.keepAlive == null || options.keepAlive) {
	      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay;
	      socket.setKeepAlive(true, keepAliveInitialDelay);
	    }

	    const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);

	    socket
	      .setNoDelay(true)
	      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
	        cancelTimeout();

	        if (callback) {
	          const cb = callback;
	          callback = null;
	          cb(null, this);
	        }
	      })
	      .on('error', function (err) {
	        cancelTimeout();

	        if (callback) {
	          const cb = callback;
	          callback = null;
	          cb(err);
	        }
	      });

	    return socket
	  }
	}

	function setupTimeout (onConnectTimeout, timeout) {
	  if (!timeout) {
	    return () => {}
	  }

	  let s1 = null;
	  let s2 = null;
	  const timeoutId = setTimeout(() => {
	    // setImmediate is added to make sure that we priotorise socket error events over timeouts
	    s1 = setImmediate(() => {
	      if (process.platform === 'win32') {
	        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic
	        s2 = setImmediate(() => onConnectTimeout());
	      } else {
	        onConnectTimeout();
	      }
	    });
	  }, timeout);
	  return () => {
	    clearTimeout(timeoutId);
	    clearImmediate(s1);
	    clearImmediate(s2);
	  }
	}

	function onConnectTimeout (socket) {
	  util.destroy(socket, new ConnectTimeoutError());
	}

	connect = buildConnector;
	return connect;
}

var constants$3 = {};

var utils$2 = {};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	Object.defineProperty(utils$2, "__esModule", { value: true });
	utils$2.enumToMap = undefined;
	function enumToMap(obj) {
	    const res = {};
	    Object.keys(obj).forEach((key) => {
	        const value = obj[key];
	        if (typeof value === 'number') {
	            res[key] = value;
	        }
	    });
	    return res;
	}
	utils$2.enumToMap = enumToMap;
	
	return utils$2;
}

var hasRequiredConstants$3;

function requireConstants$3 () {
	if (hasRequiredConstants$3) return constants$3;
	hasRequiredConstants$3 = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
		const utils_1 = requireUtils$2();
		(function (ERROR) {
		    ERROR[ERROR["OK"] = 0] = "OK";
		    ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		    ERROR[ERROR["STRICT"] = 2] = "STRICT";
		    ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		    ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		    ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		    ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		    ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		    ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		    ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		    ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		    ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		    ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		    ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		    ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		    ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		    ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		    ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		    ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		    ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		    ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		    ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		    ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		    ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		    ERROR[ERROR["USER"] = 24] = "USER";
		})(exports.ERROR || (exports.ERROR = {}));
		(function (TYPE) {
		    TYPE[TYPE["BOTH"] = 0] = "BOTH";
		    TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		    TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
		})(exports.TYPE || (exports.TYPE = {}));
		(function (FLAGS) {
		    FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		    FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		    FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		    FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		    FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		    FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		    FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		    FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		    // 1 << 8 is unused
		    FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
		})(exports.FLAGS || (exports.FLAGS = {}));
		(function (LENIENT_FLAGS) {
		    LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		    LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		    LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
		})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
		var METHODS;
		(function (METHODS) {
		    METHODS[METHODS["DELETE"] = 0] = "DELETE";
		    METHODS[METHODS["GET"] = 1] = "GET";
		    METHODS[METHODS["HEAD"] = 2] = "HEAD";
		    METHODS[METHODS["POST"] = 3] = "POST";
		    METHODS[METHODS["PUT"] = 4] = "PUT";
		    /* pathological */
		    METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
		    METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
		    METHODS[METHODS["TRACE"] = 7] = "TRACE";
		    /* WebDAV */
		    METHODS[METHODS["COPY"] = 8] = "COPY";
		    METHODS[METHODS["LOCK"] = 9] = "LOCK";
		    METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
		    METHODS[METHODS["MOVE"] = 11] = "MOVE";
		    METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
		    METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
		    METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
		    METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
		    METHODS[METHODS["BIND"] = 16] = "BIND";
		    METHODS[METHODS["REBIND"] = 17] = "REBIND";
		    METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
		    METHODS[METHODS["ACL"] = 19] = "ACL";
		    /* subversion */
		    METHODS[METHODS["REPORT"] = 20] = "REPORT";
		    METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
		    METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
		    METHODS[METHODS["MERGE"] = 23] = "MERGE";
		    /* upnp */
		    METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
		    METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
		    METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		    METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		    /* RFC-5789 */
		    METHODS[METHODS["PATCH"] = 28] = "PATCH";
		    METHODS[METHODS["PURGE"] = 29] = "PURGE";
		    /* CalDAV */
		    METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
		    /* RFC-2068, section 19.6.1.2 */
		    METHODS[METHODS["LINK"] = 31] = "LINK";
		    METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
		    /* icecast */
		    METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
		    /* RFC-7540, section 11.6 */
		    METHODS[METHODS["PRI"] = 34] = "PRI";
		    /* RFC-2326 RTSP */
		    METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
		    METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
		    METHODS[METHODS["SETUP"] = 37] = "SETUP";
		    METHODS[METHODS["PLAY"] = 38] = "PLAY";
		    METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
		    METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
		    METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		    METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		    METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
		    METHODS[METHODS["RECORD"] = 44] = "RECORD";
		    /* RAOP */
		    METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
		})(METHODS = exports.METHODS || (exports.METHODS = {}));
		exports.METHODS_HTTP = [
		    METHODS.DELETE,
		    METHODS.GET,
		    METHODS.HEAD,
		    METHODS.POST,
		    METHODS.PUT,
		    METHODS.CONNECT,
		    METHODS.OPTIONS,
		    METHODS.TRACE,
		    METHODS.COPY,
		    METHODS.LOCK,
		    METHODS.MKCOL,
		    METHODS.MOVE,
		    METHODS.PROPFIND,
		    METHODS.PROPPATCH,
		    METHODS.SEARCH,
		    METHODS.UNLOCK,
		    METHODS.BIND,
		    METHODS.REBIND,
		    METHODS.UNBIND,
		    METHODS.ACL,
		    METHODS.REPORT,
		    METHODS.MKACTIVITY,
		    METHODS.CHECKOUT,
		    METHODS.MERGE,
		    METHODS['M-SEARCH'],
		    METHODS.NOTIFY,
		    METHODS.SUBSCRIBE,
		    METHODS.UNSUBSCRIBE,
		    METHODS.PATCH,
		    METHODS.PURGE,
		    METHODS.MKCALENDAR,
		    METHODS.LINK,
		    METHODS.UNLINK,
		    METHODS.PRI,
		    // TODO(indutny): should we allow it with HTTP?
		    METHODS.SOURCE,
		];
		exports.METHODS_ICE = [
		    METHODS.SOURCE,
		];
		exports.METHODS_RTSP = [
		    METHODS.OPTIONS,
		    METHODS.DESCRIBE,
		    METHODS.ANNOUNCE,
		    METHODS.SETUP,
		    METHODS.PLAY,
		    METHODS.PAUSE,
		    METHODS.TEARDOWN,
		    METHODS.GET_PARAMETER,
		    METHODS.SET_PARAMETER,
		    METHODS.REDIRECT,
		    METHODS.RECORD,
		    METHODS.FLUSH,
		    // For AirPlay
		    METHODS.GET,
		    METHODS.POST,
		];
		exports.METHOD_MAP = utils_1.enumToMap(METHODS);
		exports.H_METHOD_MAP = {};
		Object.keys(exports.METHOD_MAP).forEach((key) => {
		    if (/^H/.test(key)) {
		        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
		    }
		});
		(function (FINISH) {
		    FINISH[FINISH["SAFE"] = 0] = "SAFE";
		    FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		    FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
		})(exports.FINISH || (exports.FINISH = {}));
		exports.ALPHA = [];
		for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
		    // Upper case
		    exports.ALPHA.push(String.fromCharCode(i));
		    // Lower case
		    exports.ALPHA.push(String.fromCharCode(i + 0x20));
		}
		exports.NUM_MAP = {
		    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
		    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
		};
		exports.HEX_MAP = {
		    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
		    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
		    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,
		    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,
		};
		exports.NUM = [
		    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
		];
		exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
		exports.MARK = ['-', '_', '.', '!', '~', '*', '\'', '(', ')'];
		exports.USERINFO_CHARS = exports.ALPHANUM
		    .concat(exports.MARK)
		    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);
		// TODO(indutny): use RFC
		exports.STRICT_URL_CHAR = [
		    '!', '"', '$', '%', '&', '\'',
		    '(', ')', '*', '+', ',', '-', '.', '/',
		    ':', ';', '<', '=', '>',
		    '@', '[', '\\', ']', '^', '_',
		    '`',
		    '{', '|', '}', '~',
		].concat(exports.ALPHANUM);
		exports.URL_CHAR = exports.STRICT_URL_CHAR
		    .concat(['\t', '\f']);
		// All characters with 0x80 bit set to 1
		for (let i = 0x80; i <= 0xff; i++) {
		    exports.URL_CHAR.push(i);
		}
		exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
		/* Tokens as defined by rfc 2616. Also lowercases them.
		 *        token       = 1*<any CHAR except CTLs or separators>
		 *     separators     = "(" | ")" | "<" | ">" | "@"
		 *                    | "," | ";" | ":" | "\" | <">
		 *                    | "/" | "[" | "]" | "?" | "="
		 *                    | "{" | "}" | SP | HT
		 */
		exports.STRICT_TOKEN = [
		    '!', '#', '$', '%', '&', '\'',
		    '*', '+', '-', '.',
		    '^', '_', '`',
		    '|', '~',
		].concat(exports.ALPHANUM);
		exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
		/*
		 * Verify that a char is a valid visible (printable) US-ASCII
		 * character or %x80-FF
		 */
		exports.HEADER_CHARS = ['\t'];
		for (let i = 32; i <= 255; i++) {
		    if (i !== 127) {
		        exports.HEADER_CHARS.push(i);
		    }
		}
		// ',' = \x44
		exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
		exports.MAJOR = exports.NUM_MAP;
		exports.MINOR = exports.MAJOR;
		var HEADER_STATE;
		(function (HEADER_STATE) {
		    HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
		    HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
		    HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		    HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		    HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
		})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
		exports.SPECIAL_HEADERS = {
		    'connection': HEADER_STATE.CONNECTION,
		    'content-length': HEADER_STATE.CONTENT_LENGTH,
		    'proxy-connection': HEADER_STATE.CONNECTION,
		    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
		    'upgrade': HEADER_STATE.UPGRADE,
		};
		
	} (constants$3));
	return constants$3;
}

var RedirectHandler_1;
var hasRequiredRedirectHandler;

function requireRedirectHandler () {
	if (hasRequiredRedirectHandler) return RedirectHandler_1;
	hasRequiredRedirectHandler = 1;

	const util = requireUtil$8();
	const { kBodyUsed } = requireSymbols$4();
	const assert = require$$0$8;
	const { InvalidArgumentError } = requireErrors();
	const EE = require$$0$6;

	const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];

	const kBody = Symbol('body');

	class BodyAsyncIterable {
	  constructor (body) {
	    this[kBody] = body;
	    this[kBodyUsed] = false;
	  }

	  async * [Symbol.asyncIterator] () {
	    assert(!this[kBodyUsed], 'disturbed');
	    this[kBodyUsed] = true;
	    yield * this[kBody];
	  }
	}

	class RedirectHandler {
	  constructor (dispatch, maxRedirections, opts, handler) {
	    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    util.validateHandler(handler, opts.method, opts.upgrade);

	    this.dispatch = dispatch;
	    this.location = null;
	    this.abort = null;
	    this.opts = { ...opts, maxRedirections: 0 }; // opts must be a copy
	    this.maxRedirections = maxRedirections;
	    this.handler = handler;
	    this.history = [];

	    if (util.isStream(this.opts.body)) {
	      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
	      // so that it can be dispatched again?
	      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?
	      if (util.bodyLength(this.opts.body) === 0) {
	        this.opts.body
	          .on('data', function () {
	            assert(false);
	          });
	      }

	      if (typeof this.opts.body.readableDidRead !== 'boolean') {
	        this.opts.body[kBodyUsed] = false;
	        EE.prototype.on.call(this.opts.body, 'data', function () {
	          this[kBodyUsed] = true;
	        });
	      }
	    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
	      // TODO (fix): We can't access ReadableStream internal state
	      // to determine whether or not it has been disturbed. This is just
	      // a workaround.
	      this.opts.body = new BodyAsyncIterable(this.opts.body);
	    } else if (
	      this.opts.body &&
	      typeof this.opts.body !== 'string' &&
	      !ArrayBuffer.isView(this.opts.body) &&
	      util.isIterable(this.opts.body)
	    ) {
	      // TODO: Should we allow re-using iterable if !this.opts.idempotent
	      // or through some other flag?
	      this.opts.body = new BodyAsyncIterable(this.opts.body);
	    }
	  }

	  onConnect (abort) {
	    this.abort = abort;
	    this.handler.onConnect(abort, { history: this.history });
	  }

	  onUpgrade (statusCode, headers, socket) {
	    this.handler.onUpgrade(statusCode, headers, socket);
	  }

	  onError (error) {
	    this.handler.onError(error);
	  }

	  onHeaders (statusCode, headers, resume, statusText) {
	    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
	      ? null
	      : parseLocation(statusCode, headers);

	    if (this.opts.origin) {
	      this.history.push(new URL(this.opts.path, this.opts.origin));
	    }

	    if (!this.location) {
	      return this.handler.onHeaders(statusCode, headers, resume, statusText)
	    }

	    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
	    const path = search ? `${pathname}${search}` : pathname;

	    // Remove headers referring to the original URL.
	    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
	    // https://tools.ietf.org/html/rfc7231#section-6.4
	    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
	    this.opts.path = path;
	    this.opts.origin = origin;
	    this.opts.maxRedirections = 0;
	    this.opts.query = null;

	    // https://tools.ietf.org/html/rfc7231#section-6.4.4
	    // In case of HTTP 303, always replace method to be either HEAD or GET
	    if (statusCode === 303 && this.opts.method !== 'HEAD') {
	      this.opts.method = 'GET';
	      this.opts.body = null;
	    }
	  }

	  onData (chunk) {
	    if (this.location) ; else {
	      return this.handler.onData(chunk)
	    }
	  }

	  onComplete (trailers) {
	    if (this.location) {
	      /*
	        https://tools.ietf.org/html/rfc7231#section-6.4

	        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
	        and neither are useful if present.

	        See comment on onData method above for more detailed informations.
	      */

	      this.location = null;
	      this.abort = null;

	      this.dispatch(this.opts, this);
	    } else {
	      this.handler.onComplete(trailers);
	    }
	  }

	  onBodySent (chunk) {
	    if (this.handler.onBodySent) {
	      this.handler.onBodySent(chunk);
	    }
	  }
	}

	function parseLocation (statusCode, headers) {
	  if (redirectableStatusCodes.indexOf(statusCode) === -1) {
	    return null
	  }

	  for (let i = 0; i < headers.length; i += 2) {
	    if (headers[i].toString().toLowerCase() === 'location') {
	      return headers[i + 1]
	    }
	  }
	}

	// https://tools.ietf.org/html/rfc7231#section-6.4.4
	function shouldRemoveHeader (header, removeContent, unknownOrigin) {
	  if (header.length === 4) {
	    return util.headerNameToString(header) === 'host'
	  }
	  if (removeContent && util.headerNameToString(header).startsWith('content-')) {
	    return true
	  }
	  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
	    const name = util.headerNameToString(header);
	    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'
	  }
	  return false
	}

	// https://tools.ietf.org/html/rfc7231#section-6.4
	function cleanRequestHeaders (headers, removeContent, unknownOrigin) {
	  const ret = [];
	  if (Array.isArray(headers)) {
	    for (let i = 0; i < headers.length; i += 2) {
	      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
	        ret.push(headers[i], headers[i + 1]);
	      }
	    }
	  } else if (headers && typeof headers === 'object') {
	    for (const key of Object.keys(headers)) {
	      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
	        ret.push(key, headers[key]);
	      }
	    }
	  } else {
	    assert(headers == null, 'headers must be an object or an array');
	  }
	  return ret
	}

	RedirectHandler_1 = RedirectHandler;
	return RedirectHandler_1;
}

var redirectInterceptor;
var hasRequiredRedirectInterceptor;

function requireRedirectInterceptor () {
	if (hasRequiredRedirectInterceptor) return redirectInterceptor;
	hasRequiredRedirectInterceptor = 1;

	const RedirectHandler = requireRedirectHandler();

	function createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {
	  return (dispatch) => {
	    return function Intercept (opts, handler) {
	      const { maxRedirections = defaultMaxRedirections } = opts;

	      if (!maxRedirections) {
	        return dispatch(opts, handler)
	      }

	      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
	      opts = { ...opts, maxRedirections: 0 }; // Stop sub dispatcher from also redirecting.
	      return dispatch(opts, redirectHandler)
	    }
	  }
	}

	redirectInterceptor = createRedirectInterceptor;
	return redirectInterceptor;
}

var llhttpWasm;
var hasRequiredLlhttpWasm;

function requireLlhttpWasm () {
	if (hasRequiredLlhttpWasm) return llhttpWasm;
	hasRequiredLlhttpWasm = 1;
	llhttpWasm = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=';
	return llhttpWasm;
}

var llhttp_simdWasm;
var hasRequiredLlhttp_simdWasm;

function requireLlhttp_simdWasm () {
	if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm;
	hasRequiredLlhttp_simdWasm = 1;
	llhttp_simdWasm = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==';
	return llhttp_simdWasm;
}

var client$1;
var hasRequiredClient$1;

function requireClient$1 () {
	if (hasRequiredClient$1) return client$1;
	hasRequiredClient$1 = 1;

	/* global WebAssembly */

	const assert = require$$0$8;
	const net = require$$0$a;
	const http = require$$2__default;
	const { pipeline } = require$$0$9;
	const util = requireUtil$8();
	const timers = requireTimers();
	const Request = requireRequest$1();
	const DispatcherBase = requireDispatcherBase();
	const {
	  RequestContentLengthMismatchError,
	  ResponseContentLengthMismatchError,
	  InvalidArgumentError,
	  RequestAbortedError,
	  HeadersTimeoutError,
	  HeadersOverflowError,
	  SocketError,
	  InformationalError,
	  BodyTimeoutError,
	  HTTPParserError,
	  ResponseExceededMaxSizeError,
	  ClientDestroyedError
	} = requireErrors();
	const buildConnector = requireConnect();
	const {
	  kUrl,
	  kReset,
	  kServerName,
	  kClient,
	  kBusy,
	  kParser,
	  kConnect,
	  kBlocking,
	  kResuming,
	  kRunning,
	  kPending,
	  kSize,
	  kWriting,
	  kQueue,
	  kConnected,
	  kConnecting,
	  kNeedDrain,
	  kNoRef,
	  kKeepAliveDefaultTimeout,
	  kHostHeader,
	  kPendingIdx,
	  kRunningIdx,
	  kError,
	  kPipelining,
	  kSocket,
	  kKeepAliveTimeoutValue,
	  kMaxHeadersSize,
	  kKeepAliveMaxTimeout,
	  kKeepAliveTimeoutThreshold,
	  kHeadersTimeout,
	  kBodyTimeout,
	  kStrictContentLength,
	  kConnector,
	  kMaxRedirections,
	  kMaxRequests,
	  kCounter,
	  kClose,
	  kDestroy,
	  kDispatch,
	  kInterceptors,
	  kLocalAddress,
	  kMaxResponseSize,
	  kHTTPConnVersion,
	  // HTTP2
	  kHost,
	  kHTTP2Session,
	  kHTTP2SessionState,
	  kHTTP2BuildRequest,
	  kHTTP2CopyHeaders,
	  kHTTP1BuildRequest
	} = requireSymbols$4();

	/** @type {import('http2')} */
	let http2;
	try {
	  http2 = require('http2');
	} catch {
	  // @ts-ignore
	  http2 = { constants: {} };
	}

	const {
	  constants: {
	    HTTP2_HEADER_AUTHORITY,
	    HTTP2_HEADER_METHOD,
	    HTTP2_HEADER_PATH,
	    HTTP2_HEADER_SCHEME,
	    HTTP2_HEADER_CONTENT_LENGTH,
	    HTTP2_HEADER_EXPECT,
	    HTTP2_HEADER_STATUS
	  }
	} = http2;

	// Experimental
	let h2ExperimentalWarned = false;

	const FastBuffer = Buffer[Symbol.species];

	const kClosedResolve = Symbol('kClosedResolve');

	const channels = {};

	try {
	  const diagnosticsChannel = require('diagnostics_channel');
	  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');
	  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');
	  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');
	  channels.connected = diagnosticsChannel.channel('undici:client:connected');
	} catch {
	  channels.sendHeaders = { hasSubscribers: false };
	  channels.beforeConnect = { hasSubscribers: false };
	  channels.connectError = { hasSubscribers: false };
	  channels.connected = { hasSubscribers: false };
	}

	/**
	 * @type {import('../types/client').default}
	 */
	class Client extends DispatcherBase {
	  /**
	   *
	   * @param {string|URL} url
	   * @param {import('../types/client').Client.Options} options
	   */
	  constructor (url, {
	    interceptors,
	    maxHeaderSize,
	    headersTimeout,
	    socketTimeout,
	    requestTimeout,
	    connectTimeout,
	    bodyTimeout,
	    idleTimeout,
	    keepAlive,
	    keepAliveTimeout,
	    maxKeepAliveTimeout,
	    keepAliveMaxTimeout,
	    keepAliveTimeoutThreshold,
	    socketPath,
	    pipelining,
	    tls,
	    strictContentLength,
	    maxCachedSessions,
	    maxRedirections,
	    connect,
	    maxRequestsPerClient,
	    localAddress,
	    maxResponseSize,
	    autoSelectFamily,
	    autoSelectFamilyAttemptTimeout,
	    // h2
	    allowH2,
	    maxConcurrentStreams
	  } = {}) {
	    super();

	    if (keepAlive !== undefined) {
	      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')
	    }

	    if (socketTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')
	    }

	    if (requestTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')
	    }

	    if (idleTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')
	    }

	    if (maxKeepAliveTimeout !== undefined) {
	      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')
	    }

	    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
	      throw new InvalidArgumentError('invalid maxHeaderSize')
	    }

	    if (socketPath != null && typeof socketPath !== 'string') {
	      throw new InvalidArgumentError('invalid socketPath')
	    }

	    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
	      throw new InvalidArgumentError('invalid connectTimeout')
	    }

	    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
	      throw new InvalidArgumentError('invalid keepAliveTimeout')
	    }

	    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
	      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')
	    }

	    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
	      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')
	    }

	    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
	      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')
	    }

	    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
	      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
	      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')
	    }

	    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {
	      throw new InvalidArgumentError('localAddress must be valid string IP address')
	    }

	    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
	      throw new InvalidArgumentError('maxResponseSize must be a positive number')
	    }

	    if (
	      autoSelectFamilyAttemptTimeout != null &&
	      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)
	    ) {
	      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')
	    }

	    // h2
	    if (allowH2 != null && typeof allowH2 !== 'boolean') {
	      throw new InvalidArgumentError('allowH2 must be a valid boolean value')
	    }

	    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {
	      throw new InvalidArgumentError('maxConcurrentStreams must be a possitive integer, greater than 0')
	    }

	    if (typeof connect !== 'function') {
	      connect = buildConnector({
	        ...tls,
	        maxCachedSessions,
	        allowH2,
	        socketPath,
	        timeout: connectTimeout,
	        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
	        ...connect
	      });
	    }

	    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)
	      ? interceptors.Client
	      : [createRedirectInterceptor({ maxRedirections })];
	    this[kUrl] = util.parseOrigin(url);
	    this[kConnector] = connect;
	    this[kSocket] = null;
	    this[kPipelining] = pipelining != null ? pipelining : 1;
	    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
	    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
	    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;
	    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
	    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
	    this[kServerName] = null;
	    this[kLocalAddress] = localAddress != null ? localAddress : null;
	    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming
	    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming
	    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`;
	    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;
	    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;
	    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
	    this[kMaxRedirections] = maxRedirections;
	    this[kMaxRequests] = maxRequestsPerClient;
	    this[kClosedResolve] = null;
	    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
	    this[kHTTPConnVersion] = 'h1';

	    // HTTP/2
	    this[kHTTP2Session] = null;
	    this[kHTTP2SessionState] = !allowH2
	      ? null
	      : {
	        // streams: null, // Fixed queue of streams - For future support of `push`
	          openStreams: 0, // Keep track of them to decide wether or not unref the session
	          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server
	        };
	    this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}`;

	    // kQueue is built up of 3 sections separated by
	    // the kRunningIdx and kPendingIdx indices.
	    // |   complete   |   running   |   pending   |
	    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
	    // kRunningIdx points to the first running element.
	    // kPendingIdx points to the first pending element.
	    // This implements a fast queue with an amortized
	    // time of O(1).

	    this[kQueue] = [];
	    this[kRunningIdx] = 0;
	    this[kPendingIdx] = 0;
	  }

	  get pipelining () {
	    return this[kPipelining]
	  }

	  set pipelining (value) {
	    this[kPipelining] = value;
	    resume(this, true);
	  }

	  get [kPending] () {
	    return this[kQueue].length - this[kPendingIdx]
	  }

	  get [kRunning] () {
	    return this[kPendingIdx] - this[kRunningIdx]
	  }

	  get [kSize] () {
	    return this[kQueue].length - this[kRunningIdx]
	  }

	  get [kConnected] () {
	    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed
	  }

	  get [kBusy] () {
	    const socket = this[kSocket];
	    return (
	      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
	      (this[kSize] >= (this[kPipelining] || 1)) ||
	      this[kPending] > 0
	    )
	  }

	  /* istanbul ignore: only used for test */
	  [kConnect] (cb) {
	    connect(this);
	    this.once('connect', cb);
	  }

	  [kDispatch] (opts, handler) {
	    const origin = opts.origin || this[kUrl].origin;

	    const request = this[kHTTPConnVersion] === 'h2'
	      ? Request[kHTTP2BuildRequest](origin, opts, handler)
	      : Request[kHTTP1BuildRequest](origin, opts, handler);

	    this[kQueue].push(request);
	    if (this[kResuming]) ; else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
	      // Wait a tick in case stream/iterator is ended in the same tick.
	      this[kResuming] = 1;
	      process.nextTick(resume, this);
	    } else {
	      resume(this, true);
	    }

	    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
	      this[kNeedDrain] = 2;
	    }

	    return this[kNeedDrain] < 2
	  }

	  async [kClose] () {
	    // TODO: for H2 we need to gracefully flush the remaining enqueued
	    // request and close each stream.
	    return new Promise((resolve) => {
	      if (!this[kSize]) {
	        resolve(null);
	      } else {
	        this[kClosedResolve] = resolve;
	      }
	    })
	  }

	  async [kDestroy] (err) {
	    return new Promise((resolve) => {
	      const requests = this[kQueue].splice(this[kPendingIdx]);
	      for (let i = 0; i < requests.length; i++) {
	        const request = requests[i];
	        errorRequest(this, request, err);
	      }

	      const callback = () => {
	        if (this[kClosedResolve]) {
	          // TODO (fix): Should we error here with ClientDestroyedError?
	          this[kClosedResolve]();
	          this[kClosedResolve] = null;
	        }
	        resolve();
	      };

	      if (this[kHTTP2Session] != null) {
	        util.destroy(this[kHTTP2Session], err);
	        this[kHTTP2Session] = null;
	        this[kHTTP2SessionState] = null;
	      }

	      if (!this[kSocket]) {
	        queueMicrotask(callback);
	      } else {
	        util.destroy(this[kSocket].on('close', callback), err);
	      }

	      resume(this);
	    })
	  }
	}

	function onHttp2SessionError (err) {
	  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');

	  this[kSocket][kError] = err;

	  onError(this[kClient], err);
	}

	function onHttp2FrameError (type, code, id) {
	  const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);

	  if (id === 0) {
	    this[kSocket][kError] = err;
	    onError(this[kClient], err);
	  }
	}

	function onHttp2SessionEnd () {
	  util.destroy(this, new SocketError('other side closed'));
	  util.destroy(this[kSocket], new SocketError('other side closed'));
	}

	function onHTTP2GoAway (code) {
	  const client = this[kClient];
	  const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
	  client[kSocket] = null;
	  client[kHTTP2Session] = null;

	  if (client.destroyed) {
	    assert(this[kPending] === 0);

	    // Fail entire queue.
	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(this, request, err);
	    }
	  } else if (client[kRunning] > 0) {
	    // Fail head of pipeline.
	    const request = client[kQueue][client[kRunningIdx]];
	    client[kQueue][client[kRunningIdx]++] = null;

	    errorRequest(client, request, err);
	  }

	  client[kPendingIdx] = client[kRunningIdx];

	  assert(client[kRunning] === 0);

	  client.emit('disconnect',
	    client[kUrl],
	    [client],
	    err
	  );

	  resume(client);
	}

	const constants = requireConstants$3();
	const createRedirectInterceptor = requireRedirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);

	async function lazyllhttp () {
	  const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : undefined;

	  let mod;
	  try {
	    mod = await WebAssembly.compile(Buffer.from(requireLlhttp_simdWasm(), 'base64'));
	  } catch (e) {
	    /* istanbul ignore next */

	    // We could check if the error was caused by the simd option not
	    // being enabled, but the occurring of this other error
	    // * https://github.com/emscripten-core/emscripten/issues/11495
	    // got me to remove that check to avoid breaking Node 12.
	    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || requireLlhttpWasm(), 'base64'));
	  }

	  return await WebAssembly.instantiate(mod, {
	    env: {
	      /* eslint-disable camelcase */

	      wasm_on_url: (p, at, len) => {
	        /* istanbul ignore next */
	        return 0
	      },
	      wasm_on_status: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_message_begin: (p) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onMessageBegin() || 0
	      },
	      wasm_on_header_field: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_header_value: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0
	      },
	      wasm_on_body: (p, at, len) => {
	        assert.strictEqual(currentParser.ptr, p);
	        const start = at - currentBufferPtr + currentBufferRef.byteOffset;
	        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0
	      },
	      wasm_on_message_complete: (p) => {
	        assert.strictEqual(currentParser.ptr, p);
	        return currentParser.onMessageComplete() || 0
	      }

	      /* eslint-enable camelcase */
	    }
	  })
	}

	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();

	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;

	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;

	class Parser {
	  constructor (client, socket, { exports }) {
	    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);

	    this.llhttp = exports;
	    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
	    this.client = client;
	    this.socket = socket;
	    this.timeout = null;
	    this.timeoutValue = null;
	    this.timeoutType = null;
	    this.statusCode = null;
	    this.statusText = '';
	    this.upgrade = false;
	    this.headers = [];
	    this.headersSize = 0;
	    this.headersMaxSize = client[kMaxHeadersSize];
	    this.shouldKeepAlive = false;
	    this.paused = false;
	    this.resume = this.resume.bind(this);

	    this.bytesRead = 0;

	    this.keepAlive = '';
	    this.contentLength = '';
	    this.connection = '';
	    this.maxResponseSize = client[kMaxResponseSize];
	  }

	  setTimeout (value, type) {
	    this.timeoutType = type;
	    if (value !== this.timeoutValue) {
	      timers.clearTimeout(this.timeout);
	      if (value) {
	        this.timeout = timers.setTimeout(onParserTimeout, value, this);
	        // istanbul ignore else: only for jest
	        if (this.timeout.unref) {
	          this.timeout.unref();
	        }
	      } else {
	        this.timeout = null;
	      }
	      this.timeoutValue = value;
	    } else if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }
	  }

	  resume () {
	    if (this.socket.destroyed || !this.paused) {
	      return
	    }

	    assert(this.ptr != null);
	    assert(currentParser == null);

	    this.llhttp.llhttp_resume(this.ptr);

	    assert(this.timeoutType === TIMEOUT_BODY);
	    if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    this.paused = false;
	    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.
	    this.readMore();
	  }

	  readMore () {
	    while (!this.paused && this.ptr) {
	      const chunk = this.socket.read();
	      if (chunk === null) {
	        break
	      }
	      this.execute(chunk);
	    }
	  }

	  execute (data) {
	    assert(this.ptr != null);
	    assert(currentParser == null);
	    assert(!this.paused);

	    const { socket, llhttp } = this;

	    if (data.length > currentBufferSize) {
	      if (currentBufferPtr) {
	        llhttp.free(currentBufferPtr);
	      }
	      currentBufferSize = Math.ceil(data.length / 4096) * 4096;
	      currentBufferPtr = llhttp.malloc(currentBufferSize);
	    }

	    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);

	    // Call `execute` on the wasm parser.
	    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
	    // and finally the length of bytes to parse.
	    // The return value is an error code or `constants.ERROR.OK`.
	    try {
	      let ret;

	      try {
	        currentBufferRef = data;
	        currentParser = this;
	        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
	        /* eslint-disable-next-line no-useless-catch */
	      } catch (err) {
	        /* istanbul ignore next: difficult to make a test case for */
	        throw err
	      } finally {
	        currentParser = null;
	        currentBufferRef = null;
	      }

	      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;

	      if (ret === constants.ERROR.PAUSED_UPGRADE) {
	        this.onUpgrade(data.slice(offset));
	      } else if (ret === constants.ERROR.PAUSED) {
	        this.paused = true;
	        socket.unshift(data.slice(offset));
	      } else if (ret !== constants.ERROR.OK) {
	        const ptr = llhttp.llhttp_get_error_reason(this.ptr);
	        let message = '';
	        /* istanbul ignore else: difficult to make a test case for */
	        if (ptr) {
	          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
	          message =
	            'Response does not match the HTTP/1.1 protocol (' +
	            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
	            ')';
	        }
	        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))
	      }
	    } catch (err) {
	      util.destroy(socket, err);
	    }
	  }

	  destroy () {
	    assert(this.ptr != null);
	    assert(currentParser == null);

	    this.llhttp.llhttp_free(this.ptr);
	    this.ptr = null;

	    timers.clearTimeout(this.timeout);
	    this.timeout = null;
	    this.timeoutValue = null;
	    this.timeoutType = null;

	    this.paused = false;
	  }

	  onStatus (buf) {
	    this.statusText = buf.toString();
	  }

	  onMessageBegin () {
	    const { socket, client } = this;

	    /* istanbul ignore next: difficult to make a test case for */
	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    if (!request) {
	      return -1
	    }
	  }

	  onHeaderField (buf) {
	    const len = this.headers.length;

	    if ((len & 1) === 0) {
	      this.headers.push(buf);
	    } else {
	      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
	    }

	    this.trackHeader(buf.length);
	  }

	  onHeaderValue (buf) {
	    let len = this.headers.length;

	    if ((len & 1) === 1) {
	      this.headers.push(buf);
	      len += 1;
	    } else {
	      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
	    }

	    const key = this.headers[len - 2];
	    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {
	      this.keepAlive += buf.toString();
	    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {
	      this.connection += buf.toString();
	    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {
	      this.contentLength += buf.toString();
	    }

	    this.trackHeader(buf.length);
	  }

	  trackHeader (len) {
	    this.headersSize += len;
	    if (this.headersSize >= this.headersMaxSize) {
	      util.destroy(this.socket, new HeadersOverflowError());
	    }
	  }

	  onUpgrade (head) {
	    const { upgrade, client, socket, headers, statusCode } = this;

	    assert(upgrade);

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert(!socket.destroyed);
	    assert(socket === client[kSocket]);
	    assert(!this.paused);
	    assert(request.upgrade || request.method === 'CONNECT');

	    this.statusCode = null;
	    this.statusText = '';
	    this.shouldKeepAlive = null;

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    socket.unshift(head);

	    socket[kParser].destroy();
	    socket[kParser] = null;

	    socket[kClient] = null;
	    socket[kError] = null;
	    socket
	      .removeListener('error', onSocketError)
	      .removeListener('readable', onSocketReadable)
	      .removeListener('end', onSocketEnd)
	      .removeListener('close', onSocketClose);

	    client[kSocket] = null;
	    client[kQueue][client[kRunningIdx]++] = null;
	    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));

	    try {
	      request.onUpgrade(statusCode, headers, socket);
	    } catch (err) {
	      util.destroy(socket, err);
	    }

	    resume(client);
	  }

	  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {
	    const { client, socket, headers, statusText } = this;

	    /* istanbul ignore next: difficult to make a test case for */
	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];

	    /* istanbul ignore next: difficult to make a test case for */
	    if (!request) {
	      return -1
	    }

	    assert(!this.upgrade);
	    assert(this.statusCode < 200);

	    if (statusCode === 100) {
	      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));
	      return -1
	    }

	    /* this can only happen if server is misbehaving */
	    if (upgrade && !request.upgrade) {
	      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));
	      return -1
	    }

	    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);

	    this.statusCode = statusCode;
	    this.shouldKeepAlive = (
	      shouldKeepAlive ||
	      // Override llhttp value which does not allow keepAlive for HEAD.
	      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')
	    );

	    if (this.statusCode >= 200) {
	      const bodyTimeout = request.bodyTimeout != null
	        ? request.bodyTimeout
	        : client[kBodyTimeout];
	      this.setTimeout(bodyTimeout, TIMEOUT_BODY);
	    } else if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    if (request.method === 'CONNECT') {
	      assert(client[kRunning] === 1);
	      this.upgrade = true;
	      return 2
	    }

	    if (upgrade) {
	      assert(client[kRunning] === 1);
	      this.upgrade = true;
	      return 2
	    }

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    if (this.shouldKeepAlive && client[kPipelining]) {
	      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;

	      if (keepAliveTimeout != null) {
	        const timeout = Math.min(
	          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
	          client[kKeepAliveMaxTimeout]
	        );
	        if (timeout <= 0) {
	          socket[kReset] = true;
	        } else {
	          client[kKeepAliveTimeoutValue] = timeout;
	        }
	      } else {
	        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
	      }
	    } else {
	      // Stop more requests from being dispatched.
	      socket[kReset] = true;
	    }

	    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;

	    if (request.aborted) {
	      return -1
	    }

	    if (request.method === 'HEAD') {
	      return 1
	    }

	    if (statusCode < 200) {
	      return 1
	    }

	    if (socket[kBlocking]) {
	      socket[kBlocking] = false;
	      resume(client);
	    }

	    return pause ? constants.ERROR.PAUSED : 0
	  }

	  onBody (buf) {
	    const { client, socket, statusCode, maxResponseSize } = this;

	    if (socket.destroyed) {
	      return -1
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
	    if (this.timeout) {
	      // istanbul ignore else: only for jest
	      if (this.timeout.refresh) {
	        this.timeout.refresh();
	      }
	    }

	    assert(statusCode >= 200);

	    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
	      util.destroy(socket, new ResponseExceededMaxSizeError());
	      return -1
	    }

	    this.bytesRead += buf.length;

	    if (request.onData(buf) === false) {
	      return constants.ERROR.PAUSED
	    }
	  }

	  onMessageComplete () {
	    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;

	    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
	      return -1
	    }

	    if (upgrade) {
	      return
	    }

	    const request = client[kQueue][client[kRunningIdx]];
	    assert(request);

	    assert(statusCode >= 100);

	    this.statusCode = null;
	    this.statusText = '';
	    this.bytesRead = 0;
	    this.contentLength = '';
	    this.keepAlive = '';
	    this.connection = '';

	    assert(this.headers.length % 2 === 0);
	    this.headers = [];
	    this.headersSize = 0;

	    if (statusCode < 200) {
	      return
	    }

	    /* istanbul ignore next: should be handled by llhttp? */
	    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
	      util.destroy(socket, new ResponseContentLengthMismatchError());
	      return -1
	    }

	    request.onComplete(headers);

	    client[kQueue][client[kRunningIdx]++] = null;

	    if (socket[kWriting]) {
	      assert.strictEqual(client[kRunning], 0);
	      // Response completed before request.
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (!shouldKeepAlive) {
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (socket[kReset] && client[kRunning] === 0) {
	      // Destroy socket once all requests have completed.
	      // The request at the tail of the pipeline is the one
	      // that requested reset and no further requests should
	      // have been queued since then.
	      util.destroy(socket, new InformationalError('reset'));
	      return constants.ERROR.PAUSED
	    } else if (client[kPipelining] === 1) {
	      // We must wait a full event loop cycle to reuse this socket to make sure
	      // that non-spec compliant servers are not closing the connection even if they
	      // said they won't.
	      setImmediate(resume, client);
	    } else {
	      resume(client);
	    }
	  }
	}

	function onParserTimeout (parser) {
	  const { socket, timeoutType, client } = parser;

	  /* istanbul ignore else */
	  if (timeoutType === TIMEOUT_HEADERS) {
	    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
	      assert(!parser.paused, 'cannot be paused while waiting for headers');
	      util.destroy(socket, new HeadersTimeoutError());
	    }
	  } else if (timeoutType === TIMEOUT_BODY) {
	    if (!parser.paused) {
	      util.destroy(socket, new BodyTimeoutError());
	    }
	  } else if (timeoutType === TIMEOUT_IDLE) {
	    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
	    util.destroy(socket, new InformationalError('socket idle timeout'));
	  }
	}

	function onSocketReadable () {
	  const { [kParser]: parser } = this;
	  if (parser) {
	    parser.readMore();
	  }
	}

	function onSocketError (err) {
	  const { [kClient]: client, [kParser]: parser } = this;

	  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');

	  if (client[kHTTPConnVersion] !== 'h2') {
	    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
	    // to the user.
	    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so for as a valid response.
	      parser.onMessageComplete();
	      return
	    }
	  }

	  this[kError] = err;

	  onError(this[kClient], err);
	}

	function onError (client, err) {
	  if (
	    client[kRunning] === 0 &&
	    err.code !== 'UND_ERR_INFO' &&
	    err.code !== 'UND_ERR_SOCKET'
	  ) {
	    // Error is not caused by running request and not a recoverable
	    // socket error.

	    assert(client[kPendingIdx] === client[kRunningIdx]);

	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(client, request, err);
	    }
	    assert(client[kSize] === 0);
	  }
	}

	function onSocketEnd () {
	  const { [kParser]: parser, [kClient]: client } = this;

	  if (client[kHTTPConnVersion] !== 'h2') {
	    if (parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so far as a valid response.
	      parser.onMessageComplete();
	      return
	    }
	  }

	  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));
	}

	function onSocketClose () {
	  const { [kClient]: client, [kParser]: parser } = this;

	  if (client[kHTTPConnVersion] === 'h1' && parser) {
	    if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
	      // We treat all incoming data so far as a valid response.
	      parser.onMessageComplete();
	    }

	    this[kParser].destroy();
	    this[kParser] = null;
	  }

	  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));

	  client[kSocket] = null;

	  if (client.destroyed) {
	    assert(client[kPending] === 0);

	    // Fail entire queue.
	    const requests = client[kQueue].splice(client[kRunningIdx]);
	    for (let i = 0; i < requests.length; i++) {
	      const request = requests[i];
	      errorRequest(client, request, err);
	    }
	  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
	    // Fail head of pipeline.
	    const request = client[kQueue][client[kRunningIdx]];
	    client[kQueue][client[kRunningIdx]++] = null;

	    errorRequest(client, request, err);
	  }

	  client[kPendingIdx] = client[kRunningIdx];

	  assert(client[kRunning] === 0);

	  client.emit('disconnect', client[kUrl], [client], err);

	  resume(client);
	}

	async function connect (client) {
	  assert(!client[kConnecting]);
	  assert(!client[kSocket]);

	  let { host, hostname, protocol, port } = client[kUrl];

	  // Resolve ipv6
	  if (hostname[0] === '[') {
	    const idx = hostname.indexOf(']');

	    assert(idx !== -1);
	    const ip = hostname.substring(1, idx);

	    assert(net.isIP(ip));
	    hostname = ip;
	  }

	  client[kConnecting] = true;

	  if (channels.beforeConnect.hasSubscribers) {
	    channels.beforeConnect.publish({
	      connectParams: {
	        host,
	        hostname,
	        protocol,
	        port,
	        servername: client[kServerName],
	        localAddress: client[kLocalAddress]
	      },
	      connector: client[kConnector]
	    });
	  }

	  try {
	    const socket = await new Promise((resolve, reject) => {
	      client[kConnector]({
	        host,
	        hostname,
	        protocol,
	        port,
	        servername: client[kServerName],
	        localAddress: client[kLocalAddress]
	      }, (err, socket) => {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(socket);
	        }
	      });
	    });

	    if (client.destroyed) {
	      util.destroy(socket.on('error', () => {}), new ClientDestroyedError());
	      return
	    }

	    client[kConnecting] = false;

	    assert(socket);

	    const isH2 = socket.alpnProtocol === 'h2';
	    if (isH2) {
	      if (!h2ExperimentalWarned) {
	        h2ExperimentalWarned = true;
	        process.emitWarning('H2 support is experimental, expect them to change at any time.', {
	          code: 'UNDICI-H2'
	        });
	      }

	      const session = http2.connect(client[kUrl], {
	        createConnection: () => socket,
	        peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
	      });

	      client[kHTTPConnVersion] = 'h2';
	      session[kClient] = client;
	      session[kSocket] = socket;
	      session.on('error', onHttp2SessionError);
	      session.on('frameError', onHttp2FrameError);
	      session.on('end', onHttp2SessionEnd);
	      session.on('goaway', onHTTP2GoAway);
	      session.on('close', onSocketClose);
	      session.unref();

	      client[kHTTP2Session] = session;
	      socket[kHTTP2Session] = session;
	    } else {
	      if (!llhttpInstance) {
	        llhttpInstance = await llhttpPromise;
	        llhttpPromise = null;
	      }

	      socket[kNoRef] = false;
	      socket[kWriting] = false;
	      socket[kReset] = false;
	      socket[kBlocking] = false;
	      socket[kParser] = new Parser(client, socket, llhttpInstance);
	    }

	    socket[kCounter] = 0;
	    socket[kMaxRequests] = client[kMaxRequests];
	    socket[kClient] = client;
	    socket[kError] = null;

	    socket
	      .on('error', onSocketError)
	      .on('readable', onSocketReadable)
	      .on('end', onSocketEnd)
	      .on('close', onSocketClose);

	    client[kSocket] = socket;

	    if (channels.connected.hasSubscribers) {
	      channels.connected.publish({
	        connectParams: {
	          host,
	          hostname,
	          protocol,
	          port,
	          servername: client[kServerName],
	          localAddress: client[kLocalAddress]
	        },
	        connector: client[kConnector],
	        socket
	      });
	    }
	    client.emit('connect', client[kUrl], [client]);
	  } catch (err) {
	    if (client.destroyed) {
	      return
	    }

	    client[kConnecting] = false;

	    if (channels.connectError.hasSubscribers) {
	      channels.connectError.publish({
	        connectParams: {
	          host,
	          hostname,
	          protocol,
	          port,
	          servername: client[kServerName],
	          localAddress: client[kLocalAddress]
	        },
	        connector: client[kConnector],
	        error: err
	      });
	    }

	    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
	      assert(client[kRunning] === 0);
	      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
	        const request = client[kQueue][client[kPendingIdx]++];
	        errorRequest(client, request, err);
	      }
	    } else {
	      onError(client, err);
	    }

	    client.emit('connectionError', client[kUrl], [client], err);
	  }

	  resume(client);
	}

	function emitDrain (client) {
	  client[kNeedDrain] = 0;
	  client.emit('drain', client[kUrl], [client]);
	}

	function resume (client, sync) {
	  if (client[kResuming] === 2) {
	    return
	  }

	  client[kResuming] = 2;

	  _resume(client, sync);
	  client[kResuming] = 0;

	  if (client[kRunningIdx] > 256) {
	    client[kQueue].splice(0, client[kRunningIdx]);
	    client[kPendingIdx] -= client[kRunningIdx];
	    client[kRunningIdx] = 0;
	  }
	}

	function _resume (client, sync) {
	  while (true) {
	    if (client.destroyed) {
	      assert(client[kPending] === 0);
	      return
	    }

	    if (client[kClosedResolve] && !client[kSize]) {
	      client[kClosedResolve]();
	      client[kClosedResolve] = null;
	      return
	    }

	    const socket = client[kSocket];

	    if (socket && !socket.destroyed && socket.alpnProtocol !== 'h2') {
	      if (client[kSize] === 0) {
	        if (!socket[kNoRef] && socket.unref) {
	          socket.unref();
	          socket[kNoRef] = true;
	        }
	      } else if (socket[kNoRef] && socket.ref) {
	        socket.ref();
	        socket[kNoRef] = false;
	      }

	      if (client[kSize] === 0) {
	        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
	          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
	        }
	      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
	        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
	          const request = client[kQueue][client[kRunningIdx]];
	          const headersTimeout = request.headersTimeout != null
	            ? request.headersTimeout
	            : client[kHeadersTimeout];
	          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
	        }
	      }
	    }

	    if (client[kBusy]) {
	      client[kNeedDrain] = 2;
	    } else if (client[kNeedDrain] === 2) {
	      if (sync) {
	        client[kNeedDrain] = 1;
	        process.nextTick(emitDrain, client);
	      } else {
	        emitDrain(client);
	      }
	      continue
	    }

	    if (client[kPending] === 0) {
	      return
	    }

	    if (client[kRunning] >= (client[kPipelining] || 1)) {
	      return
	    }

	    const request = client[kQueue][client[kPendingIdx]];

	    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {
	      if (client[kRunning] > 0) {
	        return
	      }

	      client[kServerName] = request.servername;

	      if (socket && socket.servername !== request.servername) {
	        util.destroy(socket, new InformationalError('servername changed'));
	        return
	      }
	    }

	    if (client[kConnecting]) {
	      return
	    }

	    if (!socket && !client[kHTTP2Session]) {
	      connect(client);
	      return
	    }

	    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
	      return
	    }

	    if (client[kRunning] > 0 && !request.idempotent) {
	      // Non-idempotent request cannot be retried.
	      // Ensure that no other requests are inflight and
	      // could cause failure.
	      return
	    }

	    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {
	      // Don't dispatch an upgrade until all preceding requests have completed.
	      // A misbehaving server might upgrade the connection before all pipelined
	      // request has completed.
	      return
	    }

	    if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&
	      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
	      // Request with stream or iterator body can error while other requests
	      // are inflight and indirectly error those as well.
	      // Ensure this doesn't happen by waiting for inflight
	      // to complete before dispatching.

	      // Request with stream or iterator body cannot be retried.
	      // Ensure that no other requests are inflight and
	      // could cause failure.
	      return
	    }

	    if (!request.aborted && write(client, request)) {
	      client[kPendingIdx]++;
	    } else {
	      client[kQueue].splice(client[kPendingIdx], 1);
	    }
	  }
	}

	// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2
	function shouldSendContentLength (method) {
	  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'
	}

	function write (client, request) {
	  if (client[kHTTPConnVersion] === 'h2') {
	    writeH2(client, client[kHTTP2Session], request);
	    return
	  }

	  const { body, method, path, host, upgrade, headers, blocking, reset } = request;

	  // https://tools.ietf.org/html/rfc7231#section-4.3.1
	  // https://tools.ietf.org/html/rfc7231#section-4.3.2
	  // https://tools.ietf.org/html/rfc7231#section-4.3.5

	  // Sending a payload body on a request that does not
	  // expect it can cause undefined behavior on some
	  // servers and corrupt connection state. Do not
	  // re-use the connection for further requests.

	  const expectsPayload = (
	    method === 'PUT' ||
	    method === 'POST' ||
	    method === 'PATCH'
	  );

	  if (body && typeof body.read === 'function') {
	    // Try to read EOF in order to get length.
	    body.read(0);
	  }

	  const bodyLength = util.bodyLength(body);

	  let contentLength = bodyLength;

	  if (contentLength === null) {
	    contentLength = request.contentLength;
	  }

	  if (contentLength === 0 && !expectsPayload) {
	    // https://tools.ietf.org/html/rfc7230#section-3.3.2
	    // A user agent SHOULD NOT send a Content-Length header field when
	    // the request message does not contain a payload body and the method
	    // semantics do not anticipate such a body.

	    contentLength = null;
	  }

	  // https://github.com/nodejs/undici/issues/2046
	  // A user agent may send a Content-Length header with 0 value, this should be allowed.
	  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
	    if (client[kStrictContentLength]) {
	      errorRequest(client, request, new RequestContentLengthMismatchError());
	      return false
	    }

	    process.emitWarning(new RequestContentLengthMismatchError());
	  }

	  const socket = client[kSocket];

	  try {
	    request.onConnect((err) => {
	      if (request.aborted || request.completed) {
	        return
	      }

	      errorRequest(client, request, err || new RequestAbortedError());

	      util.destroy(socket, new InformationalError('aborted'));
	    });
	  } catch (err) {
	    errorRequest(client, request, err);
	  }

	  if (request.aborted) {
	    return false
	  }

	  if (method === 'HEAD') {
	    // https://github.com/mcollina/undici/issues/258
	    // Close after a HEAD request to interop with misbehaving servers
	    // that may send a body in the response.

	    socket[kReset] = true;
	  }

	  if (upgrade || method === 'CONNECT') {
	    // On CONNECT or upgrade, block pipeline from dispatching further
	    // requests on this connection.

	    socket[kReset] = true;
	  }

	  if (reset != null) {
	    socket[kReset] = reset;
	  }

	  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
	    socket[kReset] = true;
	  }

	  if (blocking) {
	    socket[kBlocking] = true;
	  }

	  let header = `${method} ${path} HTTP/1.1\r\n`;

	  if (typeof host === 'string') {
	    header += `host: ${host}\r\n`;
	  } else {
	    header += client[kHostHeader];
	  }

	  if (upgrade) {
	    header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
	  } else if (client[kPipelining] && !socket[kReset]) {
	    header += 'connection: keep-alive\r\n';
	  } else {
	    header += 'connection: close\r\n';
	  }

	  if (headers) {
	    header += headers;
	  }

	  if (channels.sendHeaders.hasSubscribers) {
	    channels.sendHeaders.publish({ request, headers: header, socket });
	  }

	  /* istanbul ignore else: assertion */
	  if (!body || bodyLength === 0) {
	    if (contentLength === 0) {
	      socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
	    } else {
	      assert(contentLength === null, 'no body must not have content length');
	      socket.write(`${header}\r\n`, 'latin1');
	    }
	    request.onRequestSent();
	  } else if (util.isBuffer(body)) {
	    assert(contentLength === body.byteLength, 'buffer body must have content length');

	    socket.cork();
	    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	    socket.write(body);
	    socket.uncork();
	    request.onBodySent(body);
	    request.onRequestSent();
	    if (!expectsPayload) {
	      socket[kReset] = true;
	    }
	  } else if (util.isBlobLike(body)) {
	    if (typeof body.stream === 'function') {
	      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
	    } else {
	      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
	    }
	  } else if (util.isStream(body)) {
	    writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
	  } else if (util.isIterable(body)) {
	    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
	  } else {
	    assert(false);
	  }

	  return true
	}

	function writeH2 (client, session, request) {
	  const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;

	  let headers;
	  if (typeof reqHeaders === 'string') headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
	  else headers = reqHeaders;

	  if (upgrade) {
	    errorRequest(client, request, new Error('Upgrade not supported for H2'));
	    return false
	  }

	  try {
	    // TODO(HTTP/2): Should we call onConnect immediately or on stream ready event?
	    request.onConnect((err) => {
	      if (request.aborted || request.completed) {
	        return
	      }

	      errorRequest(client, request, err || new RequestAbortedError());
	    });
	  } catch (err) {
	    errorRequest(client, request, err);
	  }

	  if (request.aborted) {
	    return false
	  }

	  /** @type {import('node:http2').ClientHttp2Stream} */
	  let stream;
	  const h2State = client[kHTTP2SessionState];

	  headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
	  headers[HTTP2_HEADER_METHOD] = method;

	  if (method === 'CONNECT') {
	    session.ref();
	    // we are already connected, streams are pending, first request
	    // will create a new stream. We trigger a request to create the stream and wait until
	    // `ready` event is triggered
	    // We disabled endStream to allow the user to write to the stream
	    stream = session.request(headers, { endStream: false, signal });

	    if (stream.id && !stream.pending) {
	      request.onUpgrade(null, null, stream);
	      ++h2State.openStreams;
	    } else {
	      stream.once('ready', () => {
	        request.onUpgrade(null, null, stream);
	        ++h2State.openStreams;
	      });
	    }

	    stream.once('close', () => {
	      h2State.openStreams -= 1;
	      // TODO(HTTP/2): unref only if current streams count is 0
	      if (h2State.openStreams === 0) session.unref();
	    });

	    return true
	  }

	  // https://tools.ietf.org/html/rfc7540#section-8.3
	  // :path and :scheme headers must be omited when sending CONNECT

	  headers[HTTP2_HEADER_PATH] = path;
	  headers[HTTP2_HEADER_SCHEME] = 'https';

	  // https://tools.ietf.org/html/rfc7231#section-4.3.1
	  // https://tools.ietf.org/html/rfc7231#section-4.3.2
	  // https://tools.ietf.org/html/rfc7231#section-4.3.5

	  // Sending a payload body on a request that does not
	  // expect it can cause undefined behavior on some
	  // servers and corrupt connection state. Do not
	  // re-use the connection for further requests.

	  const expectsPayload = (
	    method === 'PUT' ||
	    method === 'POST' ||
	    method === 'PATCH'
	  );

	  if (body && typeof body.read === 'function') {
	    // Try to read EOF in order to get length.
	    body.read(0);
	  }

	  let contentLength = util.bodyLength(body);

	  if (contentLength == null) {
	    contentLength = request.contentLength;
	  }

	  if (contentLength === 0 || !expectsPayload) {
	    // https://tools.ietf.org/html/rfc7230#section-3.3.2
	    // A user agent SHOULD NOT send a Content-Length header field when
	    // the request message does not contain a payload body and the method
	    // semantics do not anticipate such a body.

	    contentLength = null;
	  }

	  // https://github.com/nodejs/undici/issues/2046
	  // A user agent may send a Content-Length header with 0 value, this should be allowed.
	  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
	    if (client[kStrictContentLength]) {
	      errorRequest(client, request, new RequestContentLengthMismatchError());
	      return false
	    }

	    process.emitWarning(new RequestContentLengthMismatchError());
	  }

	  if (contentLength != null) {
	    assert(body, 'no body must not have content length');
	    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
	  }

	  session.ref();

	  const shouldEndStream = method === 'GET' || method === 'HEAD';
	  if (expectContinue) {
	    headers[HTTP2_HEADER_EXPECT] = '100-continue';
	    stream = session.request(headers, { endStream: shouldEndStream, signal });

	    stream.once('continue', writeBodyH2);
	  } else {
	    stream = session.request(headers, {
	      endStream: shouldEndStream,
	      signal
	    });
	    writeBodyH2();
	  }

	  // Increment counter as we have new several streams open
	  ++h2State.openStreams;

	  stream.once('response', headers => {
	    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers;

	    if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), '') === false) {
	      stream.pause();
	    }
	  });

	  stream.once('end', () => {
	    request.onComplete([]);
	  });

	  stream.on('data', (chunk) => {
	    if (request.onData(chunk) === false) {
	      stream.pause();
	    }
	  });

	  stream.once('close', () => {
	    h2State.openStreams -= 1;
	    // TODO(HTTP/2): unref only if current streams count is 0
	    if (h2State.openStreams === 0) {
	      session.unref();
	    }
	  });

	  stream.once('error', function (err) {
	    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
	      h2State.streams -= 1;
	      util.destroy(stream, err);
	    }
	  });

	  stream.once('frameError', (type, code) => {
	    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
	    errorRequest(client, request, err);

	    if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
	      h2State.streams -= 1;
	      util.destroy(stream, err);
	    }
	  });

	  // stream.on('aborted', () => {
	  //   // TODO(HTTP/2): Support aborted
	  // })

	  // stream.on('timeout', () => {
	  //   // TODO(HTTP/2): Support timeout
	  // })

	  // stream.on('push', headers => {
	  //   // TODO(HTTP/2): Suppor push
	  // })

	  // stream.on('trailers', headers => {
	  //   // TODO(HTTP/2): Support trailers
	  // })

	  return true

	  function writeBodyH2 () {
	    /* istanbul ignore else: assertion */
	    if (!body) {
	      request.onRequestSent();
	    } else if (util.isBuffer(body)) {
	      assert(contentLength === body.byteLength, 'buffer body must have content length');
	      stream.cork();
	      stream.write(body);
	      stream.uncork();
	      stream.end();
	      request.onBodySent(body);
	      request.onRequestSent();
	    } else if (util.isBlobLike(body)) {
	      if (typeof body.stream === 'function') {
	        writeIterable({
	          client,
	          request,
	          contentLength,
	          h2stream: stream,
	          expectsPayload,
	          body: body.stream(),
	          socket: client[kSocket],
	          header: ''
	        });
	      } else {
	        writeBlob({
	          body,
	          client,
	          request,
	          contentLength,
	          expectsPayload,
	          h2stream: stream,
	          header: '',
	          socket: client[kSocket]
	        });
	      }
	    } else if (util.isStream(body)) {
	      writeStream({
	        body,
	        client,
	        request,
	        contentLength,
	        expectsPayload,
	        socket: client[kSocket],
	        h2stream: stream,
	        header: ''
	      });
	    } else if (util.isIterable(body)) {
	      writeIterable({
	        body,
	        client,
	        request,
	        contentLength,
	        expectsPayload,
	        header: '',
	        h2stream: stream,
	        socket: client[kSocket]
	      });
	    } else {
	      assert(false);
	    }
	  }
	}

	function writeStream ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');

	  if (client[kHTTPConnVersion] === 'h2') {
	    // For HTTP/2, is enough to pipe the stream
	    const pipe = pipeline(
	      body,
	      h2stream,
	      (err) => {
	        if (err) {
	          util.destroy(body, err);
	          util.destroy(h2stream, err);
	        } else {
	          request.onRequestSent();
	        }
	      }
	    );

	    pipe.on('data', onPipeData);
	    pipe.once('end', () => {
	      pipe.removeListener('data', onPipeData);
	      util.destroy(pipe);
	    });

	    function onPipeData (chunk) {
	      request.onBodySent(chunk);
	    }

	    return
	  }

	  let finished = false;

	  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });

	  const onData = function (chunk) {
	    if (finished) {
	      return
	    }

	    try {
	      if (!writer.write(chunk) && this.pause) {
	        this.pause();
	      }
	    } catch (err) {
	      util.destroy(this, err);
	    }
	  };
	  const onDrain = function () {
	    if (finished) {
	      return
	    }

	    if (body.resume) {
	      body.resume();
	    }
	  };
	  const onAbort = function () {
	    if (finished) {
	      return
	    }
	    const err = new RequestAbortedError();
	    queueMicrotask(() => onFinished(err));
	  };
	  const onFinished = function (err) {
	    if (finished) {
	      return
	    }

	    finished = true;

	    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1));

	    socket
	      .off('drain', onDrain)
	      .off('error', onFinished);

	    body
	      .removeListener('data', onData)
	      .removeListener('end', onFinished)
	      .removeListener('error', onFinished)
	      .removeListener('close', onAbort);

	    if (!err) {
	      try {
	        writer.end();
	      } catch (er) {
	        err = er;
	      }
	    }

	    writer.destroy(err);

	    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
	      util.destroy(body, err);
	    } else {
	      util.destroy(body);
	    }
	  };

	  body
	    .on('data', onData)
	    .on('end', onFinished)
	    .on('error', onFinished)
	    .on('close', onAbort);

	  if (body.resume) {
	    body.resume();
	  }

	  socket
	    .on('drain', onDrain)
	    .on('error', onFinished);
	}

	async function writeBlob ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength === body.size, 'blob body must have content length');

	  const isH2 = client[kHTTPConnVersion] === 'h2';
	  try {
	    if (contentLength != null && contentLength !== body.size) {
	      throw new RequestContentLengthMismatchError()
	    }

	    const buffer = Buffer.from(await body.arrayBuffer());

	    if (isH2) {
	      h2stream.cork();
	      h2stream.write(buffer);
	      h2stream.uncork();
	    } else {
	      socket.cork();
	      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	      socket.write(buffer);
	      socket.uncork();
	    }

	    request.onBodySent(buffer);
	    request.onRequestSent();

	    if (!expectsPayload) {
	      socket[kReset] = true;
	    }

	    resume(client);
	  } catch (err) {
	    util.destroy(isH2 ? h2stream : socket, err);
	  }
	}

	async function writeIterable ({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
	  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');

	  let callback = null;
	  function onDrain () {
	    if (callback) {
	      const cb = callback;
	      callback = null;
	      cb();
	    }
	  }

	  const waitForDrain = () => new Promise((resolve, reject) => {
	    assert(callback === null);

	    if (socket[kError]) {
	      reject(socket[kError]);
	    } else {
	      callback = resolve;
	    }
	  });

	  if (client[kHTTPConnVersion] === 'h2') {
	    h2stream
	      .on('close', onDrain)
	      .on('drain', onDrain);

	    try {
	      // It's up to the user to somehow abort the async iterable.
	      for await (const chunk of body) {
	        if (socket[kError]) {
	          throw socket[kError]
	        }

	        const res = h2stream.write(chunk);
	        request.onBodySent(chunk);
	        if (!res) {
	          await waitForDrain();
	        }
	      }
	    } catch (err) {
	      h2stream.destroy(err);
	    } finally {
	      request.onRequestSent();
	      h2stream.end();
	      h2stream
	        .off('close', onDrain)
	        .off('drain', onDrain);
	    }

	    return
	  }

	  socket
	    .on('close', onDrain)
	    .on('drain', onDrain);

	  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
	  try {
	    // It's up to the user to somehow abort the async iterable.
	    for await (const chunk of body) {
	      if (socket[kError]) {
	        throw socket[kError]
	      }

	      if (!writer.write(chunk)) {
	        await waitForDrain();
	      }
	    }

	    writer.end();
	  } catch (err) {
	    writer.destroy(err);
	  } finally {
	    socket
	      .off('close', onDrain)
	      .off('drain', onDrain);
	  }
	}

	class AsyncWriter {
	  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {
	    this.socket = socket;
	    this.request = request;
	    this.contentLength = contentLength;
	    this.client = client;
	    this.bytesWritten = 0;
	    this.expectsPayload = expectsPayload;
	    this.header = header;

	    socket[kWriting] = true;
	  }

	  write (chunk) {
	    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;

	    if (socket[kError]) {
	      throw socket[kError]
	    }

	    if (socket.destroyed) {
	      return false
	    }

	    const len = Buffer.byteLength(chunk);
	    if (!len) {
	      return true
	    }

	    // We should defer writing chunks.
	    if (contentLength !== null && bytesWritten + len > contentLength) {
	      if (client[kStrictContentLength]) {
	        throw new RequestContentLengthMismatchError()
	      }

	      process.emitWarning(new RequestContentLengthMismatchError());
	    }

	    socket.cork();

	    if (bytesWritten === 0) {
	      if (!expectsPayload) {
	        socket[kReset] = true;
	      }

	      if (contentLength === null) {
	        socket.write(`${header}transfer-encoding: chunked\r\n`, 'latin1');
	      } else {
	        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'latin1');
	      }
	    }

	    if (contentLength === null) {
	      socket.write(`\r\n${len.toString(16)}\r\n`, 'latin1');
	    }

	    this.bytesWritten += len;

	    const ret = socket.write(chunk);

	    socket.uncork();

	    request.onBodySent(chunk);

	    if (!ret) {
	      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
	        // istanbul ignore else: only for jest
	        if (socket[kParser].timeout.refresh) {
	          socket[kParser].timeout.refresh();
	        }
	      }
	    }

	    return ret
	  }

	  end () {
	    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
	    request.onRequestSent();

	    socket[kWriting] = false;

	    if (socket[kError]) {
	      throw socket[kError]
	    }

	    if (socket.destroyed) {
	      return
	    }

	    if (bytesWritten === 0) {
	      if (expectsPayload) {
	        // https://tools.ietf.org/html/rfc7230#section-3.3.2
	        // A user agent SHOULD send a Content-Length in a request message when
	        // no Transfer-Encoding is sent and the request method defines a meaning
	        // for an enclosed payload body.

	        socket.write(`${header}content-length: 0\r\n\r\n`, 'latin1');
	      } else {
	        socket.write(`${header}\r\n`, 'latin1');
	      }
	    } else if (contentLength === null) {
	      socket.write('\r\n0\r\n\r\n', 'latin1');
	    }

	    if (contentLength !== null && bytesWritten !== contentLength) {
	      if (client[kStrictContentLength]) {
	        throw new RequestContentLengthMismatchError()
	      } else {
	        process.emitWarning(new RequestContentLengthMismatchError());
	      }
	    }

	    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
	      // istanbul ignore else: only for jest
	      if (socket[kParser].timeout.refresh) {
	        socket[kParser].timeout.refresh();
	      }
	    }

	    resume(client);
	  }

	  destroy (err) {
	    const { socket, client } = this;

	    socket[kWriting] = false;

	    if (err) {
	      assert(client[kRunning] <= 1, 'pipeline should only contain this request');
	      util.destroy(socket, err);
	    }
	  }
	}

	function errorRequest (client, request, err) {
	  try {
	    request.onError(err);
	    assert(request.aborted);
	  } catch (err) {
	    client.emit('error', err);
	  }
	}

	client$1 = Client;
	return client$1;
}

/* eslint-disable */

var fixedQueue;
var hasRequiredFixedQueue;

function requireFixedQueue () {
	if (hasRequiredFixedQueue) return fixedQueue;
	hasRequiredFixedQueue = 1;

	// Extracted from node/lib/internal/fixed_queue.js

	// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
	const kSize = 2048;
	const kMask = kSize - 1;

	// The FixedQueue is implemented as a singly-linked list of fixed-size
	// circular buffers. It looks something like this:
	//
	//  head                                                       tail
	//    |                                                          |
	//    v                                                          v
	// +-----------+ <-----\       +-----------+ <------\         +-----------+
	// |  [null]   |        \----- |   next    |         \------- |   next    |
	// +-----------+               +-----------+                  +-----------+
	// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |                  |  [empty]  |
	// |   item    |               |   item    |       bottom --> |   item    |
	// |   item    |               |   item    |                  |   item    |
	// |    ...    |               |    ...    |                  |    ...    |
	// |   item    |               |   item    |                  |   item    |
	// |   item    |               |   item    |                  |   item    |
	// |  [empty]  | <-- top       |   item    |                  |   item    |
	// |  [empty]  |               |   item    |                  |   item    |
	// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
	// +-----------+               +-----------+                  +-----------+
	//
	// Or, if there is only one circular buffer, it looks something
	// like either of these:
	//
	//  head   tail                                 head   tail
	//    |     |                                     |     |
	//    v     v                                     v     v
	// +-----------+                               +-----------+
	// |  [null]   |                               |  [null]   |
	// +-----------+                               +-----------+
	// |  [empty]  |                               |   item    |
	// |  [empty]  |                               |   item    |
	// |   item    | <-- bottom            top --> |  [empty]  |
	// |   item    |                               |  [empty]  |
	// |  [empty]  | <-- top            bottom --> |   item    |
	// |  [empty]  |                               |   item    |
	// +-----------+                               +-----------+
	//
	// Adding a value means moving `top` forward by one, removing means
	// moving `bottom` forward by one. After reaching the end, the queue
	// wraps around.
	//
	// When `top === bottom` the current queue is empty and when
	// `top + 1 === bottom` it's full. This wastes a single space of storage
	// but allows much quicker checks.

	class FixedCircularBuffer {
	  constructor() {
	    this.bottom = 0;
	    this.top = 0;
	    this.list = new Array(kSize);
	    this.next = null;
	  }

	  isEmpty() {
	    return this.top === this.bottom;
	  }

	  isFull() {
	    return ((this.top + 1) & kMask) === this.bottom;
	  }

	  push(data) {
	    this.list[this.top] = data;
	    this.top = (this.top + 1) & kMask;
	  }

	  shift() {
	    const nextItem = this.list[this.bottom];
	    if (nextItem === undefined)
	      return null;
	    this.list[this.bottom] = undefined;
	    this.bottom = (this.bottom + 1) & kMask;
	    return nextItem;
	  }
	}

	fixedQueue = class FixedQueue {
	  constructor() {
	    this.head = this.tail = new FixedCircularBuffer();
	  }

	  isEmpty() {
	    return this.head.isEmpty();
	  }

	  push(data) {
	    if (this.head.isFull()) {
	      // Head is full: Creates a new queue, sets the old queue's `.next` to it,
	      // and sets it as the new main queue.
	      this.head = this.head.next = new FixedCircularBuffer();
	    }
	    this.head.push(data);
	  }

	  shift() {
	    const tail = this.tail;
	    const next = tail.shift();
	    if (tail.isEmpty() && tail.next !== null) {
	      // If there is another queue, it forms the new tail.
	      this.tail = tail.next;
	    }
	    return next;
	  }
	};
	return fixedQueue;
}

var poolStats;
var hasRequiredPoolStats;

function requirePoolStats () {
	if (hasRequiredPoolStats) return poolStats;
	hasRequiredPoolStats = 1;
	const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = requireSymbols$4();
	const kPool = Symbol('pool');

	class PoolStats {
	  constructor (pool) {
	    this[kPool] = pool;
	  }

	  get connected () {
	    return this[kPool][kConnected]
	  }

	  get free () {
	    return this[kPool][kFree]
	  }

	  get pending () {
	    return this[kPool][kPending]
	  }

	  get queued () {
	    return this[kPool][kQueued]
	  }

	  get running () {
	    return this[kPool][kRunning]
	  }

	  get size () {
	    return this[kPool][kSize]
	  }
	}

	poolStats = PoolStats;
	return poolStats;
}

var poolBase;
var hasRequiredPoolBase;

function requirePoolBase () {
	if (hasRequiredPoolBase) return poolBase;
	hasRequiredPoolBase = 1;

	const DispatcherBase = requireDispatcherBase();
	const FixedQueue = requireFixedQueue();
	const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = requireSymbols$4();
	const PoolStats = requirePoolStats();

	const kClients = Symbol('clients');
	const kNeedDrain = Symbol('needDrain');
	const kQueue = Symbol('queue');
	const kClosedResolve = Symbol('closed resolve');
	const kOnDrain = Symbol('onDrain');
	const kOnConnect = Symbol('onConnect');
	const kOnDisconnect = Symbol('onDisconnect');
	const kOnConnectionError = Symbol('onConnectionError');
	const kGetDispatcher = Symbol('get dispatcher');
	const kAddClient = Symbol('add client');
	const kRemoveClient = Symbol('remove client');
	const kStats = Symbol('stats');

	class PoolBase extends DispatcherBase {
	  constructor () {
	    super();

	    this[kQueue] = new FixedQueue();
	    this[kClients] = [];
	    this[kQueued] = 0;

	    const pool = this;

	    this[kOnDrain] = function onDrain (origin, targets) {
	      const queue = pool[kQueue];

	      let needDrain = false;

	      while (!needDrain) {
	        const item = queue.shift();
	        if (!item) {
	          break
	        }
	        pool[kQueued]--;
	        needDrain = !this.dispatch(item.opts, item.handler);
	      }

	      this[kNeedDrain] = needDrain;

	      if (!this[kNeedDrain] && pool[kNeedDrain]) {
	        pool[kNeedDrain] = false;
	        pool.emit('drain', origin, [pool, ...targets]);
	      }

	      if (pool[kClosedResolve] && queue.isEmpty()) {
	        Promise
	          .all(pool[kClients].map(c => c.close()))
	          .then(pool[kClosedResolve]);
	      }
	    };

	    this[kOnConnect] = (origin, targets) => {
	      pool.emit('connect', origin, [pool, ...targets]);
	    };

	    this[kOnDisconnect] = (origin, targets, err) => {
	      pool.emit('disconnect', origin, [pool, ...targets], err);
	    };

	    this[kOnConnectionError] = (origin, targets, err) => {
	      pool.emit('connectionError', origin, [pool, ...targets], err);
	    };

	    this[kStats] = new PoolStats(this);
	  }

	  get [kBusy] () {
	    return this[kNeedDrain]
	  }

	  get [kConnected] () {
	    return this[kClients].filter(client => client[kConnected]).length
	  }

	  get [kFree] () {
	    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length
	  }

	  get [kPending] () {
	    let ret = this[kQueued];
	    for (const { [kPending]: pending } of this[kClients]) {
	      ret += pending;
	    }
	    return ret
	  }

	  get [kRunning] () {
	    let ret = 0;
	    for (const { [kRunning]: running } of this[kClients]) {
	      ret += running;
	    }
	    return ret
	  }

	  get [kSize] () {
	    let ret = this[kQueued];
	    for (const { [kSize]: size } of this[kClients]) {
	      ret += size;
	    }
	    return ret
	  }

	  get stats () {
	    return this[kStats]
	  }

	  async [kClose] () {
	    if (this[kQueue].isEmpty()) {
	      return Promise.all(this[kClients].map(c => c.close()))
	    } else {
	      return new Promise((resolve) => {
	        this[kClosedResolve] = resolve;
	      })
	    }
	  }

	  async [kDestroy] (err) {
	    while (true) {
	      const item = this[kQueue].shift();
	      if (!item) {
	        break
	      }
	      item.handler.onError(err);
	    }

	    return Promise.all(this[kClients].map(c => c.destroy(err)))
	  }

	  [kDispatch] (opts, handler) {
	    const dispatcher = this[kGetDispatcher]();

	    if (!dispatcher) {
	      this[kNeedDrain] = true;
	      this[kQueue].push({ opts, handler });
	      this[kQueued]++;
	    } else if (!dispatcher.dispatch(opts, handler)) {
	      dispatcher[kNeedDrain] = true;
	      this[kNeedDrain] = !this[kGetDispatcher]();
	    }

	    return !this[kNeedDrain]
	  }

	  [kAddClient] (client) {
	    client
	      .on('drain', this[kOnDrain])
	      .on('connect', this[kOnConnect])
	      .on('disconnect', this[kOnDisconnect])
	      .on('connectionError', this[kOnConnectionError]);

	    this[kClients].push(client);

	    if (this[kNeedDrain]) {
	      process.nextTick(() => {
	        if (this[kNeedDrain]) {
	          this[kOnDrain](client[kUrl], [this, client]);
	        }
	      });
	    }

	    return this
	  }

	  [kRemoveClient] (client) {
	    client.close(() => {
	      const idx = this[kClients].indexOf(client);
	      if (idx !== -1) {
	        this[kClients].splice(idx, 1);
	      }
	    });

	    this[kNeedDrain] = this[kClients].some(dispatcher => (
	      !dispatcher[kNeedDrain] &&
	      dispatcher.closed !== true &&
	      dispatcher.destroyed !== true
	    ));
	  }
	}

	poolBase = {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kRemoveClient,
	  kGetDispatcher
	};
	return poolBase;
}

var pool;
var hasRequiredPool$1;

function requirePool$1 () {
	if (hasRequiredPool$1) return pool;
	hasRequiredPool$1 = 1;

	const {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kGetDispatcher
	} = requirePoolBase();
	const Client = requireClient$1();
	const {
	  InvalidArgumentError
	} = requireErrors();
	const util = requireUtil$8();
	const { kUrl, kInterceptors } = requireSymbols$4();
	const buildConnector = requireConnect();

	const kOptions = Symbol('options');
	const kConnections = Symbol('connections');
	const kFactory = Symbol('factory');

	function defaultFactory (origin, opts) {
	  return new Client(origin, opts)
	}

	class Pool extends PoolBase {
	  constructor (origin, {
	    connections,
	    factory = defaultFactory,
	    connect,
	    connectTimeout,
	    tls,
	    maxCachedSessions,
	    socketPath,
	    autoSelectFamily,
	    autoSelectFamilyAttemptTimeout,
	    allowH2,
	    ...options
	  } = {}) {
	    super();

	    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
	      throw new InvalidArgumentError('invalid connections')
	    }

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (typeof connect !== 'function') {
	      connect = buildConnector({
	        ...tls,
	        maxCachedSessions,
	        allowH2,
	        socketPath,
	        timeout: connectTimeout,
	        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),
	        ...connect
	      });
	    }

	    this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool)
	      ? options.interceptors.Pool
	      : [];
	    this[kConnections] = connections || null;
	    this[kUrl] = util.parseOrigin(origin);
	    this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
	    this[kOptions].interceptors = options.interceptors
	      ? { ...options.interceptors }
	      : undefined;
	    this[kFactory] = factory;
	  }

	  [kGetDispatcher] () {
	    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain]);

	    if (dispatcher) {
	      return dispatcher
	    }

	    if (!this[kConnections] || this[kClients].length < this[kConnections]) {
	      dispatcher = this[kFactory](this[kUrl], this[kOptions]);
	      this[kAddClient](dispatcher);
	    }

	    return dispatcher
	  }
	}

	pool = Pool;
	return pool;
}

var balancedPool;
var hasRequiredBalancedPool;

function requireBalancedPool () {
	if (hasRequiredBalancedPool) return balancedPool;
	hasRequiredBalancedPool = 1;

	const {
	  BalancedPoolMissingUpstreamError,
	  InvalidArgumentError
	} = requireErrors();
	const {
	  PoolBase,
	  kClients,
	  kNeedDrain,
	  kAddClient,
	  kRemoveClient,
	  kGetDispatcher
	} = requirePoolBase();
	const Pool = requirePool$1();
	const { kUrl, kInterceptors } = requireSymbols$4();
	const { parseOrigin } = requireUtil$8();
	const kFactory = Symbol('factory');

	const kOptions = Symbol('options');
	const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor');
	const kCurrentWeight = Symbol('kCurrentWeight');
	const kIndex = Symbol('kIndex');
	const kWeight = Symbol('kWeight');
	const kMaxWeightPerServer = Symbol('kMaxWeightPerServer');
	const kErrorPenalty = Symbol('kErrorPenalty');

	function getGreatestCommonDivisor (a, b) {
	  if (b === 0) return a
	  return getGreatestCommonDivisor(b, a % b)
	}

	function defaultFactory (origin, opts) {
	  return new Pool(origin, opts)
	}

	class BalancedPool extends PoolBase {
	  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {
	    super();

	    this[kOptions] = opts;
	    this[kIndex] = -1;
	    this[kCurrentWeight] = 0;

	    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
	    this[kErrorPenalty] = this[kOptions].errorPenalty || 15;

	    if (!Array.isArray(upstreams)) {
	      upstreams = [upstreams];
	    }

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)
	      ? opts.interceptors.BalancedPool
	      : [];
	    this[kFactory] = factory;

	    for (const upstream of upstreams) {
	      this.addUpstream(upstream);
	    }
	    this._updateBalancedPoolStats();
	  }

	  addUpstream (upstream) {
	    const upstreamOrigin = parseOrigin(upstream).origin;

	    if (this[kClients].find((pool) => (
	      pool[kUrl].origin === upstreamOrigin &&
	      pool.closed !== true &&
	      pool.destroyed !== true
	    ))) {
	      return this
	    }
	    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));

	    this[kAddClient](pool);
	    pool.on('connect', () => {
	      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
	    });

	    pool.on('connectionError', () => {
	      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
	      this._updateBalancedPoolStats();
	    });

	    pool.on('disconnect', (...args) => {
	      const err = args[2];
	      if (err && err.code === 'UND_ERR_SOCKET') {
	        // decrease the weight of the pool.
	        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
	        this._updateBalancedPoolStats();
	      }
	    });

	    for (const client of this[kClients]) {
	      client[kWeight] = this[kMaxWeightPerServer];
	    }

	    this._updateBalancedPoolStats();

	    return this
	  }

	  _updateBalancedPoolStats () {
	    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
	  }

	  removeUpstream (upstream) {
	    const upstreamOrigin = parseOrigin(upstream).origin;

	    const pool = this[kClients].find((pool) => (
	      pool[kUrl].origin === upstreamOrigin &&
	      pool.closed !== true &&
	      pool.destroyed !== true
	    ));

	    if (pool) {
	      this[kRemoveClient](pool);
	    }

	    return this
	  }

	  get upstreams () {
	    return this[kClients]
	      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)
	      .map((p) => p[kUrl].origin)
	  }

	  [kGetDispatcher] () {
	    // We validate that pools is greater than 0,
	    // otherwise we would have to wait until an upstream
	    // is added, which might never happen.
	    if (this[kClients].length === 0) {
	      throw new BalancedPoolMissingUpstreamError()
	    }

	    const dispatcher = this[kClients].find(dispatcher => (
	      !dispatcher[kNeedDrain] &&
	      dispatcher.closed !== true &&
	      dispatcher.destroyed !== true
	    ));

	    if (!dispatcher) {
	      return
	    }

	    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true);

	    if (allClientsBusy) {
	      return
	    }

	    let counter = 0;

	    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain]);

	    while (counter++ < this[kClients].length) {
	      this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
	      const pool = this[kClients][this[kIndex]];

	      // find pool index with the largest weight
	      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
	        maxWeightIndex = this[kIndex];
	      }

	      // decrease the current weight every `this[kClients].length`.
	      if (this[kIndex] === 0) {
	        // Set the current weight to the next lower weight.
	        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];

	        if (this[kCurrentWeight] <= 0) {
	          this[kCurrentWeight] = this[kMaxWeightPerServer];
	        }
	      }
	      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {
	        return pool
	      }
	    }

	    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
	    this[kIndex] = maxWeightIndex;
	    return this[kClients][maxWeightIndex]
	  }
	}

	balancedPool = BalancedPool;
	return balancedPool;
}

var dispatcherWeakref;
var hasRequiredDispatcherWeakref;

function requireDispatcherWeakref () {
	if (hasRequiredDispatcherWeakref) return dispatcherWeakref;
	hasRequiredDispatcherWeakref = 1;

	/* istanbul ignore file: only for Node 12 */

	const { kConnected, kSize } = requireSymbols$4();

	class CompatWeakRef {
	  constructor (value) {
	    this.value = value;
	  }

	  deref () {
	    return this.value[kConnected] === 0 && this.value[kSize] === 0
	      ? undefined
	      : this.value
	  }
	}

	class CompatFinalizer {
	  constructor (finalizer) {
	    this.finalizer = finalizer;
	  }

	  register (dispatcher, key) {
	    if (dispatcher.on) {
	      dispatcher.on('disconnect', () => {
	        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
	          this.finalizer(key);
	        }
	      });
	    }
	  }
	}

	dispatcherWeakref = function () {
	  // FIXME: remove workaround when the Node bug is fixed
	  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308
	  if (process.env.NODE_V8_COVERAGE) {
	    return {
	      WeakRef: CompatWeakRef,
	      FinalizationRegistry: CompatFinalizer
	    }
	  }
	  return {
	    WeakRef: commonjsGlobal.WeakRef || CompatWeakRef,
	    FinalizationRegistry: commonjsGlobal.FinalizationRegistry || CompatFinalizer
	  }
	};
	return dispatcherWeakref;
}

var agent;
var hasRequiredAgent;

function requireAgent () {
	if (hasRequiredAgent) return agent;
	hasRequiredAgent = 1;

	const { InvalidArgumentError } = requireErrors();
	const { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = requireSymbols$4();
	const DispatcherBase = requireDispatcherBase();
	const Pool = requirePool$1();
	const Client = requireClient$1();
	const util = requireUtil$8();
	const createRedirectInterceptor = requireRedirectInterceptor();
	const { WeakRef, FinalizationRegistry } = requireDispatcherWeakref()();

	const kOnConnect = Symbol('onConnect');
	const kOnDisconnect = Symbol('onDisconnect');
	const kOnConnectionError = Symbol('onConnectionError');
	const kMaxRedirections = Symbol('maxRedirections');
	const kOnDrain = Symbol('onDrain');
	const kFactory = Symbol('factory');
	const kFinalizer = Symbol('finalizer');
	const kOptions = Symbol('options');

	function defaultFactory (origin, opts) {
	  return opts && opts.connections === 1
	    ? new Client(origin, opts)
	    : new Pool(origin, opts)
	}

	class Agent extends DispatcherBase {
	  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
	    super();

	    if (typeof factory !== 'function') {
	      throw new InvalidArgumentError('factory must be a function.')
	    }

	    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
	      throw new InvalidArgumentError('connect must be a function or an object')
	    }

	    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
	      throw new InvalidArgumentError('maxRedirections must be a positive number')
	    }

	    if (connect && typeof connect !== 'function') {
	      connect = { ...connect };
	    }

	    this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent)
	      ? options.interceptors.Agent
	      : [createRedirectInterceptor({ maxRedirections })];

	    this[kOptions] = { ...util.deepClone(options), connect };
	    this[kOptions].interceptors = options.interceptors
	      ? { ...options.interceptors }
	      : undefined;
	    this[kMaxRedirections] = maxRedirections;
	    this[kFactory] = factory;
	    this[kClients] = new Map();
	    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {
	      const ref = this[kClients].get(key);
	      if (ref !== undefined && ref.deref() === undefined) {
	        this[kClients].delete(key);
	      }
	    });

	    const agent = this;

	    this[kOnDrain] = (origin, targets) => {
	      agent.emit('drain', origin, [agent, ...targets]);
	    };

	    this[kOnConnect] = (origin, targets) => {
	      agent.emit('connect', origin, [agent, ...targets]);
	    };

	    this[kOnDisconnect] = (origin, targets, err) => {
	      agent.emit('disconnect', origin, [agent, ...targets], err);
	    };

	    this[kOnConnectionError] = (origin, targets, err) => {
	      agent.emit('connectionError', origin, [agent, ...targets], err);
	    };
	  }

	  get [kRunning] () {
	    let ret = 0;
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore next: gc is undeterministic */
	      if (client) {
	        ret += client[kRunning];
	      }
	    }
	    return ret
	  }

	  [kDispatch] (opts, handler) {
	    let key;
	    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
	      key = String(opts.origin);
	    } else {
	      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')
	    }

	    const ref = this[kClients].get(key);

	    let dispatcher = ref ? ref.deref() : null;
	    if (!dispatcher) {
	      dispatcher = this[kFactory](opts.origin, this[kOptions])
	        .on('drain', this[kOnDrain])
	        .on('connect', this[kOnConnect])
	        .on('disconnect', this[kOnDisconnect])
	        .on('connectionError', this[kOnConnectionError]);

	      this[kClients].set(key, new WeakRef(dispatcher));
	      this[kFinalizer].register(dispatcher, key);
	    }

	    return dispatcher.dispatch(opts, handler)
	  }

	  async [kClose] () {
	    const closePromises = [];
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore else: gc is undeterministic */
	      if (client) {
	        closePromises.push(client.close());
	      }
	    }

	    await Promise.all(closePromises);
	  }

	  async [kDestroy] (err) {
	    const destroyPromises = [];
	    for (const ref of this[kClients].values()) {
	      const client = ref.deref();
	      /* istanbul ignore else: gc is undeterministic */
	      if (client) {
	        destroyPromises.push(client.destroy(err));
	      }
	    }

	    await Promise.all(destroyPromises);
	  }
	}

	agent = Agent;
	return agent;
}

var api = {};

var apiRequest = {exports: {}};

var readable;
var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable;
	hasRequiredReadable = 1;

	const assert = require$$0$8;
	const { Readable } = require$$0$9;
	const { RequestAbortedError, NotSupportedError, InvalidArgumentError } = requireErrors();
	const util = requireUtil$8();
	const { ReadableStreamFrom, toUSVString } = requireUtil$8();

	let Blob;

	const kConsume = Symbol('kConsume');
	const kReading = Symbol('kReading');
	const kBody = Symbol('kBody');
	const kAbort = Symbol('abort');
	const kContentType = Symbol('kContentType');

	const noop = () => {};

	readable = class BodyReadable extends Readable {
	  constructor ({
	    resume,
	    abort,
	    contentType = '',
	    highWaterMark = 64 * 1024 // Same as nodejs fs streams.
	  }) {
	    super({
	      autoDestroy: true,
	      read: resume,
	      highWaterMark
	    });

	    this._readableState.dataEmitted = false;

	    this[kAbort] = abort;
	    this[kConsume] = null;
	    this[kBody] = null;
	    this[kContentType] = contentType;

	    // Is stream being consumed through Readable API?
	    // This is an optimization so that we avoid checking
	    // for 'data' and 'readable' listeners in the hot path
	    // inside push().
	    this[kReading] = false;
	  }

	  destroy (err) {
	    if (this.destroyed) {
	      // Node < 16
	      return this
	    }

	    if (!err && !this._readableState.endEmitted) {
	      err = new RequestAbortedError();
	    }

	    if (err) {
	      this[kAbort]();
	    }

	    return super.destroy(err)
	  }

	  emit (ev, ...args) {
	    if (ev === 'data') {
	      // Node < 16.7
	      this._readableState.dataEmitted = true;
	    } else if (ev === 'error') {
	      // Node < 16
	      this._readableState.errorEmitted = true;
	    }
	    return super.emit(ev, ...args)
	  }

	  on (ev, ...args) {
	    if (ev === 'data' || ev === 'readable') {
	      this[kReading] = true;
	    }
	    return super.on(ev, ...args)
	  }

	  addListener (ev, ...args) {
	    return this.on(ev, ...args)
	  }

	  off (ev, ...args) {
	    const ret = super.off(ev, ...args);
	    if (ev === 'data' || ev === 'readable') {
	      this[kReading] = (
	        this.listenerCount('data') > 0 ||
	        this.listenerCount('readable') > 0
	      );
	    }
	    return ret
	  }

	  removeListener (ev, ...args) {
	    return this.off(ev, ...args)
	  }

	  push (chunk) {
	    if (this[kConsume] && chunk !== null && this.readableLength === 0) {
	      consumePush(this[kConsume], chunk);
	      return this[kReading] ? super.push(chunk) : true
	    }
	    return super.push(chunk)
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-text
	  async text () {
	    return consume(this, 'text')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-json
	  async json () {
	    return consume(this, 'json')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-blob
	  async blob () {
	    return consume(this, 'blob')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
	  async arrayBuffer () {
	    return consume(this, 'arrayBuffer')
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-formdata
	  async formData () {
	    // TODO: Implement.
	    throw new NotSupportedError()
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-bodyused
	  get bodyUsed () {
	    return util.isDisturbed(this)
	  }

	  // https://fetch.spec.whatwg.org/#dom-body-body
	  get body () {
	    if (!this[kBody]) {
	      this[kBody] = ReadableStreamFrom(this);
	      if (this[kConsume]) {
	        // TODO: Is this the best way to force a lock?
	        this[kBody].getReader(); // Ensure stream is locked.
	        assert(this[kBody].locked);
	      }
	    }
	    return this[kBody]
	  }

	  dump (opts) {
	    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
	    const signal = opts && opts.signal;

	    if (signal) {
	      try {
	        if (typeof signal !== 'object' || !('aborted' in signal)) {
	          throw new InvalidArgumentError('signal must be an AbortSignal')
	        }
	        util.throwIfAborted(signal);
	      } catch (err) {
	        return Promise.reject(err)
	      }
	    }

	    if (this.closed) {
	      return Promise.resolve(null)
	    }

	    return new Promise((resolve, reject) => {
	      const signalListenerCleanup = signal
	        ? util.addAbortListener(signal, () => {
	          this.destroy();
	        })
	        : noop;

	      this
	        .on('close', function () {
	          signalListenerCleanup();
	          if (signal && signal.aborted) {
	            reject(signal.reason || Object.assign(new Error('The operation was aborted'), { name: 'AbortError' }));
	          } else {
	            resolve(null);
	          }
	        })
	        .on('error', noop)
	        .on('data', function (chunk) {
	          limit -= chunk.length;
	          if (limit <= 0) {
	            this.destroy();
	          }
	        })
	        .resume();
	    })
	  }
	};

	// https://streams.spec.whatwg.org/#readablestream-locked
	function isLocked (self) {
	  // Consume is an implicit lock.
	  return (self[kBody] && self[kBody].locked === true) || self[kConsume]
	}

	// https://fetch.spec.whatwg.org/#body-unusable
	function isUnusable (self) {
	  return util.isDisturbed(self) || isLocked(self)
	}

	async function consume (stream, type) {
	  if (isUnusable(stream)) {
	    throw new TypeError('unusable')
	  }

	  assert(!stream[kConsume]);

	  return new Promise((resolve, reject) => {
	    stream[kConsume] = {
	      type,
	      stream,
	      resolve,
	      reject,
	      length: 0,
	      body: []
	    };

	    stream
	      .on('error', function (err) {
	        consumeFinish(this[kConsume], err);
	      })
	      .on('close', function () {
	        if (this[kConsume].body !== null) {
	          consumeFinish(this[kConsume], new RequestAbortedError());
	        }
	      });

	    process.nextTick(consumeStart, stream[kConsume]);
	  })
	}

	function consumeStart (consume) {
	  if (consume.body === null) {
	    return
	  }

	  const { _readableState: state } = consume.stream;

	  for (const chunk of state.buffer) {
	    consumePush(consume, chunk);
	  }

	  if (state.endEmitted) {
	    consumeEnd(this[kConsume]);
	  } else {
	    consume.stream.on('end', function () {
	      consumeEnd(this[kConsume]);
	    });
	  }

	  consume.stream.resume();

	  while (consume.stream.read() != null) {
	    // Loop
	  }
	}

	function consumeEnd (consume) {
	  const { type, body, resolve, stream, length } = consume;

	  try {
	    if (type === 'text') {
	      resolve(toUSVString(Buffer.concat(body)));
	    } else if (type === 'json') {
	      resolve(JSON.parse(Buffer.concat(body)));
	    } else if (type === 'arrayBuffer') {
	      const dst = new Uint8Array(length);

	      let pos = 0;
	      for (const buf of body) {
	        dst.set(buf, pos);
	        pos += buf.byteLength;
	      }

	      resolve(dst.buffer);
	    } else if (type === 'blob') {
	      if (!Blob) {
	        Blob = require('buffer').Blob;
	      }
	      resolve(new Blob(body, { type: stream[kContentType] }));
	    }

	    consumeFinish(consume);
	  } catch (err) {
	    stream.destroy(err);
	  }
	}

	function consumePush (consume, chunk) {
	  consume.length += chunk.length;
	  consume.body.push(chunk);
	}

	function consumeFinish (consume, err) {
	  if (consume.body === null) {
	    return
	  }

	  if (err) {
	    consume.reject(err);
	  } else {
	    consume.resolve();
	  }

	  consume.type = null;
	  consume.stream = null;
	  consume.resolve = null;
	  consume.reject = null;
	  consume.length = 0;
	  consume.body = null;
	}
	return readable;
}

var util$6;
var hasRequiredUtil$6;

function requireUtil$6 () {
	if (hasRequiredUtil$6) return util$6;
	hasRequiredUtil$6 = 1;
	const assert = require$$0$8;
	const {
	  ResponseStatusCodeError
	} = requireErrors();
	const { toUSVString } = requireUtil$8();

	async function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {
	  assert(body);

	  let chunks = [];
	  let limit = 0;

	  for await (const chunk of body) {
	    chunks.push(chunk);
	    limit += chunk.length;
	    if (limit > 128 * 1024) {
	      chunks = null;
	      break
	    }
	  }

	  if (statusCode === 204 || !contentType || !chunks) {
	    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
	    return
	  }

	  try {
	    if (contentType.startsWith('application/json')) {
	      const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
	      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
	      return
	    }

	    if (contentType.startsWith('text/')) {
	      const payload = toUSVString(Buffer.concat(chunks));
	      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload));
	      return
	    }
	  } catch (err) {
	    // Process in a fallback if error
	  }

	  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers));
	}

	util$6 = { getResolveErrorBodyCallback };
	return util$6;
}

var abortSignal;
var hasRequiredAbortSignal;

function requireAbortSignal () {
	if (hasRequiredAbortSignal) return abortSignal;
	hasRequiredAbortSignal = 1;
	const { addAbortListener } = requireUtil$8();
	const { RequestAbortedError } = requireErrors();

	const kListener = Symbol('kListener');
	const kSignal = Symbol('kSignal');

	function abort (self) {
	  if (self.abort) {
	    self.abort();
	  } else {
	    self.onError(new RequestAbortedError());
	  }
	}

	function addSignal (self, signal) {
	  self[kSignal] = null;
	  self[kListener] = null;

	  if (!signal) {
	    return
	  }

	  if (signal.aborted) {
	    abort(self);
	    return
	  }

	  self[kSignal] = signal;
	  self[kListener] = () => {
	    abort(self);
	  };

	  addAbortListener(self[kSignal], self[kListener]);
	}

	function removeSignal (self) {
	  if (!self[kSignal]) {
	    return
	  }

	  if ('removeEventListener' in self[kSignal]) {
	    self[kSignal].removeEventListener('abort', self[kListener]);
	  } else {
	    self[kSignal].removeListener('abort', self[kListener]);
	  }

	  self[kSignal] = null;
	  self[kListener] = null;
	}

	abortSignal = {
	  addSignal,
	  removeSignal
	};
	return abortSignal;
}

var hasRequiredApiRequest;

function requireApiRequest () {
	if (hasRequiredApiRequest) return apiRequest.exports;
	hasRequiredApiRequest = 1;

	const Readable = requireReadable();
	const {
	  InvalidArgumentError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$8();
	const { getResolveErrorBodyCallback } = requireUtil$6();
	const { AsyncResource } = require$$1$3;
	const { addSignal, removeSignal } = requireAbortSignal();

	class RequestHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;

	    try {
	      if (typeof callback !== 'function') {
	        throw new InvalidArgumentError('invalid callback')
	      }

	      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {
	        throw new InvalidArgumentError('invalid highWaterMark')
	      }

	      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	      }

	      if (method === 'CONNECT') {
	        throw new InvalidArgumentError('invalid method')
	      }

	      if (onInfo && typeof onInfo !== 'function') {
	        throw new InvalidArgumentError('invalid onInfo callback')
	      }

	      super('UNDICI_REQUEST');
	    } catch (err) {
	      if (util.isStream(body)) {
	        util.destroy(body.on('error', util.nop), err);
	      }
	      throw err
	    }

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.callback = callback;
	    this.res = null;
	    this.abort = null;
	    this.body = body;
	    this.trailers = {};
	    this.context = null;
	    this.onInfo = onInfo || null;
	    this.throwOnError = throwOnError;
	    this.highWaterMark = highWaterMark;

	    if (util.isStream(body)) {
	      body.on('error', (err) => {
	        this.onError(err);
	      });
	    }

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;

	    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
	    const contentType = parsedHeaders['content-type'];
	    const body = new Readable({ resume, abort, contentType, highWaterMark });

	    this.callback = null;
	    this.res = body;
	    if (callback !== null) {
	      if (this.throwOnError && statusCode >= 400) {
	        this.runInAsyncScope(getResolveErrorBodyCallback, null,
	          { callback, body, contentType, statusCode, statusMessage, headers }
	        );
	      } else {
	        this.runInAsyncScope(callback, null, null, {
	          statusCode,
	          headers,
	          trailers: this.trailers,
	          opaque,
	          body,
	          context
	        });
	      }
	    }
	  }

	  onData (chunk) {
	    const { res } = this;
	    return res.push(chunk)
	  }

	  onComplete (trailers) {
	    const { res } = this;

	    removeSignal(this);

	    util.parseHeaders(trailers, this.trailers);

	    res.push(null);
	  }

	  onError (err) {
	    const { res, callback, body, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      // TODO: Does this need queueMicrotask?
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }

	    if (res) {
	      this.res = null;
	      // Ensure all queued handlers are invoked before destroying res.
	      queueMicrotask(() => {
	        util.destroy(res, err);
	      });
	    }

	    if (body) {
	      this.body = null;
	      util.destroy(body, err);
	    }
	  }
	}

	function request (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      request.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    this.dispatch(opts, new RequestHandler(opts, callback));
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiRequest.exports = request;
	apiRequest.exports.RequestHandler = RequestHandler;
	return apiRequest.exports;
}

var apiStream;
var hasRequiredApiStream;

function requireApiStream () {
	if (hasRequiredApiStream) return apiStream;
	hasRequiredApiStream = 1;

	const { finished, PassThrough } = require$$0$9;
	const {
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$8();
	const { getResolveErrorBodyCallback } = requireUtil$6();
	const { AsyncResource } = require$$1$3;
	const { addSignal, removeSignal } = requireAbortSignal();

	class StreamHandler extends AsyncResource {
	  constructor (opts, factory, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;

	    try {
	      if (typeof callback !== 'function') {
	        throw new InvalidArgumentError('invalid callback')
	      }

	      if (typeof factory !== 'function') {
	        throw new InvalidArgumentError('invalid factory')
	      }

	      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	      }

	      if (method === 'CONNECT') {
	        throw new InvalidArgumentError('invalid method')
	      }

	      if (onInfo && typeof onInfo !== 'function') {
	        throw new InvalidArgumentError('invalid onInfo callback')
	      }

	      super('UNDICI_STREAM');
	    } catch (err) {
	      if (util.isStream(body)) {
	        util.destroy(body.on('error', util.nop), err);
	      }
	      throw err
	    }

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.factory = factory;
	    this.callback = callback;
	    this.res = null;
	    this.abort = null;
	    this.context = null;
	    this.trailers = null;
	    this.body = body;
	    this.onInfo = onInfo || null;
	    this.throwOnError = throwOnError || false;

	    if (util.isStream(body)) {
	      body.on('error', (err) => {
	        this.onError(err);
	      });
	    }

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const { factory, opaque, context, callback, responseHeaders } = this;

	    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    this.factory = null;

	    let res;

	    if (this.throwOnError && statusCode >= 400) {
	      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers;
	      const contentType = parsedHeaders['content-type'];
	      res = new PassThrough();

	      this.callback = null;
	      this.runInAsyncScope(getResolveErrorBodyCallback, null,
	        { callback, body: res, contentType, statusCode, statusMessage, headers }
	      );
	    } else {
	      if (factory === null) {
	        return
	      }

	      res = this.runInAsyncScope(factory, null, {
	        statusCode,
	        headers,
	        opaque,
	        context
	      });

	      if (
	        !res ||
	        typeof res.write !== 'function' ||
	        typeof res.end !== 'function' ||
	        typeof res.on !== 'function'
	      ) {
	        throw new InvalidReturnValueError('expected Writable')
	      }

	      // TODO: Avoid finished. It registers an unnecessary amount of listeners.
	      finished(res, { readable: false }, (err) => {
	        const { callback, res, opaque, trailers, abort } = this;

	        this.res = null;
	        if (err || !res.readable) {
	          util.destroy(res, err);
	        }

	        this.callback = null;
	        this.runInAsyncScope(callback, null, err || null, { opaque, trailers });

	        if (err) {
	          abort();
	        }
	      });
	    }

	    res.on('drain', resume);

	    this.res = res;

	    const needDrain = res.writableNeedDrain !== undefined
	      ? res.writableNeedDrain
	      : res._writableState && res._writableState.needDrain;

	    return needDrain !== true
	  }

	  onData (chunk) {
	    const { res } = this;

	    return res ? res.write(chunk) : true
	  }

	  onComplete (trailers) {
	    const { res } = this;

	    removeSignal(this);

	    if (!res) {
	      return
	    }

	    this.trailers = util.parseHeaders(trailers);

	    res.end();
	  }

	  onError (err) {
	    const { res, callback, opaque, body } = this;

	    removeSignal(this);

	    this.factory = null;

	    if (res) {
	      this.res = null;
	      util.destroy(res, err);
	    } else if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }

	    if (body) {
	      this.body = null;
	      util.destroy(body, err);
	    }
	  }
	}

	function stream (opts, factory, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      stream.call(this, opts, factory, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    this.dispatch(opts, new StreamHandler(opts, factory, callback));
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiStream = stream;
	return apiStream;
}

var apiPipeline;
var hasRequiredApiPipeline;

function requireApiPipeline () {
	if (hasRequiredApiPipeline) return apiPipeline;
	hasRequiredApiPipeline = 1;

	const {
	  Readable,
	  Duplex,
	  PassThrough
	} = require$$0$9;
	const {
	  InvalidArgumentError,
	  InvalidReturnValueError,
	  RequestAbortedError
	} = requireErrors();
	const util = requireUtil$8();
	const { AsyncResource } = require$$1$3;
	const { addSignal, removeSignal } = requireAbortSignal();
	const assert = require$$0$8;

	const kResume = Symbol('resume');

	class PipelineRequest extends Readable {
	  constructor () {
	    super({ autoDestroy: true });

	    this[kResume] = null;
	  }

	  _read () {
	    const { [kResume]: resume } = this;

	    if (resume) {
	      this[kResume] = null;
	      resume();
	    }
	  }

	  _destroy (err, callback) {
	    this._read();

	    callback(err);
	  }
	}

	class PipelineResponse extends Readable {
	  constructor (resume) {
	    super({ autoDestroy: true });
	    this[kResume] = resume;
	  }

	  _read () {
	    this[kResume]();
	  }

	  _destroy (err, callback) {
	    if (!err && !this._readableState.endEmitted) {
	      err = new RequestAbortedError();
	    }

	    callback(err);
	  }
	}

	class PipelineHandler extends AsyncResource {
	  constructor (opts, handler) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof handler !== 'function') {
	      throw new InvalidArgumentError('invalid handler')
	    }

	    const { signal, method, opaque, onInfo, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    if (method === 'CONNECT') {
	      throw new InvalidArgumentError('invalid method')
	    }

	    if (onInfo && typeof onInfo !== 'function') {
	      throw new InvalidArgumentError('invalid onInfo callback')
	    }

	    super('UNDICI_PIPELINE');

	    this.opaque = opaque || null;
	    this.responseHeaders = responseHeaders || null;
	    this.handler = handler;
	    this.abort = null;
	    this.context = null;
	    this.onInfo = onInfo || null;

	    this.req = new PipelineRequest().on('error', util.nop);

	    this.ret = new Duplex({
	      readableObjectMode: opts.objectMode,
	      autoDestroy: true,
	      read: () => {
	        const { body } = this;

	        if (body && body.resume) {
	          body.resume();
	        }
	      },
	      write: (chunk, encoding, callback) => {
	        const { req } = this;

	        if (req.push(chunk, encoding) || req._readableState.destroyed) {
	          callback();
	        } else {
	          req[kResume] = callback;
	        }
	      },
	      destroy: (err, callback) => {
	        const { body, req, res, ret, abort } = this;

	        if (!err && !ret._readableState.endEmitted) {
	          err = new RequestAbortedError();
	        }

	        if (abort && err) {
	          abort();
	        }

	        util.destroy(body, err);
	        util.destroy(req, err);
	        util.destroy(res, err);

	        removeSignal(this);

	        callback(err);
	      }
	    }).on('prefinish', () => {
	      const { req } = this;

	      // Node < 15 does not call _final in same tick.
	      req.push(null);
	    });

	    this.res = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    const { ret, res } = this;

	    assert(!res, 'pipeline cannot be retried');

	    if (ret.destroyed) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders (statusCode, rawHeaders, resume) {
	    const { opaque, handler, context } = this;

	    if (statusCode < 200) {
	      if (this.onInfo) {
	        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	        this.onInfo({ statusCode, headers });
	      }
	      return
	    }

	    this.res = new PipelineResponse(resume);

	    let body;
	    try {
	      this.handler = null;
	      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	      body = this.runInAsyncScope(handler, null, {
	        statusCode,
	        headers,
	        opaque,
	        body: this.res,
	        context
	      });
	    } catch (err) {
	      this.res.on('error', util.nop);
	      throw err
	    }

	    if (!body || typeof body.on !== 'function') {
	      throw new InvalidReturnValueError('expected Readable')
	    }

	    body
	      .on('data', (chunk) => {
	        const { ret, body } = this;

	        if (!ret.push(chunk) && body.pause) {
	          body.pause();
	        }
	      })
	      .on('error', (err) => {
	        const { ret } = this;

	        util.destroy(ret, err);
	      })
	      .on('end', () => {
	        const { ret } = this;

	        ret.push(null);
	      })
	      .on('close', () => {
	        const { ret } = this;

	        if (!ret._readableState.ended) {
	          util.destroy(ret, new RequestAbortedError());
	        }
	      });

	    this.body = body;
	  }

	  onData (chunk) {
	    const { res } = this;
	    return res.push(chunk)
	  }

	  onComplete (trailers) {
	    const { res } = this;
	    res.push(null);
	  }

	  onError (err) {
	    const { ret } = this;
	    this.handler = null;
	    util.destroy(ret, err);
	  }
	}

	function pipeline (opts, handler) {
	  try {
	    const pipelineHandler = new PipelineHandler(opts, handler);
	    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
	    return pipelineHandler.ret
	  } catch (err) {
	    return new PassThrough().destroy(err)
	  }
	}

	apiPipeline = pipeline;
	return apiPipeline;
}

var apiUpgrade;
var hasRequiredApiUpgrade;

function requireApiUpgrade () {
	if (hasRequiredApiUpgrade) return apiUpgrade;
	hasRequiredApiUpgrade = 1;

	const { InvalidArgumentError, RequestAbortedError, SocketError } = requireErrors();
	const { AsyncResource } = require$$1$3;
	const util = requireUtil$8();
	const { addSignal, removeSignal } = requireAbortSignal();
	const assert = require$$0$8;

	class UpgradeHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    const { signal, opaque, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    super('UNDICI_UPGRADE');

	    this.responseHeaders = responseHeaders || null;
	    this.opaque = opaque || null;
	    this.callback = callback;
	    this.abort = null;
	    this.context = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = null;
	  }

	  onHeaders () {
	    throw new SocketError('bad upgrade', null)
	  }

	  onUpgrade (statusCode, rawHeaders, socket) {
	    const { callback, opaque, context } = this;

	    assert.strictEqual(statusCode, 101);

	    removeSignal(this);

	    this.callback = null;
	    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	    this.runInAsyncScope(callback, null, null, {
	      headers,
	      socket,
	      opaque,
	      context
	    });
	  }

	  onError (err) {
	    const { callback, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }
	  }
	}

	function upgrade (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      upgrade.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    const upgradeHandler = new UpgradeHandler(opts, callback);
	    this.dispatch({
	      ...opts,
	      method: opts.method || 'GET',
	      upgrade: opts.protocol || 'Websocket'
	    }, upgradeHandler);
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiUpgrade = upgrade;
	return apiUpgrade;
}

var apiConnect;
var hasRequiredApiConnect;

function requireApiConnect () {
	if (hasRequiredApiConnect) return apiConnect;
	hasRequiredApiConnect = 1;

	const { AsyncResource } = require$$1$3;
	const { InvalidArgumentError, RequestAbortedError, SocketError } = requireErrors();
	const util = requireUtil$8();
	const { addSignal, removeSignal } = requireAbortSignal();

	class ConnectHandler extends AsyncResource {
	  constructor (opts, callback) {
	    if (!opts || typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (typeof callback !== 'function') {
	      throw new InvalidArgumentError('invalid callback')
	    }

	    const { signal, opaque, responseHeaders } = opts;

	    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
	      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
	    }

	    super('UNDICI_CONNECT');

	    this.opaque = opaque || null;
	    this.responseHeaders = responseHeaders || null;
	    this.callback = callback;
	    this.abort = null;

	    addSignal(this, signal);
	  }

	  onConnect (abort, context) {
	    if (!this.callback) {
	      throw new RequestAbortedError()
	    }

	    this.abort = abort;
	    this.context = context;
	  }

	  onHeaders () {
	    throw new SocketError('bad connect', null)
	  }

	  onUpgrade (statusCode, rawHeaders, socket) {
	    const { callback, opaque, context } = this;

	    removeSignal(this);

	    this.callback = null;

	    let headers = rawHeaders;
	    // Indicates is an HTTP2Session
	    if (headers != null) {
	      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
	    }

	    this.runInAsyncScope(callback, null, null, {
	      statusCode,
	      headers,
	      socket,
	      opaque,
	      context
	    });
	  }

	  onError (err) {
	    const { callback, opaque } = this;

	    removeSignal(this);

	    if (callback) {
	      this.callback = null;
	      queueMicrotask(() => {
	        this.runInAsyncScope(callback, null, err, { opaque });
	      });
	    }
	  }
	}

	function connect (opts, callback) {
	  if (callback === undefined) {
	    return new Promise((resolve, reject) => {
	      connect.call(this, opts, (err, data) => {
	        return err ? reject(err) : resolve(data)
	      });
	    })
	  }

	  try {
	    const connectHandler = new ConnectHandler(opts, callback);
	    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler);
	  } catch (err) {
	    if (typeof callback !== 'function') {
	      throw err
	    }
	    const opaque = opts && opts.opaque;
	    queueMicrotask(() => callback(err, { opaque }));
	  }
	}

	apiConnect = connect;
	return apiConnect;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;

	api.request = requireApiRequest();
	api.stream = requireApiStream();
	api.pipeline = requireApiPipeline();
	api.upgrade = requireApiUpgrade();
	api.connect = requireApiConnect();
	return api;
}

var mockErrors;
var hasRequiredMockErrors;

function requireMockErrors () {
	if (hasRequiredMockErrors) return mockErrors;
	hasRequiredMockErrors = 1;

	const { UndiciError } = requireErrors();

	class MockNotMatchedError extends UndiciError {
	  constructor (message) {
	    super(message);
	    Error.captureStackTrace(this, MockNotMatchedError);
	    this.name = 'MockNotMatchedError';
	    this.message = message || 'The request does not match any registered mock dispatches';
	    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
	  }
	}

	mockErrors = {
	  MockNotMatchedError
	};
	return mockErrors;
}

var mockSymbols;
var hasRequiredMockSymbols;

function requireMockSymbols () {
	if (hasRequiredMockSymbols) return mockSymbols;
	hasRequiredMockSymbols = 1;

	mockSymbols = {
	  kAgent: Symbol('agent'),
	  kOptions: Symbol('options'),
	  kFactory: Symbol('factory'),
	  kDispatches: Symbol('dispatches'),
	  kDispatchKey: Symbol('dispatch key'),
	  kDefaultHeaders: Symbol('default headers'),
	  kDefaultTrailers: Symbol('default trailers'),
	  kContentLength: Symbol('content length'),
	  kMockAgent: Symbol('mock agent'),
	  kMockAgentSet: Symbol('mock agent set'),
	  kMockAgentGet: Symbol('mock agent get'),
	  kMockDispatch: Symbol('mock dispatch'),
	  kClose: Symbol('close'),
	  kOriginalClose: Symbol('original agent close'),
	  kOrigin: Symbol('origin'),
	  kIsMockActive: Symbol('is mock active'),
	  kNetConnect: Symbol('net connect'),
	  kGetNetConnect: Symbol('get net connect'),
	  kConnected: Symbol('connected')
	};
	return mockSymbols;
}

var mockUtils;
var hasRequiredMockUtils;

function requireMockUtils () {
	if (hasRequiredMockUtils) return mockUtils;
	hasRequiredMockUtils = 1;

	const { MockNotMatchedError } = requireMockErrors();
	const {
	  kDispatches,
	  kMockAgent,
	  kOriginalDispatch,
	  kOrigin,
	  kGetNetConnect
	} = requireMockSymbols();
	const { buildURL, nop } = requireUtil$8();
	const { STATUS_CODES } = require$$2__default;
	const {
	  types: {
	    isPromise
	  }
	} = require$$0$7;

	function matchValue (match, value) {
	  if (typeof match === 'string') {
	    return match === value
	  }
	  if (match instanceof RegExp) {
	    return match.test(value)
	  }
	  if (typeof match === 'function') {
	    return match(value) === true
	  }
	  return false
	}

	function lowerCaseEntries (headers) {
	  return Object.fromEntries(
	    Object.entries(headers).map(([headerName, headerValue]) => {
	      return [headerName.toLocaleLowerCase(), headerValue]
	    })
	  )
	}

	/**
	 * @param {import('../../index').Headers|string[]|Record<string, string>} headers
	 * @param {string} key
	 */
	function getHeaderByName (headers, key) {
	  if (Array.isArray(headers)) {
	    for (let i = 0; i < headers.length; i += 2) {
	      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
	        return headers[i + 1]
	      }
	    }

	    return undefined
	  } else if (typeof headers.get === 'function') {
	    return headers.get(key)
	  } else {
	    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]
	  }
	}

	/** @param {string[]} headers */
	function buildHeadersFromArray (headers) { // fetch HeadersList
	  const clone = headers.slice();
	  const entries = [];
	  for (let index = 0; index < clone.length; index += 2) {
	    entries.push([clone[index], clone[index + 1]]);
	  }
	  return Object.fromEntries(entries)
	}

	function matchHeaders (mockDispatch, headers) {
	  if (typeof mockDispatch.headers === 'function') {
	    if (Array.isArray(headers)) { // fetch HeadersList
	      headers = buildHeadersFromArray(headers);
	    }
	    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})
	  }
	  if (typeof mockDispatch.headers === 'undefined') {
	    return true
	  }
	  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {
	    return false
	  }

	  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {
	    const headerValue = getHeaderByName(headers, matchHeaderName);

	    if (!matchValue(matchHeaderValue, headerValue)) {
	      return false
	    }
	  }
	  return true
	}

	function safeUrl (path) {
	  if (typeof path !== 'string') {
	    return path
	  }

	  const pathSegments = path.split('?');

	  if (pathSegments.length !== 2) {
	    return path
	  }

	  const qp = new URLSearchParams(pathSegments.pop());
	  qp.sort();
	  return [...pathSegments, qp.toString()].join('?')
	}

	function matchKey (mockDispatch, { path, method, body, headers }) {
	  const pathMatch = matchValue(mockDispatch.path, path);
	  const methodMatch = matchValue(mockDispatch.method, method);
	  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true;
	  const headersMatch = matchHeaders(mockDispatch, headers);
	  return pathMatch && methodMatch && bodyMatch && headersMatch
	}

	function getResponseData (data) {
	  if (Buffer.isBuffer(data)) {
	    return data
	  } else if (typeof data === 'object') {
	    return JSON.stringify(data)
	  } else {
	    return data.toString()
	  }
	}

	function getMockDispatch (mockDispatches, key) {
	  const basePath = key.query ? buildURL(key.path, key.query) : key.path;
	  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath;

	  // Match path
	  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)
	  }

	  // Match method
	  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)
	  }

	  // Match body
	  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true);
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)
	  }

	  // Match headers
	  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers));
	  if (matchedMockDispatches.length === 0) {
	    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)
	  }

	  return matchedMockDispatches[0]
	}

	function addMockDispatch (mockDispatches, key, data) {
	  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
	  const replyData = typeof data === 'function' ? { callback: data } : { ...data };
	  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
	  mockDispatches.push(newMockDispatch);
	  return newMockDispatch
	}

	function deleteMockDispatch (mockDispatches, key) {
	  const index = mockDispatches.findIndex(dispatch => {
	    if (!dispatch.consumed) {
	      return false
	    }
	    return matchKey(dispatch, key)
	  });
	  if (index !== -1) {
	    mockDispatches.splice(index, 1);
	  }
	}

	function buildKey (opts) {
	  const { path, method, body, headers, query } = opts;
	  return {
	    path,
	    method,
	    body,
	    headers,
	    query
	  }
	}

	function generateKeyValues (data) {
	  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
	    ...keyValuePairs,
	    Buffer.from(`${key}`),
	    Array.isArray(value) ? value.map(x => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
	  ], [])
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	 * @param {number} statusCode
	 */
	function getStatusText (statusCode) {
	  return STATUS_CODES[statusCode] || 'unknown'
	}

	async function getResponse (body) {
	  const buffers = [];
	  for await (const data of body) {
	    buffers.push(data);
	  }
	  return Buffer.concat(buffers).toString('utf8')
	}

	/**
	 * Mock dispatch function used to simulate undici dispatches
	 */
	function mockDispatch (opts, handler) {
	  // Get mock dispatch from built key
	  const key = buildKey(opts);
	  const mockDispatch = getMockDispatch(this[kDispatches], key);

	  mockDispatch.timesInvoked++;

	  // Here's where we resolve a callback if a callback is present for the dispatch data.
	  if (mockDispatch.data.callback) {
	    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) };
	  }

	  // Parse mockDispatch data
	  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch;
	  const { timesInvoked, times } = mockDispatch;

	  // If it's used up and not persistent, mark as consumed
	  mockDispatch.consumed = !persist && timesInvoked >= times;
	  mockDispatch.pending = timesInvoked < times;

	  // If specified, trigger dispatch error
	  if (error !== null) {
	    deleteMockDispatch(this[kDispatches], key);
	    handler.onError(error);
	    return true
	  }

	  // Handle the request with a delay if necessary
	  if (typeof delay === 'number' && delay > 0) {
	    setTimeout(() => {
	      handleReply(this[kDispatches]);
	    }, delay);
	  } else {
	    handleReply(this[kDispatches]);
	  }

	  function handleReply (mockDispatches, _data = data) {
	    // fetch's HeadersList is a 1D string array
	    const optsHeaders = Array.isArray(opts.headers)
	      ? buildHeadersFromArray(opts.headers)
	      : opts.headers;
	    const body = typeof _data === 'function'
	      ? _data({ ...opts, headers: optsHeaders })
	      : _data;

	    // util.types.isPromise is likely needed for jest.
	    if (isPromise(body)) {
	      // If handleReply is asynchronous, throwing an error
	      // in the callback will reject the promise, rather than
	      // synchronously throw the error, which breaks some tests.
	      // Rather, we wait for the callback to resolve if it is a
	      // promise, and then re-run handleReply with the new body.
	      body.then((newData) => handleReply(mockDispatches, newData));
	      return
	    }

	    const responseData = getResponseData(body);
	    const responseHeaders = generateKeyValues(headers);
	    const responseTrailers = generateKeyValues(trailers);

	    handler.abort = nop;
	    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
	    handler.onData(Buffer.from(responseData));
	    handler.onComplete(responseTrailers);
	    deleteMockDispatch(mockDispatches, key);
	  }

	  function resume () {}

	  return true
	}

	function buildMockDispatch () {
	  const agent = this[kMockAgent];
	  const origin = this[kOrigin];
	  const originalDispatch = this[kOriginalDispatch];

	  return function dispatch (opts, handler) {
	    if (agent.isMockActive) {
	      try {
	        mockDispatch.call(this, opts, handler);
	      } catch (error) {
	        if (error instanceof MockNotMatchedError) {
	          const netConnect = agent[kGetNetConnect]();
	          if (netConnect === false) {
	            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)
	          }
	          if (checkNetConnect(netConnect, origin)) {
	            originalDispatch.call(this, opts, handler);
	          } else {
	            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)
	          }
	        } else {
	          throw error
	        }
	      }
	    } else {
	      originalDispatch.call(this, opts, handler);
	    }
	  }
	}

	function checkNetConnect (netConnect, origin) {
	  const url = new URL(origin);
	  if (netConnect === true) {
	    return true
	  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
	    return true
	  }
	  return false
	}

	function buildMockOptions (opts) {
	  if (opts) {
	    const { agent, ...mockOptions } = opts;
	    return mockOptions
	  }
	}

	mockUtils = {
	  getResponseData,
	  getMockDispatch,
	  addMockDispatch,
	  deleteMockDispatch,
	  buildKey,
	  generateKeyValues,
	  matchValue,
	  getResponse,
	  getStatusText,
	  mockDispatch,
	  buildMockDispatch,
	  checkNetConnect,
	  buildMockOptions,
	  getHeaderByName
	};
	return mockUtils;
}

var mockInterceptor = {};

var hasRequiredMockInterceptor;

function requireMockInterceptor () {
	if (hasRequiredMockInterceptor) return mockInterceptor;
	hasRequiredMockInterceptor = 1;

	const { getResponseData, buildKey, addMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kDispatchKey,
	  kDefaultHeaders,
	  kDefaultTrailers,
	  kContentLength,
	  kMockDispatch
	} = requireMockSymbols();
	const { InvalidArgumentError } = requireErrors();
	const { buildURL } = requireUtil$8();

	/**
	 * Defines the scope API for an interceptor reply
	 */
	class MockScope {
	  constructor (mockDispatch) {
	    this[kMockDispatch] = mockDispatch;
	  }

	  /**
	   * Delay a reply by a set amount in ms.
	   */
	  delay (waitInMs) {
	    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {
	      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')
	    }

	    this[kMockDispatch].delay = waitInMs;
	    return this
	  }

	  /**
	   * For a defined reply, never mark as consumed.
	   */
	  persist () {
	    this[kMockDispatch].persist = true;
	    return this
	  }

	  /**
	   * Allow one to define a reply for a set amount of matching requests.
	   */
	  times (repeatTimes) {
	    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
	      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')
	    }

	    this[kMockDispatch].times = repeatTimes;
	    return this
	  }
	}

	/**
	 * Defines an interceptor for a Mock
	 */
	class MockInterceptor {
	  constructor (opts, mockDispatches) {
	    if (typeof opts !== 'object') {
	      throw new InvalidArgumentError('opts must be an object')
	    }
	    if (typeof opts.path === 'undefined') {
	      throw new InvalidArgumentError('opts.path must be defined')
	    }
	    if (typeof opts.method === 'undefined') {
	      opts.method = 'GET';
	    }
	    // See https://github.com/nodejs/undici/issues/1245
	    // As per RFC 3986, clients are not supposed to send URI
	    // fragments to servers when they retrieve a document,
	    if (typeof opts.path === 'string') {
	      if (opts.query) {
	        opts.path = buildURL(opts.path, opts.query);
	      } else {
	        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811
	        const parsedURL = new URL(opts.path, 'data://');
	        opts.path = parsedURL.pathname + parsedURL.search;
	      }
	    }
	    if (typeof opts.method === 'string') {
	      opts.method = opts.method.toUpperCase();
	    }

	    this[kDispatchKey] = buildKey(opts);
	    this[kDispatches] = mockDispatches;
	    this[kDefaultHeaders] = {};
	    this[kDefaultTrailers] = {};
	    this[kContentLength] = false;
	  }

	  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {
	    const responseData = getResponseData(data);
	    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {};
	    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
	    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };

	    return { statusCode, data, headers, trailers }
	  }

	  validateReplyParameters (statusCode, data, responseOptions) {
	    if (typeof statusCode === 'undefined') {
	      throw new InvalidArgumentError('statusCode must be defined')
	    }
	    if (typeof data === 'undefined') {
	      throw new InvalidArgumentError('data must be defined')
	    }
	    if (typeof responseOptions !== 'object') {
	      throw new InvalidArgumentError('responseOptions must be an object')
	    }
	  }

	  /**
	   * Mock an undici request with a defined reply.
	   */
	  reply (replyData) {
	    // Values of reply aren't available right now as they
	    // can only be available when the reply callback is invoked.
	    if (typeof replyData === 'function') {
	      // We'll first wrap the provided callback in another function,
	      // this function will properly resolve the data from the callback
	      // when invoked.
	      const wrappedDefaultsCallback = (opts) => {
	        // Our reply options callback contains the parameter for statusCode, data and options.
	        const resolvedData = replyData(opts);

	        // Check if it is in the right format
	        if (typeof resolvedData !== 'object') {
	          throw new InvalidArgumentError('reply options callback must return an object')
	        }

	        const { statusCode, data = '', responseOptions = {} } = resolvedData;
	        this.validateReplyParameters(statusCode, data, responseOptions);
	        // Since the values can be obtained immediately we return them
	        // from this higher order function that will be resolved later.
	        return {
	          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)
	        }
	      };

	      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
	      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
	      return new MockScope(newMockDispatch)
	    }

	    // We can have either one or three parameters, if we get here,
	    // we should have 1-3 parameters. So we spread the arguments of
	    // this function to obtain the parameters, since replyData will always
	    // just be the statusCode.
	    const [statusCode, data = '', responseOptions = {}] = [...arguments];
	    this.validateReplyParameters(statusCode, data, responseOptions);

	    // Send in-already provided data like usual
	    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
	    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
	    return new MockScope(newMockDispatch)
	  }

	  /**
	   * Mock an undici request with a defined error.
	   */
	  replyWithError (error) {
	    if (typeof error === 'undefined') {
	      throw new InvalidArgumentError('error must be defined')
	    }

	    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
	    return new MockScope(newMockDispatch)
	  }

	  /**
	   * Set default reply headers on the interceptor for subsequent replies
	   */
	  defaultReplyHeaders (headers) {
	    if (typeof headers === 'undefined') {
	      throw new InvalidArgumentError('headers must be defined')
	    }

	    this[kDefaultHeaders] = headers;
	    return this
	  }

	  /**
	   * Set default reply trailers on the interceptor for subsequent replies
	   */
	  defaultReplyTrailers (trailers) {
	    if (typeof trailers === 'undefined') {
	      throw new InvalidArgumentError('trailers must be defined')
	    }

	    this[kDefaultTrailers] = trailers;
	    return this
	  }

	  /**
	   * Set reply content length header for replies on the interceptor
	   */
	  replyContentLength () {
	    this[kContentLength] = true;
	    return this
	  }
	}

	mockInterceptor.MockInterceptor = MockInterceptor;
	mockInterceptor.MockScope = MockScope;
	return mockInterceptor;
}

var mockClient;
var hasRequiredMockClient;

function requireMockClient () {
	if (hasRequiredMockClient) return mockClient;
	hasRequiredMockClient = 1;

	const { promisify } = require$$0$7;
	const Client = requireClient$1();
	const { buildMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kMockAgent,
	  kClose,
	  kOriginalClose,
	  kOrigin,
	  kOriginalDispatch,
	  kConnected
	} = requireMockSymbols();
	const { MockInterceptor } = requireMockInterceptor();
	const Symbols = requireSymbols$4();
	const { InvalidArgumentError } = requireErrors();

	/**
	 * MockClient provides an API that extends the Client to influence the mockDispatches.
	 */
	class MockClient extends Client {
	  constructor (origin, opts) {
	    super(origin, opts);

	    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }

	    this[kMockAgent] = opts.agent;
	    this[kOrigin] = origin;
	    this[kDispatches] = [];
	    this[kConnected] = 1;
	    this[kOriginalDispatch] = this.dispatch;
	    this[kOriginalClose] = this.close.bind(this);

	    this.dispatch = buildMockDispatch.call(this);
	    this.close = this[kClose];
	  }

	  get [Symbols.kConnected] () {
	    return this[kConnected]
	  }

	  /**
	   * Sets up the base interceptor for mocking replies from undici.
	   */
	  intercept (opts) {
	    return new MockInterceptor(opts, this[kDispatches])
	  }

	  async [kClose] () {
	    await promisify(this[kOriginalClose])();
	    this[kConnected] = 0;
	    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	  }
	}

	mockClient = MockClient;
	return mockClient;
}

var mockPool;
var hasRequiredMockPool;

function requireMockPool () {
	if (hasRequiredMockPool) return mockPool;
	hasRequiredMockPool = 1;

	const { promisify } = require$$0$7;
	const Pool = requirePool$1();
	const { buildMockDispatch } = requireMockUtils();
	const {
	  kDispatches,
	  kMockAgent,
	  kClose,
	  kOriginalClose,
	  kOrigin,
	  kOriginalDispatch,
	  kConnected
	} = requireMockSymbols();
	const { MockInterceptor } = requireMockInterceptor();
	const Symbols = requireSymbols$4();
	const { InvalidArgumentError } = requireErrors();

	/**
	 * MockPool provides an API that extends the Pool to influence the mockDispatches.
	 */
	class MockPool extends Pool {
	  constructor (origin, opts) {
	    super(origin, opts);

	    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }

	    this[kMockAgent] = opts.agent;
	    this[kOrigin] = origin;
	    this[kDispatches] = [];
	    this[kConnected] = 1;
	    this[kOriginalDispatch] = this.dispatch;
	    this[kOriginalClose] = this.close.bind(this);

	    this.dispatch = buildMockDispatch.call(this);
	    this.close = this[kClose];
	  }

	  get [Symbols.kConnected] () {
	    return this[kConnected]
	  }

	  /**
	   * Sets up the base interceptor for mocking replies from undici.
	   */
	  intercept (opts) {
	    return new MockInterceptor(opts, this[kDispatches])
	  }

	  async [kClose] () {
	    await promisify(this[kOriginalClose])();
	    this[kConnected] = 0;
	    this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
	  }
	}

	mockPool = MockPool;
	return mockPool;
}

var pluralizer;
var hasRequiredPluralizer;

function requirePluralizer () {
	if (hasRequiredPluralizer) return pluralizer;
	hasRequiredPluralizer = 1;

	const singulars = {
	  pronoun: 'it',
	  is: 'is',
	  was: 'was',
	  this: 'this'
	};

	const plurals = {
	  pronoun: 'they',
	  is: 'are',
	  was: 'were',
	  this: 'these'
	};

	pluralizer = class Pluralizer {
	  constructor (singular, plural) {
	    this.singular = singular;
	    this.plural = plural;
	  }

	  pluralize (count) {
	    const one = count === 1;
	    const keys = one ? singulars : plurals;
	    const noun = one ? this.singular : this.plural;
	    return { ...keys, count, noun }
	  }
	};
	return pluralizer;
}

var pendingInterceptorsFormatter;
var hasRequiredPendingInterceptorsFormatter;

function requirePendingInterceptorsFormatter () {
	if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
	hasRequiredPendingInterceptorsFormatter = 1;

	const { Transform } = require$$0$9;
	const { Console } = require$$1$4;

	/**
	 * Gets the output of `console.table()` as a string.
	 */
	pendingInterceptorsFormatter = class PendingInterceptorsFormatter {
	  constructor ({ disableColors } = {}) {
	    this.transform = new Transform({
	      transform (chunk, _enc, cb) {
	        cb(null, chunk);
	      }
	    });

	    this.logger = new Console({
	      stdout: this.transform,
	      inspectOptions: {
	        colors: !disableColors && !process.env.CI
	      }
	    });
	  }

	  format (pendingInterceptors) {
	    const withPrettyHeaders = pendingInterceptors.map(
	      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
	        Method: method,
	        Origin: origin,
	        Path: path,
	        'Status code': statusCode,
	        Persistent: persist ? '' : '',
	        Invocations: timesInvoked,
	        Remaining: persist ? Infinity : times - timesInvoked
	      }));

	    this.logger.table(withPrettyHeaders);
	    return this.transform.read().toString()
	  }
	};
	return pendingInterceptorsFormatter;
}

var mockAgent;
var hasRequiredMockAgent;

function requireMockAgent () {
	if (hasRequiredMockAgent) return mockAgent;
	hasRequiredMockAgent = 1;

	const { kClients } = requireSymbols$4();
	const Agent = requireAgent();
	const {
	  kAgent,
	  kMockAgentSet,
	  kMockAgentGet,
	  kDispatches,
	  kIsMockActive,
	  kNetConnect,
	  kGetNetConnect,
	  kOptions,
	  kFactory
	} = requireMockSymbols();
	const MockClient = requireMockClient();
	const MockPool = requireMockPool();
	const { matchValue, buildMockOptions } = requireMockUtils();
	const { InvalidArgumentError, UndiciError } = requireErrors();
	const Dispatcher = requireDispatcher();
	const Pluralizer = requirePluralizer();
	const PendingInterceptorsFormatter = requirePendingInterceptorsFormatter();

	class FakeWeakRef {
	  constructor (value) {
	    this.value = value;
	  }

	  deref () {
	    return this.value
	  }
	}

	class MockAgent extends Dispatcher {
	  constructor (opts) {
	    super(opts);

	    this[kNetConnect] = true;
	    this[kIsMockActive] = true;

	    // Instantiate Agent and encapsulate
	    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {
	      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
	    }
	    const agent = opts && opts.agent ? opts.agent : new Agent(opts);
	    this[kAgent] = agent;

	    this[kClients] = agent[kClients];
	    this[kOptions] = buildMockOptions(opts);
	  }

	  get (origin) {
	    let dispatcher = this[kMockAgentGet](origin);

	    if (!dispatcher) {
	      dispatcher = this[kFactory](origin);
	      this[kMockAgentSet](origin, dispatcher);
	    }
	    return dispatcher
	  }

	  dispatch (opts, handler) {
	    // Call MockAgent.get to perform additional setup before dispatching as normal
	    this.get(opts.origin);
	    return this[kAgent].dispatch(opts, handler)
	  }

	  async close () {
	    await this[kAgent].close();
	    this[kClients].clear();
	  }

	  deactivate () {
	    this[kIsMockActive] = false;
	  }

	  activate () {
	    this[kIsMockActive] = true;
	  }

	  enableNetConnect (matcher) {
	    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {
	      if (Array.isArray(this[kNetConnect])) {
	        this[kNetConnect].push(matcher);
	      } else {
	        this[kNetConnect] = [matcher];
	      }
	    } else if (typeof matcher === 'undefined') {
	      this[kNetConnect] = true;
	    } else {
	      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')
	    }
	  }

	  disableNetConnect () {
	    this[kNetConnect] = false;
	  }

	  // This is required to bypass issues caused by using global symbols - see:
	  // https://github.com/nodejs/undici/issues/1447
	  get isMockActive () {
	    return this[kIsMockActive]
	  }

	  [kMockAgentSet] (origin, dispatcher) {
	    this[kClients].set(origin, new FakeWeakRef(dispatcher));
	  }

	  [kFactory] (origin) {
	    const mockOptions = Object.assign({ agent: this }, this[kOptions]);
	    return this[kOptions] && this[kOptions].connections === 1
	      ? new MockClient(origin, mockOptions)
	      : new MockPool(origin, mockOptions)
	  }

	  [kMockAgentGet] (origin) {
	    // First check if we can immediately find it
	    const ref = this[kClients].get(origin);
	    if (ref) {
	      return ref.deref()
	    }

	    // If the origin is not a string create a dummy parent pool and return to user
	    if (typeof origin !== 'string') {
	      const dispatcher = this[kFactory]('http://localhost:9999');
	      this[kMockAgentSet](origin, dispatcher);
	      return dispatcher
	    }

	    // If we match, create a pool and assign the same dispatches
	    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
	      const nonExplicitDispatcher = nonExplicitRef.deref();
	      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {
	        const dispatcher = this[kFactory](origin);
	        this[kMockAgentSet](origin, dispatcher);
	        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
	        return dispatcher
	      }
	    }
	  }

	  [kGetNetConnect] () {
	    return this[kNetConnect]
	  }

	  pendingInterceptors () {
	    const mockAgentClients = this[kClients];

	    return Array.from(mockAgentClients.entries())
	      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))
	      .filter(({ pending }) => pending)
	  }

	  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
	    const pending = this.pendingInterceptors();

	    if (pending.length === 0) {
	      return
	    }

	    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length);

	    throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim())
	  }
	}

	mockAgent = MockAgent;
	return mockAgent;
}

var proxyAgent;
var hasRequiredProxyAgent;

function requireProxyAgent () {
	if (hasRequiredProxyAgent) return proxyAgent;
	hasRequiredProxyAgent = 1;

	const { kProxy, kClose, kDestroy, kInterceptors } = requireSymbols$4();
	const { URL } = require$$1$5;
	const Agent = requireAgent();
	const Pool = requirePool$1();
	const DispatcherBase = requireDispatcherBase();
	const { InvalidArgumentError, RequestAbortedError } = requireErrors();
	const buildConnector = requireConnect();

	const kAgent = Symbol('proxy agent');
	const kClient = Symbol('proxy client');
	const kProxyHeaders = Symbol('proxy headers');
	const kRequestTls = Symbol('request tls settings');
	const kProxyTls = Symbol('proxy tls settings');
	const kConnectEndpoint = Symbol('connect endpoint function');

	function defaultProtocolPort (protocol) {
	  return protocol === 'https:' ? 443 : 80
	}

	function buildProxyOptions (opts) {
	  if (typeof opts === 'string') {
	    opts = { uri: opts };
	  }

	  if (!opts || !opts.uri) {
	    throw new InvalidArgumentError('Proxy opts.uri is mandatory')
	  }

	  return {
	    uri: opts.uri,
	    protocol: opts.protocol || 'https'
	  }
	}

	function defaultFactory (origin, opts) {
	  return new Pool(origin, opts)
	}

	class ProxyAgent extends DispatcherBase {
	  constructor (opts) {
	    super(opts);
	    this[kProxy] = buildProxyOptions(opts);
	    this[kAgent] = new Agent(opts);
	    this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)
	      ? opts.interceptors.ProxyAgent
	      : [];

	    if (typeof opts === 'string') {
	      opts = { uri: opts };
	    }

	    if (!opts || !opts.uri) {
	      throw new InvalidArgumentError('Proxy opts.uri is mandatory')
	    }

	    const { clientFactory = defaultFactory } = opts;

	    if (typeof clientFactory !== 'function') {
	      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')
	    }

	    this[kRequestTls] = opts.requestTls;
	    this[kProxyTls] = opts.proxyTls;
	    this[kProxyHeaders] = opts.headers || {};

	    const resolvedUrl = new URL(opts.uri);
	    const { origin, port, host, username, password } = resolvedUrl;

	    if (opts.auth && opts.token) {
	      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')
	    } else if (opts.auth) {
	      /* @deprecated in favour of opts.token */
	      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`;
	    } else if (opts.token) {
	      this[kProxyHeaders]['proxy-authorization'] = opts.token;
	    } else if (username && password) {
	      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`;
	    }

	    const connect = buildConnector({ ...opts.proxyTls });
	    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
	    this[kClient] = clientFactory(resolvedUrl, { connect });
	    this[kAgent] = new Agent({
	      ...opts,
	      connect: async (opts, callback) => {
	        let requestedHost = opts.host;
	        if (!opts.port) {
	          requestedHost += `:${defaultProtocolPort(opts.protocol)}`;
	        }
	        try {
	          const { socket, statusCode } = await this[kClient].connect({
	            origin,
	            port,
	            path: requestedHost,
	            signal: opts.signal,
	            headers: {
	              ...this[kProxyHeaders],
	              host
	            }
	          });
	          if (statusCode !== 200) {
	            socket.on('error', () => {}).destroy();
	            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
	          }
	          if (opts.protocol !== 'https:') {
	            callback(null, socket);
	            return
	          }
	          let servername;
	          if (this[kRequestTls]) {
	            servername = this[kRequestTls].servername;
	          } else {
	            servername = opts.servername;
	          }
	          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback);
	        } catch (err) {
	          callback(err);
	        }
	      }
	    });
	  }

	  dispatch (opts, handler) {
	    const { host } = new URL(opts.origin);
	    const headers = buildHeaders(opts.headers);
	    throwIfProxyAuthIsSent(headers);
	    return this[kAgent].dispatch(
	      {
	        ...opts,
	        headers: {
	          ...headers,
	          host
	        }
	      },
	      handler
	    )
	  }

	  async [kClose] () {
	    await this[kAgent].close();
	    await this[kClient].close();
	  }

	  async [kDestroy] () {
	    await this[kAgent].destroy();
	    await this[kClient].destroy();
	  }
	}

	/**
	 * @param {string[] | Record<string, string>} headers
	 * @returns {Record<string, string>}
	 */
	function buildHeaders (headers) {
	  // When using undici.fetch, the headers list is stored
	  // as an array.
	  if (Array.isArray(headers)) {
	    /** @type {Record<string, string>} */
	    const headersPair = {};

	    for (let i = 0; i < headers.length; i += 2) {
	      headersPair[headers[i]] = headers[i + 1];
	    }

	    return headersPair
	  }

	  return headers
	}

	/**
	 * @param {Record<string, string>} headers
	 *
	 * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	 * Nevertheless, it was changed and to avoid a security vulnerability by end users
	 * this check was created.
	 * It should be removed in the next major version for performance reasons
	 */
	function throwIfProxyAuthIsSent (headers) {
	  const existProxyAuth = headers && Object.keys(headers)
	    .find((key) => key.toLowerCase() === 'proxy-authorization');
	  if (existProxyAuth) {
	    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')
	  }
	}

	proxyAgent = ProxyAgent;
	return proxyAgent;
}

var RetryHandler_1;
var hasRequiredRetryHandler;

function requireRetryHandler () {
	if (hasRequiredRetryHandler) return RetryHandler_1;
	hasRequiredRetryHandler = 1;
	const assert = require$$0$8;

	const { kRetryHandlerDefaultRetry } = requireSymbols$4();
	const { RequestRetryError } = requireErrors();
	const { isDisturbed, parseHeaders, parseRangeHeader } = requireUtil$8();

	function calculateRetryAfterHeader (retryAfter) {
	  const current = Date.now();
	  const diff = new Date(retryAfter).getTime() - current;

	  return diff
	}

	class RetryHandler {
	  constructor (opts, handlers) {
	    const { retryOptions, ...dispatchOpts } = opts;
	    const {
	      // Retry scoped
	      retry: retryFn,
	      maxRetries,
	      maxTimeout,
	      minTimeout,
	      timeoutFactor,
	      // Response scoped
	      methods,
	      errorCodes,
	      retryAfter,
	      statusCodes
	    } = retryOptions ?? {};

	    this.dispatch = handlers.dispatch;
	    this.handler = handlers.handler;
	    this.opts = dispatchOpts;
	    this.abort = null;
	    this.aborted = false;
	    this.retryOpts = {
	      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
	      retryAfter: retryAfter ?? true,
	      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,
	      timeout: minTimeout ?? 500, // .5s
	      timeoutFactor: timeoutFactor ?? 2,
	      maxRetries: maxRetries ?? 5,
	      // What errors we should retry
	      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],
	      // Indicates which errors to retry
	      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
	      // List of errors to retry
	      errorCodes: errorCodes ?? [
	        'ECONNRESET',
	        'ECONNREFUSED',
	        'ENOTFOUND',
	        'ENETDOWN',
	        'ENETUNREACH',
	        'EHOSTDOWN',
	        'EHOSTUNREACH',
	        'EPIPE'
	      ]
	    };

	    this.retryCount = 0;
	    this.start = 0;
	    this.end = null;
	    this.etag = null;
	    this.resume = null;

	    // Handle possible onConnect duplication
	    this.handler.onConnect(reason => {
	      this.aborted = true;
	      if (this.abort) {
	        this.abort(reason);
	      } else {
	        this.reason = reason;
	      }
	    });
	  }

	  onRequestSent () {
	    if (this.handler.onRequestSent) {
	      this.handler.onRequestSent();
	    }
	  }

	  onUpgrade (statusCode, headers, socket) {
	    if (this.handler.onUpgrade) {
	      this.handler.onUpgrade(statusCode, headers, socket);
	    }
	  }

	  onConnect (abort) {
	    if (this.aborted) {
	      abort(this.reason);
	    } else {
	      this.abort = abort;
	    }
	  }

	  onBodySent (chunk) {
	    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)
	  }

	  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {
	    const { statusCode, code, headers } = err;
	    const { method, retryOptions } = opts;
	    const {
	      maxRetries,
	      timeout,
	      maxTimeout,
	      timeoutFactor,
	      statusCodes,
	      errorCodes,
	      methods
	    } = retryOptions;
	    let { counter, currentTimeout } = state;

	    currentTimeout =
	      currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;

	    // Any code that is not a Undici's originated and allowed to retry
	    if (
	      code &&
	      code !== 'UND_ERR_REQ_RETRY' &&
	      code !== 'UND_ERR_SOCKET' &&
	      !errorCodes.includes(code)
	    ) {
	      cb(err);
	      return
	    }

	    // If a set of method are provided and the current method is not in the list
	    if (Array.isArray(methods) && !methods.includes(method)) {
	      cb(err);
	      return
	    }

	    // If a set of status code are provided and the current status code is not in the list
	    if (
	      statusCode != null &&
	      Array.isArray(statusCodes) &&
	      !statusCodes.includes(statusCode)
	    ) {
	      cb(err);
	      return
	    }

	    // If we reached the max number of retries
	    if (counter > maxRetries) {
	      cb(err);
	      return
	    }

	    let retryAfterHeader = headers != null && headers['retry-after'];
	    if (retryAfterHeader) {
	      retryAfterHeader = Number(retryAfterHeader);
	      retryAfterHeader = isNaN(retryAfterHeader)
	        ? calculateRetryAfterHeader(retryAfterHeader)
	        : retryAfterHeader * 1e3; // Retry-After is in seconds
	    }

	    const retryTimeout =
	      retryAfterHeader > 0
	        ? Math.min(retryAfterHeader, maxTimeout)
	        : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);

	    state.currentTimeout = retryTimeout;

	    setTimeout(() => cb(null), retryTimeout);
	  }

	  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
	    const headers = parseHeaders(rawHeaders);

	    this.retryCount += 1;

	    if (statusCode >= 300) {
	      this.abort(
	        new RequestRetryError('Request failed', statusCode, {
	          headers,
	          count: this.retryCount
	        })
	      );
	      return false
	    }

	    // Checkpoint for resume from where we left it
	    if (this.resume != null) {
	      this.resume = null;

	      if (statusCode !== 206) {
	        return true
	      }

	      const contentRange = parseRangeHeader(headers['content-range']);
	      // If no content range
	      if (!contentRange) {
	        this.abort(
	          new RequestRetryError('Content-Range mismatch', statusCode, {
	            headers,
	            count: this.retryCount
	          })
	        );
	        return false
	      }

	      // Let's start with a weak etag check
	      if (this.etag != null && this.etag !== headers.etag) {
	        this.abort(
	          new RequestRetryError('ETag mismatch', statusCode, {
	            headers,
	            count: this.retryCount
	          })
	        );
	        return false
	      }

	      const { start, size, end = size } = contentRange;

	      assert(this.start === start, 'content-range mismatch');
	      assert(this.end == null || this.end === end, 'content-range mismatch');

	      this.resume = resume;
	      return true
	    }

	    if (this.end == null) {
	      if (statusCode === 206) {
	        // First time we receive 206
	        const range = parseRangeHeader(headers['content-range']);

	        if (range == null) {
	          return this.handler.onHeaders(
	            statusCode,
	            rawHeaders,
	            resume,
	            statusMessage
	          )
	        }

	        const { start, size, end = size } = range;

	        assert(
	          start != null && Number.isFinite(start) && this.start !== start,
	          'content-range mismatch'
	        );
	        assert(Number.isFinite(start));
	        assert(
	          end != null && Number.isFinite(end) && this.end !== end,
	          'invalid content-length'
	        );

	        this.start = start;
	        this.end = end;
	      }

	      // We make our best to checkpoint the body for further range headers
	      if (this.end == null) {
	        const contentLength = headers['content-length'];
	        this.end = contentLength != null ? Number(contentLength) : null;
	      }

	      assert(Number.isFinite(this.start));
	      assert(
	        this.end == null || Number.isFinite(this.end),
	        'invalid content-length'
	      );

	      this.resume = resume;
	      this.etag = headers.etag != null ? headers.etag : null;

	      return this.handler.onHeaders(
	        statusCode,
	        rawHeaders,
	        resume,
	        statusMessage
	      )
	    }

	    const err = new RequestRetryError('Request failed', statusCode, {
	      headers,
	      count: this.retryCount
	    });

	    this.abort(err);

	    return false
	  }

	  onData (chunk) {
	    this.start += chunk.length;

	    return this.handler.onData(chunk)
	  }

	  onComplete (rawTrailers) {
	    this.retryCount = 0;
	    return this.handler.onComplete(rawTrailers)
	  }

	  onError (err) {
	    if (this.aborted || isDisturbed(this.opts.body)) {
	      return this.handler.onError(err)
	    }

	    this.retryOpts.retry(
	      err,
	      {
	        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
	        opts: { retryOptions: this.retryOpts, ...this.opts }
	      },
	      onRetry.bind(this)
	    );

	    function onRetry (err) {
	      if (err != null || this.aborted || isDisturbed(this.opts.body)) {
	        return this.handler.onError(err)
	      }

	      if (this.start !== 0) {
	        this.opts = {
	          ...this.opts,
	          headers: {
	            ...this.opts.headers,
	            range: `bytes=${this.start}-${this.end ?? ''}`
	          }
	        };
	      }

	      try {
	        this.dispatch(this.opts, this);
	      } catch (err) {
	        this.handler.onError(err);
	      }
	    }
	  }
	}

	RetryHandler_1 = RetryHandler;
	return RetryHandler_1;
}

var global$1;
var hasRequiredGlobal;

function requireGlobal () {
	if (hasRequiredGlobal) return global$1;
	hasRequiredGlobal = 1;

	// We include a version number for the Dispatcher API. In case of breaking changes,
	// this version number must be increased to avoid conflicts.
	const globalDispatcher = Symbol.for('undici.globalDispatcher.1');
	const { InvalidArgumentError } = requireErrors();
	const Agent = requireAgent();

	if (getGlobalDispatcher() === undefined) {
	  setGlobalDispatcher(new Agent());
	}

	function setGlobalDispatcher (agent) {
	  if (!agent || typeof agent.dispatch !== 'function') {
	    throw new InvalidArgumentError('Argument agent must implement Agent')
	  }
	  Object.defineProperty(globalThis, globalDispatcher, {
	    value: agent,
	    writable: true,
	    enumerable: false,
	    configurable: false
	  });
	}

	function getGlobalDispatcher () {
	  return globalThis[globalDispatcher]
	}

	global$1 = {
	  setGlobalDispatcher,
	  getGlobalDispatcher
	};
	return global$1;
}

var DecoratorHandler_1;
var hasRequiredDecoratorHandler;

function requireDecoratorHandler () {
	if (hasRequiredDecoratorHandler) return DecoratorHandler_1;
	hasRequiredDecoratorHandler = 1;

	DecoratorHandler_1 = class DecoratorHandler {
	  constructor (handler) {
	    this.handler = handler;
	  }

	  onConnect (...args) {
	    return this.handler.onConnect(...args)
	  }

	  onError (...args) {
	    return this.handler.onError(...args)
	  }

	  onUpgrade (...args) {
	    return this.handler.onUpgrade(...args)
	  }

	  onHeaders (...args) {
	    return this.handler.onHeaders(...args)
	  }

	  onData (...args) {
	    return this.handler.onData(...args)
	  }

	  onComplete (...args) {
	    return this.handler.onComplete(...args)
	  }

	  onBodySent (...args) {
	    return this.handler.onBodySent(...args)
	  }
	};
	return DecoratorHandler_1;
}

var headers;
var hasRequiredHeaders;

function requireHeaders () {
	if (hasRequiredHeaders) return headers;
	hasRequiredHeaders = 1;

	const { kHeadersList, kConstruct } = requireSymbols$4();
	const { kGuard } = requireSymbols$3();
	const { kEnumerableProperty } = requireUtil$8();
	const {
	  makeIterator,
	  isValidHeaderName,
	  isValidHeaderValue
	} = requireUtil$7();
	const { webidl } = requireWebidl();
	const assert = require$$0$8;

	const kHeadersMap = Symbol('headers map');
	const kHeadersSortedMap = Symbol('headers map sorted');

	/**
	 * @param {number} code
	 */
	function isHTTPWhiteSpaceCharCode (code) {
	  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	 * @param {string} potentialValue
	 */
	function headerValueNormalize (potentialValue) {
	  //  To normalize a byte sequence potentialValue, remove
	  //  any leading and trailing HTTP whitespace bytes from
	  //  potentialValue.
	  let i = 0; let j = potentialValue.length;

	  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
	  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;

	  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)
	}

	function fill (headers, object) {
	  // To fill a Headers object headers with a given object object, run these steps:

	  // 1. If object is a sequence, then for each header in object:
	  // Note: webidl conversion to array has already been done.
	  if (Array.isArray(object)) {
	    for (let i = 0; i < object.length; ++i) {
	      const header = object[i];
	      // 1. If header does not contain exactly two items, then throw a TypeError.
	      if (header.length !== 2) {
	        throw webidl.errors.exception({
	          header: 'Headers constructor',
	          message: `expected name/value pair to be length 2, found ${header.length}.`
	        })
	      }

	      // 2. Append (headers first item, headers second item) to headers.
	      appendHeader(headers, header[0], header[1]);
	    }
	  } else if (typeof object === 'object' && object !== null) {
	    // Note: null should throw

	    // 2. Otherwise, object is a record, then for each key  value in object,
	    //    append (key, value) to headers
	    const keys = Object.keys(object);
	    for (let i = 0; i < keys.length; ++i) {
	      appendHeader(headers, keys[i], object[keys[i]]);
	    }
	  } else {
	    throw webidl.errors.conversionFailed({
	      prefix: 'Headers constructor',
	      argument: 'Argument 1',
	      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
	    })
	  }
	}

	/**
	 * @see https://fetch.spec.whatwg.org/#concept-headers-append
	 */
	function appendHeader (headers, name, value) {
	  // 1. Normalize value.
	  value = headerValueNormalize(value);

	  // 2. If name is not a header name or value is not a
	  //    header value, then throw a TypeError.
	  if (!isValidHeaderName(name)) {
	    throw webidl.errors.invalidArgument({
	      prefix: 'Headers.append',
	      value: name,
	      type: 'header name'
	    })
	  } else if (!isValidHeaderValue(value)) {
	    throw webidl.errors.invalidArgument({
	      prefix: 'Headers.append',
	      value,
	      type: 'header value'
	    })
	  }

	  // 3. If headerss guard is "immutable", then throw a TypeError.
	  // 4. Otherwise, if headerss guard is "request" and name is a
	  //    forbidden header name, return.
	  // Note: undici does not implement forbidden header names
	  if (headers[kGuard] === 'immutable') {
	    throw new TypeError('immutable')
	  } else if (headers[kGuard] === 'request-no-cors') ;

	  // 6. Otherwise, if headerss guard is "response" and name is a
	  //    forbidden response-header name, return.

	  // 7. Append (name, value) to headerss header list.
	  return headers[kHeadersList].append(name, value)

	  // 8. If headerss guard is "request-no-cors", then remove
	  //    privileged no-CORS request headers from headers
	}

	class HeadersList {
	  /** @type {[string, string][]|null} */
	  cookies = null

	  constructor (init) {
	    if (init instanceof HeadersList) {
	      this[kHeadersMap] = new Map(init[kHeadersMap]);
	      this[kHeadersSortedMap] = init[kHeadersSortedMap];
	      this.cookies = init.cookies === null ? null : [...init.cookies];
	    } else {
	      this[kHeadersMap] = new Map(init);
	      this[kHeadersSortedMap] = null;
	    }
	  }

	  // https://fetch.spec.whatwg.org/#header-list-contains
	  contains (name) {
	    // A header list list contains a header name name if list
	    // contains a header whose name is a byte-case-insensitive
	    // match for name.
	    name = name.toLowerCase();

	    return this[kHeadersMap].has(name)
	  }

	  clear () {
	    this[kHeadersMap].clear();
	    this[kHeadersSortedMap] = null;
	    this.cookies = null;
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-append
	  append (name, value) {
	    this[kHeadersSortedMap] = null;

	    // 1. If list contains name, then set name to the first such
	    //    headers name.
	    const lowercaseName = name.toLowerCase();
	    const exists = this[kHeadersMap].get(lowercaseName);

	    // 2. Append (name, value) to list.
	    if (exists) {
	      const delimiter = lowercaseName === 'cookie' ? '; ' : ', ';
	      this[kHeadersMap].set(lowercaseName, {
	        name: exists.name,
	        value: `${exists.value}${delimiter}${value}`
	      });
	    } else {
	      this[kHeadersMap].set(lowercaseName, { name, value });
	    }

	    if (lowercaseName === 'set-cookie') {
	      this.cookies ??= [];
	      this.cookies.push(value);
	    }
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-set
	  set (name, value) {
	    this[kHeadersSortedMap] = null;
	    const lowercaseName = name.toLowerCase();

	    if (lowercaseName === 'set-cookie') {
	      this.cookies = [value];
	    }

	    // 1. If list contains name, then set the value of
	    //    the first such header to value and remove the
	    //    others.
	    // 2. Otherwise, append header (name, value) to list.
	    this[kHeadersMap].set(lowercaseName, { name, value });
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-delete
	  delete (name) {
	    this[kHeadersSortedMap] = null;

	    name = name.toLowerCase();

	    if (name === 'set-cookie') {
	      this.cookies = null;
	    }

	    this[kHeadersMap].delete(name);
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-get
	  get (name) {
	    const value = this[kHeadersMap].get(name.toLowerCase());

	    // 1. If list does not contain name, then return null.
	    // 2. Return the values of all headers in list whose name
	    //    is a byte-case-insensitive match for name,
	    //    separated from each other by 0x2C 0x20, in order.
	    return value === undefined ? null : value.value
	  }

	  * [Symbol.iterator] () {
	    // use the lowercased name
	    for (const [name, { value }] of this[kHeadersMap]) {
	      yield [name, value];
	    }
	  }

	  get entries () {
	    const headers = {};

	    if (this[kHeadersMap].size) {
	      for (const { name, value } of this[kHeadersMap].values()) {
	        headers[name] = value;
	      }
	    }

	    return headers
	  }
	}

	// https://fetch.spec.whatwg.org/#headers-class
	class Headers {
	  constructor (init = undefined) {
	    if (init === kConstruct) {
	      return
	    }
	    this[kHeadersList] = new HeadersList();

	    // The new Headers(init) constructor steps are:

	    // 1. Set thiss guard to "none".
	    this[kGuard] = 'none';

	    // 2. If init is given, then fill this with init.
	    if (init !== undefined) {
	      init = webidl.converters.HeadersInit(init);
	      fill(this, init);
	    }
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-append
	  append (name, value) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.append' });

	    name = webidl.converters.ByteString(name);
	    value = webidl.converters.ByteString(value);

	    return appendHeader(this, name, value)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-delete
	  delete (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.delete' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.delete',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. If thiss guard is "immutable", then throw a TypeError.
	    // 3. Otherwise, if thiss guard is "request" and name is a
	    //    forbidden header name, return.
	    // 4. Otherwise, if thiss guard is "request-no-cors", name
	    //    is not a no-CORS-safelisted request-header name, and
	    //    name is not a privileged no-CORS request-header name,
	    //    return.
	    // 5. Otherwise, if thiss guard is "response" and name is
	    //    a forbidden response-header name, return.
	    // Note: undici does not implement forbidden header names
	    if (this[kGuard] === 'immutable') {
	      throw new TypeError('immutable')
	    } else if (this[kGuard] === 'request-no-cors') ;

	    // 6. If thiss header list does not contain name, then
	    //    return.
	    if (!this[kHeadersList].contains(name)) {
	      return
	    }

	    // 7. Delete name from thiss header list.
	    // 8. If thiss guard is "request-no-cors", then remove
	    //    privileged no-CORS request headers from this.
	    this[kHeadersList].delete(name);
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-get
	  get (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.get' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.get',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. Return the result of getting name from thiss header
	    //    list.
	    return this[kHeadersList].get(name)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-has
	  has (name) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.has' });

	    name = webidl.converters.ByteString(name);

	    // 1. If name is not a header name, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.has',
	        value: name,
	        type: 'header name'
	      })
	    }

	    // 2. Return true if thiss header list contains name;
	    //    otherwise false.
	    return this[kHeadersList].contains(name)
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-set
	  set (name, value) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 2, { header: 'Headers.set' });

	    name = webidl.converters.ByteString(name);
	    value = webidl.converters.ByteString(value);

	    // 1. Normalize value.
	    value = headerValueNormalize(value);

	    // 2. If name is not a header name or value is not a
	    //    header value, then throw a TypeError.
	    if (!isValidHeaderName(name)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.set',
	        value: name,
	        type: 'header name'
	      })
	    } else if (!isValidHeaderValue(value)) {
	      throw webidl.errors.invalidArgument({
	        prefix: 'Headers.set',
	        value,
	        type: 'header value'
	      })
	    }

	    // 3. If thiss guard is "immutable", then throw a TypeError.
	    // 4. Otherwise, if thiss guard is "request" and name is a
	    //    forbidden header name, return.
	    // 5. Otherwise, if thiss guard is "request-no-cors" and
	    //    name/value is not a no-CORS-safelisted request-header,
	    //    return.
	    // 6. Otherwise, if thiss guard is "response" and name is a
	    //    forbidden response-header name, return.
	    // Note: undici does not implement forbidden header names
	    if (this[kGuard] === 'immutable') {
	      throw new TypeError('immutable')
	    } else if (this[kGuard] === 'request-no-cors') ;

	    // 7. Set (name, value) in thiss header list.
	    // 8. If thiss guard is "request-no-cors", then remove
	    //    privileged no-CORS request headers from this
	    this[kHeadersList].set(name, value);
	  }

	  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
	  getSetCookie () {
	    webidl.brandCheck(this, Headers);

	    // 1. If thiss header list does not contain `Set-Cookie`, then return  .
	    // 2. Return the values of all headers in thiss header list whose name is
	    //    a byte-case-insensitive match for `Set-Cookie`, in order.

	    const list = this[kHeadersList].cookies;

	    if (list) {
	      return [...list]
	    }

	    return []
	  }

	  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
	  get [kHeadersSortedMap] () {
	    if (this[kHeadersList][kHeadersSortedMap]) {
	      return this[kHeadersList][kHeadersSortedMap]
	    }

	    // 1. Let headers be an empty list of headers with the key being the name
	    //    and value the value.
	    const headers = [];

	    // 2. Let names be the result of convert header names to a sorted-lowercase
	    //    set with all the names of the headers in list.
	    const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
	    const cookies = this[kHeadersList].cookies;

	    // 3. For each name of names:
	    for (let i = 0; i < names.length; ++i) {
	      const [name, value] = names[i];
	      // 1. If name is `set-cookie`, then:
	      if (name === 'set-cookie') {
	        // 1. Let values be a list of all values of headers in list whose name
	        //    is a byte-case-insensitive match for name, in order.

	        // 2. For each value of values:
	        // 1. Append (name, value) to headers.
	        for (let j = 0; j < cookies.length; ++j) {
	          headers.push([name, cookies[j]]);
	        }
	      } else {
	        // 2. Otherwise:

	        // 1. Let value be the result of getting name from list.

	        // 2. Assert: value is non-null.
	        assert(value !== null);

	        // 3. Append (name, value) to headers.
	        headers.push([name, value]);
	      }
	    }

	    this[kHeadersList][kHeadersSortedMap] = headers;

	    // 4. Return headers.
	    return headers
	  }

	  keys () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'key')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'key'
	    )
	  }

	  values () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'value')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'value'
	    )
	  }

	  entries () {
	    webidl.brandCheck(this, Headers);

	    if (this[kGuard] === 'immutable') {
	      const value = this[kHeadersSortedMap];
	      return makeIterator(() => value, 'Headers',
	        'key+value')
	    }

	    return makeIterator(
	      () => [...this[kHeadersSortedMap].values()],
	      'Headers',
	      'key+value'
	    )
	  }

	  /**
	   * @param {(value: string, key: string, self: Headers) => void} callbackFn
	   * @param {unknown} thisArg
	   */
	  forEach (callbackFn, thisArg = globalThis) {
	    webidl.brandCheck(this, Headers);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Headers.forEach' });

	    if (typeof callbackFn !== 'function') {
	      throw new TypeError(
	        "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
	      )
	    }

	    for (const [key, value] of this) {
	      callbackFn.apply(thisArg, [value, key, this]);
	    }
	  }

	  [Symbol.for('nodejs.util.inspect.custom')] () {
	    webidl.brandCheck(this, Headers);

	    return this[kHeadersList]
	  }
	}

	Headers.prototype[Symbol.iterator] = Headers.prototype.entries;

	Object.defineProperties(Headers.prototype, {
	  append: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  get: kEnumerableProperty,
	  has: kEnumerableProperty,
	  set: kEnumerableProperty,
	  getSetCookie: kEnumerableProperty,
	  keys: kEnumerableProperty,
	  values: kEnumerableProperty,
	  entries: kEnumerableProperty,
	  forEach: kEnumerableProperty,
	  [Symbol.iterator]: { enumerable: false },
	  [Symbol.toStringTag]: {
	    value: 'Headers',
	    configurable: true
	  }
	});

	webidl.converters.HeadersInit = function (V) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (V[Symbol.iterator]) {
	      return webidl.converters['sequence<sequence<ByteString>>'](V)
	    }

	    return webidl.converters['record<ByteString, ByteString>'](V)
	  }

	  throw webidl.errors.conversionFailed({
	    prefix: 'Headers constructor',
	    argument: 'Argument 1',
	    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
	  })
	};

	headers = {
	  fill,
	  Headers,
	  HeadersList
	};
	return headers;
}

var response;
var hasRequiredResponse;

function requireResponse () {
	if (hasRequiredResponse) return response;
	hasRequiredResponse = 1;

	const { Headers, HeadersList, fill } = requireHeaders();
	const { extractBody, cloneBody, mixinBody } = requireBody();
	const util = requireUtil$8();
	const { kEnumerableProperty } = util;
	const {
	  isValidReasonPhrase,
	  isCancelled,
	  isAborted,
	  isBlobLike,
	  serializeJavascriptValueToJSONString,
	  isErrorLike,
	  isomorphicEncode
	} = requireUtil$7();
	const {
	  redirectStatusSet,
	  nullBodyStatus,
	  DOMException
	} = requireConstants$4();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { FormData } = requireFormdata();
	const { getGlobalOrigin } = requireGlobal$1();
	const { URLSerializer } = requireDataURL();
	const { kHeadersList, kConstruct } = requireSymbols$4();
	const assert = require$$0$8;
	const { types } = require$$0$7;

	const ReadableStream = globalThis.ReadableStream || require$$14.ReadableStream;
	const textEncoder = new TextEncoder('utf-8');

	// https://fetch.spec.whatwg.org/#response-class
	class Response {
	  // Creates network error Response.
	  static error () {
	    // TODO
	    const relevantRealm = { settingsObject: {} };

	    // The static error() method steps are to return the result of creating a
	    // Response object, given a new network error, "immutable", and thiss
	    // relevant Realm.
	    const responseObject = new Response();
	    responseObject[kState] = makeNetworkError();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;
	    return responseObject
	  }

	  // https://fetch.spec.whatwg.org/#dom-response-json
	  static json (data, init = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.json' });

	    if (init !== null) {
	      init = webidl.converters.ResponseInit(init);
	    }

	    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
	    const bytes = textEncoder.encode(
	      serializeJavascriptValueToJSONString(data)
	    );

	    // 2. Let body be the result of extracting bytes.
	    const body = extractBody(bytes);

	    // 3. Let responseObject be the result of creating a Response object, given a new response,
	    //    "response", and thiss relevant Realm.
	    const relevantRealm = { settingsObject: {} };
	    const responseObject = new Response();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kGuard] = 'response';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 4. Perform initialize a response given responseObject, init, and (body, "application/json").
	    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' });

	    // 5. Return responseObject.
	    return responseObject
	  }

	  // Creates a redirect Response that redirects to url with status status.
	  static redirect (url, status = 302) {
	    const relevantRealm = { settingsObject: {} };

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Response.redirect' });

	    url = webidl.converters.USVString(url);
	    status = webidl.converters['unsigned short'](status);

	    // 1. Let parsedURL be the result of parsing url with current settings
	    // objects API base URL.
	    // 2. If parsedURL is failure, then throw a TypeError.
	    // TODO: base-URL?
	    let parsedURL;
	    try {
	      parsedURL = new URL(url, getGlobalOrigin());
	    } catch (err) {
	      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
	        cause: err
	      })
	    }

	    // 3. If status is not a redirect status, then throw a RangeError.
	    if (!redirectStatusSet.has(status)) {
	      throw new RangeError('Invalid status code ' + status)
	    }

	    // 4. Let responseObject be the result of creating a Response object,
	    // given a new response, "immutable", and thiss relevant Realm.
	    const responseObject = new Response();
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 5. Set responseObjects responses status to status.
	    responseObject[kState].status = status;

	    // 6. Let value be parsedURL, serialized and isomorphic encoded.
	    const value = isomorphicEncode(URLSerializer(parsedURL));

	    // 7. Append `Location`/value to responseObjects responses header list.
	    responseObject[kState].headersList.append('location', value);

	    // 8. Return responseObject.
	    return responseObject
	  }

	  // https://fetch.spec.whatwg.org/#dom-response
	  constructor (body = null, init = {}) {
	    if (body !== null) {
	      body = webidl.converters.BodyInit(body);
	    }

	    init = webidl.converters.ResponseInit(init);

	    // TODO
	    this[kRealm] = { settingsObject: {} };

	    // 1. Set thiss response to a new response.
	    this[kState] = makeResponse({});

	    // 2. Set thiss headers to a new Headers object with thiss relevant
	    // Realm, whose header list is thiss responses header list and guard
	    // is "response".
	    this[kHeaders] = new Headers(kConstruct);
	    this[kHeaders][kGuard] = 'response';
	    this[kHeaders][kHeadersList] = this[kState].headersList;
	    this[kHeaders][kRealm] = this[kRealm];

	    // 3. Let bodyWithType be null.
	    let bodyWithType = null;

	    // 4. If body is non-null, then set bodyWithType to the result of extracting body.
	    if (body != null) {
	      const [extractedBody, type] = extractBody(body);
	      bodyWithType = { body: extractedBody, type };
	    }

	    // 5. Perform initialize a response given this, init, and bodyWithType.
	    initializeResponse(this, init, bodyWithType);
	  }

	  // Returns responses type, e.g., "cors".
	  get type () {
	    webidl.brandCheck(this, Response);

	    // The type getter steps are to return thiss responses type.
	    return this[kState].type
	  }

	  // Returns responses URL, if it has one; otherwise the empty string.
	  get url () {
	    webidl.brandCheck(this, Response);

	    const urlList = this[kState].urlList;

	    // The url getter steps are to return the empty string if thiss
	    // responses URL is null; otherwise thiss responses URL,
	    // serialized with exclude fragment set to true.
	    const url = urlList[urlList.length - 1] ?? null;

	    if (url === null) {
	      return ''
	    }

	    return URLSerializer(url, true)
	  }

	  // Returns whether response was obtained through a redirect.
	  get redirected () {
	    webidl.brandCheck(this, Response);

	    // The redirected getter steps are to return true if thiss responses URL
	    // list has more than one item; otherwise false.
	    return this[kState].urlList.length > 1
	  }

	  // Returns responses status.
	  get status () {
	    webidl.brandCheck(this, Response);

	    // The status getter steps are to return thiss responses status.
	    return this[kState].status
	  }

	  // Returns whether responses status is an ok status.
	  get ok () {
	    webidl.brandCheck(this, Response);

	    // The ok getter steps are to return true if thiss responses status is an
	    // ok status; otherwise false.
	    return this[kState].status >= 200 && this[kState].status <= 299
	  }

	  // Returns responses status message.
	  get statusText () {
	    webidl.brandCheck(this, Response);

	    // The statusText getter steps are to return thiss responses status
	    // message.
	    return this[kState].statusText
	  }

	  // Returns responses headers as Headers.
	  get headers () {
	    webidl.brandCheck(this, Response);

	    // The headers getter steps are to return thiss headers.
	    return this[kHeaders]
	  }

	  get body () {
	    webidl.brandCheck(this, Response);

	    return this[kState].body ? this[kState].body.stream : null
	  }

	  get bodyUsed () {
	    webidl.brandCheck(this, Response);

	    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
	  }

	  // Returns a clone of response.
	  clone () {
	    webidl.brandCheck(this, Response);

	    // 1. If this is unusable, then throw a TypeError.
	    if (this.bodyUsed || (this.body && this.body.locked)) {
	      throw webidl.errors.exception({
	        header: 'Response.clone',
	        message: 'Body has already been consumed.'
	      })
	    }

	    // 2. Let clonedResponse be the result of cloning thiss response.
	    const clonedResponse = cloneResponse(this[kState]);

	    // 3. Return the result of creating a Response object, given
	    // clonedResponse, thiss headerss guard, and thiss relevant Realm.
	    const clonedResponseObject = new Response();
	    clonedResponseObject[kState] = clonedResponse;
	    clonedResponseObject[kRealm] = this[kRealm];
	    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
	    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
	    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];

	    return clonedResponseObject
	  }
	}

	mixinBody(Response);

	Object.defineProperties(Response.prototype, {
	  type: kEnumerableProperty,
	  url: kEnumerableProperty,
	  status: kEnumerableProperty,
	  ok: kEnumerableProperty,
	  redirected: kEnumerableProperty,
	  statusText: kEnumerableProperty,
	  headers: kEnumerableProperty,
	  clone: kEnumerableProperty,
	  body: kEnumerableProperty,
	  bodyUsed: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'Response',
	    configurable: true
	  }
	});

	Object.defineProperties(Response, {
	  json: kEnumerableProperty,
	  redirect: kEnumerableProperty,
	  error: kEnumerableProperty
	});

	// https://fetch.spec.whatwg.org/#concept-response-clone
	function cloneResponse (response) {
	  // To clone a response response, run these steps:

	  // 1. If response is a filtered response, then return a new identical
	  // filtered response whose internal response is a clone of responses
	  // internal response.
	  if (response.internalResponse) {
	    return filterResponse(
	      cloneResponse(response.internalResponse),
	      response.type
	    )
	  }

	  // 2. Let newResponse be a copy of response, except for its body.
	  const newResponse = makeResponse({ ...response, body: null });

	  // 3. If responses body is non-null, then set newResponses body to the
	  // result of cloning responses body.
	  if (response.body != null) {
	    newResponse.body = cloneBody(response.body);
	  }

	  // 4. Return newResponse.
	  return newResponse
	}

	function makeResponse (init) {
	  return {
	    aborted: false,
	    rangeRequested: false,
	    timingAllowPassed: false,
	    requestIncludesCredentials: false,
	    type: 'default',
	    status: 200,
	    timingInfo: null,
	    cacheState: '',
	    statusText: '',
	    ...init,
	    headersList: init.headersList
	      ? new HeadersList(init.headersList)
	      : new HeadersList(),
	    urlList: init.urlList ? [...init.urlList] : []
	  }
	}

	function makeNetworkError (reason) {
	  const isError = isErrorLike(reason);
	  return makeResponse({
	    type: 'error',
	    status: 0,
	    error: isError
	      ? reason
	      : new Error(reason ? String(reason) : reason),
	    aborted: reason && reason.name === 'AbortError'
	  })
	}

	function makeFilteredResponse (response, state) {
	  state = {
	    internalResponse: response,
	    ...state
	  };

	  return new Proxy(response, {
	    get (target, p) {
	      return p in state ? state[p] : target[p]
	    },
	    set (target, p, value) {
	      assert(!(p in state));
	      target[p] = value;
	      return true
	    }
	  })
	}

	// https://fetch.spec.whatwg.org/#concept-filtered-response
	function filterResponse (response, type) {
	  // Set response to the following filtered response with response as its
	  // internal response, depending on requests response tainting:
	  if (type === 'basic') {
	    // A basic filtered response is a filtered response whose type is "basic"
	    // and header list excludes any headers in internal responses header list
	    // whose name is a forbidden response-header name.

	    // Note: undici does not implement forbidden response-header names
	    return makeFilteredResponse(response, {
	      type: 'basic',
	      headersList: response.headersList
	    })
	  } else if (type === 'cors') {
	    // A CORS filtered response is a filtered response whose type is "cors"
	    // and header list excludes any headers in internal responses header
	    // list whose name is not a CORS-safelisted response-header name, given
	    // internal responses CORS-exposed header-name list.

	    // Note: undici does not implement CORS-safelisted response-header names
	    return makeFilteredResponse(response, {
	      type: 'cors',
	      headersList: response.headersList
	    })
	  } else if (type === 'opaque') {
	    // An opaque filtered response is a filtered response whose type is
	    // "opaque", URL list is the empty list, status is 0, status message
	    // is the empty byte sequence, header list is empty, and body is null.

	    return makeFilteredResponse(response, {
	      type: 'opaque',
	      urlList: Object.freeze([]),
	      status: 0,
	      statusText: '',
	      body: null
	    })
	  } else if (type === 'opaqueredirect') {
	    // An opaque-redirect filtered response is a filtered response whose type
	    // is "opaqueredirect", status is 0, status message is the empty byte
	    // sequence, header list is empty, and body is null.

	    return makeFilteredResponse(response, {
	      type: 'opaqueredirect',
	      status: 0,
	      statusText: '',
	      headersList: [],
	      body: null
	    })
	  } else {
	    assert(false);
	  }
	}

	// https://fetch.spec.whatwg.org/#appropriate-network-error
	function makeAppropriateNetworkError (fetchParams, err = null) {
	  // 1. Assert: fetchParams is canceled.
	  assert(isCancelled(fetchParams));

	  // 2. Return an aborted network error if fetchParams is aborted;
	  // otherwise return a network error.
	  return isAborted(fetchParams)
	    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))
	    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))
	}

	// https://whatpr.org/fetch/1392.html#initialize-a-response
	function initializeResponse (response, init, body) {
	  // 1. If init["status"] is not in the range 200 to 599, inclusive, then
	  //    throw a RangeError.
	  if (init.status !== null && (init.status < 200 || init.status > 599)) {
	    throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.')
	  }

	  // 2. If init["statusText"] does not match the reason-phrase token production,
	  //    then throw a TypeError.
	  if ('statusText' in init && init.statusText != null) {
	    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
	    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
	    if (!isValidReasonPhrase(String(init.statusText))) {
	      throw new TypeError('Invalid statusText')
	    }
	  }

	  // 3. Set responses responses status to init["status"].
	  if ('status' in init && init.status != null) {
	    response[kState].status = init.status;
	  }

	  // 4. Set responses responses status message to init["statusText"].
	  if ('statusText' in init && init.statusText != null) {
	    response[kState].statusText = init.statusText;
	  }

	  // 5. If init["headers"] exists, then fill responses headers with init["headers"].
	  if ('headers' in init && init.headers != null) {
	    fill(response[kHeaders], init.headers);
	  }

	  // 6. If body was given, then:
	  if (body) {
	    // 1. If response's status is a null body status, then throw a TypeError.
	    if (nullBodyStatus.includes(response.status)) {
	      throw webidl.errors.exception({
	        header: 'Response constructor',
	        message: 'Invalid response status code ' + response.status
	      })
	    }

	    // 2. Set response's body to body's body.
	    response[kState].body = body.body;

	    // 3. If body's type is non-null and response's header list does not contain
	    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
	    if (body.type != null && !response[kState].headersList.contains('Content-Type')) {
	      response[kState].headersList.append('content-type', body.type);
	    }
	  }
	}

	webidl.converters.ReadableStream = webidl.interfaceConverter(
	  ReadableStream
	);

	webidl.converters.FormData = webidl.interfaceConverter(
	  FormData
	);

	webidl.converters.URLSearchParams = webidl.interfaceConverter(
	  URLSearchParams
	);

	// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
	webidl.converters.XMLHttpRequestBodyInit = function (V) {
	  if (typeof V === 'string') {
	    return webidl.converters.USVString(V)
	  }

	  if (isBlobLike(V)) {
	    return webidl.converters.Blob(V, { strict: false })
	  }

	  if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
	    return webidl.converters.BufferSource(V)
	  }

	  if (util.isFormDataLike(V)) {
	    return webidl.converters.FormData(V, { strict: false })
	  }

	  if (V instanceof URLSearchParams) {
	    return webidl.converters.URLSearchParams(V)
	  }

	  return webidl.converters.DOMString(V)
	};

	// https://fetch.spec.whatwg.org/#bodyinit
	webidl.converters.BodyInit = function (V) {
	  if (V instanceof ReadableStream) {
	    return webidl.converters.ReadableStream(V)
	  }

	  // Note: the spec doesn't include async iterables,
	  // this is an undici extension.
	  if (V?.[Symbol.asyncIterator]) {
	    return V
	  }

	  return webidl.converters.XMLHttpRequestBodyInit(V)
	};

	webidl.converters.ResponseInit = webidl.dictionaryConverter([
	  {
	    key: 'status',
	    converter: webidl.converters['unsigned short'],
	    defaultValue: 200
	  },
	  {
	    key: 'statusText',
	    converter: webidl.converters.ByteString,
	    defaultValue: ''
	  },
	  {
	    key: 'headers',
	    converter: webidl.converters.HeadersInit
	  }
	]);

	response = {
	  makeNetworkError,
	  makeResponse,
	  makeAppropriateNetworkError,
	  filterResponse,
	  Response,
	  cloneResponse
	};
	return response;
}

/* globals AbortController */

var request$1;
var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request$1;
	hasRequiredRequest = 1;

	const { extractBody, mixinBody, cloneBody } = requireBody();
	const { Headers, fill: fillHeaders, HeadersList } = requireHeaders();
	const { FinalizationRegistry } = requireDispatcherWeakref()();
	const util = requireUtil$8();
	const {
	  isValidHTTPToken,
	  sameOrigin,
	  normalizeMethod,
	  makePolicyContainer,
	  normalizeMethodRecord
	} = requireUtil$7();
	const {
	  forbiddenMethodsSet,
	  corsSafeListedMethodsSet,
	  referrerPolicy,
	  requestRedirect,
	  requestMode,
	  requestCredentials,
	  requestCache,
	  requestDuplex
	} = requireConstants$4();
	const { kEnumerableProperty } = util;
	const { kHeaders, kSignal, kState, kGuard, kRealm } = requireSymbols$3();
	const { webidl } = requireWebidl();
	const { getGlobalOrigin } = requireGlobal$1();
	const { URLSerializer } = requireDataURL();
	const { kHeadersList, kConstruct } = requireSymbols$4();
	const assert = require$$0$8;
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require$$0$6;

	let TransformStream = globalThis.TransformStream;

	const kAbortController = Symbol('abortController');

	const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
	  signal.removeEventListener('abort', abort);
	});

	// https://fetch.spec.whatwg.org/#request-class
	class Request {
	  // https://fetch.spec.whatwg.org/#dom-request
	  constructor (input, init = {}) {
	    if (input === kConstruct) {
	      return
	    }

	    webidl.argumentLengthCheck(arguments, 1, { header: 'Request constructor' });

	    input = webidl.converters.RequestInfo(input);
	    init = webidl.converters.RequestInit(init);

	    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object
	    this[kRealm] = {
	      settingsObject: {
	        baseUrl: getGlobalOrigin(),
	        get origin () {
	          return this.baseUrl?.origin
	        },
	        policyContainer: makePolicyContainer()
	      }
	    };

	    // 1. Let request be null.
	    let request = null;

	    // 2. Let fallbackMode be null.
	    let fallbackMode = null;

	    // 3. Let baseURL be thiss relevant settings objects API base URL.
	    const baseUrl = this[kRealm].settingsObject.baseUrl;

	    // 4. Let signal be null.
	    let signal = null;

	    // 5. If input is a string, then:
	    if (typeof input === 'string') {
	      // 1. Let parsedURL be the result of parsing input with baseURL.
	      // 2. If parsedURL is failure, then throw a TypeError.
	      let parsedURL;
	      try {
	        parsedURL = new URL(input, baseUrl);
	      } catch (err) {
	        throw new TypeError('Failed to parse URL from ' + input, { cause: err })
	      }

	      // 3. If parsedURL includes credentials, then throw a TypeError.
	      if (parsedURL.username || parsedURL.password) {
	        throw new TypeError(
	          'Request cannot be constructed from a URL that includes credentials: ' +
	            input
	        )
	      }

	      // 4. Set request to a new request whose URL is parsedURL.
	      request = makeRequest({ urlList: [parsedURL] });

	      // 5. Set fallbackMode to "cors".
	      fallbackMode = 'cors';
	    } else {
	      // 6. Otherwise:

	      // 7. Assert: input is a Request object.
	      assert(input instanceof Request);

	      // 8. Set request to inputs request.
	      request = input[kState];

	      // 9. Set signal to inputs signal.
	      signal = input[kSignal];
	    }

	    // 7. Let origin be thiss relevant settings objects origin.
	    const origin = this[kRealm].settingsObject.origin;

	    // 8. Let window be "client".
	    let window = 'client';

	    // 9. If requests window is an environment settings object and its origin
	    // is same origin with origin, then set window to requests window.
	    if (
	      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&
	      sameOrigin(request.window, origin)
	    ) {
	      window = request.window;
	    }

	    // 10. If init["window"] exists and is non-null, then throw a TypeError.
	    if (init.window != null) {
	      throw new TypeError(`'window' option '${window}' must be null`)
	    }

	    // 11. If init["window"] exists, then set window to "no-window".
	    if ('window' in init) {
	      window = 'no-window';
	    }

	    // 12. Set request to a new request with the following properties:
	    request = makeRequest({
	      // URL requests URL.
	      // undici implementation note: this is set as the first item in request's urlList in makeRequest
	      // method requests method.
	      method: request.method,
	      // header list A copy of requests header list.
	      // undici implementation note: headersList is cloned in makeRequest
	      headersList: request.headersList,
	      // unsafe-request flag Set.
	      unsafeRequest: request.unsafeRequest,
	      // client Thiss relevant settings object.
	      client: this[kRealm].settingsObject,
	      // window window.
	      window,
	      // priority requests priority.
	      priority: request.priority,
	      // origin requests origin. The propagation of the origin is only significant for navigation requests
	      // being handled by a service worker. In this scenario a request can have an origin that is different
	      // from the current client.
	      origin: request.origin,
	      // referrer requests referrer.
	      referrer: request.referrer,
	      // referrer policy requests referrer policy.
	      referrerPolicy: request.referrerPolicy,
	      // mode requests mode.
	      mode: request.mode,
	      // credentials mode requests credentials mode.
	      credentials: request.credentials,
	      // cache mode requests cache mode.
	      cache: request.cache,
	      // redirect mode requests redirect mode.
	      redirect: request.redirect,
	      // integrity metadata requests integrity metadata.
	      integrity: request.integrity,
	      // keepalive requests keepalive.
	      keepalive: request.keepalive,
	      // reload-navigation flag requests reload-navigation flag.
	      reloadNavigation: request.reloadNavigation,
	      // history-navigation flag requests history-navigation flag.
	      historyNavigation: request.historyNavigation,
	      // URL list A clone of requests URL list.
	      urlList: [...request.urlList]
	    });

	    const initHasKey = Object.keys(init).length !== 0;

	    // 13. If init is not empty, then:
	    if (initHasKey) {
	      // 1. If requests mode is "navigate", then set it to "same-origin".
	      if (request.mode === 'navigate') {
	        request.mode = 'same-origin';
	      }

	      // 2. Unset requests reload-navigation flag.
	      request.reloadNavigation = false;

	      // 3. Unset requests history-navigation flag.
	      request.historyNavigation = false;

	      // 4. Set requests origin to "client".
	      request.origin = 'client';

	      // 5. Set requests referrer to "client"
	      request.referrer = 'client';

	      // 6. Set requests referrer policy to the empty string.
	      request.referrerPolicy = '';

	      // 7. Set requests URL to requests current URL.
	      request.url = request.urlList[request.urlList.length - 1];

	      // 8. Set requests URL list to  requests URL .
	      request.urlList = [request.url];
	    }

	    // 14. If init["referrer"] exists, then:
	    if (init.referrer !== undefined) {
	      // 1. Let referrer be init["referrer"].
	      const referrer = init.referrer;

	      // 2. If referrer is the empty string, then set requests referrer to "no-referrer".
	      if (referrer === '') {
	        request.referrer = 'no-referrer';
	      } else {
	        // 1. Let parsedReferrer be the result of parsing referrer with
	        // baseURL.
	        // 2. If parsedReferrer is failure, then throw a TypeError.
	        let parsedReferrer;
	        try {
	          parsedReferrer = new URL(referrer, baseUrl);
	        } catch (err) {
	          throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err })
	        }

	        // 3. If one of the following is true
	        // - parsedReferrers scheme is "about" and path is the string "client"
	        // - parsedReferrers origin is not same origin with origin
	        // then set requests referrer to "client".
	        if (
	          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||
	          (origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
	        ) {
	          request.referrer = 'client';
	        } else {
	          // 4. Otherwise, set requests referrer to parsedReferrer.
	          request.referrer = parsedReferrer;
	        }
	      }
	    }

	    // 15. If init["referrerPolicy"] exists, then set requests referrer policy
	    // to it.
	    if (init.referrerPolicy !== undefined) {
	      request.referrerPolicy = init.referrerPolicy;
	    }

	    // 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
	    let mode;
	    if (init.mode !== undefined) {
	      mode = init.mode;
	    } else {
	      mode = fallbackMode;
	    }

	    // 17. If mode is "navigate", then throw a TypeError.
	    if (mode === 'navigate') {
	      throw webidl.errors.exception({
	        header: 'Request constructor',
	        message: 'invalid request mode navigate.'
	      })
	    }

	    // 18. If mode is non-null, set requests mode to mode.
	    if (mode != null) {
	      request.mode = mode;
	    }

	    // 19. If init["credentials"] exists, then set requests credentials mode
	    // to it.
	    if (init.credentials !== undefined) {
	      request.credentials = init.credentials;
	    }

	    // 18. If init["cache"] exists, then set requests cache mode to it.
	    if (init.cache !== undefined) {
	      request.cache = init.cache;
	    }

	    // 21. If requests cache mode is "only-if-cached" and requests mode is
	    // not "same-origin", then throw a TypeError.
	    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
	      throw new TypeError(
	        "'only-if-cached' can be set only with 'same-origin' mode"
	      )
	    }

	    // 22. If init["redirect"] exists, then set requests redirect mode to it.
	    if (init.redirect !== undefined) {
	      request.redirect = init.redirect;
	    }

	    // 23. If init["integrity"] exists, then set requests integrity metadata to it.
	    if (init.integrity != null) {
	      request.integrity = String(init.integrity);
	    }

	    // 24. If init["keepalive"] exists, then set requests keepalive to it.
	    if (init.keepalive !== undefined) {
	      request.keepalive = Boolean(init.keepalive);
	    }

	    // 25. If init["method"] exists, then:
	    if (init.method !== undefined) {
	      // 1. Let method be init["method"].
	      let method = init.method;

	      // 2. If method is not a method or method is a forbidden method, then
	      // throw a TypeError.
	      if (!isValidHTTPToken(method)) {
	        throw new TypeError(`'${method}' is not a valid HTTP method.`)
	      }

	      if (forbiddenMethodsSet.has(method.toUpperCase())) {
	        throw new TypeError(`'${method}' HTTP method is unsupported.`)
	      }

	      // 3. Normalize method.
	      method = normalizeMethodRecord[method] ?? normalizeMethod(method);

	      // 4. Set requests method to method.
	      request.method = method;
	    }

	    // 26. If init["signal"] exists, then set signal to it.
	    if (init.signal !== undefined) {
	      signal = init.signal;
	    }

	    // 27. Set thiss request to request.
	    this[kState] = request;

	    // 28. Set thiss signal to a new AbortSignal object with thiss relevant
	    // Realm.
	    // TODO: could this be simplified with AbortSignal.any
	    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)
	    const ac = new AbortController();
	    this[kSignal] = ac.signal;
	    this[kSignal][kRealm] = this[kRealm];

	    // 29. If signal is not null, then make thiss signal follow signal.
	    if (signal != null) {
	      if (
	        !signal ||
	        typeof signal.aborted !== 'boolean' ||
	        typeof signal.addEventListener !== 'function'
	      ) {
	        throw new TypeError(
	          "Failed to construct 'Request': member signal is not of type AbortSignal."
	        )
	      }

	      if (signal.aborted) {
	        ac.abort(signal.reason);
	      } else {
	        // Keep a strong ref to ac while request object
	        // is alive. This is needed to prevent AbortController
	        // from being prematurely garbage collected.
	        // See, https://github.com/nodejs/undici/issues/1926.
	        this[kAbortController] = ac;

	        const acRef = new WeakRef(ac);
	        const abort = function () {
	          const ac = acRef.deref();
	          if (ac !== undefined) {
	            ac.abort(this.reason);
	          }
	        };

	        // Third-party AbortControllers may not work with these.
	        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.
	        try {
	          // If the max amount of listeners is equal to the default, increase it
	          // This is only available in node >= v19.9.0
	          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {
	            setMaxListeners(100, signal);
	          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {
	            setMaxListeners(100, signal);
	          }
	        } catch {}

	        util.addAbortListener(signal, abort);
	        requestFinalizer.register(ac, { signal, abort });
	      }
	    }

	    // 30. Set thiss headers to a new Headers object with thiss relevant
	    // Realm, whose header list is requests header list and guard is
	    // "request".
	    this[kHeaders] = new Headers(kConstruct);
	    this[kHeaders][kHeadersList] = request.headersList;
	    this[kHeaders][kGuard] = 'request';
	    this[kHeaders][kRealm] = this[kRealm];

	    // 31. If thiss requests mode is "no-cors", then:
	    if (mode === 'no-cors') {
	      // 1. If thiss requests method is not a CORS-safelisted method,
	      // then throw a TypeError.
	      if (!corsSafeListedMethodsSet.has(request.method)) {
	        throw new TypeError(
	          `'${request.method} is unsupported in no-cors mode.`
	        )
	      }

	      // 2. Set thiss headerss guard to "request-no-cors".
	      this[kHeaders][kGuard] = 'request-no-cors';
	    }

	    // 32. If init is not empty, then:
	    if (initHasKey) {
	      /** @type {HeadersList} */
	      const headersList = this[kHeaders][kHeadersList];
	      // 1. Let headers be a copy of thiss headers and its associated header
	      // list.
	      // 2. If init["headers"] exists, then set headers to init["headers"].
	      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);

	      // 3. Empty thiss headerss header list.
	      headersList.clear();

	      // 4. If headers is a Headers object, then for each header in its header
	      // list, append headers name/headers value to thiss headers.
	      if (headers instanceof HeadersList) {
	        for (const [key, val] of headers) {
	          headersList.append(key, val);
	        }
	        // Note: Copy the `set-cookie` meta-data.
	        headersList.cookies = headers.cookies;
	      } else {
	        // 5. Otherwise, fill thiss headers with headers.
	        fillHeaders(this[kHeaders], headers);
	      }
	    }

	    // 33. Let inputBody be inputs requests body if input is a Request
	    // object; otherwise null.
	    const inputBody = input instanceof Request ? input[kState].body : null;

	    // 34. If either init["body"] exists and is non-null or inputBody is
	    // non-null, and requests method is `GET` or `HEAD`, then throw a
	    // TypeError.
	    if (
	      (init.body != null || inputBody != null) &&
	      (request.method === 'GET' || request.method === 'HEAD')
	    ) {
	      throw new TypeError('Request with GET/HEAD method cannot have body.')
	    }

	    // 35. Let initBody be null.
	    let initBody = null;

	    // 36. If init["body"] exists and is non-null, then:
	    if (init.body != null) {
	      // 1. Let Content-Type be null.
	      // 2. Set initBody and Content-Type to the result of extracting
	      // init["body"], with keepalive set to requests keepalive.
	      const [extractedBody, contentType] = extractBody(
	        init.body,
	        request.keepalive
	      );
	      initBody = extractedBody;

	      // 3, If Content-Type is non-null and thiss headerss header list does
	      // not contain `Content-Type`, then append `Content-Type`/Content-Type to
	      // thiss headers.
	      if (contentType && !this[kHeaders][kHeadersList].contains('content-type')) {
	        this[kHeaders].append('content-type', contentType);
	      }
	    }

	    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise
	    // inputBody.
	    const inputOrInitBody = initBody ?? inputBody;

	    // 38. If inputOrInitBody is non-null and inputOrInitBodys source is
	    // null, then:
	    if (inputOrInitBody != null && inputOrInitBody.source == null) {
	      // 1. If initBody is non-null and init["duplex"] does not exist,
	      //    then throw a TypeError.
	      if (initBody != null && init.duplex == null) {
	        throw new TypeError('RequestInit: duplex option is required when sending a body.')
	      }

	      // 2. If thiss requests mode is neither "same-origin" nor "cors",
	      // then throw a TypeError.
	      if (request.mode !== 'same-origin' && request.mode !== 'cors') {
	        throw new TypeError(
	          'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
	        )
	      }

	      // 3. Set thiss requests use-CORS-preflight flag.
	      request.useCORSPreflightFlag = true;
	    }

	    // 39. Let finalBody be inputOrInitBody.
	    let finalBody = inputOrInitBody;

	    // 40. If initBody is null and inputBody is non-null, then:
	    if (initBody == null && inputBody != null) {
	      // 1. If input is unusable, then throw a TypeError.
	      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
	        throw new TypeError(
	          'Cannot construct a Request with a Request object that has already been used.'
	        )
	      }

	      // 2. Set finalBody to the result of creating a proxy for inputBody.
	      if (!TransformStream) {
	        TransformStream = require$$14.TransformStream;
	      }

	      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy
	      const identityTransform = new TransformStream();
	      inputBody.stream.pipeThrough(identityTransform);
	      finalBody = {
	        source: inputBody.source,
	        length: inputBody.length,
	        stream: identityTransform.readable
	      };
	    }

	    // 41. Set thiss requests body to finalBody.
	    this[kState].body = finalBody;
	  }

	  // Returns requests HTTP method, which is "GET" by default.
	  get method () {
	    webidl.brandCheck(this, Request);

	    // The method getter steps are to return thiss requests method.
	    return this[kState].method
	  }

	  // Returns the URL of request as a string.
	  get url () {
	    webidl.brandCheck(this, Request);

	    // The url getter steps are to return thiss requests URL, serialized.
	    return URLSerializer(this[kState].url)
	  }

	  // Returns a Headers object consisting of the headers associated with request.
	  // Note that headers added in the network layer by the user agent will not
	  // be accounted for in this object, e.g., the "Host" header.
	  get headers () {
	    webidl.brandCheck(this, Request);

	    // The headers getter steps are to return thiss headers.
	    return this[kHeaders]
	  }

	  // Returns the kind of resource requested by request, e.g., "document"
	  // or "script".
	  get destination () {
	    webidl.brandCheck(this, Request);

	    // The destination getter are to return thiss requests destination.
	    return this[kState].destination
	  }

	  // Returns the referrer of request. Its value can be a same-origin URL if
	  // explicitly set in init, the empty string to indicate no referrer, and
	  // "about:client" when defaulting to the globals default. This is used
	  // during fetching to determine the value of the `Referer` header of the
	  // request being made.
	  get referrer () {
	    webidl.brandCheck(this, Request);

	    // 1. If thiss requests referrer is "no-referrer", then return the
	    // empty string.
	    if (this[kState].referrer === 'no-referrer') {
	      return ''
	    }

	    // 2. If thiss requests referrer is "client", then return
	    // "about:client".
	    if (this[kState].referrer === 'client') {
	      return 'about:client'
	    }

	    // Return thiss requests referrer, serialized.
	    return this[kState].referrer.toString()
	  }

	  // Returns the referrer policy associated with request.
	  // This is used during fetching to compute the value of the requests
	  // referrer.
	  get referrerPolicy () {
	    webidl.brandCheck(this, Request);

	    // The referrerPolicy getter steps are to return thiss requests referrer policy.
	    return this[kState].referrerPolicy
	  }

	  // Returns the mode associated with request, which is a string indicating
	  // whether the request will use CORS, or will be restricted to same-origin
	  // URLs.
	  get mode () {
	    webidl.brandCheck(this, Request);

	    // The mode getter steps are to return thiss requests mode.
	    return this[kState].mode
	  }

	  // Returns the credentials mode associated with request,
	  // which is a string indicating whether credentials will be sent with the
	  // request always, never, or only when sent to a same-origin URL.
	  get credentials () {
	    // The credentials getter steps are to return thiss requests credentials mode.
	    return this[kState].credentials
	  }

	  // Returns the cache mode associated with request,
	  // which is a string indicating how the request will
	  // interact with the browsers cache when fetching.
	  get cache () {
	    webidl.brandCheck(this, Request);

	    // The cache getter steps are to return thiss requests cache mode.
	    return this[kState].cache
	  }

	  // Returns the redirect mode associated with request,
	  // which is a string indicating how redirects for the
	  // request will be handled during fetching. A request
	  // will follow redirects by default.
	  get redirect () {
	    webidl.brandCheck(this, Request);

	    // The redirect getter steps are to return thiss requests redirect mode.
	    return this[kState].redirect
	  }

	  // Returns requests subresource integrity metadata, which is a
	  // cryptographic hash of the resource being fetched. Its value
	  // consists of multiple hashes separated by whitespace. [SRI]
	  get integrity () {
	    webidl.brandCheck(this, Request);

	    // The integrity getter steps are to return thiss requests integrity
	    // metadata.
	    return this[kState].integrity
	  }

	  // Returns a boolean indicating whether or not request can outlive the
	  // global in which it was created.
	  get keepalive () {
	    webidl.brandCheck(this, Request);

	    // The keepalive getter steps are to return thiss requests keepalive.
	    return this[kState].keepalive
	  }

	  // Returns a boolean indicating whether or not request is for a reload
	  // navigation.
	  get isReloadNavigation () {
	    webidl.brandCheck(this, Request);

	    // The isReloadNavigation getter steps are to return true if thiss
	    // requests reload-navigation flag is set; otherwise false.
	    return this[kState].reloadNavigation
	  }

	  // Returns a boolean indicating whether or not request is for a history
	  // navigation (a.k.a. back-foward navigation).
	  get isHistoryNavigation () {
	    webidl.brandCheck(this, Request);

	    // The isHistoryNavigation getter steps are to return true if thiss requests
	    // history-navigation flag is set; otherwise false.
	    return this[kState].historyNavigation
	  }

	  // Returns the signal associated with request, which is an AbortSignal
	  // object indicating whether or not request has been aborted, and its
	  // abort event handler.
	  get signal () {
	    webidl.brandCheck(this, Request);

	    // The signal getter steps are to return thiss signal.
	    return this[kSignal]
	  }

	  get body () {
	    webidl.brandCheck(this, Request);

	    return this[kState].body ? this[kState].body.stream : null
	  }

	  get bodyUsed () {
	    webidl.brandCheck(this, Request);

	    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
	  }

	  get duplex () {
	    webidl.brandCheck(this, Request);

	    return 'half'
	  }

	  // Returns a clone of request.
	  clone () {
	    webidl.brandCheck(this, Request);

	    // 1. If this is unusable, then throw a TypeError.
	    if (this.bodyUsed || this.body?.locked) {
	      throw new TypeError('unusable')
	    }

	    // 2. Let clonedRequest be the result of cloning thiss request.
	    const clonedRequest = cloneRequest(this[kState]);

	    // 3. Let clonedRequestObject be the result of creating a Request object,
	    // given clonedRequest, thiss headerss guard, and thiss relevant Realm.
	    const clonedRequestObject = new Request(kConstruct);
	    clonedRequestObject[kState] = clonedRequest;
	    clonedRequestObject[kRealm] = this[kRealm];
	    clonedRequestObject[kHeaders] = new Headers(kConstruct);
	    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
	    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
	    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];

	    // 4. Make clonedRequestObjects signal follow thiss signal.
	    const ac = new AbortController();
	    if (this.signal.aborted) {
	      ac.abort(this.signal.reason);
	    } else {
	      util.addAbortListener(
	        this.signal,
	        () => {
	          ac.abort(this.signal.reason);
	        }
	      );
	    }
	    clonedRequestObject[kSignal] = ac.signal;

	    // 4. Return clonedRequestObject.
	    return clonedRequestObject
	  }
	}

	mixinBody(Request);

	function makeRequest (init) {
	  // https://fetch.spec.whatwg.org/#requests
	  const request = {
	    method: 'GET',
	    localURLsOnly: false,
	    unsafeRequest: false,
	    body: null,
	    client: null,
	    reservedClient: null,
	    replacesClientId: '',
	    window: 'client',
	    keepalive: false,
	    serviceWorkers: 'all',
	    initiator: '',
	    destination: '',
	    priority: null,
	    origin: 'client',
	    policyContainer: 'client',
	    referrer: 'client',
	    referrerPolicy: '',
	    mode: 'no-cors',
	    useCORSPreflightFlag: false,
	    credentials: 'same-origin',
	    useCredentials: false,
	    cache: 'default',
	    redirect: 'follow',
	    integrity: '',
	    cryptoGraphicsNonceMetadata: '',
	    parserMetadata: '',
	    reloadNavigation: false,
	    historyNavigation: false,
	    userActivation: false,
	    taintedOrigin: false,
	    redirectCount: 0,
	    responseTainting: 'basic',
	    preventNoCacheCacheControlHeaderModification: false,
	    done: false,
	    timingAllowFailed: false,
	    ...init,
	    headersList: init.headersList
	      ? new HeadersList(init.headersList)
	      : new HeadersList()
	  };
	  request.url = request.urlList[0];
	  return request
	}

	// https://fetch.spec.whatwg.org/#concept-request-clone
	function cloneRequest (request) {
	  // To clone a request request, run these steps:

	  // 1. Let newRequest be a copy of request, except for its body.
	  const newRequest = makeRequest({ ...request, body: null });

	  // 2. If requests body is non-null, set newRequests body to the
	  // result of cloning requests body.
	  if (request.body != null) {
	    newRequest.body = cloneBody(request.body);
	  }

	  // 3. Return newRequest.
	  return newRequest
	}

	Object.defineProperties(Request.prototype, {
	  method: kEnumerableProperty,
	  url: kEnumerableProperty,
	  headers: kEnumerableProperty,
	  redirect: kEnumerableProperty,
	  clone: kEnumerableProperty,
	  signal: kEnumerableProperty,
	  duplex: kEnumerableProperty,
	  destination: kEnumerableProperty,
	  body: kEnumerableProperty,
	  bodyUsed: kEnumerableProperty,
	  isHistoryNavigation: kEnumerableProperty,
	  isReloadNavigation: kEnumerableProperty,
	  keepalive: kEnumerableProperty,
	  integrity: kEnumerableProperty,
	  cache: kEnumerableProperty,
	  credentials: kEnumerableProperty,
	  attribute: kEnumerableProperty,
	  referrerPolicy: kEnumerableProperty,
	  referrer: kEnumerableProperty,
	  mode: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'Request',
	    configurable: true
	  }
	});

	webidl.converters.Request = webidl.interfaceConverter(
	  Request
	);

	// https://fetch.spec.whatwg.org/#requestinfo
	webidl.converters.RequestInfo = function (V) {
	  if (typeof V === 'string') {
	    return webidl.converters.USVString(V)
	  }

	  if (V instanceof Request) {
	    return webidl.converters.Request(V)
	  }

	  return webidl.converters.USVString(V)
	};

	webidl.converters.AbortSignal = webidl.interfaceConverter(
	  AbortSignal
	);

	// https://fetch.spec.whatwg.org/#requestinit
	webidl.converters.RequestInit = webidl.dictionaryConverter([
	  {
	    key: 'method',
	    converter: webidl.converters.ByteString
	  },
	  {
	    key: 'headers',
	    converter: webidl.converters.HeadersInit
	  },
	  {
	    key: 'body',
	    converter: webidl.nullableConverter(
	      webidl.converters.BodyInit
	    )
	  },
	  {
	    key: 'referrer',
	    converter: webidl.converters.USVString
	  },
	  {
	    key: 'referrerPolicy',
	    converter: webidl.converters.DOMString,
	    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
	    allowedValues: referrerPolicy
	  },
	  {
	    key: 'mode',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#concept-request-mode
	    allowedValues: requestMode
	  },
	  {
	    key: 'credentials',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestcredentials
	    allowedValues: requestCredentials
	  },
	  {
	    key: 'cache',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestcache
	    allowedValues: requestCache
	  },
	  {
	    key: 'redirect',
	    converter: webidl.converters.DOMString,
	    // https://fetch.spec.whatwg.org/#requestredirect
	    allowedValues: requestRedirect
	  },
	  {
	    key: 'integrity',
	    converter: webidl.converters.DOMString
	  },
	  {
	    key: 'keepalive',
	    converter: webidl.converters.boolean
	  },
	  {
	    key: 'signal',
	    converter: webidl.nullableConverter(
	      (signal) => webidl.converters.AbortSignal(
	        signal,
	        { strict: false }
	      )
	    )
	  },
	  {
	    key: 'window',
	    converter: webidl.converters.any
	  },
	  {
	    key: 'duplex',
	    converter: webidl.converters.DOMString,
	    allowedValues: requestDuplex
	  }
	]);

	request$1 = { Request, makeRequest };
	return request$1;
}

var fetch_1$1;
var hasRequiredFetch$1;

function requireFetch$1 () {
	if (hasRequiredFetch$1) return fetch_1$1;
	hasRequiredFetch$1 = 1;

	const {
	  Response,
	  makeNetworkError,
	  makeAppropriateNetworkError,
	  filterResponse,
	  makeResponse
	} = requireResponse();
	const { Headers } = requireHeaders();
	const { Request, makeRequest } = requireRequest();
	const zlib = require$$3__default;
	const {
	  bytesMatch,
	  makePolicyContainer,
	  clonePolicyContainer,
	  requestBadPort,
	  TAOCheck,
	  appendRequestOriginHeader,
	  responseLocationURL,
	  requestCurrentURL,
	  setRequestReferrerPolicyOnRedirect,
	  tryUpgradeRequestToAPotentiallyTrustworthyURL,
	  createOpaqueTimingInfo,
	  appendFetchMetadata,
	  corsCheck,
	  crossOriginResourcePolicyCheck,
	  determineRequestsReferrer,
	  coarsenedSharedCurrentTime,
	  createDeferredPromise,
	  isBlobLike,
	  sameOrigin,
	  isCancelled,
	  isAborted,
	  isErrorLike,
	  fullyReadBody,
	  readableStreamClose,
	  isomorphicEncode,
	  urlIsLocal,
	  urlIsHttpHttpsScheme,
	  urlHasHttpsScheme
	} = requireUtil$7();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const assert = require$$0$8;
	const { safelyExtractBody } = requireBody();
	const {
	  redirectStatusSet,
	  nullBodyStatus,
	  safeMethodsSet,
	  requestBodyHeader,
	  subresourceSet,
	  DOMException
	} = requireConstants$4();
	const { kHeadersList } = requireSymbols$4();
	const EE = require$$0$6;
	const { Readable, pipeline } = require$$0$9;
	const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = requireUtil$8();
	const { dataURLProcessor, serializeAMimeType } = requireDataURL();
	const { TransformStream } = require$$14;
	const { getGlobalDispatcher } = requireGlobal();
	const { webidl } = requireWebidl();
	const { STATUS_CODES } = require$$2__default;
	const GET_OR_HEAD = ['GET', 'HEAD'];

	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream = globalThis.ReadableStream;

	class Fetch extends EE {
	  constructor (dispatcher) {
	    super();

	    this.dispatcher = dispatcher;
	    this.connection = null;
	    this.dump = false;
	    this.state = 'ongoing';
	    // 2 terminated listeners get added per request,
	    // but only 1 gets removed. If there are 20 redirects,
	    // 21 listeners will be added.
	    // See https://github.com/nodejs/undici/issues/1711
	    // TODO (fix): Find and fix root cause for leaked listener.
	    this.setMaxListeners(21);
	  }

	  terminate (reason) {
	    if (this.state !== 'ongoing') {
	      return
	    }

	    this.state = 'terminated';
	    this.connection?.destroy(reason);
	    this.emit('terminated', reason);
	  }

	  // https://fetch.spec.whatwg.org/#fetch-controller-abort
	  abort (error) {
	    if (this.state !== 'ongoing') {
	      return
	    }

	    // 1. Set controllers state to "aborted".
	    this.state = 'aborted';

	    // 2. Let fallbackError be an "AbortError" DOMException.
	    // 3. Set error to fallbackError if it is not given.
	    if (!error) {
	      error = new DOMException('The operation was aborted.', 'AbortError');
	    }

	    // 4. Let serializedError be StructuredSerialize(error).
	    //    If that threw an exception, catch it, and let
	    //    serializedError be StructuredSerialize(fallbackError).

	    // 5. Set controllers serialized abort reason to serializedError.
	    this.serializedAbortReason = error;

	    this.connection?.destroy(error);
	    this.emit('terminated', error);
	  }
	}

	// https://fetch.spec.whatwg.org/#fetch-method
	function fetch (input, init = {}) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'globalThis.fetch' });

	  // 1. Let p be a new promise.
	  const p = createDeferredPromise();

	  // 2. Let requestObject be the result of invoking the initial value of
	  // Request as constructor with input and init as arguments. If this throws
	  // an exception, reject p with it and return p.
	  let requestObject;

	  try {
	    requestObject = new Request(input, init);
	  } catch (e) {
	    p.reject(e);
	    return p.promise
	  }

	  // 3. Let request be requestObjects request.
	  const request = requestObject[kState];

	  // 4. If requestObjects signals aborted flag is set, then:
	  if (requestObject.signal.aborted) {
	    // 1. Abort the fetch() call with p, request, null, and
	    //    requestObjects signals abort reason.
	    abortFetch(p, request, null, requestObject.signal.reason);

	    // 2. Return p.
	    return p.promise
	  }

	  // 5. Let globalObject be requests clients global object.
	  const globalObject = request.client.globalObject;

	  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set
	  // requests service-workers mode to "none".
	  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
	    request.serviceWorkers = 'none';
	  }

	  // 7. Let responseObject be null.
	  let responseObject = null;

	  // 8. Let relevantRealm be thiss relevant Realm.
	  const relevantRealm = null;

	  // 9. Let locallyAborted be false.
	  let locallyAborted = false;

	  // 10. Let controller be null.
	  let controller = null;

	  // 11. Add the following abort steps to requestObjects signal:
	  addAbortListener(
	    requestObject.signal,
	    () => {
	      // 1. Set locallyAborted to true.
	      locallyAborted = true;

	      // 2. Assert: controller is non-null.
	      assert(controller != null);

	      // 3. Abort controller with requestObjects signals abort reason.
	      controller.abort(requestObject.signal.reason);

	      // 4. Abort the fetch() call with p, request, responseObject,
	      //    and requestObjects signals abort reason.
	      abortFetch(p, request, responseObject, requestObject.signal.reason);
	    }
	  );

	  // 12. Let handleFetchDone given response response be to finalize and
	  // report timing with response, globalObject, and "fetch".
	  const handleFetchDone = (response) =>
	    finalizeAndReportTiming(response, 'fetch');

	  // 13. Set controller to the result of calling fetch given request,
	  // with processResponseEndOfBody set to handleFetchDone, and processResponse
	  // given response being these substeps:

	  const processResponse = (response) => {
	    // 1. If locallyAborted is true, terminate these substeps.
	    if (locallyAborted) {
	      return Promise.resolve()
	    }

	    // 2. If responses aborted flag is set, then:
	    if (response.aborted) {
	      // 1. Let deserializedError be the result of deserialize a serialized
	      //    abort reason given controllers serialized abort reason and
	      //    relevantRealm.

	      // 2. Abort the fetch() call with p, request, responseObject, and
	      //    deserializedError.

	      abortFetch(p, request, responseObject, controller.serializedAbortReason);
	      return Promise.resolve()
	    }

	    // 3. If response is a network error, then reject p with a TypeError
	    // and terminate these substeps.
	    if (response.type === 'error') {
	      p.reject(
	        Object.assign(new TypeError('fetch failed'), { cause: response.error })
	      );
	      return Promise.resolve()
	    }

	    // 4. Set responseObject to the result of creating a Response object,
	    // given response, "immutable", and relevantRealm.
	    responseObject = new Response();
	    responseObject[kState] = response;
	    responseObject[kRealm] = relevantRealm;
	    responseObject[kHeaders][kHeadersList] = response.headersList;
	    responseObject[kHeaders][kGuard] = 'immutable';
	    responseObject[kHeaders][kRealm] = relevantRealm;

	    // 5. Resolve p with responseObject.
	    p.resolve(responseObject);
	  };

	  controller = fetching({
	    request,
	    processResponseEndOfBody: handleFetchDone,
	    processResponse,
	    dispatcher: init.dispatcher ?? getGlobalDispatcher() // undici
	  });

	  // 14. Return p.
	  return p.promise
	}

	// https://fetch.spec.whatwg.org/#finalize-and-report-timing
	function finalizeAndReportTiming (response, initiatorType = 'other') {
	  // 1. If response is an aborted network error, then return.
	  if (response.type === 'error' && response.aborted) {
	    return
	  }

	  // 2. If responses URL list is null or empty, then return.
	  if (!response.urlList?.length) {
	    return
	  }

	  // 3. Let originalURL be responses URL list[0].
	  const originalURL = response.urlList[0];

	  // 4. Let timingInfo be responses timing info.
	  let timingInfo = response.timingInfo;

	  // 5. Let cacheState be responses cache state.
	  let cacheState = response.cacheState;

	  // 6. If originalURLs scheme is not an HTTP(S) scheme, then return.
	  if (!urlIsHttpHttpsScheme(originalURL)) {
	    return
	  }

	  // 7. If timingInfo is null, then return.
	  if (timingInfo === null) {
	    return
	  }

	  // 8. If responses timing allow passed flag is not set, then:
	  if (!response.timingAllowPassed) {
	    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
	    timingInfo = createOpaqueTimingInfo({
	      startTime: timingInfo.startTime
	    });

	    //  2. Set cacheState to the empty string.
	    cacheState = '';
	  }

	  // 9. Set timingInfos end time to the coarsened shared current time
	  // given globals relevant settings objects cross-origin isolated
	  // capability.
	  // TODO: given globals relevant settings objects cross-origin isolated
	  // capability?
	  timingInfo.endTime = coarsenedSharedCurrentTime();

	  // 10. Set responses timing info to timingInfo.
	  response.timingInfo = timingInfo;

	  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,
	  // global, and cacheState.
	  markResourceTiming(
	    timingInfo,
	    originalURL,
	    initiatorType,
	    globalThis,
	    cacheState
	  );
	}

	// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
	function markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {
	  if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
	    performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis, cacheState);
	  }
	}

	// https://fetch.spec.whatwg.org/#abort-fetch
	function abortFetch (p, request, responseObject, error) {
	  // Note: AbortSignal.reason was added in node v17.2.0
	  // which would give us an undefined error to reject with.
	  // Remove this once node v16 is no longer supported.
	  if (!error) {
	    error = new DOMException('The operation was aborted.', 'AbortError');
	  }

	  // 1. Reject promise with error.
	  p.reject(error);

	  // 2. If requests body is not null and is readable, then cancel requests
	  // body with error.
	  if (request.body != null && isReadable(request.body?.stream)) {
	    request.body.stream.cancel(error).catch((err) => {
	      if (err.code === 'ERR_INVALID_STATE') {
	        // Node bug?
	        return
	      }
	      throw err
	    });
	  }

	  // 3. If responseObject is null, then return.
	  if (responseObject == null) {
	    return
	  }

	  // 4. Let response be responseObjects response.
	  const response = responseObject[kState];

	  // 5. If responses body is not null and is readable, then error responses
	  // body with error.
	  if (response.body != null && isReadable(response.body?.stream)) {
	    response.body.stream.cancel(error).catch((err) => {
	      if (err.code === 'ERR_INVALID_STATE') {
	        // Node bug?
	        return
	      }
	      throw err
	    });
	  }
	}

	// https://fetch.spec.whatwg.org/#fetching
	function fetching ({
	  request,
	  processRequestBodyChunkLength,
	  processRequestEndOfBody,
	  processResponse,
	  processResponseEndOfBody,
	  processResponseConsumeBody,
	  useParallelQueue = false,
	  dispatcher // undici
	}) {
	  // 1. Let taskDestination be null.
	  let taskDestination = null;

	  // 2. Let crossOriginIsolatedCapability be false.
	  let crossOriginIsolatedCapability = false;

	  // 3. If requests client is non-null, then:
	  if (request.client != null) {
	    // 1. Set taskDestination to requests clients global object.
	    taskDestination = request.client.globalObject;

	    // 2. Set crossOriginIsolatedCapability to requests clients cross-origin
	    // isolated capability.
	    crossOriginIsolatedCapability =
	      request.client.crossOriginIsolatedCapability;
	  }

	  // 4. If useParallelQueue is true, then set taskDestination to the result of
	  // starting a new parallel queue.
	  // TODO

	  // 5. Let timingInfo be a new fetch timing info whose start time and
	  // post-redirect start time are the coarsened shared current time given
	  // crossOriginIsolatedCapability.
	  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
	  const timingInfo = createOpaqueTimingInfo({
	    startTime: currenTime
	  });

	  // 6. Let fetchParams be a new fetch params whose
	  // request is request,
	  // timing info is timingInfo,
	  // process request body chunk length is processRequestBodyChunkLength,
	  // process request end-of-body is processRequestEndOfBody,
	  // process response is processResponse,
	  // process response consume body is processResponseConsumeBody,
	  // process response end-of-body is processResponseEndOfBody,
	  // task destination is taskDestination,
	  // and cross-origin isolated capability is crossOriginIsolatedCapability.
	  const fetchParams = {
	    controller: new Fetch(dispatcher),
	    request,
	    timingInfo,
	    processRequestBodyChunkLength,
	    processRequestEndOfBody,
	    processResponse,
	    processResponseConsumeBody,
	    processResponseEndOfBody,
	    taskDestination,
	    crossOriginIsolatedCapability
	  };

	  // 7. If requests body is a byte sequence, then set requests body to
	  //    requests body as a body.
	  // NOTE: Since fetching is only called from fetch, body should already be
	  // extracted.
	  assert(!request.body || request.body.stream);

	  // 8. If requests window is "client", then set requests window to requests
	  // client, if requests clients global object is a Window object; otherwise
	  // "no-window".
	  if (request.window === 'client') {
	    // TODO: What if request.client is null?
	    request.window =
	      request.client?.globalObject?.constructor?.name === 'Window'
	        ? request.client
	        : 'no-window';
	  }

	  // 9. If requests origin is "client", then set requests origin to requests
	  // clients origin.
	  if (request.origin === 'client') {
	    // TODO: What if request.client is null?
	    request.origin = request.client?.origin;
	  }

	  // 10. If all of the following conditions are true:
	  // TODO

	  // 11. If requests policy container is "client", then:
	  if (request.policyContainer === 'client') {
	    // 1. If requests client is non-null, then set requests policy
	    // container to a clone of requests clients policy container. [HTML]
	    if (request.client != null) {
	      request.policyContainer = clonePolicyContainer(
	        request.client.policyContainer
	      );
	    } else {
	      // 2. Otherwise, set requests policy container to a new policy
	      // container.
	      request.policyContainer = makePolicyContainer();
	    }
	  }

	  // 12. If requests header list does not contain `Accept`, then:
	  if (!request.headersList.contains('accept')) {
	    // 1. Let value be `*/*`.
	    const value = '*/*';

	    // 2. A user agent should set value to the first matching statement, if
	    // any, switching on requests destination:
	    // "document"
	    // "frame"
	    // "iframe"
	    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
	    // "image"
	    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
	    // "style"
	    // `text/css,*/*;q=0.1`
	    // TODO

	    // 3. Append `Accept`/value to requests header list.
	    request.headersList.append('accept', value);
	  }

	  // 13. If requests header list does not contain `Accept-Language`, then
	  // user agents should append `Accept-Language`/an appropriate value to
	  // requests header list.
	  if (!request.headersList.contains('accept-language')) {
	    request.headersList.append('accept-language', '*');
	  }

	  // 14. If requests priority is null, then use requests initiator and
	  // destination appropriately in setting requests priority to a
	  // user-agent-defined object.
	  if (request.priority === null) ;

	  // 15. If request is a subresource request, then:
	  if (subresourceSet.has(request.destination)) ;

	  // 16. Run main fetch given fetchParams.
	  mainFetch(fetchParams)
	    .catch(err => {
	      fetchParams.controller.terminate(err);
	    });

	  // 17. Return fetchParam's controller
	  return fetchParams.controller
	}

	// https://fetch.spec.whatwg.org/#concept-main-fetch
	async function mainFetch (fetchParams, recursive = false) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. If requests local-URLs-only flag is set and requests current URL is
	  // not local, then set response to a network error.
	  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
	    response = makeNetworkError('local URLs only');
	  }

	  // 4. Run report Content Security Policy violations for request.
	  // TODO

	  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.
	  tryUpgradeRequestToAPotentiallyTrustworthyURL(request);

	  // 6. If should request be blocked due to a bad port, should fetching request
	  // be blocked as mixed content, or should request be blocked by Content
	  // Security Policy returns blocked, then set response to a network error.
	  if (requestBadPort(request) === 'blocked') {
	    response = makeNetworkError('bad port');
	  }
	  // TODO: should fetching request be blocked as mixed content?
	  // TODO: should request be blocked by Content Security Policy?

	  // 7. If requests referrer policy is the empty string, then set requests
	  // referrer policy to requests policy containers referrer policy.
	  if (request.referrerPolicy === '') {
	    request.referrerPolicy = request.policyContainer.referrerPolicy;
	  }

	  // 8. If requests referrer is not "no-referrer", then set requests
	  // referrer to the result of invoking determine requests referrer.
	  if (request.referrer !== 'no-referrer') {
	    request.referrer = determineRequestsReferrer(request);
	  }

	  // 9. Set requests current URLs scheme to "https" if all of the following
	  // conditions are true:
	  // - requests current URLs scheme is "http"
	  // - requests current URLs host is a domain
	  // - Matching requests current URLs host per Known HSTS Host Domain Name
	  //   Matching results in either a superdomain match with an asserted
	  //   includeSubDomains directive or a congruent match (with or without an
	  //   asserted includeSubDomains directive). [HSTS]
	  // TODO

	  // 10. If recursive is false, then run the remaining steps in parallel.
	  // TODO

	  // 11. If response is null, then set response to the result of running
	  // the steps corresponding to the first matching statement:
	  if (response === null) {
	    response = await (async () => {
	      const currentURL = requestCurrentURL(request);

	      if (
	        // - requests current URLs origin is same origin with requests origin,
	        //   and requests response tainting is "basic"
	        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||
	        // requests current URLs scheme is "data"
	        (currentURL.protocol === 'data:') ||
	        // - requests mode is "navigate" or "websocket"
	        (request.mode === 'navigate' || request.mode === 'websocket')
	      ) {
	        // 1. Set requests response tainting to "basic".
	        request.responseTainting = 'basic';

	        // 2. Return the result of running scheme fetch given fetchParams.
	        return await schemeFetch(fetchParams)
	      }

	      // requests mode is "same-origin"
	      if (request.mode === 'same-origin') {
	        // 1. Return a network error.
	        return makeNetworkError('request mode cannot be "same-origin"')
	      }

	      // requests mode is "no-cors"
	      if (request.mode === 'no-cors') {
	        // 1. If requests redirect mode is not "follow", then return a network
	        // error.
	        if (request.redirect !== 'follow') {
	          return makeNetworkError(
	            'redirect mode cannot be "follow" for "no-cors" request'
	          )
	        }

	        // 2. Set requests response tainting to "opaque".
	        request.responseTainting = 'opaque';

	        // 3. Return the result of running scheme fetch given fetchParams.
	        return await schemeFetch(fetchParams)
	      }

	      // requests current URLs scheme is not an HTTP(S) scheme
	      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
	        // Return a network error.
	        return makeNetworkError('URL scheme must be a HTTP(S) scheme')
	      }

	      // - requests use-CORS-preflight flag is set
	      // - requests unsafe-request flag is set and either requests method is
	      //   not a CORS-safelisted method or CORS-unsafe request-header names with
	      //   requests header list is not empty
	      //    1. Set requests response tainting to "cors".
	      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch
	      //    given fetchParams and true.
	      //    3. If corsWithPreflightResponse is a network error, then clear cache
	      //    entries using request.
	      //    4. Return corsWithPreflightResponse.
	      // TODO

	      // Otherwise
	      //    1. Set requests response tainting to "cors".
	      request.responseTainting = 'cors';

	      //    2. Return the result of running HTTP fetch given fetchParams.
	      return await httpFetch(fetchParams)
	    })();
	  }

	  // 12. If recursive is true, then return response.
	  if (recursive) {
	    return response
	  }

	  // 13. If response is not a network error and response is not a filtered
	  // response, then:
	  if (response.status !== 0 && !response.internalResponse) {
	    // If requests response tainting is "cors", then:
	    if (request.responseTainting === 'cors') ;

	    // Set response to the following filtered response with response as its
	    // internal response, depending on requests response tainting:
	    if (request.responseTainting === 'basic') {
	      response = filterResponse(response, 'basic');
	    } else if (request.responseTainting === 'cors') {
	      response = filterResponse(response, 'cors');
	    } else if (request.responseTainting === 'opaque') {
	      response = filterResponse(response, 'opaque');
	    } else {
	      assert(false);
	    }
	  }

	  // 14. Let internalResponse be response, if response is a network error,
	  // and responses internal response otherwise.
	  let internalResponse =
	    response.status === 0 ? response : response.internalResponse;

	  // 15. If internalResponses URL list is empty, then set it to a clone of
	  // requests URL list.
	  if (internalResponse.urlList.length === 0) {
	    internalResponse.urlList.push(...request.urlList);
	  }

	  // 16. If requests timing allow failed flag is unset, then set
	  // internalResponses timing allow passed flag.
	  if (!request.timingAllowFailed) {
	    response.timingAllowPassed = true;
	  }

	  // 17. If response is not a network error and any of the following returns
	  // blocked
	  // - should internalResponse to request be blocked as mixed content
	  // - should internalResponse to request be blocked by Content Security Policy
	  // - should internalResponse to request be blocked due to its MIME type
	  // - should internalResponse to request be blocked due to nosniff
	  // TODO

	  // 18. If responses type is "opaque", internalResponses status is 206,
	  // internalResponses range-requested flag is set, and requests header
	  // list does not contain `Range`, then set response and internalResponse
	  // to a network error.
	  if (
	    response.type === 'opaque' &&
	    internalResponse.status === 206 &&
	    internalResponse.rangeRequested &&
	    !request.headers.contains('range')
	  ) {
	    response = internalResponse = makeNetworkError();
	  }

	  // 19. If response is not a network error and either requests method is
	  // `HEAD` or `CONNECT`, or internalResponses status is a null body status,
	  // set internalResponses body to null and disregard any enqueuing toward
	  // it (if any).
	  if (
	    response.status !== 0 &&
	    (request.method === 'HEAD' ||
	      request.method === 'CONNECT' ||
	      nullBodyStatus.includes(internalResponse.status))
	  ) {
	    internalResponse.body = null;
	    fetchParams.controller.dump = true;
	  }

	  // 20. If requests integrity metadata is not the empty string, then:
	  if (request.integrity) {
	    // 1. Let processBodyError be this step: run fetch finale given fetchParams
	    // and a network error.
	    const processBodyError = (reason) =>
	      fetchFinale(fetchParams, makeNetworkError(reason));

	    // 2. If requests response tainting is "opaque", or responses body is null,
	    // then run processBodyError and abort these steps.
	    if (request.responseTainting === 'opaque' || response.body == null) {
	      processBodyError(response.error);
	      return
	    }

	    // 3. Let processBody given bytes be these steps:
	    const processBody = (bytes) => {
	      // 1. If bytes do not match requests integrity metadata,
	      // then run processBodyError and abort these steps. [SRI]
	      if (!bytesMatch(bytes, request.integrity)) {
	        processBodyError('integrity mismatch');
	        return
	      }

	      // 2. Set responses body to bytes as a body.
	      response.body = safelyExtractBody(bytes)[0];

	      // 3. Run fetch finale given fetchParams and response.
	      fetchFinale(fetchParams, response);
	    };

	    // 4. Fully read responses body given processBody and processBodyError.
	    await fullyReadBody(response.body, processBody, processBodyError);
	  } else {
	    // 21. Otherwise, run fetch finale given fetchParams and response.
	    fetchFinale(fetchParams, response);
	  }
	}

	// https://fetch.spec.whatwg.org/#concept-scheme-fetch
	// given a fetch params fetchParams
	function schemeFetch (fetchParams) {
	  // Note: since the connection is destroyed on redirect, which sets fetchParams to a
	  // cancelled state, we do not want this condition to trigger *unless* there have been
	  // no redirects. See https://github.com/nodejs/undici/issues/1776
	  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
	    return Promise.resolve(makeAppropriateNetworkError(fetchParams))
	  }

	  // 2. Let request be fetchParamss request.
	  const { request } = fetchParams;

	  const { protocol: scheme } = requestCurrentURL(request);

	  // 3. Switch on requests current URLs scheme and run the associated steps:
	  switch (scheme) {
	    case 'about:': {
	      // If requests current URLs path is the string "blank", then return a new response
	      // whose status message is `OK`, header list is  (`Content-Type`, `text/html;charset=utf-8`) ,
	      // and body is the empty byte sequence as a body.

	      // Otherwise, return a network error.
	      return Promise.resolve(makeNetworkError('about scheme is not supported'))
	    }
	    case 'blob:': {
	      if (!resolveObjectURL) {
	        resolveObjectURL = require$$7.resolveObjectURL;
	      }

	      // 1. Let blobURLEntry be requests current URLs blob URL entry.
	      const blobURLEntry = requestCurrentURL(request);

	      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
	      // Buffer.resolveObjectURL does not ignore URL queries.
	      if (blobURLEntry.search.length !== 0) {
	        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))
	      }

	      const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());

	      // 2. If requests method is not `GET`, blobURLEntry is null, or blobURLEntrys
	      //    object is not a Blob object, then return a network error.
	      if (request.method !== 'GET' || !isBlobLike(blobURLEntryObject)) {
	        return Promise.resolve(makeNetworkError('invalid method'))
	      }

	      // 3. Let bodyWithType be the result of safely extracting blobURLEntrys object.
	      const bodyWithType = safelyExtractBody(blobURLEntryObject);

	      // 4. Let body be bodyWithTypes body.
	      const body = bodyWithType[0];

	      // 5. Let length be bodys length, serialized and isomorphic encoded.
	      const length = isomorphicEncode(`${body.length}`);

	      // 6. Let type be bodyWithTypes type if it is non-null; otherwise the empty byte sequence.
	      const type = bodyWithType[1] ?? '';

	      // 7. Return a new response whose status message is `OK`, header list is
	      //     (`Content-Length`, length), (`Content-Type`, type) , and body is body.
	      const response = makeResponse({
	        statusText: 'OK',
	        headersList: [
	          ['content-length', { name: 'Content-Length', value: length }],
	          ['content-type', { name: 'Content-Type', value: type }]
	        ]
	      });

	      response.body = body;

	      return Promise.resolve(response)
	    }
	    case 'data:': {
	      // 1. Let dataURLStruct be the result of running the
	      //    data: URL processor on requests current URL.
	      const currentURL = requestCurrentURL(request);
	      const dataURLStruct = dataURLProcessor(currentURL);

	      // 2. If dataURLStruct is failure, then return a
	      //    network error.
	      if (dataURLStruct === 'failure') {
	        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))
	      }

	      // 3. Let mimeType be dataURLStructs MIME type, serialized.
	      const mimeType = serializeAMimeType(dataURLStruct.mimeType);

	      // 4. Return a response whose status message is `OK`,
	      //    header list is  (`Content-Type`, mimeType) ,
	      //    and body is dataURLStructs body as a body.
	      return Promise.resolve(makeResponse({
	        statusText: 'OK',
	        headersList: [
	          ['content-type', { name: 'Content-Type', value: mimeType }]
	        ],
	        body: safelyExtractBody(dataURLStruct.body)[0]
	      }))
	    }
	    case 'file:': {
	      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.
	      // When in doubt, return a network error.
	      return Promise.resolve(makeNetworkError('not implemented... yet...'))
	    }
	    case 'http:':
	    case 'https:': {
	      // Return the result of running HTTP fetch given fetchParams.

	      return httpFetch(fetchParams)
	        .catch((err) => makeNetworkError(err))
	    }
	    default: {
	      return Promise.resolve(makeNetworkError('unknown scheme'))
	    }
	  }
	}

	// https://fetch.spec.whatwg.org/#finalize-response
	function finalizeResponse (fetchParams, response) {
	  // 1. Set fetchParamss requests done flag.
	  fetchParams.request.done = true;

	  // 2, If fetchParamss process response done is not null, then queue a fetch
	  // task to run fetchParamss process response done given response, with
	  // fetchParamss task destination.
	  if (fetchParams.processResponseDone != null) {
	    queueMicrotask(() => fetchParams.processResponseDone(response));
	  }
	}

	// https://fetch.spec.whatwg.org/#fetch-finale
	function fetchFinale (fetchParams, response) {
	  // 1. If response is a network error, then:
	  if (response.type === 'error') {
	    // 1. Set responses URL list to  fetchParamss requests URL list[0] .
	    response.urlList = [fetchParams.request.urlList[0]];

	    // 2. Set responses timing info to the result of creating an opaque timing
	    // info for fetchParamss timing info.
	    response.timingInfo = createOpaqueTimingInfo({
	      startTime: fetchParams.timingInfo.startTime
	    });
	  }

	  // 2. Let processResponseEndOfBody be the following steps:
	  const processResponseEndOfBody = () => {
	    // 1. Set fetchParamss requests done flag.
	    fetchParams.request.done = true;

	    // If fetchParamss process response end-of-body is not null,
	    // then queue a fetch task to run fetchParamss process response
	    // end-of-body given response with fetchParamss task destination.
	    if (fetchParams.processResponseEndOfBody != null) {
	      queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
	    }
	  };

	  // 3. If fetchParamss process response is non-null, then queue a fetch task
	  // to run fetchParamss process response given response, with fetchParamss
	  // task destination.
	  if (fetchParams.processResponse != null) {
	    queueMicrotask(() => fetchParams.processResponse(response));
	  }

	  // 4. If responses body is null, then run processResponseEndOfBody.
	  if (response.body == null) {
	    processResponseEndOfBody();
	  } else {
	  // 5. Otherwise:

	    // 1. Let transformStream be a new a TransformStream.

	    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,
	    // enqueues chunk in transformStream.
	    const identityTransformAlgorithm = (chunk, controller) => {
	      controller.enqueue(chunk);
	    };

	    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm
	    // and flushAlgorithm set to processResponseEndOfBody.
	    const transformStream = new TransformStream({
	      start () {},
	      transform: identityTransformAlgorithm,
	      flush: processResponseEndOfBody
	    }, {
	      size () {
	        return 1
	      }
	    }, {
	      size () {
	        return 1
	      }
	    });

	    // 4. Set responses body to the result of piping responses body through transformStream.
	    response.body = { stream: response.body.stream.pipeThrough(transformStream) };
	  }

	  // 6. If fetchParamss process response consume body is non-null, then:
	  if (fetchParams.processResponseConsumeBody != null) {
	    // 1. Let processBody given nullOrBytes be this step: run fetchParamss
	    // process response consume body given response and nullOrBytes.
	    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);

	    // 2. Let processBodyError be this step: run fetchParamss process
	    // response consume body given response and failure.
	    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);

	    // 3. If responses body is null, then queue a fetch task to run processBody
	    // given null, with fetchParamss task destination.
	    if (response.body == null) {
	      queueMicrotask(() => processBody(null));
	    } else {
	      // 4. Otherwise, fully read responses body given processBody, processBodyError,
	      // and fetchParamss task destination.
	      return fullyReadBody(response.body, processBody, processBodyError)
	    }
	    return Promise.resolve()
	  }
	}

	// https://fetch.spec.whatwg.org/#http-fetch
	async function httpFetch (fetchParams) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. Let actualResponse be null.
	  let actualResponse = null;

	  // 4. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 5. If requests service-workers mode is "all", then:
	  if (request.serviceWorkers === 'all') ;

	  // 6. If response is null, then:
	  if (response === null) {
	    // 1. If makeCORSPreflight is true and one of these conditions is true:
	    // TODO

	    // 2. If requests redirect mode is "follow", then set requests
	    // service-workers mode to "none".
	    if (request.redirect === 'follow') {
	      request.serviceWorkers = 'none';
	    }

	    // 3. Set response and actualResponse to the result of running
	    // HTTP-network-or-cache fetch given fetchParams.
	    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);

	    // 4. If requests response tainting is "cors" and a CORS check
	    // for request and response returns failure, then return a network error.
	    if (
	      request.responseTainting === 'cors' &&
	      corsCheck(request, response) === 'failure'
	    ) {
	      return makeNetworkError('cors failure')
	    }

	    // 5. If the TAO check for request and response returns failure, then set
	    // requests timing allow failed flag.
	    if (TAOCheck(request, response) === 'failure') {
	      request.timingAllowFailed = true;
	    }
	  }

	  // 7. If either requests response tainting or responses type
	  // is "opaque", and the cross-origin resource policy check with
	  // requests origin, requests client, requests destination,
	  // and actualResponse returns blocked, then return a network error.
	  if (
	    (request.responseTainting === 'opaque' || response.type === 'opaque') &&
	    crossOriginResourcePolicyCheck(
	      request.origin,
	      request.client,
	      request.destination,
	      actualResponse
	    ) === 'blocked'
	  ) {
	    return makeNetworkError('blocked')
	  }

	  // 8. If actualResponses status is a redirect status, then:
	  if (redirectStatusSet.has(actualResponse.status)) {
	    // 1. If actualResponses status is not 303, requests body is not null,
	    // and the connection uses HTTP/2, then user agents may, and are even
	    // encouraged to, transmit an RST_STREAM frame.
	    // See, https://github.com/whatwg/fetch/issues/1288
	    if (request.redirect !== 'manual') {
	      fetchParams.controller.connection.destroy();
	    }

	    // 2. Switch on requests redirect mode:
	    if (request.redirect === 'error') {
	      // Set response to a network error.
	      response = makeNetworkError('unexpected redirect');
	    } else if (request.redirect === 'manual') {
	      // Set response to an opaque-redirect filtered response whose internal
	      // response is actualResponse.
	      // NOTE(spec): On the web this would return an `opaqueredirect` response,
	      // but that doesn't make sense server side.
	      // See https://github.com/nodejs/undici/issues/1193.
	      response = actualResponse;
	    } else if (request.redirect === 'follow') {
	      // Set response to the result of running HTTP-redirect fetch given
	      // fetchParams and response.
	      response = await httpRedirectFetch(fetchParams, response);
	    } else {
	      assert(false);
	    }
	  }

	  // 9. Set responses timing info to timingInfo.
	  response.timingInfo = timingInfo;

	  // 10. Return response.
	  return response
	}

	// https://fetch.spec.whatwg.org/#http-redirect-fetch
	function httpRedirectFetch (fetchParams, response) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let actualResponse be response, if response is not a filtered response,
	  // and responses internal response otherwise.
	  const actualResponse = response.internalResponse
	    ? response.internalResponse
	    : response;

	  // 3. Let locationURL be actualResponses location URL given requests current
	  // URLs fragment.
	  let locationURL;

	  try {
	    locationURL = responseLocationURL(
	      actualResponse,
	      requestCurrentURL(request).hash
	    );

	    // 4. If locationURL is null, then return response.
	    if (locationURL == null) {
	      return response
	    }
	  } catch (err) {
	    // 5. If locationURL is failure, then return a network error.
	    return Promise.resolve(makeNetworkError(err))
	  }

	  // 6. If locationURLs scheme is not an HTTP(S) scheme, then return a network
	  // error.
	  if (!urlIsHttpHttpsScheme(locationURL)) {
	    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))
	  }

	  // 7. If requests redirect count is 20, then return a network error.
	  if (request.redirectCount === 20) {
	    return Promise.resolve(makeNetworkError('redirect count exceeded'))
	  }

	  // 8. Increase requests redirect count by 1.
	  request.redirectCount += 1;

	  // 9. If requests mode is "cors", locationURL includes credentials, and
	  // requests origin is not same origin with locationURLs origin, then return
	  //  a network error.
	  if (
	    request.mode === 'cors' &&
	    (locationURL.username || locationURL.password) &&
	    !sameOrigin(request, locationURL)
	  ) {
	    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'))
	  }

	  // 10. If requests response tainting is "cors" and locationURL includes
	  // credentials, then return a network error.
	  if (
	    request.responseTainting === 'cors' &&
	    (locationURL.username || locationURL.password)
	  ) {
	    return Promise.resolve(makeNetworkError(
	      'URL cannot contain credentials for request mode "cors"'
	    ))
	  }

	  // 11. If actualResponses status is not 303, requests body is non-null,
	  // and requests bodys source is null, then return a network error.
	  if (
	    actualResponse.status !== 303 &&
	    request.body != null &&
	    request.body.source == null
	  ) {
	    return Promise.resolve(makeNetworkError())
	  }

	  // 12. If one of the following is true
	  // - actualResponses status is 301 or 302 and requests method is `POST`
	  // - actualResponses status is 303 and requests method is not `GET` or `HEAD`
	  if (
	    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||
	    (actualResponse.status === 303 &&
	      !GET_OR_HEAD.includes(request.method))
	  ) {
	    // then:
	    // 1. Set requests method to `GET` and requests body to null.
	    request.method = 'GET';
	    request.body = null;

	    // 2. For each headerName of request-body-header name, delete headerName from
	    // requests header list.
	    for (const headerName of requestBodyHeader) {
	      request.headersList.delete(headerName);
	    }
	  }

	  // 13. If requests current URLs origin is not same origin with locationURLs
	  //     origin, then for each headerName of CORS non-wildcard request-header name,
	  //     delete headerName from requests header list.
	  if (!sameOrigin(requestCurrentURL(request), locationURL)) {
	    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name
	    request.headersList.delete('authorization');

	    // https://fetch.spec.whatwg.org/#authentication-entries
	    request.headersList.delete('proxy-authorization', true);

	    // "Cookie" and "Host" are forbidden request-headers, which undici doesn't implement.
	    request.headersList.delete('cookie');
	    request.headersList.delete('host');
	  }

	  // 14. If requests body is non-null, then set requests body to the first return
	  // value of safely extracting requests bodys source.
	  if (request.body != null) {
	    assert(request.body.source != null);
	    request.body = safelyExtractBody(request.body.source)[0];
	  }

	  // 15. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 16. Set timingInfos redirect end time and post-redirect start time to the
	  // coarsened shared current time given fetchParamss cross-origin isolated
	  // capability.
	  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
	    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);

	  // 17. If timingInfos redirect start time is 0, then set timingInfos
	  //  redirect start time to timingInfos start time.
	  if (timingInfo.redirectStartTime === 0) {
	    timingInfo.redirectStartTime = timingInfo.startTime;
	  }

	  // 18. Append locationURL to requests URL list.
	  request.urlList.push(locationURL);

	  // 19. Invoke set requests referrer policy on redirect on request and
	  // actualResponse.
	  setRequestReferrerPolicyOnRedirect(request, actualResponse);

	  // 20. Return the result of running main fetch given fetchParams and true.
	  return mainFetch(fetchParams, true)
	}

	// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
	async function httpNetworkOrCacheFetch (
	  fetchParams,
	  isAuthenticationFetch = false,
	  isNewConnectionFetch = false
	) {
	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let httpFetchParams be null.
	  let httpFetchParams = null;

	  // 3. Let httpRequest be null.
	  let httpRequest = null;

	  // 4. Let response be null.
	  let response = null;

	  // 8. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. If requests window is "no-window" and requests redirect mode is
	  //    "error", then set httpFetchParams to fetchParams and httpRequest to
	  //    request.
	  if (request.window === 'no-window' && request.redirect === 'error') {
	    httpFetchParams = fetchParams;
	    httpRequest = request;
	  } else {
	    // Otherwise:

	    // 1. Set httpRequest to a clone of request.
	    httpRequest = makeRequest(request);

	    // 2. Set httpFetchParams to a copy of fetchParams.
	    httpFetchParams = { ...fetchParams };

	    // 3. Set httpFetchParamss request to httpRequest.
	    httpFetchParams.request = httpRequest;
	  }

	  //    3. Let includeCredentials be true if one of
	  const includeCredentials =
	    request.credentials === 'include' ||
	    (request.credentials === 'same-origin' &&
	      request.responseTainting === 'basic');

	  //    4. Let contentLength be httpRequests bodys length, if httpRequests
	  //    body is non-null; otherwise null.
	  const contentLength = httpRequest.body ? httpRequest.body.length : null;

	  //    5. Let contentLengthHeaderValue be null.
	  let contentLengthHeaderValue = null;

	  //    6. If httpRequests body is null and httpRequests method is `POST` or
	  //    `PUT`, then set contentLengthHeaderValue to `0`.
	  if (
	    httpRequest.body == null &&
	    ['POST', 'PUT'].includes(httpRequest.method)
	  ) {
	    contentLengthHeaderValue = '0';
	  }

	  //    7. If contentLength is non-null, then set contentLengthHeaderValue to
	  //    contentLength, serialized and isomorphic encoded.
	  if (contentLength != null) {
	    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
	  }

	  //    8. If contentLengthHeaderValue is non-null, then append
	  //    `Content-Length`/contentLengthHeaderValue to httpRequests header
	  //    list.
	  if (contentLengthHeaderValue != null) {
	    httpRequest.headersList.append('content-length', contentLengthHeaderValue);
	  }

	  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
	  //    contentLengthHeaderValue) to httpRequests header list.

	  //    10. If contentLength is non-null and httpRequests keepalive is true,
	  //    then:
	  if (contentLength != null && httpRequest.keepalive) ;

	  //    11. If httpRequests referrer is a URL, then append
	  //    `Referer`/httpRequests referrer, serialized and isomorphic encoded,
	  //     to httpRequests header list.
	  if (httpRequest.referrer instanceof URL) {
	    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href));
	  }

	  //    12. Append a request `Origin` header for httpRequest.
	  appendRequestOriginHeader(httpRequest);

	  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
	  appendFetchMetadata(httpRequest);

	  //    14. If httpRequests header list does not contain `User-Agent`, then
	  //    user agents should append `User-Agent`/default `User-Agent` value to
	  //    httpRequests header list.
	  if (!httpRequest.headersList.contains('user-agent')) {
	    httpRequest.headersList.append('user-agent', typeof esbuildDetection === 'undefined' ? 'undici' : 'node');
	  }

	  //    15. If httpRequests cache mode is "default" and httpRequests header
	  //    list contains `If-Modified-Since`, `If-None-Match`,
	  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
	  //    httpRequests cache mode to "no-store".
	  if (
	    httpRequest.cache === 'default' &&
	    (httpRequest.headersList.contains('if-modified-since') ||
	      httpRequest.headersList.contains('if-none-match') ||
	      httpRequest.headersList.contains('if-unmodified-since') ||
	      httpRequest.headersList.contains('if-match') ||
	      httpRequest.headersList.contains('if-range'))
	  ) {
	    httpRequest.cache = 'no-store';
	  }

	  //    16. If httpRequests cache mode is "no-cache", httpRequests prevent
	  //    no-cache cache-control header modification flag is unset, and
	  //    httpRequests header list does not contain `Cache-Control`, then append
	  //    `Cache-Control`/`max-age=0` to httpRequests header list.
	  if (
	    httpRequest.cache === 'no-cache' &&
	    !httpRequest.preventNoCacheCacheControlHeaderModification &&
	    !httpRequest.headersList.contains('cache-control')
	  ) {
	    httpRequest.headersList.append('cache-control', 'max-age=0');
	  }

	  //    17. If httpRequests cache mode is "no-store" or "reload", then:
	  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
	    // 1. If httpRequests header list does not contain `Pragma`, then append
	    // `Pragma`/`no-cache` to httpRequests header list.
	    if (!httpRequest.headersList.contains('pragma')) {
	      httpRequest.headersList.append('pragma', 'no-cache');
	    }

	    // 2. If httpRequests header list does not contain `Cache-Control`,
	    // then append `Cache-Control`/`no-cache` to httpRequests header list.
	    if (!httpRequest.headersList.contains('cache-control')) {
	      httpRequest.headersList.append('cache-control', 'no-cache');
	    }
	  }

	  //    18. If httpRequests header list contains `Range`, then append
	  //    `Accept-Encoding`/`identity` to httpRequests header list.
	  if (httpRequest.headersList.contains('range')) {
	    httpRequest.headersList.append('accept-encoding', 'identity');
	  }

	  //    19. Modify httpRequests header list per HTTP. Do not append a given
	  //    header if httpRequests header list contains that headers name.
	  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
	  if (!httpRequest.headersList.contains('accept-encoding')) {
	    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
	      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');
	    } else {
	      httpRequest.headersList.append('accept-encoding', 'gzip, deflate');
	    }
	  }

	  httpRequest.headersList.delete('host');

	  //    21. If theres a proxy-authentication entry, use it as appropriate.
	  //    TODO: proxy-authentication

	  //    22. Set httpCache to the result of determining the HTTP cache
	  //    partition, given httpRequest.
	  //    TODO: cache

	  //    23. If httpCache is null, then set httpRequests cache mode to
	  //    "no-store".
	  {
	    httpRequest.cache = 'no-store';
	  }

	  //    24. If httpRequests cache mode is neither "no-store" nor "reload",
	  //    then:
	  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') ;

	  // 9. If aborted, then return the appropriate network error for fetchParams.
	  // TODO

	  // 10. If response is null, then:
	  if (response == null) {
	    // 1. If httpRequests cache mode is "only-if-cached", then return a
	    // network error.
	    if (httpRequest.mode === 'only-if-cached') {
	      return makeNetworkError('only if cached')
	    }

	    // 2. Let forwardResponse be the result of running HTTP-network fetch
	    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.
	    const forwardResponse = await httpNetworkFetch(
	      httpFetchParams,
	      includeCredentials,
	      isNewConnectionFetch
	    );

	    // 3. If httpRequests method is unsafe and forwardResponses status is
	    // in the range 200 to 399, inclusive, invalidate appropriate stored
	    // responses in httpCache, as per the "Invalidation" chapter of HTTP
	    // Caching, and set storedResponse to null. [HTTP-CACHING]
	    if (
	      !safeMethodsSet.has(httpRequest.method) &&
	      forwardResponse.status >= 200 &&
	      forwardResponse.status <= 399
	    ) ;

	    // 5. If response is null, then:
	    if (response == null) {
	      // 1. Set response to forwardResponse.
	      response = forwardResponse;

	      // 2. Store httpRequest and forwardResponse in httpCache, as per the
	      // "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
	      // TODO: cache
	    }
	  }

	  // 11. Set responses URL list to a clone of httpRequests URL list.
	  response.urlList = [...httpRequest.urlList];

	  // 12. If httpRequests header list contains `Range`, then set responses
	  // range-requested flag.
	  if (httpRequest.headersList.contains('range')) {
	    response.rangeRequested = true;
	  }

	  // 13. Set responses request-includes-credentials to includeCredentials.
	  response.requestIncludesCredentials = includeCredentials;

	  // 14. If responses status is 401, httpRequests response tainting is not
	  // "cors", includeCredentials is true, and requests window is an environment
	  // settings object, then:
	  // TODO

	  // 15. If responses status is 407, then:
	  if (response.status === 407) {
	    // 1. If requests window is "no-window", then return a network error.
	    if (request.window === 'no-window') {
	      return makeNetworkError()
	    }

	    // 2. ???

	    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	    if (isCancelled(fetchParams)) {
	      return makeAppropriateNetworkError(fetchParams)
	    }

	    // 4. Prompt the end user as appropriate in requests window and store
	    // the result as a proxy-authentication entry. [HTTP-AUTH]
	    // TODO: Invoke some kind of callback?

	    // 5. Set response to the result of running HTTP-network-or-cache fetch given
	    // fetchParams.
	    // TODO
	    return makeNetworkError('proxy authentication required')
	  }

	  // 16. If all of the following are true
	  if (
	    // responses status is 421
	    response.status === 421 &&
	    // isNewConnectionFetch is false
	    !isNewConnectionFetch &&
	    // requests body is null, or requests body is non-null and requests bodys source is non-null
	    (request.body == null || request.body.source != null)
	  ) {
	    // then:

	    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
	    if (isCancelled(fetchParams)) {
	      return makeAppropriateNetworkError(fetchParams)
	    }

	    // 2. Set response to the result of running HTTP-network-or-cache
	    // fetch given fetchParams, isAuthenticationFetch, and true.

	    // TODO (spec): The spec doesn't specify this but we need to cancel
	    // the active response before we can start a new one.
	    // https://github.com/whatwg/fetch/issues/1293
	    fetchParams.controller.connection.destroy();

	    response = await httpNetworkOrCacheFetch(
	      fetchParams,
	      isAuthenticationFetch,
	      true
	    );
	  }

	  // 18. Return response.
	  return response
	}

	// https://fetch.spec.whatwg.org/#http-network-fetch
	async function httpNetworkFetch (
	  fetchParams,
	  includeCredentials = false,
	  forceNewConnection = false
	) {
	  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);

	  fetchParams.controller.connection = {
	    abort: null,
	    destroyed: false,
	    destroy (err) {
	      if (!this.destroyed) {
	        this.destroyed = true;
	        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'));
	      }
	    }
	  };

	  // 1. Let request be fetchParamss request.
	  const request = fetchParams.request;

	  // 2. Let response be null.
	  let response = null;

	  // 3. Let timingInfo be fetchParamss timing info.
	  const timingInfo = fetchParams.timingInfo;

	  // 5. If httpCache is null, then set requests cache mode to "no-store".
	  {
	    request.cache = 'no-store';
	  }

	  // 8. Switch on requests mode:
	  if (request.mode === 'websocket') ;

	  // 9. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. If connection is failure, then return a network error.

	  //    2. Set timingInfos final connection timing info to the result of
	  //    calling clamp and coarsen connection timing info with connections
	  //    timing info, timingInfos post-redirect start time, and fetchParamss
	  //    cross-origin isolated capability.

	  //    3. If connection is not an HTTP/2 connection, requests body is non-null,
	  //    and requests bodys source is null, then append (`Transfer-Encoding`,
	  //    `chunked`) to requests header list.

	  //    4. Set timingInfos final network-request start time to the coarsened
	  //    shared current time given fetchParamss cross-origin isolated
	  //    capability.

	  //    5. Set response to the result of making an HTTP request over connection
	  //    using request with the following caveats:

	  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
	  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

	  //        - If requests body is non-null, and requests bodys source is null,
	  //        then the user agent may have a buffer of up to 64 kibibytes and store
	  //        a part of requests body in that buffer. If the user agent reads from
	  //        requests body beyond that buffers size and the user agent needs to
	  //        resend request, then instead return a network error.

	  //        - Set timingInfos final network-response start time to the coarsened
	  //        shared current time given fetchParamss cross-origin isolated capability,
	  //        immediately after the user agents HTTP parser receives the first byte
	  //        of the response (e.g., frame header bytes for HTTP/2 or response status
	  //        line for HTTP/1.x).

	  //        - Wait until all the headers are transmitted.

	  //        - Any responses whose status is in the range 100 to 199, inclusive,
	  //        and is not 101, are to be ignored, except for the purposes of setting
	  //        timingInfos final network-response start time above.

	  //    - If requests header list contains `Transfer-Encoding`/`chunked` and
	  //    response is transferred via HTTP/1.0 or older, then return a network
	  //    error.

	  //    - If the HTTP request results in a TLS client certificate dialog, then:

	  //        1. If requests window is an environment settings object, make the
	  //        dialog available in requests window.

	  //        2. Otherwise, return a network error.

	  // To transmit requests body body, run these steps:
	  let requestBody = null;
	  // 1. If body is null and fetchParamss process request end-of-body is
	  // non-null, then queue a fetch task given fetchParamss process request
	  // end-of-body and fetchParamss task destination.
	  if (request.body == null && fetchParams.processRequestEndOfBody) {
	    queueMicrotask(() => fetchParams.processRequestEndOfBody());
	  } else if (request.body != null) {
	    // 2. Otherwise, if body is non-null:

	    //    1. Let processBodyChunk given bytes be these steps:
	    const processBodyChunk = async function * (bytes) {
	      // 1. If the ongoing fetch is terminated, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. Run this step in parallel: transmit bytes.
	      yield bytes;

	      // 3. If fetchParamss process request body is non-null, then run
	      // fetchParamss process request body given bytess length.
	      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
	    };

	    // 2. Let processEndOfBody be these steps:
	    const processEndOfBody = () => {
	      // 1. If fetchParams is canceled, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. If fetchParamss process request end-of-body is non-null,
	      // then run fetchParamss process request end-of-body.
	      if (fetchParams.processRequestEndOfBody) {
	        fetchParams.processRequestEndOfBody();
	      }
	    };

	    // 3. Let processBodyError given e be these steps:
	    const processBodyError = (e) => {
	      // 1. If fetchParams is canceled, then abort these steps.
	      if (isCancelled(fetchParams)) {
	        return
	      }

	      // 2. If e is an "AbortError" DOMException, then abort fetchParamss controller.
	      if (e.name === 'AbortError') {
	        fetchParams.controller.abort();
	      } else {
	        fetchParams.controller.terminate(e);
	      }
	    };

	    // 4. Incrementally read requests body given processBodyChunk, processEndOfBody,
	    // processBodyError, and fetchParamss task destination.
	    requestBody = (async function * () {
	      try {
	        for await (const bytes of request.body.stream) {
	          yield * processBodyChunk(bytes);
	        }
	        processEndOfBody();
	      } catch (err) {
	        processBodyError(err);
	      }
	    })();
	  }

	  try {
	    // socket is only provided for websockets
	    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });

	    if (socket) {
	      response = makeResponse({ status, statusText, headersList, socket });
	    } else {
	      const iterator = body[Symbol.asyncIterator]();
	      fetchParams.controller.next = () => iterator.next();

	      response = makeResponse({ status, statusText, headersList });
	    }
	  } catch (err) {
	    // 10. If aborted, then:
	    if (err.name === 'AbortError') {
	      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
	      fetchParams.controller.connection.destroy();

	      // 2. Return the appropriate network error for fetchParams.
	      return makeAppropriateNetworkError(fetchParams, err)
	    }

	    return makeNetworkError(err)
	  }

	  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch
	  // if it is suspended.
	  const pullAlgorithm = () => {
	    fetchParams.controller.resume();
	  };

	  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParamss
	  // controller with reason, given reason.
	  const cancelAlgorithm = (reason) => {
	    fetchParams.controller.abort(reason);
	  };

	  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
	  // the user agent.
	  // TODO

	  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
	  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
	  // TODO

	  // 15. Let stream be a new ReadableStream.
	  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,
	  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to
	  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.
	  if (!ReadableStream) {
	    ReadableStream = require$$14.ReadableStream;
	  }

	  const stream = new ReadableStream(
	    {
	      async start (controller) {
	        fetchParams.controller.controller = controller;
	      },
	      async pull (controller) {
	        await pullAlgorithm();
	      },
	      async cancel (reason) {
	        await cancelAlgorithm(reason);
	      }
	    },
	    {
	      highWaterMark: 0,
	      size () {
	        return 1
	      }
	    }
	  );

	  // 17. Run these steps, but abort when the ongoing fetch is terminated:

	  //    1. Set responses body to a new body whose stream is stream.
	  response.body = { stream };

	  //    2. If response is not a network error and requests cache mode is
	  //    not "no-store", then update response in httpCache for request.
	  //    TODO

	  //    3. If includeCredentials is true and the user agent is not configured
	  //    to block cookies for request (see section 7 of [COOKIES]), then run the
	  //    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
	  //    the value of each header whose name is a byte-case-insensitive match for
	  //    `Set-Cookie` in responses header list, if any, and requests current URL.
	  //    TODO

	  // 18. If aborted, then:
	  // TODO

	  // 19. Run these steps in parallel:

	  //    1. Run these steps, but abort when fetchParams is canceled:
	  fetchParams.controller.on('terminated', onAborted);
	  fetchParams.controller.resume = async () => {
	    // 1. While true
	    while (true) {
	      // 1-3. See onData...

	      // 4. Set bytes to the result of handling content codings given
	      // codings and bytes.
	      let bytes;
	      let isFailure;
	      try {
	        const { done, value } = await fetchParams.controller.next();

	        if (isAborted(fetchParams)) {
	          break
	        }

	        bytes = done ? undefined : value;
	      } catch (err) {
	        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
	          // zlib doesn't like empty streams.
	          bytes = undefined;
	        } else {
	          bytes = err;

	          // err may be propagated from the result of calling readablestream.cancel,
	          // which might not be an error. https://github.com/nodejs/undici/issues/2009
	          isFailure = true;
	        }
	      }

	      if (bytes === undefined) {
	        // 2. Otherwise, if the bytes transmission for responses message
	        // body is done normally and stream is readable, then close
	        // stream, finalize response for fetchParams and response, and
	        // abort these in-parallel steps.
	        readableStreamClose(fetchParams.controller.controller);

	        finalizeResponse(fetchParams, response);

	        return
	      }

	      // 5. Increase timingInfos decoded body size by bytess length.
	      timingInfo.decodedBodySize += bytes?.byteLength ?? 0;

	      // 6. If bytes is failure, then terminate fetchParamss controller.
	      if (isFailure) {
	        fetchParams.controller.terminate(bytes);
	        return
	      }

	      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
	      // into stream.
	      fetchParams.controller.controller.enqueue(new Uint8Array(bytes));

	      // 8. If stream is errored, then terminate the ongoing fetch.
	      if (isErrored(stream)) {
	        fetchParams.controller.terminate();
	        return
	      }

	      // 9. If stream doesnt need more data ask the user agent to suspend
	      // the ongoing fetch.
	      if (!fetchParams.controller.controller.desiredSize) {
	        return
	      }
	    }
	  };

	  //    2. If aborted, then:
	  function onAborted (reason) {
	    // 2. If fetchParams is aborted, then:
	    if (isAborted(fetchParams)) {
	      // 1. Set responses aborted flag.
	      response.aborted = true;

	      // 2. If stream is readable, then error stream with the result of
	      //    deserialize a serialized abort reason given fetchParamss
	      //    controllers serialized abort reason and an
	      //    implementation-defined realm.
	      if (isReadable(stream)) {
	        fetchParams.controller.controller.error(
	          fetchParams.controller.serializedAbortReason
	        );
	      }
	    } else {
	      // 3. Otherwise, if stream is readable, error stream with a TypeError.
	      if (isReadable(stream)) {
	        fetchParams.controller.controller.error(new TypeError('terminated', {
	          cause: isErrorLike(reason) ? reason : undefined
	        }));
	      }
	    }

	    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
	    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
	    fetchParams.controller.connection.destroy();
	  }

	  // 20. Return response.
	  return response

	  async function dispatch ({ body }) {
	    const url = requestCurrentURL(request);
	    /** @type {import('../..').Agent} */
	    const agent = fetchParams.controller.dispatcher;

	    return new Promise((resolve, reject) => agent.dispatch(
	      {
	        path: url.pathname + url.search,
	        origin: url.origin,
	        method: request.method,
	        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
	        headers: request.headersList.entries,
	        maxRedirections: 0,
	        upgrade: request.mode === 'websocket' ? 'websocket' : undefined
	      },
	      {
	        body: null,
	        abort: null,

	        onConnect (abort) {
	          // TODO (fix): Do we need connection here?
	          const { connection } = fetchParams.controller;

	          if (connection.destroyed) {
	            abort(new DOMException('The operation was aborted.', 'AbortError'));
	          } else {
	            fetchParams.controller.on('terminated', abort);
	            this.abort = connection.abort = abort;
	          }
	        },

	        onHeaders (status, headersList, resume, statusText) {
	          if (status < 200) {
	            return
	          }

	          let codings = [];
	          let location = '';

	          const headers = new Headers();

	          // For H2, the headers are a plain JS object
	          // We distinguish between them and iterate accordingly
	          if (Array.isArray(headersList)) {
	            for (let n = 0; n < headersList.length; n += 2) {
	              const key = headersList[n + 0].toString('latin1');
	              const val = headersList[n + 1].toString('latin1');
	              if (key.toLowerCase() === 'content-encoding') {
	                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
	                // "All content-coding values are case-insensitive..."
	                codings = val.toLowerCase().split(',').map((x) => x.trim());
	              } else if (key.toLowerCase() === 'location') {
	                location = val;
	              }

	              headers[kHeadersList].append(key, val);
	            }
	          } else {
	            const keys = Object.keys(headersList);
	            for (const key of keys) {
	              const val = headersList[key];
	              if (key.toLowerCase() === 'content-encoding') {
	                // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1
	                // "All content-coding values are case-insensitive..."
	                codings = val.toLowerCase().split(',').map((x) => x.trim()).reverse();
	              } else if (key.toLowerCase() === 'location') {
	                location = val;
	              }

	              headers[kHeadersList].append(key, val);
	            }
	          }

	          this.body = new Readable({ read: resume });

	          const decoders = [];

	          const willFollow = request.redirect === 'follow' &&
	            location &&
	            redirectStatusSet.has(status);

	          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
	          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {
	            for (const coding of codings) {
	              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2
	              if (coding === 'x-gzip' || coding === 'gzip') {
	                decoders.push(zlib.createGunzip({
	                  // Be less strict when decoding compressed responses, since sometimes
	                  // servers send slightly invalid responses that are still accepted
	                  // by common browsers.
	                  // Always using Z_SYNC_FLUSH is what cURL does.
	                  flush: zlib.constants.Z_SYNC_FLUSH,
	                  finishFlush: zlib.constants.Z_SYNC_FLUSH
	                }));
	              } else if (coding === 'deflate') {
	                decoders.push(zlib.createInflate());
	              } else if (coding === 'br') {
	                decoders.push(zlib.createBrotliDecompress());
	              } else {
	                decoders.length = 0;
	                break
	              }
	            }
	          }

	          resolve({
	            status,
	            statusText,
	            headersList: headers[kHeadersList],
	            body: decoders.length
	              ? pipeline(this.body, ...decoders, () => { })
	              : this.body.on('error', () => {})
	          });

	          return true
	        },

	        onData (chunk) {
	          if (fetchParams.controller.dump) {
	            return
	          }

	          // 1. If one or more bytes have been transmitted from responses
	          // message body, then:

	          //  1. Let bytes be the transmitted bytes.
	          const bytes = chunk;

	          //  2. Let codings be the result of extracting header list values
	          //  given `Content-Encoding` and responses header list.
	          //  See pullAlgorithm.

	          //  3. Increase timingInfos encoded body size by bytess length.
	          timingInfo.encodedBodySize += bytes.byteLength;

	          //  4. See pullAlgorithm...

	          return this.body.push(bytes)
	        },

	        onComplete () {
	          if (this.abort) {
	            fetchParams.controller.off('terminated', this.abort);
	          }

	          fetchParams.controller.ended = true;

	          this.body.push(null);
	        },

	        onError (error) {
	          if (this.abort) {
	            fetchParams.controller.off('terminated', this.abort);
	          }

	          this.body?.destroy(error);

	          fetchParams.controller.terminate(error);

	          reject(error);
	        },

	        onUpgrade (status, headersList, socket) {
	          if (status !== 101) {
	            return
	          }

	          const headers = new Headers();

	          for (let n = 0; n < headersList.length; n += 2) {
	            const key = headersList[n + 0].toString('latin1');
	            const val = headersList[n + 1].toString('latin1');

	            headers[kHeadersList].append(key, val);
	          }

	          resolve({
	            status,
	            statusText: STATUS_CODES[status],
	            headersList: headers[kHeadersList],
	            socket
	          });

	          return true
	        }
	      }
	    ))
	  }
	}

	fetch_1$1 = {
	  fetch,
	  Fetch,
	  fetching,
	  finalizeAndReportTiming
	};
	return fetch_1$1;
}

var symbols$2;
var hasRequiredSymbols$2;

function requireSymbols$2 () {
	if (hasRequiredSymbols$2) return symbols$2;
	hasRequiredSymbols$2 = 1;

	symbols$2 = {
	  kState: Symbol('FileReader state'),
	  kResult: Symbol('FileReader result'),
	  kError: Symbol('FileReader error'),
	  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),
	  kEvents: Symbol('FileReader events'),
	  kAborted: Symbol('FileReader aborted')
	};
	return symbols$2;
}

var progressevent;
var hasRequiredProgressevent;

function requireProgressevent () {
	if (hasRequiredProgressevent) return progressevent;
	hasRequiredProgressevent = 1;

	const { webidl } = requireWebidl();

	const kState = Symbol('ProgressEvent state');

	/**
	 * @see https://xhr.spec.whatwg.org/#progressevent
	 */
	class ProgressEvent extends Event {
	  constructor (type, eventInitDict = {}) {
	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});

	    super(type, eventInitDict);

	    this[kState] = {
	      lengthComputable: eventInitDict.lengthComputable,
	      loaded: eventInitDict.loaded,
	      total: eventInitDict.total
	    };
	  }

	  get lengthComputable () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].lengthComputable
	  }

	  get loaded () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].loaded
	  }

	  get total () {
	    webidl.brandCheck(this, ProgressEvent);

	    return this[kState].total
	  }
	}

	webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
	  {
	    key: 'lengthComputable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'loaded',
	    converter: webidl.converters['unsigned long long'],
	    defaultValue: 0
	  },
	  {
	    key: 'total',
	    converter: webidl.converters['unsigned long long'],
	    defaultValue: 0
	  },
	  {
	    key: 'bubbles',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'cancelable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'composed',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	]);

	progressevent = {
	  ProgressEvent
	};
	return progressevent;
}

var encoding;
var hasRequiredEncoding;

function requireEncoding () {
	if (hasRequiredEncoding) return encoding;
	hasRequiredEncoding = 1;

	/**
	 * @see https://encoding.spec.whatwg.org/#concept-encoding-get
	 * @param {string|undefined} label
	 */
	function getEncoding (label) {
	  if (!label) {
	    return 'failure'
	  }

	  // 1. Remove any leading and trailing ASCII whitespace from label.
	  // 2. If label is an ASCII case-insensitive match for any of the
	  //    labels listed in the table below, then return the
	  //    corresponding encoding; otherwise return failure.
	  switch (label.trim().toLowerCase()) {
	    case 'unicode-1-1-utf-8':
	    case 'unicode11utf8':
	    case 'unicode20utf8':
	    case 'utf-8':
	    case 'utf8':
	    case 'x-unicode20utf8':
	      return 'UTF-8'
	    case '866':
	    case 'cp866':
	    case 'csibm866':
	    case 'ibm866':
	      return 'IBM866'
	    case 'csisolatin2':
	    case 'iso-8859-2':
	    case 'iso-ir-101':
	    case 'iso8859-2':
	    case 'iso88592':
	    case 'iso_8859-2':
	    case 'iso_8859-2:1987':
	    case 'l2':
	    case 'latin2':
	      return 'ISO-8859-2'
	    case 'csisolatin3':
	    case 'iso-8859-3':
	    case 'iso-ir-109':
	    case 'iso8859-3':
	    case 'iso88593':
	    case 'iso_8859-3':
	    case 'iso_8859-3:1988':
	    case 'l3':
	    case 'latin3':
	      return 'ISO-8859-3'
	    case 'csisolatin4':
	    case 'iso-8859-4':
	    case 'iso-ir-110':
	    case 'iso8859-4':
	    case 'iso88594':
	    case 'iso_8859-4':
	    case 'iso_8859-4:1988':
	    case 'l4':
	    case 'latin4':
	      return 'ISO-8859-4'
	    case 'csisolatincyrillic':
	    case 'cyrillic':
	    case 'iso-8859-5':
	    case 'iso-ir-144':
	    case 'iso8859-5':
	    case 'iso88595':
	    case 'iso_8859-5':
	    case 'iso_8859-5:1988':
	      return 'ISO-8859-5'
	    case 'arabic':
	    case 'asmo-708':
	    case 'csiso88596e':
	    case 'csiso88596i':
	    case 'csisolatinarabic':
	    case 'ecma-114':
	    case 'iso-8859-6':
	    case 'iso-8859-6-e':
	    case 'iso-8859-6-i':
	    case 'iso-ir-127':
	    case 'iso8859-6':
	    case 'iso88596':
	    case 'iso_8859-6':
	    case 'iso_8859-6:1987':
	      return 'ISO-8859-6'
	    case 'csisolatingreek':
	    case 'ecma-118':
	    case 'elot_928':
	    case 'greek':
	    case 'greek8':
	    case 'iso-8859-7':
	    case 'iso-ir-126':
	    case 'iso8859-7':
	    case 'iso88597':
	    case 'iso_8859-7':
	    case 'iso_8859-7:1987':
	    case 'sun_eu_greek':
	      return 'ISO-8859-7'
	    case 'csiso88598e':
	    case 'csisolatinhebrew':
	    case 'hebrew':
	    case 'iso-8859-8':
	    case 'iso-8859-8-e':
	    case 'iso-ir-138':
	    case 'iso8859-8':
	    case 'iso88598':
	    case 'iso_8859-8':
	    case 'iso_8859-8:1988':
	    case 'visual':
	      return 'ISO-8859-8'
	    case 'csiso88598i':
	    case 'iso-8859-8-i':
	    case 'logical':
	      return 'ISO-8859-8-I'
	    case 'csisolatin6':
	    case 'iso-8859-10':
	    case 'iso-ir-157':
	    case 'iso8859-10':
	    case 'iso885910':
	    case 'l6':
	    case 'latin6':
	      return 'ISO-8859-10'
	    case 'iso-8859-13':
	    case 'iso8859-13':
	    case 'iso885913':
	      return 'ISO-8859-13'
	    case 'iso-8859-14':
	    case 'iso8859-14':
	    case 'iso885914':
	      return 'ISO-8859-14'
	    case 'csisolatin9':
	    case 'iso-8859-15':
	    case 'iso8859-15':
	    case 'iso885915':
	    case 'iso_8859-15':
	    case 'l9':
	      return 'ISO-8859-15'
	    case 'iso-8859-16':
	      return 'ISO-8859-16'
	    case 'cskoi8r':
	    case 'koi':
	    case 'koi8':
	    case 'koi8-r':
	    case 'koi8_r':
	      return 'KOI8-R'
	    case 'koi8-ru':
	    case 'koi8-u':
	      return 'KOI8-U'
	    case 'csmacintosh':
	    case 'mac':
	    case 'macintosh':
	    case 'x-mac-roman':
	      return 'macintosh'
	    case 'iso-8859-11':
	    case 'iso8859-11':
	    case 'iso885911':
	    case 'tis-620':
	    case 'windows-874':
	      return 'windows-874'
	    case 'cp1250':
	    case 'windows-1250':
	    case 'x-cp1250':
	      return 'windows-1250'
	    case 'cp1251':
	    case 'windows-1251':
	    case 'x-cp1251':
	      return 'windows-1251'
	    case 'ansi_x3.4-1968':
	    case 'ascii':
	    case 'cp1252':
	    case 'cp819':
	    case 'csisolatin1':
	    case 'ibm819':
	    case 'iso-8859-1':
	    case 'iso-ir-100':
	    case 'iso8859-1':
	    case 'iso88591':
	    case 'iso_8859-1':
	    case 'iso_8859-1:1987':
	    case 'l1':
	    case 'latin1':
	    case 'us-ascii':
	    case 'windows-1252':
	    case 'x-cp1252':
	      return 'windows-1252'
	    case 'cp1253':
	    case 'windows-1253':
	    case 'x-cp1253':
	      return 'windows-1253'
	    case 'cp1254':
	    case 'csisolatin5':
	    case 'iso-8859-9':
	    case 'iso-ir-148':
	    case 'iso8859-9':
	    case 'iso88599':
	    case 'iso_8859-9':
	    case 'iso_8859-9:1989':
	    case 'l5':
	    case 'latin5':
	    case 'windows-1254':
	    case 'x-cp1254':
	      return 'windows-1254'
	    case 'cp1255':
	    case 'windows-1255':
	    case 'x-cp1255':
	      return 'windows-1255'
	    case 'cp1256':
	    case 'windows-1256':
	    case 'x-cp1256':
	      return 'windows-1256'
	    case 'cp1257':
	    case 'windows-1257':
	    case 'x-cp1257':
	      return 'windows-1257'
	    case 'cp1258':
	    case 'windows-1258':
	    case 'x-cp1258':
	      return 'windows-1258'
	    case 'x-mac-cyrillic':
	    case 'x-mac-ukrainian':
	      return 'x-mac-cyrillic'
	    case 'chinese':
	    case 'csgb2312':
	    case 'csiso58gb231280':
	    case 'gb2312':
	    case 'gb_2312':
	    case 'gb_2312-80':
	    case 'gbk':
	    case 'iso-ir-58':
	    case 'x-gbk':
	      return 'GBK'
	    case 'gb18030':
	      return 'gb18030'
	    case 'big5':
	    case 'big5-hkscs':
	    case 'cn-big5':
	    case 'csbig5':
	    case 'x-x-big5':
	      return 'Big5'
	    case 'cseucpkdfmtjapanese':
	    case 'euc-jp':
	    case 'x-euc-jp':
	      return 'EUC-JP'
	    case 'csiso2022jp':
	    case 'iso-2022-jp':
	      return 'ISO-2022-JP'
	    case 'csshiftjis':
	    case 'ms932':
	    case 'ms_kanji':
	    case 'shift-jis':
	    case 'shift_jis':
	    case 'sjis':
	    case 'windows-31j':
	    case 'x-sjis':
	      return 'Shift_JIS'
	    case 'cseuckr':
	    case 'csksc56011987':
	    case 'euc-kr':
	    case 'iso-ir-149':
	    case 'korean':
	    case 'ks_c_5601-1987':
	    case 'ks_c_5601-1989':
	    case 'ksc5601':
	    case 'ksc_5601':
	    case 'windows-949':
	      return 'EUC-KR'
	    case 'csiso2022kr':
	    case 'hz-gb-2312':
	    case 'iso-2022-cn':
	    case 'iso-2022-cn-ext':
	    case 'iso-2022-kr':
	    case 'replacement':
	      return 'replacement'
	    case 'unicodefffe':
	    case 'utf-16be':
	      return 'UTF-16BE'
	    case 'csunicode':
	    case 'iso-10646-ucs-2':
	    case 'ucs-2':
	    case 'unicode':
	    case 'unicodefeff':
	    case 'utf-16':
	    case 'utf-16le':
	      return 'UTF-16LE'
	    case 'x-user-defined':
	      return 'x-user-defined'
	    default: return 'failure'
	  }
	}

	encoding = {
	  getEncoding
	};
	return encoding;
}

var util$5;
var hasRequiredUtil$5;

function requireUtil$5 () {
	if (hasRequiredUtil$5) return util$5;
	hasRequiredUtil$5 = 1;

	const {
	  kState,
	  kError,
	  kResult,
	  kAborted,
	  kLastProgressEventFired
	} = requireSymbols$2();
	const { ProgressEvent } = requireProgressevent();
	const { getEncoding } = requireEncoding();
	const { DOMException } = requireConstants$4();
	const { serializeAMimeType, parseMIMEType } = requireDataURL();
	const { types } = require$$0$7;
	const { StringDecoder } = require$$6$1;
	const { btoa } = require$$7;

	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
	  enumerable: true,
	  writable: false,
	  configurable: false
	};

	/**
	 * @see https://w3c.github.io/FileAPI/#readOperation
	 * @param {import('./filereader').FileReader} fr
	 * @param {import('buffer').Blob} blob
	 * @param {string} type
	 * @param {string?} encodingName
	 */
	function readOperation (fr, blob, type, encodingName) {
	  // 1. If frs state is "loading", throw an InvalidStateError
	  //    DOMException.
	  if (fr[kState] === 'loading') {
	    throw new DOMException('Invalid state', 'InvalidStateError')
	  }

	  // 2. Set frs state to "loading".
	  fr[kState] = 'loading';

	  // 3. Set frs result to null.
	  fr[kResult] = null;

	  // 4. Set frs error to null.
	  fr[kError] = null;

	  // 5. Let stream be the result of calling get stream on blob.
	  /** @type {import('stream/web').ReadableStream} */
	  const stream = blob.stream();

	  // 6. Let reader be the result of getting a reader from stream.
	  const reader = stream.getReader();

	  // 7. Let bytes be an empty byte sequence.
	  /** @type {Uint8Array[]} */
	  const bytes = [];

	  // 8. Let chunkPromise be the result of reading a chunk from
	  //    stream with reader.
	  let chunkPromise = reader.read();

	  // 9. Let isFirstChunk be true.
	  let isFirstChunk = true

	  // 10. In parallel, while true:
	  // Note: "In parallel" just means non-blocking
	  // Note 2: readOperation itself cannot be async as double
	  // reading the body would then reject the promise, instead
	  // of throwing an error.
	  ;(async () => {
	    while (!fr[kAborted]) {
	      // 1. Wait for chunkPromise to be fulfilled or rejected.
	      try {
	        const { done, value } = await chunkPromise;

	        // 2. If chunkPromise is fulfilled, and isFirstChunk is
	        //    true, queue a task to fire a progress event called
	        //    loadstart at fr.
	        if (isFirstChunk && !fr[kAborted]) {
	          queueMicrotask(() => {
	            fireAProgressEvent('loadstart', fr);
	          });
	        }

	        // 3. Set isFirstChunk to false.
	        isFirstChunk = false;

	        // 4. If chunkPromise is fulfilled with an object whose
	        //    done property is false and whose value property is
	        //    a Uint8Array object, run these steps:
	        if (!done && types.isUint8Array(value)) {
	          // 1. Let bs be the byte sequence represented by the
	          //    Uint8Array object.

	          // 2. Append bs to bytes.
	          bytes.push(value);

	          // 3. If roughly 50ms have passed since these steps
	          //    were last invoked, queue a task to fire a
	          //    progress event called progress at fr.
	          if (
	            (
	              fr[kLastProgressEventFired] === undefined ||
	              Date.now() - fr[kLastProgressEventFired] >= 50
	            ) &&
	            !fr[kAborted]
	          ) {
	            fr[kLastProgressEventFired] = Date.now();
	            queueMicrotask(() => {
	              fireAProgressEvent('progress', fr);
	            });
	          }

	          // 4. Set chunkPromise to the result of reading a
	          //    chunk from stream with reader.
	          chunkPromise = reader.read();
	        } else if (done) {
	          // 5. Otherwise, if chunkPromise is fulfilled with an
	          //    object whose done property is true, queue a task
	          //    to run the following steps and abort this algorithm:
	          queueMicrotask(() => {
	            // 1. Set frs state to "done".
	            fr[kState] = 'done';

	            // 2. Let result be the result of package data given
	            //    bytes, type, blobs type, and encodingName.
	            try {
	              const result = packageData(bytes, type, blob.type, encodingName);

	              // 4. Else:

	              if (fr[kAborted]) {
	                return
	              }

	              // 1. Set frs result to result.
	              fr[kResult] = result;

	              // 2. Fire a progress event called load at the fr.
	              fireAProgressEvent('load', fr);
	            } catch (error) {
	              // 3. If package data threw an exception error:

	              // 1. Set frs error to error.
	              fr[kError] = error;

	              // 2. Fire a progress event called error at fr.
	              fireAProgressEvent('error', fr);
	            }

	            // 5. If frs state is not "loading", fire a progress
	            //    event called loadend at the fr.
	            if (fr[kState] !== 'loading') {
	              fireAProgressEvent('loadend', fr);
	            }
	          });

	          break
	        }
	      } catch (error) {
	        if (fr[kAborted]) {
	          return
	        }

	        // 6. Otherwise, if chunkPromise is rejected with an
	        //    error error, queue a task to run the following
	        //    steps and abort this algorithm:
	        queueMicrotask(() => {
	          // 1. Set frs state to "done".
	          fr[kState] = 'done';

	          // 2. Set frs error to error.
	          fr[kError] = error;

	          // 3. Fire a progress event called error at fr.
	          fireAProgressEvent('error', fr);

	          // 4. If frs state is not "loading", fire a progress
	          //    event called loadend at fr.
	          if (fr[kState] !== 'loading') {
	            fireAProgressEvent('loadend', fr);
	          }
	        });

	        break
	      }
	    }
	  })();
	}

	/**
	 * @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	 * @see https://dom.spec.whatwg.org/#concept-event-fire
	 * @param {string} e The name of the event
	 * @param {import('./filereader').FileReader} reader
	 */
	function fireAProgressEvent (e, reader) {
	  // The progress event e does not bubble. e.bubbles must be false
	  // The progress event e is NOT cancelable. e.cancelable must be false
	  const event = new ProgressEvent(e, {
	    bubbles: false,
	    cancelable: false
	  });

	  reader.dispatchEvent(event);
	}

	/**
	 * @see https://w3c.github.io/FileAPI/#blob-package-data
	 * @param {Uint8Array[]} bytes
	 * @param {string} type
	 * @param {string?} mimeType
	 * @param {string?} encodingName
	 */
	function packageData (bytes, type, mimeType, encodingName) {
	  // 1. A Blob has an associated package data algorithm, given
	  //    bytes, a type, a optional mimeType, and a optional
	  //    encodingName, which switches on type and runs the
	  //    associated steps:

	  switch (type) {
	    case 'DataURL': {
	      // 1. Return bytes as a DataURL [RFC2397] subject to
	      //    the considerations below:
	      //  * Use mimeType as part of the Data URL if it is
	      //    available in keeping with the Data URL
	      //    specification [RFC2397].
	      //  * If mimeType is not available return a Data URL
	      //    without a media-type. [RFC2397].

	      // https://datatracker.ietf.org/doc/html/rfc2397#section-3
	      // dataurl    := "data:" [ mediatype ] [ ";base64" ] "," data
	      // mediatype  := [ type "/" subtype ] *( ";" parameter )
	      // data       := *urlchar
	      // parameter  := attribute "=" value
	      let dataURL = 'data:';

	      const parsed = parseMIMEType(mimeType || 'application/octet-stream');

	      if (parsed !== 'failure') {
	        dataURL += serializeAMimeType(parsed);
	      }

	      dataURL += ';base64,';

	      const decoder = new StringDecoder('latin1');

	      for (const chunk of bytes) {
	        dataURL += btoa(decoder.write(chunk));
	      }

	      dataURL += btoa(decoder.end());

	      return dataURL
	    }
	    case 'Text': {
	      // 1. Let encoding be failure
	      let encoding = 'failure';

	      // 2. If the encodingName is present, set encoding to the
	      //    result of getting an encoding from encodingName.
	      if (encodingName) {
	        encoding = getEncoding(encodingName);
	      }

	      // 3. If encoding is failure, and mimeType is present:
	      if (encoding === 'failure' && mimeType) {
	        // 1. Let type be the result of parse a MIME type
	        //    given mimeType.
	        const type = parseMIMEType(mimeType);

	        // 2. If type is not failure, set encoding to the result
	        //    of getting an encoding from types parameters["charset"].
	        if (type !== 'failure') {
	          encoding = getEncoding(type.parameters.get('charset'));
	        }
	      }

	      // 4. If encoding is failure, then set encoding to UTF-8.
	      if (encoding === 'failure') {
	        encoding = 'UTF-8';
	      }

	      // 5. Decode bytes using fallback encoding encoding, and
	      //    return the result.
	      return decode(bytes, encoding)
	    }
	    case 'ArrayBuffer': {
	      // Return a new ArrayBuffer whose contents are bytes.
	      const sequence = combineByteSequences(bytes);

	      return sequence.buffer
	    }
	    case 'BinaryString': {
	      // Return bytes as a binary string, in which every byte
	      //  is represented by a code unit of equal value [0..255].
	      let binaryString = '';

	      const decoder = new StringDecoder('latin1');

	      for (const chunk of bytes) {
	        binaryString += decoder.write(chunk);
	      }

	      binaryString += decoder.end();

	      return binaryString
	    }
	  }
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#decode
	 * @param {Uint8Array[]} ioQueue
	 * @param {string} encoding
	 */
	function decode (ioQueue, encoding) {
	  const bytes = combineByteSequences(ioQueue);

	  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.
	  const BOMEncoding = BOMSniffing(bytes);

	  let slice = 0;

	  // 2. If BOMEncoding is non-null:
	  if (BOMEncoding !== null) {
	    // 1. Set encoding to BOMEncoding.
	    encoding = BOMEncoding;

	    // 2. Read three bytes from ioQueue, if BOMEncoding is
	    //    UTF-8; otherwise read two bytes.
	    //    (Do nothing with those bytes.)
	    slice = BOMEncoding === 'UTF-8' ? 3 : 2;
	  }

	  // 3. Process a queue with an instance of encodings
	  //    decoder, ioQueue, output, and "replacement".

	  // 4. Return output.

	  const sliced = bytes.slice(slice);
	  return new TextDecoder(encoding).decode(sliced)
	}

	/**
	 * @see https://encoding.spec.whatwg.org/#bom-sniff
	 * @param {Uint8Array} ioQueue
	 */
	function BOMSniffing (ioQueue) {
	  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,
	  //    converted to a byte sequence.
	  const [a, b, c] = ioQueue;

	  // 2. For each of the rows in the table below, starting with
	  //    the first one and going down, if BOM starts with the
	  //    bytes given in the first column, then return the
	  //    encoding given in the cell in the second column of that
	  //    row. Otherwise, return null.
	  if (a === 0xEF && b === 0xBB && c === 0xBF) {
	    return 'UTF-8'
	  } else if (a === 0xFE && b === 0xFF) {
	    return 'UTF-16BE'
	  } else if (a === 0xFF && b === 0xFE) {
	    return 'UTF-16LE'
	  }

	  return null
	}

	/**
	 * @param {Uint8Array[]} sequences
	 */
	function combineByteSequences (sequences) {
	  const size = sequences.reduce((a, b) => {
	    return a + b.byteLength
	  }, 0);

	  let offset = 0;

	  return sequences.reduce((a, b) => {
	    a.set(b, offset);
	    offset += b.byteLength;
	    return a
	  }, new Uint8Array(size))
	}

	util$5 = {
	  staticPropertyDescriptors,
	  readOperation,
	  fireAProgressEvent
	};
	return util$5;
}

var filereader;
var hasRequiredFilereader;

function requireFilereader () {
	if (hasRequiredFilereader) return filereader;
	hasRequiredFilereader = 1;

	const {
	  staticPropertyDescriptors,
	  readOperation,
	  fireAProgressEvent
	} = requireUtil$5();
	const {
	  kState,
	  kError,
	  kResult,
	  kEvents,
	  kAborted
	} = requireSymbols$2();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$8();

	class FileReader extends EventTarget {
	  constructor () {
	    super();

	    this[kState] = 'empty';
	    this[kResult] = null;
	    this[kError] = null;
	    this[kEvents] = {
	      loadend: null,
	      error: null,
	      abort: null,
	      load: null,
	      progress: null,
	      loadstart: null
	    };
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
	   * @param {import('buffer').Blob} blob
	   */
	  readAsArrayBuffer (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsArrayBuffer' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsArrayBuffer(blob) method, when invoked,
	    // must initiate a read operation for blob with ArrayBuffer.
	    readOperation(this, blob, 'ArrayBuffer');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#readAsBinaryString
	   * @param {import('buffer').Blob} blob
	   */
	  readAsBinaryString (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsBinaryString' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsBinaryString(blob) method, when invoked,
	    // must initiate a read operation for blob with BinaryString.
	    readOperation(this, blob, 'BinaryString');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#readAsDataText
	   * @param {import('buffer').Blob} blob
	   * @param {string?} encoding
	   */
	  readAsText (blob, encoding = undefined) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsText' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    if (encoding !== undefined) {
	      encoding = webidl.converters.DOMString(encoding);
	    }

	    // The readAsText(blob, encoding) method, when invoked,
	    // must initiate a read operation for blob with Text and encoding.
	    readOperation(this, blob, 'Text', encoding);
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
	   * @param {import('buffer').Blob} blob
	   */
	  readAsDataURL (blob) {
	    webidl.brandCheck(this, FileReader);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'FileReader.readAsDataURL' });

	    blob = webidl.converters.Blob(blob, { strict: false });

	    // The readAsDataURL(blob) method, when invoked, must
	    // initiate a read operation for blob with DataURL.
	    readOperation(this, blob, 'DataURL');
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dfn-abort
	   */
	  abort () {
	    // 1. If this's state is "empty" or if this's state is
	    //    "done" set this's result to null and terminate
	    //    this algorithm.
	    if (this[kState] === 'empty' || this[kState] === 'done') {
	      this[kResult] = null;
	      return
	    }

	    // 2. If this's state is "loading" set this's state to
	    //    "done" and set this's result to null.
	    if (this[kState] === 'loading') {
	      this[kState] = 'done';
	      this[kResult] = null;
	    }

	    // 3. If there are any tasks from this on the file reading
	    //    task source in an affiliated task queue, then remove
	    //    those tasks from that task queue.
	    this[kAborted] = true;

	    // 4. Terminate the algorithm for the read method being processed.
	    // TODO

	    // 5. Fire a progress event called abort at this.
	    fireAProgressEvent('abort', this);

	    // 6. If this's state is not "loading", fire a progress
	    //    event called loadend at this.
	    if (this[kState] !== 'loading') {
	      fireAProgressEvent('loadend', this);
	    }
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
	   */
	  get readyState () {
	    webidl.brandCheck(this, FileReader);

	    switch (this[kState]) {
	      case 'empty': return this.EMPTY
	      case 'loading': return this.LOADING
	      case 'done': return this.DONE
	    }
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-result
	   */
	  get result () {
	    webidl.brandCheck(this, FileReader);

	    // The result attributes getter, when invoked, must return
	    // this's result.
	    return this[kResult]
	  }

	  /**
	   * @see https://w3c.github.io/FileAPI/#dom-filereader-error
	   */
	  get error () {
	    webidl.brandCheck(this, FileReader);

	    // The error attributes getter, when invoked, must return
	    // this's error.
	    return this[kError]
	  }

	  get onloadend () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].loadend
	  }

	  set onloadend (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].loadend) {
	      this.removeEventListener('loadend', this[kEvents].loadend);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].loadend = fn;
	      this.addEventListener('loadend', fn);
	    } else {
	      this[kEvents].loadend = null;
	    }
	  }

	  get onerror () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].error
	  }

	  set onerror (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].error) {
	      this.removeEventListener('error', this[kEvents].error);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].error = fn;
	      this.addEventListener('error', fn);
	    } else {
	      this[kEvents].error = null;
	    }
	  }

	  get onloadstart () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].loadstart
	  }

	  set onloadstart (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].loadstart) {
	      this.removeEventListener('loadstart', this[kEvents].loadstart);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].loadstart = fn;
	      this.addEventListener('loadstart', fn);
	    } else {
	      this[kEvents].loadstart = null;
	    }
	  }

	  get onprogress () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].progress
	  }

	  set onprogress (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].progress) {
	      this.removeEventListener('progress', this[kEvents].progress);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].progress = fn;
	      this.addEventListener('progress', fn);
	    } else {
	      this[kEvents].progress = null;
	    }
	  }

	  get onload () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].load
	  }

	  set onload (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].load) {
	      this.removeEventListener('load', this[kEvents].load);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].load = fn;
	      this.addEventListener('load', fn);
	    } else {
	      this[kEvents].load = null;
	    }
	  }

	  get onabort () {
	    webidl.brandCheck(this, FileReader);

	    return this[kEvents].abort
	  }

	  set onabort (fn) {
	    webidl.brandCheck(this, FileReader);

	    if (this[kEvents].abort) {
	      this.removeEventListener('abort', this[kEvents].abort);
	    }

	    if (typeof fn === 'function') {
	      this[kEvents].abort = fn;
	      this.addEventListener('abort', fn);
	    } else {
	      this[kEvents].abort = null;
	    }
	  }
	}

	// https://w3c.github.io/FileAPI/#dom-filereader-empty
	FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
	// https://w3c.github.io/FileAPI/#dom-filereader-loading
	FileReader.LOADING = FileReader.prototype.LOADING = 1;
	// https://w3c.github.io/FileAPI/#dom-filereader-done
	FileReader.DONE = FileReader.prototype.DONE = 2;

	Object.defineProperties(FileReader.prototype, {
	  EMPTY: staticPropertyDescriptors,
	  LOADING: staticPropertyDescriptors,
	  DONE: staticPropertyDescriptors,
	  readAsArrayBuffer: kEnumerableProperty,
	  readAsBinaryString: kEnumerableProperty,
	  readAsText: kEnumerableProperty,
	  readAsDataURL: kEnumerableProperty,
	  abort: kEnumerableProperty,
	  readyState: kEnumerableProperty,
	  result: kEnumerableProperty,
	  error: kEnumerableProperty,
	  onloadstart: kEnumerableProperty,
	  onprogress: kEnumerableProperty,
	  onload: kEnumerableProperty,
	  onabort: kEnumerableProperty,
	  onerror: kEnumerableProperty,
	  onloadend: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'FileReader',
	    writable: false,
	    enumerable: false,
	    configurable: true
	  }
	});

	Object.defineProperties(FileReader, {
	  EMPTY: staticPropertyDescriptors,
	  LOADING: staticPropertyDescriptors,
	  DONE: staticPropertyDescriptors
	});

	filereader = {
	  FileReader
	};
	return filereader;
}

var symbols$1;
var hasRequiredSymbols$1;

function requireSymbols$1 () {
	if (hasRequiredSymbols$1) return symbols$1;
	hasRequiredSymbols$1 = 1;

	symbols$1 = {
	  kConstruct: requireSymbols$4().kConstruct
	};
	return symbols$1;
}

var util$4;
var hasRequiredUtil$4;

function requireUtil$4 () {
	if (hasRequiredUtil$4) return util$4;
	hasRequiredUtil$4 = 1;

	const assert = require$$0$8;
	const { URLSerializer } = requireDataURL();
	const { isValidHeaderName } = requireUtil$7();

	/**
	 * @see https://url.spec.whatwg.org/#concept-url-equals
	 * @param {URL} A
	 * @param {URL} B
	 * @param {boolean | undefined} excludeFragment
	 * @returns {boolean}
	 */
	function urlEquals (A, B, excludeFragment = false) {
	  const serializedA = URLSerializer(A, excludeFragment);

	  const serializedB = URLSerializer(B, excludeFragment);

	  return serializedA === serializedB
	}

	/**
	 * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	 * @param {string} header
	 */
	function fieldValues (header) {
	  assert(header !== null);

	  const values = [];

	  for (let value of header.split(',')) {
	    value = value.trim();

	    if (!value.length) {
	      continue
	    } else if (!isValidHeaderName(value)) {
	      continue
	    }

	    values.push(value);
	  }

	  return values
	}

	util$4 = {
	  urlEquals,
	  fieldValues
	};
	return util$4;
}

var cache;
var hasRequiredCache;

function requireCache () {
	if (hasRequiredCache) return cache;
	hasRequiredCache = 1;

	const { kConstruct } = requireSymbols$1();
	const { urlEquals, fieldValues: getFieldValues } = requireUtil$4();
	const { kEnumerableProperty, isDisturbed } = requireUtil$8();
	const { kHeadersList } = requireSymbols$4();
	const { webidl } = requireWebidl();
	const { Response, cloneResponse } = requireResponse();
	const { Request } = requireRequest();
	const { kState, kHeaders, kGuard, kRealm } = requireSymbols$3();
	const { fetching } = requireFetch$1();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = requireUtil$7();
	const assert = require$$0$8;
	const { getGlobalDispatcher } = requireGlobal();

	/**
	 * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	 * @typedef {Object} CacheBatchOperation
	 * @property {'delete' | 'put'} type
	 * @property {any} request
	 * @property {any} response
	 * @property {import('../../types/cache').CacheQueryOptions} options
	 */

	/**
	 * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	 * @typedef {[any, any][]} requestResponseList
	 */

	class Cache {
	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
	   * @type {requestResponseList}
	   */
	  #relevantRequestResponseList

	  constructor () {
	    if (arguments[0] !== kConstruct) {
	      webidl.illegalConstructor();
	    }

	    this.#relevantRequestResponseList = arguments[1];
	  }

	  async match (request, options = {}) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.match' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    const p = await this.matchAll(request, options);

	    if (p.length === 0) {
	      return
	    }

	    return p[0]
	  }

	  async matchAll (request = undefined, options = {}) {
	    webidl.brandCheck(this, Cache);

	    if (request !== undefined) request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    // 1.
	    let r = null;

	    // 2.
	    if (request !== undefined) {
	      if (request instanceof Request) {
	        // 2.1.1
	        r = request[kState];

	        // 2.1.2
	        if (r.method !== 'GET' && !options.ignoreMethod) {
	          return []
	        }
	      } else if (typeof request === 'string') {
	        // 2.2.1
	        r = new Request(request)[kState];
	      }
	    }

	    // 5.
	    // 5.1
	    const responses = [];

	    // 5.2
	    if (request === undefined) {
	      // 5.2.1
	      for (const requestResponse of this.#relevantRequestResponseList) {
	        responses.push(requestResponse[1]);
	      }
	    } else { // 5.3
	      // 5.3.1
	      const requestResponses = this.#queryCache(r, options);

	      // 5.3.2
	      for (const requestResponse of requestResponses) {
	        responses.push(requestResponse[1]);
	      }
	    }

	    // 5.4
	    // We don't implement CORs so we don't need to loop over the responses, yay!

	    // 5.5.1
	    const responseList = [];

	    // 5.5.2
	    for (const response of responses) {
	      // 5.5.2.1
	      const responseObject = new Response(response.body?.source ?? null);
	      const body = responseObject[kState].body;
	      responseObject[kState] = response;
	      responseObject[kState].body = body;
	      responseObject[kHeaders][kHeadersList] = response.headersList;
	      responseObject[kHeaders][kGuard] = 'immutable';

	      responseList.push(responseObject);
	    }

	    // 6.
	    return Object.freeze(responseList)
	  }

	  async add (request) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.add' });

	    request = webidl.converters.RequestInfo(request);

	    // 1.
	    const requests = [request];

	    // 2.
	    const responseArrayPromise = this.addAll(requests);

	    // 3.
	    return await responseArrayPromise
	  }

	  async addAll (requests) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.addAll' });

	    requests = webidl.converters['sequence<RequestInfo>'](requests);

	    // 1.
	    const responsePromises = [];

	    // 2.
	    const requestList = [];

	    // 3.
	    for (const request of requests) {
	      if (typeof request === 'string') {
	        continue
	      }

	      // 3.1
	      const r = request[kState];

	      // 3.2
	      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {
	        throw webidl.errors.exception({
	          header: 'Cache.addAll',
	          message: 'Expected http/s scheme when method is not GET.'
	        })
	      }
	    }

	    // 4.
	    /** @type {ReturnType<typeof fetching>[]} */
	    const fetchControllers = [];

	    // 5.
	    for (const request of requests) {
	      // 5.1
	      const r = new Request(request)[kState];

	      // 5.2
	      if (!urlIsHttpHttpsScheme(r.url)) {
	        throw webidl.errors.exception({
	          header: 'Cache.addAll',
	          message: 'Expected http/s scheme.'
	        })
	      }

	      // 5.4
	      r.initiator = 'fetch';
	      r.destination = 'subresource';

	      // 5.5
	      requestList.push(r);

	      // 5.6
	      const responsePromise = createDeferredPromise();

	      // 5.7
	      fetchControllers.push(fetching({
	        request: r,
	        dispatcher: getGlobalDispatcher(),
	        processResponse (response) {
	          // 1.
	          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {
	            responsePromise.reject(webidl.errors.exception({
	              header: 'Cache.addAll',
	              message: 'Received an invalid status code or the request failed.'
	            }));
	          } else if (response.headersList.contains('vary')) { // 2.
	            // 2.1
	            const fieldValues = getFieldValues(response.headersList.get('vary'));

	            // 2.2
	            for (const fieldValue of fieldValues) {
	              // 2.2.1
	              if (fieldValue === '*') {
	                responsePromise.reject(webidl.errors.exception({
	                  header: 'Cache.addAll',
	                  message: 'invalid vary field value'
	                }));

	                for (const controller of fetchControllers) {
	                  controller.abort();
	                }

	                return
	              }
	            }
	          }
	        },
	        processResponseEndOfBody (response) {
	          // 1.
	          if (response.aborted) {
	            responsePromise.reject(new DOMException('aborted', 'AbortError'));
	            return
	          }

	          // 2.
	          responsePromise.resolve(response);
	        }
	      }));

	      // 5.8
	      responsePromises.push(responsePromise.promise);
	    }

	    // 6.
	    const p = Promise.all(responsePromises);

	    // 7.
	    const responses = await p;

	    // 7.1
	    const operations = [];

	    // 7.2
	    let index = 0;

	    // 7.3
	    for (const response of responses) {
	      // 7.3.1
	      /** @type {CacheBatchOperation} */
	      const operation = {
	        type: 'put', // 7.3.2
	        request: requestList[index], // 7.3.3
	        response // 7.3.4
	      };

	      operations.push(operation); // 7.3.5

	      index++; // 7.3.6
	    }

	    // 7.5
	    const cacheJobPromise = createDeferredPromise();

	    // 7.6.1
	    let errorData = null;

	    // 7.6.2
	    try {
	      this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    // 7.6.3
	    queueMicrotask(() => {
	      // 7.6.3.1
	      if (errorData === null) {
	        cacheJobPromise.resolve(undefined);
	      } else {
	        // 7.6.3.2
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    // 7.7
	    return cacheJobPromise.promise
	  }

	  async put (request, response) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 2, { header: 'Cache.put' });

	    request = webidl.converters.RequestInfo(request);
	    response = webidl.converters.Response(response);

	    // 1.
	    let innerRequest = null;

	    // 2.
	    if (request instanceof Request) {
	      innerRequest = request[kState];
	    } else { // 3.
	      innerRequest = new Request(request)[kState];
	    }

	    // 4.
	    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Expected an http/s scheme when method is not GET'
	      })
	    }

	    // 5.
	    const innerResponse = response[kState];

	    // 6.
	    if (innerResponse.status === 206) {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Got 206 status'
	      })
	    }

	    // 7.
	    if (innerResponse.headersList.contains('vary')) {
	      // 7.1.
	      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'));

	      // 7.2.
	      for (const fieldValue of fieldValues) {
	        // 7.2.1
	        if (fieldValue === '*') {
	          throw webidl.errors.exception({
	            header: 'Cache.put',
	            message: 'Got * vary field value'
	          })
	        }
	      }
	    }

	    // 8.
	    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
	      throw webidl.errors.exception({
	        header: 'Cache.put',
	        message: 'Response body is locked or disturbed'
	      })
	    }

	    // 9.
	    const clonedResponse = cloneResponse(innerResponse);

	    // 10.
	    const bodyReadPromise = createDeferredPromise();

	    // 11.
	    if (innerResponse.body != null) {
	      // 11.1
	      const stream = innerResponse.body.stream;

	      // 11.2
	      const reader = stream.getReader();

	      // 11.3
	      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
	    } else {
	      bodyReadPromise.resolve(undefined);
	    }

	    // 12.
	    /** @type {CacheBatchOperation[]} */
	    const operations = [];

	    // 13.
	    /** @type {CacheBatchOperation} */
	    const operation = {
	      type: 'put', // 14.
	      request: innerRequest, // 15.
	      response: clonedResponse // 16.
	    };

	    // 17.
	    operations.push(operation);

	    // 19.
	    const bytes = await bodyReadPromise.promise;

	    if (clonedResponse.body != null) {
	      clonedResponse.body.source = bytes;
	    }

	    // 19.1
	    const cacheJobPromise = createDeferredPromise();

	    // 19.2.1
	    let errorData = null;

	    // 19.2.2
	    try {
	      this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    // 19.2.3
	    queueMicrotask(() => {
	      // 19.2.3.1
	      if (errorData === null) {
	        cacheJobPromise.resolve();
	      } else { // 19.2.3.2
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    return cacheJobPromise.promise
	  }

	  async delete (request, options = {}) {
	    webidl.brandCheck(this, Cache);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'Cache.delete' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    /**
	     * @type {Request}
	     */
	    let r = null;

	    if (request instanceof Request) {
	      r = request[kState];

	      if (r.method !== 'GET' && !options.ignoreMethod) {
	        return false
	      }
	    } else {
	      assert(typeof request === 'string');

	      r = new Request(request)[kState];
	    }

	    /** @type {CacheBatchOperation[]} */
	    const operations = [];

	    /** @type {CacheBatchOperation} */
	    const operation = {
	      type: 'delete',
	      request: r,
	      options
	    };

	    operations.push(operation);

	    const cacheJobPromise = createDeferredPromise();

	    let errorData = null;
	    let requestResponses;

	    try {
	      requestResponses = this.#batchCacheOperations(operations);
	    } catch (e) {
	      errorData = e;
	    }

	    queueMicrotask(() => {
	      if (errorData === null) {
	        cacheJobPromise.resolve(!!requestResponses?.length);
	      } else {
	        cacheJobPromise.reject(errorData);
	      }
	    });

	    return cacheJobPromise.promise
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
	   * @param {any} request
	   * @param {import('../../types/cache').CacheQueryOptions} options
	   * @returns {readonly Request[]}
	   */
	  async keys (request = undefined, options = {}) {
	    webidl.brandCheck(this, Cache);

	    if (request !== undefined) request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.CacheQueryOptions(options);

	    // 1.
	    let r = null;

	    // 2.
	    if (request !== undefined) {
	      // 2.1
	      if (request instanceof Request) {
	        // 2.1.1
	        r = request[kState];

	        // 2.1.2
	        if (r.method !== 'GET' && !options.ignoreMethod) {
	          return []
	        }
	      } else if (typeof request === 'string') { // 2.2
	        r = new Request(request)[kState];
	      }
	    }

	    // 4.
	    const promise = createDeferredPromise();

	    // 5.
	    // 5.1
	    const requests = [];

	    // 5.2
	    if (request === undefined) {
	      // 5.2.1
	      for (const requestResponse of this.#relevantRequestResponseList) {
	        // 5.2.1.1
	        requests.push(requestResponse[0]);
	      }
	    } else { // 5.3
	      // 5.3.1
	      const requestResponses = this.#queryCache(r, options);

	      // 5.3.2
	      for (const requestResponse of requestResponses) {
	        // 5.3.2.1
	        requests.push(requestResponse[0]);
	      }
	    }

	    // 5.4
	    queueMicrotask(() => {
	      // 5.4.1
	      const requestList = [];

	      // 5.4.2
	      for (const request of requests) {
	        const requestObject = new Request('https://a');
	        requestObject[kState] = request;
	        requestObject[kHeaders][kHeadersList] = request.headersList;
	        requestObject[kHeaders][kGuard] = 'immutable';
	        requestObject[kRealm] = request.client;

	        // 5.4.2.1
	        requestList.push(requestObject);
	      }

	      // 5.4.3
	      promise.resolve(Object.freeze(requestList));
	    });

	    return promise.promise
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
	   * @param {CacheBatchOperation[]} operations
	   * @returns {requestResponseList}
	   */
	  #batchCacheOperations (operations) {
	    // 1.
	    const cache = this.#relevantRequestResponseList;

	    // 2.
	    const backupCache = [...cache];

	    // 3.
	    const addedItems = [];

	    // 4.1
	    const resultList = [];

	    try {
	      // 4.2
	      for (const operation of operations) {
	        // 4.2.1
	        if (operation.type !== 'delete' && operation.type !== 'put') {
	          throw webidl.errors.exception({
	            header: 'Cache.#batchCacheOperations',
	            message: 'operation type does not match "delete" or "put"'
	          })
	        }

	        // 4.2.2
	        if (operation.type === 'delete' && operation.response != null) {
	          throw webidl.errors.exception({
	            header: 'Cache.#batchCacheOperations',
	            message: 'delete operation should not have an associated response'
	          })
	        }

	        // 4.2.3
	        if (this.#queryCache(operation.request, operation.options, addedItems).length) {
	          throw new DOMException('???', 'InvalidStateError')
	        }

	        // 4.2.4
	        let requestResponses;

	        // 4.2.5
	        if (operation.type === 'delete') {
	          // 4.2.5.1
	          requestResponses = this.#queryCache(operation.request, operation.options);

	          // TODO: the spec is wrong, this is needed to pass WPTs
	          if (requestResponses.length === 0) {
	            return []
	          }

	          // 4.2.5.2
	          for (const requestResponse of requestResponses) {
	            const idx = cache.indexOf(requestResponse);
	            assert(idx !== -1);

	            // 4.2.5.2.1
	            cache.splice(idx, 1);
	          }
	        } else if (operation.type === 'put') { // 4.2.6
	          // 4.2.6.1
	          if (operation.response == null) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'put operation should have an associated response'
	            })
	          }

	          // 4.2.6.2
	          const r = operation.request;

	          // 4.2.6.3
	          if (!urlIsHttpHttpsScheme(r.url)) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'expected http or https scheme'
	            })
	          }

	          // 4.2.6.4
	          if (r.method !== 'GET') {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'not get method'
	            })
	          }

	          // 4.2.6.5
	          if (operation.options != null) {
	            throw webidl.errors.exception({
	              header: 'Cache.#batchCacheOperations',
	              message: 'options must not be defined'
	            })
	          }

	          // 4.2.6.6
	          requestResponses = this.#queryCache(operation.request);

	          // 4.2.6.7
	          for (const requestResponse of requestResponses) {
	            const idx = cache.indexOf(requestResponse);
	            assert(idx !== -1);

	            // 4.2.6.7.1
	            cache.splice(idx, 1);
	          }

	          // 4.2.6.8
	          cache.push([operation.request, operation.response]);

	          // 4.2.6.10
	          addedItems.push([operation.request, operation.response]);
	        }

	        // 4.2.7
	        resultList.push([operation.request, operation.response]);
	      }

	      // 4.3
	      return resultList
	    } catch (e) { // 5.
	      // 5.1
	      this.#relevantRequestResponseList.length = 0;

	      // 5.2
	      this.#relevantRequestResponseList = backupCache;

	      // 5.3
	      throw e
	    }
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#query-cache
	   * @param {any} requestQuery
	   * @param {import('../../types/cache').CacheQueryOptions} options
	   * @param {requestResponseList} targetStorage
	   * @returns {requestResponseList}
	   */
	  #queryCache (requestQuery, options, targetStorage) {
	    /** @type {requestResponseList} */
	    const resultList = [];

	    const storage = targetStorage ?? this.#relevantRequestResponseList;

	    for (const requestResponse of storage) {
	      const [cachedRequest, cachedResponse] = requestResponse;
	      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
	        resultList.push(requestResponse);
	      }
	    }

	    return resultList
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
	   * @param {any} requestQuery
	   * @param {any} request
	   * @param {any | null} response
	   * @param {import('../../types/cache').CacheQueryOptions | undefined} options
	   * @returns {boolean}
	   */
	  #requestMatchesCachedItem (requestQuery, request, response = null, options) {
	    // if (options?.ignoreMethod === false && request.method === 'GET') {
	    //   return false
	    // }

	    const queryURL = new URL(requestQuery.url);

	    const cachedURL = new URL(request.url);

	    if (options?.ignoreSearch) {
	      cachedURL.search = '';

	      queryURL.search = '';
	    }

	    if (!urlEquals(queryURL, cachedURL, true)) {
	      return false
	    }

	    if (
	      response == null ||
	      options?.ignoreVary ||
	      !response.headersList.contains('vary')
	    ) {
	      return true
	    }

	    const fieldValues = getFieldValues(response.headersList.get('vary'));

	    for (const fieldValue of fieldValues) {
	      if (fieldValue === '*') {
	        return false
	      }

	      const requestValue = request.headersList.get(fieldValue);
	      const queryValue = requestQuery.headersList.get(fieldValue);

	      // If one has the header and the other doesn't, or one has
	      // a different value than the other, return false
	      if (requestValue !== queryValue) {
	        return false
	      }
	    }

	    return true
	  }
	}

	Object.defineProperties(Cache.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'Cache',
	    configurable: true
	  },
	  match: kEnumerableProperty,
	  matchAll: kEnumerableProperty,
	  add: kEnumerableProperty,
	  addAll: kEnumerableProperty,
	  put: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  keys: kEnumerableProperty
	});

	const cacheQueryOptionConverters = [
	  {
	    key: 'ignoreSearch',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'ignoreMethod',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'ignoreVary',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	];

	webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);

	webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
	  ...cacheQueryOptionConverters,
	  {
	    key: 'cacheName',
	    converter: webidl.converters.DOMString
	  }
	]);

	webidl.converters.Response = webidl.interfaceConverter(Response);

	webidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(
	  webidl.converters.RequestInfo
	);

	cache = {
	  Cache
	};
	return cache;
}

var cachestorage;
var hasRequiredCachestorage;

function requireCachestorage () {
	if (hasRequiredCachestorage) return cachestorage;
	hasRequiredCachestorage = 1;

	const { kConstruct } = requireSymbols$1();
	const { Cache } = requireCache();
	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$8();

	class CacheStorage {
	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
	   * @type {Map<string, import('./cache').requestResponseList}
	   */
	  #caches = new Map()

	  constructor () {
	    if (arguments[0] !== kConstruct) {
	      webidl.illegalConstructor();
	    }
	  }

	  async match (request, options = {}) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.match' });

	    request = webidl.converters.RequestInfo(request);
	    options = webidl.converters.MultiCacheQueryOptions(options);

	    // 1.
	    if (options.cacheName != null) {
	      // 1.1.1.1
	      if (this.#caches.has(options.cacheName)) {
	        // 1.1.1.1.1
	        const cacheList = this.#caches.get(options.cacheName);
	        const cache = new Cache(kConstruct, cacheList);

	        return await cache.match(request, options)
	      }
	    } else { // 2.
	      // 2.2
	      for (const cacheList of this.#caches.values()) {
	        const cache = new Cache(kConstruct, cacheList);

	        // 2.2.1.2
	        const response = await cache.match(request, options);

	        if (response !== undefined) {
	          return response
	        }
	      }
	    }
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
	   * @param {string} cacheName
	   * @returns {Promise<boolean>}
	   */
	  async has (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.has' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    // 2.1.1
	    // 2.2
	    return this.#caches.has(cacheName)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
	   * @param {string} cacheName
	   * @returns {Promise<Cache>}
	   */
	  async open (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.open' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    // 2.1
	    if (this.#caches.has(cacheName)) {
	      // await caches.open('v1') !== await caches.open('v1')

	      // 2.1.1
	      const cache = this.#caches.get(cacheName);

	      // 2.1.1.1
	      return new Cache(kConstruct, cache)
	    }

	    // 2.2
	    const cache = [];

	    // 2.3
	    this.#caches.set(cacheName, cache);

	    // 2.4
	    return new Cache(kConstruct, cache)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
	   * @param {string} cacheName
	   * @returns {Promise<boolean>}
	   */
	  async delete (cacheName) {
	    webidl.brandCheck(this, CacheStorage);
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CacheStorage.delete' });

	    cacheName = webidl.converters.DOMString(cacheName);

	    return this.#caches.delete(cacheName)
	  }

	  /**
	   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
	   * @returns {string[]}
	   */
	  async keys () {
	    webidl.brandCheck(this, CacheStorage);

	    // 2.1
	    const keys = this.#caches.keys();

	    // 2.2
	    return [...keys]
	  }
	}

	Object.defineProperties(CacheStorage.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'CacheStorage',
	    configurable: true
	  },
	  match: kEnumerableProperty,
	  has: kEnumerableProperty,
	  open: kEnumerableProperty,
	  delete: kEnumerableProperty,
	  keys: kEnumerableProperty
	});

	cachestorage = {
	  CacheStorage
	};
	return cachestorage;
}

var constants$2;
var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;

	// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size
	const maxAttributeValueSize = 1024;

	// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size
	const maxNameValuePairSize = 4096;

	constants$2 = {
	  maxAttributeValueSize,
	  maxNameValuePairSize
	};
	return constants$2;
}

var util$3;
var hasRequiredUtil$3;

function requireUtil$3 () {
	if (hasRequiredUtil$3) return util$3;
	hasRequiredUtil$3 = 1;

	const assert = require$$0$8;
	const { kHeadersList } = requireSymbols$4();

	function isCTLExcludingHtab (value) {
	  if (value.length === 0) {
	    return false
	  }

	  for (const char of value) {
	    const code = char.charCodeAt(0);

	    if (
	      (code >= 0x00 || code <= 0x08) ||
	      (code >= 0x0A || code <= 0x1F) ||
	      code === 0x7F
	    ) {
	      return false
	    }
	  }
	}

	/**
	 CHAR           = <any US-ASCII character (octets 0 - 127)>
	 token          = 1*<any CHAR except CTLs or separators>
	 separators     = "(" | ")" | "<" | ">" | "@"
	                | "," | ";" | ":" | "\" | <">
	                | "/" | "[" | "]" | "?" | "="
	                | "{" | "}" | SP | HT
	 * @param {string} name
	 */
	function validateCookieName (name) {
	  for (const char of name) {
	    const code = char.charCodeAt(0);

	    if (
	      (code <= 0x20 || code > 0x7F) ||
	      char === '(' ||
	      char === ')' ||
	      char === '>' ||
	      char === '<' ||
	      char === '@' ||
	      char === ',' ||
	      char === ';' ||
	      char === ':' ||
	      char === '\\' ||
	      char === '"' ||
	      char === '/' ||
	      char === '[' ||
	      char === ']' ||
	      char === '?' ||
	      char === '=' ||
	      char === '{' ||
	      char === '}'
	    ) {
	      throw new Error('Invalid cookie name')
	    }
	  }
	}

	/**
	 cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	 cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	                       ; US-ASCII characters excluding CTLs,
	                       ; whitespace DQUOTE, comma, semicolon,
	                       ; and backslash
	 * @param {string} value
	 */
	function validateCookieValue (value) {
	  for (const char of value) {
	    const code = char.charCodeAt(0);

	    if (
	      code < 0x21 || // exclude CTLs (0-31)
	      code === 0x22 ||
	      code === 0x2C ||
	      code === 0x3B ||
	      code === 0x5C ||
	      code > 0x7E // non-ascii
	    ) {
	      throw new Error('Invalid header value')
	    }
	  }
	}

	/**
	 * path-value        = <any CHAR except CTLs or ";">
	 * @param {string} path
	 */
	function validateCookiePath (path) {
	  for (const char of path) {
	    const code = char.charCodeAt(0);

	    if (code < 0x21 || char === ';') {
	      throw new Error('Invalid cookie path')
	    }
	  }
	}

	/**
	 * I have no idea why these values aren't allowed to be honest,
	 * but Deno tests these. - Khafra
	 * @param {string} domain
	 */
	function validateCookieDomain (domain) {
	  if (
	    domain.startsWith('-') ||
	    domain.endsWith('.') ||
	    domain.endsWith('-')
	  ) {
	    throw new Error('Invalid cookie domain')
	  }
	}

	/**
	 * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	 * @param {number|Date} date
	  IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	  ; fixed length/zone/capitalization subset of the format
	  ; see Section 3.3 of [RFC5322]

	  day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	              / %x54.75.65 ; "Tue", case-sensitive
	              / %x57.65.64 ; "Wed", case-sensitive
	              / %x54.68.75 ; "Thu", case-sensitive
	              / %x46.72.69 ; "Fri", case-sensitive
	              / %x53.61.74 ; "Sat", case-sensitive
	              / %x53.75.6E ; "Sun", case-sensitive
	  date1        = day SP month SP year
	                  ; e.g., 02 Jun 1982

	  day          = 2DIGIT
	  month        = %x4A.61.6E ; "Jan", case-sensitive
	              / %x46.65.62 ; "Feb", case-sensitive
	              / %x4D.61.72 ; "Mar", case-sensitive
	              / %x41.70.72 ; "Apr", case-sensitive
	              / %x4D.61.79 ; "May", case-sensitive
	              / %x4A.75.6E ; "Jun", case-sensitive
	              / %x4A.75.6C ; "Jul", case-sensitive
	              / %x41.75.67 ; "Aug", case-sensitive
	              / %x53.65.70 ; "Sep", case-sensitive
	              / %x4F.63.74 ; "Oct", case-sensitive
	              / %x4E.6F.76 ; "Nov", case-sensitive
	              / %x44.65.63 ; "Dec", case-sensitive
	  year         = 4DIGIT

	  GMT          = %x47.4D.54 ; "GMT", case-sensitive

	  time-of-day  = hour ":" minute ":" second
	              ; 00:00:00 - 23:59:60 (leap second)

	  hour         = 2DIGIT
	  minute       = 2DIGIT
	  second       = 2DIGIT
	 */
	function toIMFDate (date) {
	  if (typeof date === 'number') {
	    date = new Date(date);
	  }

	  const days = [
	    'Sun', 'Mon', 'Tue', 'Wed',
	    'Thu', 'Fri', 'Sat'
	  ];

	  const months = [
	    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
	    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
	  ];

	  const dayName = days[date.getUTCDay()];
	  const day = date.getUTCDate().toString().padStart(2, '0');
	  const month = months[date.getUTCMonth()];
	  const year = date.getUTCFullYear();
	  const hour = date.getUTCHours().toString().padStart(2, '0');
	  const minute = date.getUTCMinutes().toString().padStart(2, '0');
	  const second = date.getUTCSeconds().toString().padStart(2, '0');

	  return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`
	}

	/**
	 max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	                       ; In practice, both expires-av and max-age-av
	                       ; are limited to dates representable by the
	                       ; user agent.
	 * @param {number} maxAge
	 */
	function validateCookieMaxAge (maxAge) {
	  if (maxAge < 0) {
	    throw new Error('Invalid cookie max-age')
	  }
	}

	/**
	 * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	 * @param {import('./index').Cookie} cookie
	 */
	function stringify (cookie) {
	  if (cookie.name.length === 0) {
	    return null
	  }

	  validateCookieName(cookie.name);
	  validateCookieValue(cookie.value);

	  const out = [`${cookie.name}=${cookie.value}`];

	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1
	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2
	  if (cookie.name.startsWith('__Secure-')) {
	    cookie.secure = true;
	  }

	  if (cookie.name.startsWith('__Host-')) {
	    cookie.secure = true;
	    cookie.domain = null;
	    cookie.path = '/';
	  }

	  if (cookie.secure) {
	    out.push('Secure');
	  }

	  if (cookie.httpOnly) {
	    out.push('HttpOnly');
	  }

	  if (typeof cookie.maxAge === 'number') {
	    validateCookieMaxAge(cookie.maxAge);
	    out.push(`Max-Age=${cookie.maxAge}`);
	  }

	  if (cookie.domain) {
	    validateCookieDomain(cookie.domain);
	    out.push(`Domain=${cookie.domain}`);
	  }

	  if (cookie.path) {
	    validateCookiePath(cookie.path);
	    out.push(`Path=${cookie.path}`);
	  }

	  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {
	    out.push(`Expires=${toIMFDate(cookie.expires)}`);
	  }

	  if (cookie.sameSite) {
	    out.push(`SameSite=${cookie.sameSite}`);
	  }

	  for (const part of cookie.unparsed) {
	    if (!part.includes('=')) {
	      throw new Error('Invalid unparsed')
	    }

	    const [key, ...value] = part.split('=');

	    out.push(`${key.trim()}=${value.join('=')}`);
	  }

	  return out.join('; ')
	}

	let kHeadersListNode;

	function getHeadersList (headers) {
	  if (headers[kHeadersList]) {
	    return headers[kHeadersList]
	  }

	  if (!kHeadersListNode) {
	    kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
	      (symbol) => symbol.description === 'headers list'
	    );

	    assert(kHeadersListNode, 'Headers cannot be parsed');
	  }

	  const headersList = headers[kHeadersListNode];
	  assert(headersList);

	  return headersList
	}

	util$3 = {
	  isCTLExcludingHtab,
	  stringify,
	  getHeadersList
	};
	return util$3;
}

var parse$1;
var hasRequiredParse$1;

function requireParse$1 () {
	if (hasRequiredParse$1) return parse$1;
	hasRequiredParse$1 = 1;

	const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$2();
	const { isCTLExcludingHtab } = requireUtil$3();
	const { collectASequenceOfCodePointsFast } = requireDataURL();
	const assert = require$$0$8;

	/**
	 * @description Parses the field-value attributes of a set-cookie header string.
	 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	 * @param {string} header
	 * @returns if the header is invalid, null will be returned
	 */
	function parseSetCookie (header) {
	  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F
	  //    character (CTL characters excluding HTAB): Abort these steps and
	  //    ignore the set-cookie-string entirely.
	  if (isCTLExcludingHtab(header)) {
	    return null
	  }

	  let nameValuePair = '';
	  let unparsedAttributes = '';
	  let name = '';
	  let value = '';

	  // 2. If the set-cookie-string contains a %x3B (";") character:
	  if (header.includes(';')) {
	    // 1. The name-value-pair string consists of the characters up to,
	    //    but not including, the first %x3B (";"), and the unparsed-
	    //    attributes consist of the remainder of the set-cookie-string
	    //    (including the %x3B (";") in question).
	    const position = { position: 0 };

	    nameValuePair = collectASequenceOfCodePointsFast(';', header, position);
	    unparsedAttributes = header.slice(position.position);
	  } else {
	    // Otherwise:

	    // 1. The name-value-pair string consists of all the characters
	    //    contained in the set-cookie-string, and the unparsed-
	    //    attributes is the empty string.
	    nameValuePair = header;
	  }

	  // 3. If the name-value-pair string lacks a %x3D ("=") character, then
	  //    the name string is empty, and the value string is the value of
	  //    name-value-pair.
	  if (!nameValuePair.includes('=')) {
	    value = nameValuePair;
	  } else {
	    //    Otherwise, the name string consists of the characters up to, but
	    //    not including, the first %x3D ("=") character, and the (possibly
	    //    empty) value string consists of the characters after the first
	    //    %x3D ("=") character.
	    const position = { position: 0 };
	    name = collectASequenceOfCodePointsFast(
	      '=',
	      nameValuePair,
	      position
	    );
	    value = nameValuePair.slice(position.position + 1);
	  }

	  // 4. Remove any leading or trailing WSP characters from the name
	  //    string and the value string.
	  name = name.trim();
	  value = value.trim();

	  // 5. If the sum of the lengths of the name string and the value string
	  //    is more than 4096 octets, abort these steps and ignore the set-
	  //    cookie-string entirely.
	  if (name.length + value.length > maxNameValuePairSize) {
	    return null
	  }

	  // 6. The cookie-name is the name string, and the cookie-value is the
	  //    value string.
	  return {
	    name, value, ...parseUnparsedAttributes(unparsedAttributes)
	  }
	}

	/**
	 * Parses the remaining attributes of a set-cookie header
	 * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	 * @param {string} unparsedAttributes
	 * @param {[Object.<string, unknown>]={}} cookieAttributeList
	 */
	function parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {
	  // 1. If the unparsed-attributes string is empty, skip the rest of
	  //    these steps.
	  if (unparsedAttributes.length === 0) {
	    return cookieAttributeList
	  }

	  // 2. Discard the first character of the unparsed-attributes (which
	  //    will be a %x3B (";") character).
	  assert(unparsedAttributes[0] === ';');
	  unparsedAttributes = unparsedAttributes.slice(1);

	  let cookieAv = '';

	  // 3. If the remaining unparsed-attributes contains a %x3B (";")
	  //    character:
	  if (unparsedAttributes.includes(';')) {
	    // 1. Consume the characters of the unparsed-attributes up to, but
	    //    not including, the first %x3B (";") character.
	    cookieAv = collectASequenceOfCodePointsFast(
	      ';',
	      unparsedAttributes,
	      { position: 0 }
	    );
	    unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
	  } else {
	    // Otherwise:

	    // 1. Consume the remainder of the unparsed-attributes.
	    cookieAv = unparsedAttributes;
	    unparsedAttributes = '';
	  }

	  // Let the cookie-av string be the characters consumed in this step.

	  let attributeName = '';
	  let attributeValue = '';

	  // 4. If the cookie-av string contains a %x3D ("=") character:
	  if (cookieAv.includes('=')) {
	    // 1. The (possibly empty) attribute-name string consists of the
	    //    characters up to, but not including, the first %x3D ("=")
	    //    character, and the (possibly empty) attribute-value string
	    //    consists of the characters after the first %x3D ("=")
	    //    character.
	    const position = { position: 0 };

	    attributeName = collectASequenceOfCodePointsFast(
	      '=',
	      cookieAv,
	      position
	    );
	    attributeValue = cookieAv.slice(position.position + 1);
	  } else {
	    // Otherwise:

	    // 1. The attribute-name string consists of the entire cookie-av
	    //    string, and the attribute-value string is empty.
	    attributeName = cookieAv;
	  }

	  // 5. Remove any leading or trailing WSP characters from the attribute-
	  //    name string and the attribute-value string.
	  attributeName = attributeName.trim();
	  attributeValue = attributeValue.trim();

	  // 6. If the attribute-value is longer than 1024 octets, ignore the
	  //    cookie-av string and return to Step 1 of this algorithm.
	  if (attributeValue.length > maxAttributeValueSize) {
	    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	  }

	  // 7. Process the attribute-name and attribute-value according to the
	  //    requirements in the following subsections.  (Notice that
	  //    attributes with unrecognized attribute-names are ignored.)
	  const attributeNameLowercase = attributeName.toLowerCase();

	  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1
	  // If the attribute-name case-insensitively matches the string
	  // "Expires", the user agent MUST process the cookie-av as follows.
	  if (attributeNameLowercase === 'expires') {
	    // 1. Let the expiry-time be the result of parsing the attribute-value
	    //    as cookie-date (see Section 5.1.1).
	    const expiryTime = new Date(attributeValue);

	    // 2. If the attribute-value failed to parse as a cookie date, ignore
	    //    the cookie-av.

	    cookieAttributeList.expires = expiryTime;
	  } else if (attributeNameLowercase === 'max-age') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2
	    // If the attribute-name case-insensitively matches the string "Max-
	    // Age", the user agent MUST process the cookie-av as follows.

	    // 1. If the first character of the attribute-value is not a DIGIT or a
	    //    "-" character, ignore the cookie-av.
	    const charCode = attributeValue.charCodeAt(0);

	    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {
	      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	    }

	    // 2. If the remainder of attribute-value contains a non-DIGIT
	    //    character, ignore the cookie-av.
	    if (!/^\d+$/.test(attributeValue)) {
	      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	    }

	    // 3. Let delta-seconds be the attribute-value converted to an integer.
	    const deltaSeconds = Number(attributeValue);

	    // 4. Let cookie-age-limit be the maximum age of the cookie (which
	    //    SHOULD be 400 days or less, see Section 4.1.2.2).

	    // 5. Set delta-seconds to the smaller of its present value and cookie-
	    //    age-limit.
	    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)

	    // 6. If delta-seconds is less than or equal to zero (0), let expiry-
	    //    time be the earliest representable date and time.  Otherwise, let
	    //    the expiry-time be the current date and time plus delta-seconds
	    //    seconds.
	    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds

	    // 7. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Max-Age and an attribute-value of expiry-time.
	    cookieAttributeList.maxAge = deltaSeconds;
	  } else if (attributeNameLowercase === 'domain') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3
	    // If the attribute-name case-insensitively matches the string "Domain",
	    // the user agent MUST process the cookie-av as follows.

	    // 1. Let cookie-domain be the attribute-value.
	    let cookieDomain = attributeValue;

	    // 2. If cookie-domain starts with %x2E ("."), let cookie-domain be
	    //    cookie-domain without its leading %x2E (".").
	    if (cookieDomain[0] === '.') {
	      cookieDomain = cookieDomain.slice(1);
	    }

	    // 3. Convert the cookie-domain to lower case.
	    cookieDomain = cookieDomain.toLowerCase();

	    // 4. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Domain and an attribute-value of cookie-domain.
	    cookieAttributeList.domain = cookieDomain;
	  } else if (attributeNameLowercase === 'path') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4
	    // If the attribute-name case-insensitively matches the string "Path",
	    // the user agent MUST process the cookie-av as follows.

	    // 1. If the attribute-value is empty or if the first character of the
	    //    attribute-value is not %x2F ("/"):
	    let cookiePath = '';
	    if (attributeValue.length === 0 || attributeValue[0] !== '/') {
	      // 1. Let cookie-path be the default-path.
	      cookiePath = '/';
	    } else {
	      // Otherwise:

	      // 1. Let cookie-path be the attribute-value.
	      cookiePath = attributeValue;
	    }

	    // 2. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of Path and an attribute-value of cookie-path.
	    cookieAttributeList.path = cookiePath;
	  } else if (attributeNameLowercase === 'secure') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5
	    // If the attribute-name case-insensitively matches the string "Secure",
	    // the user agent MUST append an attribute to the cookie-attribute-list
	    // with an attribute-name of Secure and an empty attribute-value.

	    cookieAttributeList.secure = true;
	  } else if (attributeNameLowercase === 'httponly') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6
	    // If the attribute-name case-insensitively matches the string
	    // "HttpOnly", the user agent MUST append an attribute to the cookie-
	    // attribute-list with an attribute-name of HttpOnly and an empty
	    // attribute-value.

	    cookieAttributeList.httpOnly = true;
	  } else if (attributeNameLowercase === 'samesite') {
	    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7
	    // If the attribute-name case-insensitively matches the string
	    // "SameSite", the user agent MUST process the cookie-av as follows:

	    // 1. Let enforcement be "Default".
	    let enforcement = 'Default';

	    const attributeValueLowercase = attributeValue.toLowerCase();
	    // 2. If cookie-av's attribute-value is a case-insensitive match for
	    //    "None", set enforcement to "None".
	    if (attributeValueLowercase.includes('none')) {
	      enforcement = 'None';
	    }

	    // 3. If cookie-av's attribute-value is a case-insensitive match for
	    //    "Strict", set enforcement to "Strict".
	    if (attributeValueLowercase.includes('strict')) {
	      enforcement = 'Strict';
	    }

	    // 4. If cookie-av's attribute-value is a case-insensitive match for
	    //    "Lax", set enforcement to "Lax".
	    if (attributeValueLowercase.includes('lax')) {
	      enforcement = 'Lax';
	    }

	    // 5. Append an attribute to the cookie-attribute-list with an
	    //    attribute-name of "SameSite" and an attribute-value of
	    //    enforcement.
	    cookieAttributeList.sameSite = enforcement;
	  } else {
	    cookieAttributeList.unparsed ??= [];

	    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
	  }

	  // 8. Return to Step 1 of this algorithm.
	  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)
	}

	parse$1 = {
	  parseSetCookie,
	  parseUnparsedAttributes
	};
	return parse$1;
}

var cookies;
var hasRequiredCookies;

function requireCookies () {
	if (hasRequiredCookies) return cookies;
	hasRequiredCookies = 1;

	const { parseSetCookie } = requireParse$1();
	const { stringify, getHeadersList } = requireUtil$3();
	const { webidl } = requireWebidl();
	const { Headers } = requireHeaders();

	/**
	 * @typedef {Object} Cookie
	 * @property {string} name
	 * @property {string} value
	 * @property {Date|number|undefined} expires
	 * @property {number|undefined} maxAge
	 * @property {string|undefined} domain
	 * @property {string|undefined} path
	 * @property {boolean|undefined} secure
	 * @property {boolean|undefined} httpOnly
	 * @property {'Strict'|'Lax'|'None'} sameSite
	 * @property {string[]} unparsed
	 */

	/**
	 * @param {Headers} headers
	 * @returns {Record<string, string>}
	 */
	function getCookies (headers) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'getCookies' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  const cookie = headers.get('cookie');
	  const out = {};

	  if (!cookie) {
	    return out
	  }

	  for (const piece of cookie.split(';')) {
	    const [name, ...value] = piece.split('=');

	    out[name.trim()] = value.join('=');
	  }

	  return out
	}

	/**
	 * @param {Headers} headers
	 * @param {string} name
	 * @param {{ path?: string, domain?: string }|undefined} attributes
	 * @returns {void}
	 */
	function deleteCookie (headers, name, attributes) {
	  webidl.argumentLengthCheck(arguments, 2, { header: 'deleteCookie' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  name = webidl.converters.DOMString(name);
	  attributes = webidl.converters.DeleteCookieAttributes(attributes);

	  // Matches behavior of
	  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278
	  setCookie(headers, {
	    name,
	    value: '',
	    expires: new Date(0),
	    ...attributes
	  });
	}

	/**
	 * @param {Headers} headers
	 * @returns {Cookie[]}
	 */
	function getSetCookies (headers) {
	  webidl.argumentLengthCheck(arguments, 1, { header: 'getSetCookies' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  const cookies = getHeadersList(headers).cookies;

	  if (!cookies) {
	    return []
	  }

	  // In older versions of undici, cookies is a list of name:value.
	  return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair))
	}

	/**
	 * @param {Headers} headers
	 * @param {Cookie} cookie
	 * @returns {void}
	 */
	function setCookie (headers, cookie) {
	  webidl.argumentLengthCheck(arguments, 2, { header: 'setCookie' });

	  webidl.brandCheck(headers, Headers, { strict: false });

	  cookie = webidl.converters.Cookie(cookie);

	  const str = stringify(cookie);

	  if (str) {
	    headers.append('Set-Cookie', stringify(cookie));
	  }
	}

	webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'path',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'domain',
	    defaultValue: null
	  }
	]);

	webidl.converters.Cookie = webidl.dictionaryConverter([
	  {
	    converter: webidl.converters.DOMString,
	    key: 'name'
	  },
	  {
	    converter: webidl.converters.DOMString,
	    key: 'value'
	  },
	  {
	    converter: webidl.nullableConverter((value) => {
	      if (typeof value === 'number') {
	        return webidl.converters['unsigned long long'](value)
	      }

	      return new Date(value)
	    }),
	    key: 'expires',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters['long long']),
	    key: 'maxAge',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'domain',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.DOMString),
	    key: 'path',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.boolean),
	    key: 'secure',
	    defaultValue: null
	  },
	  {
	    converter: webidl.nullableConverter(webidl.converters.boolean),
	    key: 'httpOnly',
	    defaultValue: null
	  },
	  {
	    converter: webidl.converters.USVString,
	    key: 'sameSite',
	    allowedValues: ['Strict', 'Lax', 'None']
	  },
	  {
	    converter: webidl.sequenceConverter(webidl.converters.DOMString),
	    key: 'unparsed',
	    defaultValue: []
	  }
	]);

	cookies = {
	  getCookies,
	  deleteCookie,
	  getSetCookies,
	  setCookie
	};
	return cookies;
}

var constants$1;
var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;

	// This is a Globally Unique Identifier unique used
	// to validate that the endpoint accepts websocket
	// connections.
	// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3
	const uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';

	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors = {
	  enumerable: true,
	  writable: false,
	  configurable: false
	};

	const states = {
	  CONNECTING: 0,
	  OPEN: 1,
	  CLOSING: 2,
	  CLOSED: 3
	};

	const opcodes = {
	  CONTINUATION: 0x0,
	  TEXT: 0x1,
	  BINARY: 0x2,
	  CLOSE: 0x8,
	  PING: 0x9,
	  PONG: 0xA
	};

	const maxUnsigned16Bit = 2 ** 16 - 1; // 65535

	const parserStates = {
	  INFO: 0,
	  PAYLOADLENGTH_16: 2,
	  PAYLOADLENGTH_64: 3,
	  READ_DATA: 4
	};

	const emptyBuffer = Buffer.allocUnsafe(0);

	constants$1 = {
	  uid,
	  staticPropertyDescriptors,
	  states,
	  opcodes,
	  maxUnsigned16Bit,
	  parserStates,
	  emptyBuffer
	};
	return constants$1;
}

var symbols;
var hasRequiredSymbols;

function requireSymbols () {
	if (hasRequiredSymbols) return symbols;
	hasRequiredSymbols = 1;

	symbols = {
	  kWebSocketURL: Symbol('url'),
	  kReadyState: Symbol('ready state'),
	  kController: Symbol('controller'),
	  kResponse: Symbol('response'),
	  kBinaryType: Symbol('binary type'),
	  kSentClose: Symbol('sent close'),
	  kReceivedClose: Symbol('received close'),
	  kByteParser: Symbol('byte parser')
	};
	return symbols;
}

var events;
var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events;
	hasRequiredEvents = 1;

	const { webidl } = requireWebidl();
	const { kEnumerableProperty } = requireUtil$8();
	const { MessagePort } = require$$0$d;

	/**
	 * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	 */
	class MessageEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent constructor' });

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.MessageEventInit(eventInitDict);

	    super(type, eventInitDict);

	    this.#eventInit = eventInitDict;
	  }

	  get data () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.data
	  }

	  get origin () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.origin
	  }

	  get lastEventId () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.lastEventId
	  }

	  get source () {
	    webidl.brandCheck(this, MessageEvent);

	    return this.#eventInit.source
	  }

	  get ports () {
	    webidl.brandCheck(this, MessageEvent);

	    if (!Object.isFrozen(this.#eventInit.ports)) {
	      Object.freeze(this.#eventInit.ports);
	    }

	    return this.#eventInit.ports
	  }

	  initMessageEvent (
	    type,
	    bubbles = false,
	    cancelable = false,
	    data = null,
	    origin = '',
	    lastEventId = '',
	    source = null,
	    ports = []
	  ) {
	    webidl.brandCheck(this, MessageEvent);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'MessageEvent.initMessageEvent' });

	    return new MessageEvent(type, {
	      bubbles, cancelable, data, origin, lastEventId, source, ports
	    })
	  }
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	 */
	class CloseEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict = {}) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'CloseEvent constructor' });

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.CloseEventInit(eventInitDict);

	    super(type, eventInitDict);

	    this.#eventInit = eventInitDict;
	  }

	  get wasClean () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.wasClean
	  }

	  get code () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.code
	  }

	  get reason () {
	    webidl.brandCheck(this, CloseEvent);

	    return this.#eventInit.reason
	  }
	}

	// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface
	class ErrorEvent extends Event {
	  #eventInit

	  constructor (type, eventInitDict) {
	    webidl.argumentLengthCheck(arguments, 1, { header: 'ErrorEvent constructor' });

	    super(type, eventInitDict);

	    type = webidl.converters.DOMString(type);
	    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});

	    this.#eventInit = eventInitDict;
	  }

	  get message () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.message
	  }

	  get filename () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.filename
	  }

	  get lineno () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.lineno
	  }

	  get colno () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.colno
	  }

	  get error () {
	    webidl.brandCheck(this, ErrorEvent);

	    return this.#eventInit.error
	  }
	}

	Object.defineProperties(MessageEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'MessageEvent',
	    configurable: true
	  },
	  data: kEnumerableProperty,
	  origin: kEnumerableProperty,
	  lastEventId: kEnumerableProperty,
	  source: kEnumerableProperty,
	  ports: kEnumerableProperty,
	  initMessageEvent: kEnumerableProperty
	});

	Object.defineProperties(CloseEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'CloseEvent',
	    configurable: true
	  },
	  reason: kEnumerableProperty,
	  code: kEnumerableProperty,
	  wasClean: kEnumerableProperty
	});

	Object.defineProperties(ErrorEvent.prototype, {
	  [Symbol.toStringTag]: {
	    value: 'ErrorEvent',
	    configurable: true
	  },
	  message: kEnumerableProperty,
	  filename: kEnumerableProperty,
	  lineno: kEnumerableProperty,
	  colno: kEnumerableProperty,
	  error: kEnumerableProperty
	});

	webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);

	webidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(
	  webidl.converters.MessagePort
	);

	const eventInit = [
	  {
	    key: 'bubbles',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'cancelable',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'composed',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  }
	];

	webidl.converters.MessageEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'data',
	    converter: webidl.converters.any,
	    defaultValue: null
	  },
	  {
	    key: 'origin',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  },
	  {
	    key: 'lastEventId',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'source',
	    // Node doesn't implement WindowProxy or ServiceWorker, so the only
	    // valid value for source is a MessagePort.
	    converter: webidl.nullableConverter(webidl.converters.MessagePort),
	    defaultValue: null
	  },
	  {
	    key: 'ports',
	    converter: webidl.converters['sequence<MessagePort>'],
	    get defaultValue () {
	      return []
	    }
	  }
	]);

	webidl.converters.CloseEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'wasClean',
	    converter: webidl.converters.boolean,
	    defaultValue: false
	  },
	  {
	    key: 'code',
	    converter: webidl.converters['unsigned short'],
	    defaultValue: 0
	  },
	  {
	    key: 'reason',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  }
	]);

	webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
	  ...eventInit,
	  {
	    key: 'message',
	    converter: webidl.converters.DOMString,
	    defaultValue: ''
	  },
	  {
	    key: 'filename',
	    converter: webidl.converters.USVString,
	    defaultValue: ''
	  },
	  {
	    key: 'lineno',
	    converter: webidl.converters['unsigned long'],
	    defaultValue: 0
	  },
	  {
	    key: 'colno',
	    converter: webidl.converters['unsigned long'],
	    defaultValue: 0
	  },
	  {
	    key: 'error',
	    converter: webidl.converters.any
	  }
	]);

	events = {
	  MessageEvent,
	  CloseEvent,
	  ErrorEvent
	};
	return events;
}

var util$2;
var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;

	const { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = requireSymbols();
	const { states, opcodes } = requireConstants$1();
	const { MessageEvent, ErrorEvent } = requireEvents();

	/* globals Blob */

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isEstablished (ws) {
	  // If the server's response is validated as provided for above, it is
	  // said that _The WebSocket Connection is Established_ and that the
	  // WebSocket Connection is in the OPEN state.
	  return ws[kReadyState] === states.OPEN
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isClosing (ws) {
	  // Upon either sending or receiving a Close control frame, it is said
	  // that _The WebSocket Closing Handshake is Started_ and that the
	  // WebSocket connection is in the CLOSING state.
	  return ws[kReadyState] === states.CLOSING
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 */
	function isClosed (ws) {
	  return ws[kReadyState] === states.CLOSED
	}

	/**
	 * @see https://dom.spec.whatwg.org/#concept-event-fire
	 * @param {string} e
	 * @param {EventTarget} target
	 * @param {EventInit | undefined} eventInitDict
	 */
	function fireEvent (e, target, eventConstructor = Event, eventInitDict) {
	  // 1. If eventConstructor is not given, then let eventConstructor be Event.

	  // 2. Let event be the result of creating an event given eventConstructor,
	  //    in the relevant realm of target.
	  // 3. Initialize events type attribute to e.
	  const event = new eventConstructor(e, eventInitDict); // eslint-disable-line new-cap

	  // 4. Initialize any other IDL attributes of event as described in the
	  //    invocation of this algorithm.

	  // 5. Return the result of dispatching event at target, with legacy target
	  //    override flag set if set.
	  target.dispatchEvent(event);
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	 * @param {import('./websocket').WebSocket} ws
	 * @param {number} type Opcode
	 * @param {Buffer} data application data
	 */
	function websocketMessageReceived (ws, type, data) {
	  // 1. If ready state is not OPEN (1), then return.
	  if (ws[kReadyState] !== states.OPEN) {
	    return
	  }

	  // 2. Let dataForEvent be determined by switching on type and binary type:
	  let dataForEvent;

	  if (type === opcodes.TEXT) {
	    // -> type indicates that the data is Text
	    //      a new DOMString containing data
	    try {
	      dataForEvent = new TextDecoder('utf-8', { fatal: true }).decode(data);
	    } catch {
	      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.');
	      return
	    }
	  } else if (type === opcodes.BINARY) {
	    if (ws[kBinaryType] === 'blob') {
	      // -> type indicates that the data is Binary and binary type is "blob"
	      //      a new Blob object, created in the relevant Realm of the WebSocket
	      //      object, that represents data as its raw data
	      dataForEvent = new Blob([data]);
	    } else {
	      // -> type indicates that the data is Binary and binary type is "arraybuffer"
	      //      a new ArrayBuffer object, created in the relevant Realm of the
	      //      WebSocket object, whose contents are data
	      dataForEvent = new Uint8Array(data).buffer;
	    }
	  }

	  // 3. Fire an event named message at the WebSocket object, using MessageEvent,
	  //    with the origin attribute initialized to the serialization of the WebSocket
	  //    objects url's origin, and the data attribute initialized to dataForEvent.
	  fireEvent('message', ws, MessageEvent, {
	    origin: ws[kWebSocketURL].origin,
	    data: dataForEvent
	  });
	}

	/**
	 * @see https://datatracker.ietf.org/doc/html/rfc6455
	 * @see https://datatracker.ietf.org/doc/html/rfc2616
	 * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	 * @param {string} protocol
	 */
	function isValidSubprotocol (protocol) {
	  // If present, this value indicates one
	  // or more comma-separated subprotocol the client wishes to speak,
	  // ordered by preference.  The elements that comprise this value
	  // MUST be non-empty strings with characters in the range U+0021 to
	  // U+007E not including separator characters as defined in
	  // [RFC2616] and MUST all be unique strings.
	  if (protocol.length === 0) {
	    return false
	  }

	  for (const char of protocol) {
	    const code = char.charCodeAt(0);

	    if (
	      code < 0x21 ||
	      code > 0x7E ||
	      char === '(' ||
	      char === ')' ||
	      char === '<' ||
	      char === '>' ||
	      char === '@' ||
	      char === ',' ||
	      char === ';' ||
	      char === ':' ||
	      char === '\\' ||
	      char === '"' ||
	      char === '/' ||
	      char === '[' ||
	      char === ']' ||
	      char === '?' ||
	      char === '=' ||
	      char === '{' ||
	      char === '}' ||
	      code === 32 || // SP
	      code === 9 // HT
	    ) {
	      return false
	    }
	  }

	  return true
	}

	/**
	 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	 * @param {number} code
	 */
	function isValidStatusCode (code) {
	  if (code >= 1000 && code < 1015) {
	    return (
	      code !== 1004 && // reserved
	      code !== 1005 && // "MUST NOT be set as a status code"
	      code !== 1006 // "MUST NOT be set as a status code"
	    )
	  }

	  return code >= 3000 && code <= 4999
	}

	/**
	 * @param {import('./websocket').WebSocket} ws
	 * @param {string|undefined} reason
	 */
	function failWebsocketConnection (ws, reason) {
	  const { [kController]: controller, [kResponse]: response } = ws;

	  controller.abort();

	  if (response?.socket && !response.socket.destroyed) {
	    response.socket.destroy();
	  }

	  if (reason) {
	    fireEvent('error', ws, ErrorEvent, {
	      error: new Error(reason)
	    });
	  }
	}

	util$2 = {
	  isEstablished,
	  isClosing,
	  isClosed,
	  fireEvent,
	  isValidSubprotocol,
	  isValidStatusCode,
	  failWebsocketConnection,
	  websocketMessageReceived
	};
	return util$2;
}

var connection;
var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection;
	hasRequiredConnection = 1;

	const diagnosticsChannel = require$$0$e;
	const { uid, states } = requireConstants$1();
	const {
	  kReadyState,
	  kSentClose,
	  kByteParser,
	  kReceivedClose
	} = requireSymbols();
	const { fireEvent, failWebsocketConnection } = requireUtil$2();
	const { CloseEvent } = requireEvents();
	const { makeRequest } = requireRequest();
	const { fetching } = requireFetch$1();
	const { Headers } = requireHeaders();
	const { getGlobalDispatcher } = requireGlobal();
	const { kHeadersList } = requireSymbols$4();

	const channels = {};
	channels.open = diagnosticsChannel.channel('undici:websocket:open');
	channels.close = diagnosticsChannel.channel('undici:websocket:close');
	channels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');

	/** @type {import('crypto')} */
	let crypto;
	try {
	  crypto = require('crypto');
	} catch {

	}

	/**
	 * @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	 * @param {URL} url
	 * @param {string|string[]} protocols
	 * @param {import('./websocket').WebSocket} ws
	 * @param {(response: any) => void} onEstablish
	 * @param {Partial<import('../../types/websocket').WebSocketInit>} options
	 */
	function establishWebSocketConnection (url, protocols, ws, onEstablish, options) {
	  // 1. Let requestURL be a copy of url, with its scheme set to "http", if urls
	  //    scheme is "ws", and to "https" otherwise.
	  const requestURL = url;

	  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';

	  // 2. Let request be a new request, whose URL is requestURL, client is client,
	  //    service-workers mode is "none", referrer is "no-referrer", mode is
	  //    "websocket", credentials mode is "include", cache mode is "no-store" ,
	  //    and redirect mode is "error".
	  const request = makeRequest({
	    urlList: [requestURL],
	    serviceWorkers: 'none',
	    referrer: 'no-referrer',
	    mode: 'websocket',
	    credentials: 'include',
	    cache: 'no-store',
	    redirect: 'error'
	  });

	  // Note: undici extension, allow setting custom headers.
	  if (options.headers) {
	    const headersList = new Headers(options.headers)[kHeadersList];

	    request.headersList = headersList;
	  }

	  // 3. Append (`Upgrade`, `websocket`) to requests header list.
	  // 4. Append (`Connection`, `Upgrade`) to requests header list.
	  // Note: both of these are handled by undici currently.
	  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397

	  // 5. Let keyValue be a nonce consisting of a randomly selected
	  //    16-byte value that has been forgiving-base64-encoded and
	  //    isomorphic encoded.
	  const keyValue = crypto.randomBytes(16).toString('base64');

	  // 6. Append (`Sec-WebSocket-Key`, keyValue) to requests
	  //    header list.
	  request.headersList.append('sec-websocket-key', keyValue);

	  // 7. Append (`Sec-WebSocket-Version`, `13`) to requests
	  //    header list.
	  request.headersList.append('sec-websocket-version', '13');

	  // 8. For each protocol in protocols, combine
	  //    (`Sec-WebSocket-Protocol`, protocol) in requests header
	  //    list.
	  for (const protocol of protocols) {
	    request.headersList.append('sec-websocket-protocol', protocol);
	  }

	  // 9. Let permessageDeflate be a user-agent defined
	  //    "permessage-deflate" extension header value.
	  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673
	  // TODO: enable once permessage-deflate is supported
	  const permessageDeflate = ''; // 'permessage-deflate; 15'

	  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to
	  //     requests header list.
	  // request.headersList.append('sec-websocket-extensions', permessageDeflate)

	  // 11. Fetch request with useParallelQueue set to true, and
	  //     processResponse given response being these steps:
	  const controller = fetching({
	    request,
	    useParallelQueue: true,
	    dispatcher: options.dispatcher ?? getGlobalDispatcher(),
	    processResponse (response) {
	      // 1. If response is a network error or its status is not 101,
	      //    fail the WebSocket connection.
	      if (response.type === 'error' || response.status !== 101) {
	        failWebsocketConnection(ws, 'Received network error or non-101 status code.');
	        return
	      }

	      // 2. If protocols is not the empty list and extracting header
	      //    list values given `Sec-WebSocket-Protocol` and responses
	      //    header list results in null, failure, or the empty byte
	      //    sequence, then fail the WebSocket connection.
	      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {
	        failWebsocketConnection(ws, 'Server did not respond with sent protocols.');
	        return
	      }

	      // 3. Follow the requirements stated step 2 to step 6, inclusive,
	      //    of the last set of steps in section 4.1 of The WebSocket
	      //    Protocol to validate response. This either results in fail
	      //    the WebSocket connection or the WebSocket connection is
	      //    established.

	      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|
	      //    header field contains a value that is not an ASCII case-
	      //    insensitive match for the value "websocket", the client MUST
	      //    _Fail the WebSocket Connection_.
	      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {
	        failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
	        return
	      }

	      // 3. If the response lacks a |Connection| header field or the
	      //    |Connection| header field doesn't contain a token that is an
	      //    ASCII case-insensitive match for the value "Upgrade", the client
	      //    MUST _Fail the WebSocket Connection_.
	      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {
	        failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
	        return
	      }

	      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or
	      //    the |Sec-WebSocket-Accept| contains a value other than the
	      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-
	      //    Key| (as a string, not base64-decoded) with the string "258EAFA5-
	      //    E914-47DA-95CA-C5AB0DC85B11" but ignoring any leading and
	      //    trailing whitespace, the client MUST _Fail the WebSocket
	      //    Connection_.
	      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');
	      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64');
	      if (secWSAccept !== digest) {
	        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');
	        return
	      }

	      // 5. If the response includes a |Sec-WebSocket-Extensions| header
	      //    field and this header field indicates the use of an extension
	      //    that was not present in the client's handshake (the server has
	      //    indicated an extension not requested by the client), the client
	      //    MUST _Fail the WebSocket Connection_.  (The parsing of this
	      //    header field to determine which extensions are requested is
	      //    discussed in Section 9.1.)
	      const secExtension = response.headersList.get('Sec-WebSocket-Extensions');

	      if (secExtension !== null && secExtension !== permessageDeflate) {
	        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');
	        return
	      }

	      // 6. If the response includes a |Sec-WebSocket-Protocol| header field
	      //    and this header field indicates the use of a subprotocol that was
	      //    not present in the client's handshake (the server has indicated a
	      //    subprotocol not requested by the client), the client MUST _Fail
	      //    the WebSocket Connection_.
	      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');

	      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {
	        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');
	        return
	      }

	      response.socket.on('data', onSocketData);
	      response.socket.on('close', onSocketClose);
	      response.socket.on('error', onSocketError);

	      if (channels.open.hasSubscribers) {
	        channels.open.publish({
	          address: response.socket.address(),
	          protocol: secProtocol,
	          extensions: secExtension
	        });
	      }

	      onEstablish(response);
	    }
	  });

	  return controller
	}

	/**
	 * @param {Buffer} chunk
	 */
	function onSocketData (chunk) {
	  if (!this.ws[kByteParser].write(chunk)) {
	    this.pause();
	  }
	}

	/**
	 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	 * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	 */
	function onSocketClose () {
	  const { ws } = this;

	  // If the TCP connection was closed after the
	  // WebSocket closing handshake was completed, the WebSocket connection
	  // is said to have been closed _cleanly_.
	  const wasClean = ws[kSentClose] && ws[kReceivedClose];

	  let code = 1005;
	  let reason = '';

	  const result = ws[kByteParser].closingInfo;

	  if (result) {
	    code = result.code ?? 1005;
	    reason = result.reason;
	  } else if (!ws[kSentClose]) {
	    // If _The WebSocket
	    // Connection is Closed_ and no Close control frame was received by the
	    // endpoint (such as could occur if the underlying transport connection
	    // is lost), _The WebSocket Connection Close Code_ is considered to be
	    // 1006.
	    code = 1006;
	  }

	  // 1. Change the ready state to CLOSED (3).
	  ws[kReadyState] = states.CLOSED;

	  // 2. If the user agent was required to fail the WebSocket
	  //    connection, or if the WebSocket connection was closed
	  //    after being flagged as full, fire an event named error
	  //    at the WebSocket object.
	  // TODO

	  // 3. Fire an event named close at the WebSocket object,
	  //    using CloseEvent, with the wasClean attribute
	  //    initialized to true if the connection closed cleanly
	  //    and false otherwise, the code attribute initialized to
	  //    the WebSocket connection close code, and the reason
	  //    attribute initialized to the result of applying UTF-8
	  //    decode without BOM to the WebSocket connection close
	  //    reason.
	  fireEvent('close', ws, CloseEvent, {
	    wasClean, code, reason
	  });

	  if (channels.close.hasSubscribers) {
	    channels.close.publish({
	      websocket: ws,
	      code,
	      reason
	    });
	  }
	}

	function onSocketError (error) {
	  const { ws } = this;

	  ws[kReadyState] = states.CLOSING;

	  if (channels.socketError.hasSubscribers) {
	    channels.socketError.publish(error);
	  }

	  this.destroy();
	}

	connection = {
	  establishWebSocketConnection
	};
	return connection;
}

var frame;
var hasRequiredFrame;

function requireFrame () {
	if (hasRequiredFrame) return frame;
	hasRequiredFrame = 1;

	const { maxUnsigned16Bit } = requireConstants$1();

	/** @type {import('crypto')} */
	let crypto;
	try {
	  crypto = require('crypto');
	} catch {

	}

	class WebsocketFrameSend {
	  /**
	   * @param {Buffer|undefined} data
	   */
	  constructor (data) {
	    this.frameData = data;
	    this.maskKey = crypto.randomBytes(4);
	  }

	  createFrame (opcode) {
	    const bodyLength = this.frameData?.byteLength ?? 0;

	    /** @type {number} */
	    let payloadLength = bodyLength; // 0-125
	    let offset = 6;

	    if (bodyLength > maxUnsigned16Bit) {
	      offset += 8; // payload length is next 8 bytes
	      payloadLength = 127;
	    } else if (bodyLength > 125) {
	      offset += 2; // payload length is next 2 bytes
	      payloadLength = 126;
	    }

	    const buffer = Buffer.allocUnsafe(bodyLength + offset);

	    // Clear first 2 bytes, everything else is overwritten
	    buffer[0] = buffer[1] = 0;
	    buffer[0] |= 0x80; // FIN
	    buffer[0] = (buffer[0] & 0xF0) + opcode; // opcode

	    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
	    buffer[offset - 4] = this.maskKey[0];
	    buffer[offset - 3] = this.maskKey[1];
	    buffer[offset - 2] = this.maskKey[2];
	    buffer[offset - 1] = this.maskKey[3];

	    buffer[1] = payloadLength;

	    if (payloadLength === 126) {
	      buffer.writeUInt16BE(bodyLength, 2);
	    } else if (payloadLength === 127) {
	      // Clear extended payload length
	      buffer[2] = buffer[3] = 0;
	      buffer.writeUIntBE(bodyLength, 4, 6);
	    }

	    buffer[1] |= 0x80; // MASK

	    // mask body
	    for (let i = 0; i < bodyLength; i++) {
	      buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
	    }

	    return buffer
	  }
	}

	frame = {
	  WebsocketFrameSend
	};
	return frame;
}

var receiver;
var hasRequiredReceiver;

function requireReceiver () {
	if (hasRequiredReceiver) return receiver;
	hasRequiredReceiver = 1;

	const { Writable } = require$$0$9;
	const diagnosticsChannel = require$$0$e;
	const { parserStates, opcodes, states, emptyBuffer } = requireConstants$1();
	const { kReadyState, kSentClose, kResponse, kReceivedClose } = requireSymbols();
	const { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = requireUtil$2();
	const { WebsocketFrameSend } = requireFrame();

	// This code was influenced by ws released under the MIT license.
	// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>
	// Copyright (c) 2013 Arnout Kazemier and contributors
	// Copyright (c) 2016 Luigi Pinca and contributors

	const channels = {};
	channels.ping = diagnosticsChannel.channel('undici:websocket:ping');
	channels.pong = diagnosticsChannel.channel('undici:websocket:pong');

	class ByteParser extends Writable {
	  #buffers = []
	  #byteOffset = 0

	  #state = parserStates.INFO

	  #info = {}
	  #fragments = []

	  constructor (ws) {
	    super();

	    this.ws = ws;
	  }

	  /**
	   * @param {Buffer} chunk
	   * @param {() => void} callback
	   */
	  _write (chunk, _, callback) {
	    this.#buffers.push(chunk);
	    this.#byteOffset += chunk.length;

	    this.run(callback);
	  }

	  /**
	   * Runs whenever a new chunk is received.
	   * Callback is called whenever there are no more chunks buffering,
	   * or not enough bytes are buffered to parse.
	   */
	  run (callback) {
	    while (true) {
	      if (this.#state === parserStates.INFO) {
	        // If there aren't enough bytes to parse the payload length, etc.
	        if (this.#byteOffset < 2) {
	          return callback()
	        }

	        const buffer = this.consume(2);

	        this.#info.fin = (buffer[0] & 0x80) !== 0;
	        this.#info.opcode = buffer[0] & 0x0F;

	        // If we receive a fragmented message, we use the type of the first
	        // frame to parse the full message as binary/text, when it's terminated
	        this.#info.originalOpcode ??= this.#info.opcode;

	        this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;

	        if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
	          // Only text and binary frames can be fragmented
	          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.');
	          return
	        }

	        const payloadLength = buffer[1] & 0x7F;

	        if (payloadLength <= 125) {
	          this.#info.payloadLength = payloadLength;
	          this.#state = parserStates.READ_DATA;
	        } else if (payloadLength === 126) {
	          this.#state = parserStates.PAYLOADLENGTH_16;
	        } else if (payloadLength === 127) {
	          this.#state = parserStates.PAYLOADLENGTH_64;
	        }

	        if (this.#info.fragmented && payloadLength > 125) {
	          // A fragmented frame can't be fragmented itself
	          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.');
	          return
	        } else if (
	          (this.#info.opcode === opcodes.PING ||
	            this.#info.opcode === opcodes.PONG ||
	            this.#info.opcode === opcodes.CLOSE) &&
	          payloadLength > 125
	        ) {
	          // Control frames can have a payload length of 125 bytes MAX
	          failWebsocketConnection(this.ws, 'Payload length for control frame exceeded 125 bytes.');
	          return
	        } else if (this.#info.opcode === opcodes.CLOSE) {
	          if (payloadLength === 1) {
	            failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.');
	            return
	          }

	          const body = this.consume(payloadLength);

	          this.#info.closeInfo = this.parseCloseBody(false, body);

	          if (!this.ws[kSentClose]) {
	            // If an endpoint receives a Close frame and did not previously send a
	            // Close frame, the endpoint MUST send a Close frame in response.  (When
	            // sending a Close frame in response, the endpoint typically echos the
	            // status code it received.)
	            const body = Buffer.allocUnsafe(2);
	            body.writeUInt16BE(this.#info.closeInfo.code, 0);
	            const closeFrame = new WebsocketFrameSend(body);

	            this.ws[kResponse].socket.write(
	              closeFrame.createFrame(opcodes.CLOSE),
	              (err) => {
	                if (!err) {
	                  this.ws[kSentClose] = true;
	                }
	              }
	            );
	          }

	          // Upon either sending or receiving a Close control frame, it is said
	          // that _The WebSocket Closing Handshake is Started_ and that the
	          // WebSocket connection is in the CLOSING state.
	          this.ws[kReadyState] = states.CLOSING;
	          this.ws[kReceivedClose] = true;

	          this.end();

	          return
	        } else if (this.#info.opcode === opcodes.PING) {
	          // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in
	          // response, unless it already received a Close frame.
	          // A Pong frame sent in response to a Ping frame must have identical
	          // "Application data"

	          const body = this.consume(payloadLength);

	          if (!this.ws[kReceivedClose]) {
	            const frame = new WebsocketFrameSend(body);

	            this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));

	            if (channels.ping.hasSubscribers) {
	              channels.ping.publish({
	                payload: body
	              });
	            }
	          }

	          this.#state = parserStates.INFO;

	          if (this.#byteOffset > 0) {
	            continue
	          } else {
	            callback();
	            return
	          }
	        } else if (this.#info.opcode === opcodes.PONG) {
	          // A Pong frame MAY be sent unsolicited.  This serves as a
	          // unidirectional heartbeat.  A response to an unsolicited Pong frame is
	          // not expected.

	          const body = this.consume(payloadLength);

	          if (channels.pong.hasSubscribers) {
	            channels.pong.publish({
	              payload: body
	            });
	          }

	          if (this.#byteOffset > 0) {
	            continue
	          } else {
	            callback();
	            return
	          }
	        }
	      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
	        if (this.#byteOffset < 2) {
	          return callback()
	        }

	        const buffer = this.consume(2);

	        this.#info.payloadLength = buffer.readUInt16BE(0);
	        this.#state = parserStates.READ_DATA;
	      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
	        if (this.#byteOffset < 8) {
	          return callback()
	        }

	        const buffer = this.consume(8);
	        const upper = buffer.readUInt32BE(0);

	        // 2^31 is the maxinimum bytes an arraybuffer can contain
	        // on 32-bit systems. Although, on 64-bit systems, this is
	        // 2^53-1 bytes.
	        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length
	        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275
	        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e
	        if (upper > 2 ** 31 - 1) {
	          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.');
	          return
	        }

	        const lower = buffer.readUInt32BE(4);

	        this.#info.payloadLength = (upper << 8) + lower;
	        this.#state = parserStates.READ_DATA;
	      } else if (this.#state === parserStates.READ_DATA) {
	        if (this.#byteOffset < this.#info.payloadLength) {
	          // If there is still more data in this chunk that needs to be read
	          return callback()
	        } else if (this.#byteOffset >= this.#info.payloadLength) {
	          // If the server sent multiple frames in a single chunk

	          const body = this.consume(this.#info.payloadLength);

	          this.#fragments.push(body);

	          // If the frame is unfragmented, or a fragmented frame was terminated,
	          // a message was received
	          if (!this.#info.fragmented || (this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)) {
	            const fullMessage = Buffer.concat(this.#fragments);

	            websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);

	            this.#info = {};
	            this.#fragments.length = 0;
	          }

	          this.#state = parserStates.INFO;
	        }
	      }

	      if (this.#byteOffset > 0) {
	        continue
	      } else {
	        callback();
	        break
	      }
	    }
	  }

	  /**
	   * Take n bytes from the buffered Buffers
	   * @param {number} n
	   * @returns {Buffer|null}
	   */
	  consume (n) {
	    if (n > this.#byteOffset) {
	      return null
	    } else if (n === 0) {
	      return emptyBuffer
	    }

	    if (this.#buffers[0].length === n) {
	      this.#byteOffset -= this.#buffers[0].length;
	      return this.#buffers.shift()
	    }

	    const buffer = Buffer.allocUnsafe(n);
	    let offset = 0;

	    while (offset !== n) {
	      const next = this.#buffers[0];
	      const { length } = next;

	      if (length + offset === n) {
	        buffer.set(this.#buffers.shift(), offset);
	        break
	      } else if (length + offset > n) {
	        buffer.set(next.subarray(0, n - offset), offset);
	        this.#buffers[0] = next.subarray(n - offset);
	        break
	      } else {
	        buffer.set(this.#buffers.shift(), offset);
	        offset += next.length;
	      }
	    }

	    this.#byteOffset -= n;

	    return buffer
	  }

	  parseCloseBody (onlyCode, data) {
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5
	    /** @type {number|undefined} */
	    let code;

	    if (data.length >= 2) {
	      // _The WebSocket Connection Close Code_ is
	      // defined as the status code (Section 7.4) contained in the first Close
	      // control frame received by the application
	      code = data.readUInt16BE(0);
	    }

	    if (onlyCode) {
	      if (!isValidStatusCode(code)) {
	        return null
	      }

	      return { code }
	    }

	    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6
	    /** @type {Buffer} */
	    let reason = data.subarray(2);

	    // Remove BOM
	    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {
	      reason = reason.subarray(3);
	    }

	    if (code !== undefined && !isValidStatusCode(code)) {
	      return null
	    }

	    try {
	      // TODO: optimize this
	      reason = new TextDecoder('utf-8', { fatal: true }).decode(reason);
	    } catch {
	      return null
	    }

	    return { code, reason }
	  }

	  get closingInfo () {
	    return this.#info.closeInfo
	  }
	}

	receiver = {
	  ByteParser
	};
	return receiver;
}

var websocket;
var hasRequiredWebsocket;

function requireWebsocket () {
	if (hasRequiredWebsocket) return websocket;
	hasRequiredWebsocket = 1;

	const { webidl } = requireWebidl();
	const { DOMException } = requireConstants$4();
	const { URLSerializer } = requireDataURL();
	const { getGlobalOrigin } = requireGlobal$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = requireConstants$1();
	const {
	  kWebSocketURL,
	  kReadyState,
	  kController,
	  kBinaryType,
	  kResponse,
	  kSentClose,
	  kByteParser
	} = requireSymbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = requireUtil$2();
	const { establishWebSocketConnection } = requireConnection();
	const { WebsocketFrameSend } = requireFrame();
	const { ByteParser } = requireReceiver();
	const { kEnumerableProperty, isBlobLike } = requireUtil$8();
	const { getGlobalDispatcher } = requireGlobal();
	const { types } = require$$0$7;

	let experimentalWarned = false;

	// https://websockets.spec.whatwg.org/#interface-definition
	class WebSocket extends EventTarget {
	  #events = {
	    open: null,
	    error: null,
	    close: null,
	    message: null
	  }

	  #bufferedAmount = 0
	  #protocol = ''
	  #extensions = ''

	  /**
	   * @param {string} url
	   * @param {string|string[]} protocols
	   */
	  constructor (url, protocols = []) {
	    super();

	    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' });

	    if (!experimentalWarned) {
	      experimentalWarned = true;
	      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {
	        code: 'UNDICI-WS'
	      });
	    }

	    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols);

	    url = webidl.converters.USVString(url);
	    protocols = options.protocols;

	    // 1. Let baseURL be this's relevant settings object's API base URL.
	    const baseURL = getGlobalOrigin();

	    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.
	    let urlRecord;

	    try {
	      urlRecord = new URL(url, baseURL);
	    } catch (e) {
	      // 3. If urlRecord is failure, then throw a "SyntaxError" DOMException.
	      throw new DOMException(e, 'SyntaxError')
	    }

	    // 4. If urlRecords scheme is "http", then set urlRecords scheme to "ws".
	    if (urlRecord.protocol === 'http:') {
	      urlRecord.protocol = 'ws:';
	    } else if (urlRecord.protocol === 'https:') {
	      // 5. Otherwise, if urlRecords scheme is "https", set urlRecords scheme to "wss".
	      urlRecord.protocol = 'wss:';
	    }

	    // 6. If urlRecords scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
	    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {
	      throw new DOMException(
	        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
	        'SyntaxError'
	      )
	    }

	    // 7. If urlRecords fragment is non-null, then throw a "SyntaxError"
	    //    DOMException.
	    if (urlRecord.hash || urlRecord.href.endsWith('#')) {
	      throw new DOMException('Got fragment', 'SyntaxError')
	    }

	    // 8. If protocols is a string, set protocols to a sequence consisting
	    //    of just that string.
	    if (typeof protocols === 'string') {
	      protocols = [protocols];
	    }

	    // 9. If any of the values in protocols occur more than once or otherwise
	    //    fail to match the requirements for elements that comprise the value
	    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket
	    //    protocol, then throw a "SyntaxError" DOMException.
	    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {
	      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
	    }

	    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {
	      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')
	    }

	    // 10. Set this's url to urlRecord.
	    this[kWebSocketURL] = new URL(urlRecord.href);

	    // 11. Let client be this's relevant settings object.

	    // 12. Run this step in parallel:

	    //    1. Establish a WebSocket connection given urlRecord, protocols,
	    //       and client.
	    this[kController] = establishWebSocketConnection(
	      urlRecord,
	      protocols,
	      this,
	      (response) => this.#onConnectionEstablished(response),
	      options
	    );

	    // Each WebSocket object has an associated ready state, which is a
	    // number representing the state of the connection. Initially it must
	    // be CONNECTING (0).
	    this[kReadyState] = WebSocket.CONNECTING;

	    // The extensions attribute must initially return the empty string.

	    // The protocol attribute must initially return the empty string.

	    // Each WebSocket object has an associated binary type, which is a
	    // BinaryType. Initially it must be "blob".
	    this[kBinaryType] = 'blob';
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#dom-websocket-close
	   * @param {number|undefined} code
	   * @param {string|undefined} reason
	   */
	  close (code = undefined, reason = undefined) {
	    webidl.brandCheck(this, WebSocket);

	    if (code !== undefined) {
	      code = webidl.converters['unsigned short'](code, { clamp: true });
	    }

	    if (reason !== undefined) {
	      reason = webidl.converters.USVString(reason);
	    }

	    // 1. If code is present, but is neither an integer equal to 1000 nor an
	    //    integer in the range 3000 to 4999, inclusive, throw an
	    //    "InvalidAccessError" DOMException.
	    if (code !== undefined) {
	      if (code !== 1000 && (code < 3000 || code > 4999)) {
	        throw new DOMException('invalid code', 'InvalidAccessError')
	      }
	    }

	    let reasonByteLength = 0;

	    // 2. If reason is present, then run these substeps:
	    if (reason !== undefined) {
	      // 1. Let reasonBytes be the result of encoding reason.
	      // 2. If reasonBytes is longer than 123 bytes, then throw a
	      //    "SyntaxError" DOMException.
	      reasonByteLength = Buffer.byteLength(reason);

	      if (reasonByteLength > 123) {
	        throw new DOMException(
	          `Reason must be less than 123 bytes; received ${reasonByteLength}`,
	          'SyntaxError'
	        )
	      }
	    }

	    // 3. Run the first matching steps from the following list:
	    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) ; else if (!isEstablished(this)) {
	      // If the WebSocket connection is not yet established
	      // Fail the WebSocket connection and set this's ready state
	      // to CLOSING (2).
	      failWebsocketConnection(this, 'Connection was closed before it was established.');
	      this[kReadyState] = WebSocket.CLOSING;
	    } else if (!isClosing(this)) {
	      // If the WebSocket closing handshake has not yet been started
	      // Start the WebSocket closing handshake and set this's ready
	      // state to CLOSING (2).
	      // - If neither code nor reason is present, the WebSocket Close
	      //   message must not have a body.
	      // - If code is present, then the status code to use in the
	      //   WebSocket Close message must be the integer given by code.
	      // - If reason is also present, then reasonBytes must be
	      //   provided in the Close message after the status code.

	      const frame = new WebsocketFrameSend();

	      // If neither code nor reason is present, the WebSocket Close
	      // message must not have a body.

	      // If code is present, then the status code to use in the
	      // WebSocket Close message must be the integer given by code.
	      if (code !== undefined && reason === undefined) {
	        frame.frameData = Buffer.allocUnsafe(2);
	        frame.frameData.writeUInt16BE(code, 0);
	      } else if (code !== undefined && reason !== undefined) {
	        // If reason is also present, then reasonBytes must be
	        // provided in the Close message after the status code.
	        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
	        frame.frameData.writeUInt16BE(code, 0);
	        // the body MAY contain UTF-8-encoded data with value /reason/
	        frame.frameData.write(reason, 2, 'utf-8');
	      } else {
	        frame.frameData = emptyBuffer;
	      }

	      /** @type {import('stream').Duplex} */
	      const socket = this[kResponse].socket;

	      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
	        if (!err) {
	          this[kSentClose] = true;
	        }
	      });

	      // Upon either sending or receiving a Close control frame, it is said
	      // that _The WebSocket Closing Handshake is Started_ and that the
	      // WebSocket connection is in the CLOSING state.
	      this[kReadyState] = states.CLOSING;
	    } else {
	      // Otherwise
	      // Set this's ready state to CLOSING (2).
	      this[kReadyState] = WebSocket.CLOSING;
	    }
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#dom-websocket-send
	   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
	   */
	  send (data) {
	    webidl.brandCheck(this, WebSocket);

	    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' });

	    data = webidl.converters.WebSocketSendData(data);

	    // 1. If this's ready state is CONNECTING, then throw an
	    //    "InvalidStateError" DOMException.
	    if (this[kReadyState] === WebSocket.CONNECTING) {
	      throw new DOMException('Sent before connected.', 'InvalidStateError')
	    }

	    // 2. Run the appropriate set of steps from the following list:
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2

	    if (!isEstablished(this) || isClosing(this)) {
	      return
	    }

	    /** @type {import('stream').Duplex} */
	    const socket = this[kResponse].socket;

	    // If data is a string
	    if (typeof data === 'string') {
	      // If the WebSocket connection is established and the WebSocket
	      // closing handshake has not yet started, then the user agent
	      // must send a WebSocket Message comprised of the data argument
	      // using a text frame opcode; if the data cannot be sent, e.g.
	      // because it would need to be buffered but the buffer is full,
	      // the user agent must flag the WebSocket as full and then close
	      // the WebSocket connection. Any invocation of this method with a
	      // string argument that does not throw an exception must increase
	      // the bufferedAmount attribute by the number of bytes needed to
	      // express the argument as UTF-8.

	      const value = Buffer.from(data);
	      const frame = new WebsocketFrameSend(value);
	      const buffer = frame.createFrame(opcodes.TEXT);

	      this.#bufferedAmount += value.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= value.byteLength;
	      });
	    } else if (types.isArrayBuffer(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need
	      // to be buffered but the buffer is full, the user agent must flag
	      // the WebSocket as full and then close the WebSocket connection.
	      // The data to be sent is the data stored in the buffer described
	      // by the ArrayBuffer object. Any invocation of this method with an
	      // ArrayBuffer argument that does not throw an exception must
	      // increase the bufferedAmount attribute by the length of the
	      // ArrayBuffer in bytes.

	      const value = Buffer.from(data);
	      const frame = new WebsocketFrameSend(value);
	      const buffer = frame.createFrame(opcodes.BINARY);

	      this.#bufferedAmount += value.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= value.byteLength;
	      });
	    } else if (ArrayBuffer.isView(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need to
	      // be buffered but the buffer is full, the user agent must flag the
	      // WebSocket as full and then close the WebSocket connection. The
	      // data to be sent is the data stored in the section of the buffer
	      // described by the ArrayBuffer object that data references. Any
	      // invocation of this method with this kind of argument that does
	      // not throw an exception must increase the bufferedAmount attribute
	      // by the length of datas buffer in bytes.

	      const ab = Buffer.from(data, data.byteOffset, data.byteLength);

	      const frame = new WebsocketFrameSend(ab);
	      const buffer = frame.createFrame(opcodes.BINARY);

	      this.#bufferedAmount += ab.byteLength;
	      socket.write(buffer, () => {
	        this.#bufferedAmount -= ab.byteLength;
	      });
	    } else if (isBlobLike(data)) {
	      // If the WebSocket connection is established, and the WebSocket
	      // closing handshake has not yet started, then the user agent must
	      // send a WebSocket Message comprised of data using a binary frame
	      // opcode; if the data cannot be sent, e.g. because it would need to
	      // be buffered but the buffer is full, the user agent must flag the
	      // WebSocket as full and then close the WebSocket connection. The data
	      // to be sent is the raw data represented by the Blob object. Any
	      // invocation of this method with a Blob argument that does not throw
	      // an exception must increase the bufferedAmount attribute by the size
	      // of the Blob objects raw data, in bytes.

	      const frame = new WebsocketFrameSend();

	      data.arrayBuffer().then((ab) => {
	        const value = Buffer.from(ab);
	        frame.frameData = value;
	        const buffer = frame.createFrame(opcodes.BINARY);

	        this.#bufferedAmount += value.byteLength;
	        socket.write(buffer, () => {
	          this.#bufferedAmount -= value.byteLength;
	        });
	      });
	    }
	  }

	  get readyState () {
	    webidl.brandCheck(this, WebSocket);

	    // The readyState getter steps are to return this's ready state.
	    return this[kReadyState]
	  }

	  get bufferedAmount () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#bufferedAmount
	  }

	  get url () {
	    webidl.brandCheck(this, WebSocket);

	    // The url getter steps are to return this's url, serialized.
	    return URLSerializer(this[kWebSocketURL])
	  }

	  get extensions () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#extensions
	  }

	  get protocol () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#protocol
	  }

	  get onopen () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.open
	  }

	  set onopen (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.open) {
	      this.removeEventListener('open', this.#events.open);
	    }

	    if (typeof fn === 'function') {
	      this.#events.open = fn;
	      this.addEventListener('open', fn);
	    } else {
	      this.#events.open = null;
	    }
	  }

	  get onerror () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.error
	  }

	  set onerror (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.error) {
	      this.removeEventListener('error', this.#events.error);
	    }

	    if (typeof fn === 'function') {
	      this.#events.error = fn;
	      this.addEventListener('error', fn);
	    } else {
	      this.#events.error = null;
	    }
	  }

	  get onclose () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.close
	  }

	  set onclose (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.close) {
	      this.removeEventListener('close', this.#events.close);
	    }

	    if (typeof fn === 'function') {
	      this.#events.close = fn;
	      this.addEventListener('close', fn);
	    } else {
	      this.#events.close = null;
	    }
	  }

	  get onmessage () {
	    webidl.brandCheck(this, WebSocket);

	    return this.#events.message
	  }

	  set onmessage (fn) {
	    webidl.brandCheck(this, WebSocket);

	    if (this.#events.message) {
	      this.removeEventListener('message', this.#events.message);
	    }

	    if (typeof fn === 'function') {
	      this.#events.message = fn;
	      this.addEventListener('message', fn);
	    } else {
	      this.#events.message = null;
	    }
	  }

	  get binaryType () {
	    webidl.brandCheck(this, WebSocket);

	    return this[kBinaryType]
	  }

	  set binaryType (type) {
	    webidl.brandCheck(this, WebSocket);

	    if (type !== 'blob' && type !== 'arraybuffer') {
	      this[kBinaryType] = 'blob';
	    } else {
	      this[kBinaryType] = type;
	    }
	  }

	  /**
	   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	   */
	  #onConnectionEstablished (response) {
	    // processResponse is called when the "responses header list has been received and initialized."
	    // once this happens, the connection is open
	    this[kResponse] = response;

	    const parser = new ByteParser(this);
	    parser.on('drain', function onParserDrain () {
	      this.ws[kResponse].socket.resume();
	    });

	    response.socket.ws = this;
	    this[kByteParser] = parser;

	    // 1. Change the ready state to OPEN (1).
	    this[kReadyState] = states.OPEN;

	    // 2. Change the extensions attributes value to the extensions in use, if
	    //    it is not the null value.
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1
	    const extensions = response.headersList.get('sec-websocket-extensions');

	    if (extensions !== null) {
	      this.#extensions = extensions;
	    }

	    // 3. Change the protocol attributes value to the subprotocol in use, if
	    //    it is not the null value.
	    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
	    const protocol = response.headersList.get('sec-websocket-protocol');

	    if (protocol !== null) {
	      this.#protocol = protocol;
	    }

	    // 4. Fire an event named open at the WebSocket object.
	    fireEvent('open', this);
	  }
	}

	// https://websockets.spec.whatwg.org/#dom-websocket-connecting
	WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
	// https://websockets.spec.whatwg.org/#dom-websocket-open
	WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
	// https://websockets.spec.whatwg.org/#dom-websocket-closing
	WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
	// https://websockets.spec.whatwg.org/#dom-websocket-closed
	WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;

	Object.defineProperties(WebSocket.prototype, {
	  CONNECTING: staticPropertyDescriptors,
	  OPEN: staticPropertyDescriptors,
	  CLOSING: staticPropertyDescriptors,
	  CLOSED: staticPropertyDescriptors,
	  url: kEnumerableProperty,
	  readyState: kEnumerableProperty,
	  bufferedAmount: kEnumerableProperty,
	  onopen: kEnumerableProperty,
	  onerror: kEnumerableProperty,
	  onclose: kEnumerableProperty,
	  close: kEnumerableProperty,
	  onmessage: kEnumerableProperty,
	  binaryType: kEnumerableProperty,
	  send: kEnumerableProperty,
	  extensions: kEnumerableProperty,
	  protocol: kEnumerableProperty,
	  [Symbol.toStringTag]: {
	    value: 'WebSocket',
	    writable: false,
	    enumerable: false,
	    configurable: true
	  }
	});

	Object.defineProperties(WebSocket, {
	  CONNECTING: staticPropertyDescriptors,
	  OPEN: staticPropertyDescriptors,
	  CLOSING: staticPropertyDescriptors,
	  CLOSED: staticPropertyDescriptors
	});

	webidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(
	  webidl.converters.DOMString
	);

	webidl.converters['DOMString or sequence<DOMString>'] = function (V) {
	  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {
	    return webidl.converters['sequence<DOMString>'](V)
	  }

	  return webidl.converters.DOMString(V)
	};

	// This implements the propsal made in https://github.com/whatwg/websockets/issues/42
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
	  {
	    key: 'protocols',
	    converter: webidl.converters['DOMString or sequence<DOMString>'],
	    get defaultValue () {
	      return []
	    }
	  },
	  {
	    key: 'dispatcher',
	    converter: (V) => V,
	    get defaultValue () {
	      return getGlobalDispatcher()
	    }
	  },
	  {
	    key: 'headers',
	    converter: webidl.nullableConverter(webidl.converters.HeadersInit)
	  }
	]);

	webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {
	  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {
	    return webidl.converters.WebSocketInit(V)
	  }

	  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }
	};

	webidl.converters.WebSocketSendData = function (V) {
	  if (webidl.util.Type(V) === 'Object') {
	    if (isBlobLike(V)) {
	      return webidl.converters.Blob(V, { strict: false })
	    }

	    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
	      return webidl.converters.BufferSource(V)
	    }
	  }

	  return webidl.converters.USVString(V)
	};

	websocket = {
	  WebSocket
	};
	return websocket;
}

var hasRequiredUndici;

function requireUndici () {
	if (hasRequiredUndici) return undici;
	hasRequiredUndici = 1;

	const Client = requireClient$1();
	const Dispatcher = requireDispatcher();
	const errors = requireErrors();
	const Pool = requirePool$1();
	const BalancedPool = requireBalancedPool();
	const Agent = requireAgent();
	const util = requireUtil$8();
	const { InvalidArgumentError } = errors;
	const api = requireApi();
	const buildConnector = requireConnect();
	const MockClient = requireMockClient();
	const MockAgent = requireMockAgent();
	const MockPool = requireMockPool();
	const mockErrors = requireMockErrors();
	const ProxyAgent = requireProxyAgent();
	const RetryHandler = requireRetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = requireGlobal();
	const DecoratorHandler = requireDecoratorHandler();
	const RedirectHandler = requireRedirectHandler();
	const createRedirectInterceptor = requireRedirectInterceptor();

	let hasCrypto;
	try {
	  require('crypto');
	  hasCrypto = true;
	} catch {
	  hasCrypto = false;
	}

	Object.assign(Dispatcher.prototype, api);

	undici.Dispatcher = Dispatcher;
	undici.Client = Client;
	undici.Pool = Pool;
	undici.BalancedPool = BalancedPool;
	undici.Agent = Agent;
	undici.ProxyAgent = ProxyAgent;
	undici.RetryHandler = RetryHandler;

	undici.DecoratorHandler = DecoratorHandler;
	undici.RedirectHandler = RedirectHandler;
	undici.createRedirectInterceptor = createRedirectInterceptor;

	undici.buildConnector = buildConnector;
	undici.errors = errors;

	function makeDispatcher (fn) {
	  return (url, opts, handler) => {
	    if (typeof opts === 'function') {
	      handler = opts;
	      opts = null;
	    }

	    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
	      throw new InvalidArgumentError('invalid url')
	    }

	    if (opts != null && typeof opts !== 'object') {
	      throw new InvalidArgumentError('invalid opts')
	    }

	    if (opts && opts.path != null) {
	      if (typeof opts.path !== 'string') {
	        throw new InvalidArgumentError('invalid opts.path')
	      }

	      let path = opts.path;
	      if (!opts.path.startsWith('/')) {
	        path = `/${path}`;
	      }

	      url = new URL(util.parseOrigin(url).origin + path);
	    } else {
	      if (!opts) {
	        opts = typeof url === 'object' ? url : {};
	      }

	      url = util.parseURL(url);
	    }

	    const { agent, dispatcher = getGlobalDispatcher() } = opts;

	    if (agent) {
	      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')
	    }

	    return fn.call(dispatcher, {
	      ...opts,
	      origin: url.origin,
	      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
	      method: opts.method || (opts.body ? 'PUT' : 'GET')
	    }, handler)
	  }
	}

	undici.setGlobalDispatcher = setGlobalDispatcher;
	undici.getGlobalDispatcher = getGlobalDispatcher;

	if (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {
	  let fetchImpl = null;
	  undici.fetch = async function fetch (resource) {
	    if (!fetchImpl) {
	      fetchImpl = requireFetch$1().fetch;
	    }

	    try {
	      return await fetchImpl(...arguments)
	    } catch (err) {
	      if (typeof err === 'object') {
	        Error.captureStackTrace(err, this);
	      }

	      throw err
	    }
	  };
	  undici.Headers = requireHeaders().Headers;
	  undici.Response = requireResponse().Response;
	  undici.Request = requireRequest().Request;
	  undici.FormData = requireFormdata().FormData;
	  undici.File = requireFile().File;
	  undici.FileReader = requireFilereader().FileReader;

	  const { setGlobalOrigin, getGlobalOrigin } = requireGlobal$1();

	  undici.setGlobalOrigin = setGlobalOrigin;
	  undici.getGlobalOrigin = getGlobalOrigin;

	  const { CacheStorage } = requireCachestorage();
	  const { kConstruct } = requireSymbols$1();

	  // Cache & CacheStorage are tightly coupled with fetch. Even if it may run
	  // in an older version of Node, it doesn't have any use without fetch.
	  undici.caches = new CacheStorage(kConstruct);
	}

	if (util.nodeMajor >= 16) {
	  const { deleteCookie, getCookies, getSetCookies, setCookie } = requireCookies();

	  undici.deleteCookie = deleteCookie;
	  undici.getCookies = getCookies;
	  undici.getSetCookies = getSetCookies;
	  undici.setCookie = setCookie;

	  const { parseMIMEType, serializeAMimeType } = requireDataURL();

	  undici.parseMIMEType = parseMIMEType;
	  undici.serializeAMimeType = serializeAMimeType;
	}

	if (util.nodeMajor >= 18 && hasCrypto) {
	  const { WebSocket } = requireWebsocket();

	  undici.WebSocket = WebSocket;
	}

	undici.request = makeDispatcher(api.request);
	undici.stream = makeDispatcher(api.stream);
	undici.pipeline = makeDispatcher(api.pipeline);
	undici.connect = makeDispatcher(api.connect);
	undici.upgrade = makeDispatcher(api.upgrade);

	undici.MockClient = MockClient;
	undici.MockPool = MockPool;
	undici.MockAgent = MockAgent;
	undici.mockErrors = mockErrors;
	return undici;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	/* eslint-disable @typescript-eslint/no-explicit-any */
	var __createBinding = (lib.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (lib.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (lib.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (lib.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(lib, "__esModule", { value: true });
	lib.HttpClient = lib.isHttps = lib.HttpClientResponse = lib.HttpClientError = lib.getProxyUrl = lib.MediaTypes = lib.Headers = lib.HttpCodes = undefined;
	const http = __importStar(require$$2__default);
	const https = __importStar(https__default);
	const pm = __importStar(requireProxy());
	const tunnel = __importStar(requireTunnel());
	const undici_1 = requireUndici();
	var HttpCodes;
	(function (HttpCodes) {
	    HttpCodes[HttpCodes["OK"] = 200] = "OK";
	    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
	    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
	    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
	    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
	    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
	    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
	    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
	    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
	    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
	    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
	    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
	    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
	    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
	    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
	    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
	    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
	    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
	    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
	    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
	    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
	    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
	    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
	    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
	    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
	    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
	    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (lib.HttpCodes = HttpCodes = {}));
	var Headers;
	(function (Headers) {
	    Headers["Accept"] = "accept";
	    Headers["ContentType"] = "content-type";
	})(Headers || (lib.Headers = Headers = {}));
	var MediaTypes;
	(function (MediaTypes) {
	    MediaTypes["ApplicationJson"] = "application/json";
	})(MediaTypes || (lib.MediaTypes = MediaTypes = {}));
	/**
	 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	 */
	function getProxyUrl(serverUrl) {
	    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
	    return proxyUrl ? proxyUrl.href : '';
	}
	lib.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
	    HttpCodes.MovedPermanently,
	    HttpCodes.ResourceMoved,
	    HttpCodes.SeeOther,
	    HttpCodes.TemporaryRedirect,
	    HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
	    HttpCodes.BadGateway,
	    HttpCodes.ServiceUnavailable,
	    HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	class HttpClientError extends Error {
	    constructor(message, statusCode) {
	        super(message);
	        this.name = 'HttpClientError';
	        this.statusCode = statusCode;
	        Object.setPrototypeOf(this, HttpClientError.prototype);
	    }
	}
	lib.HttpClientError = HttpClientError;
	class HttpClientResponse {
	    constructor(message) {
	        this.message = message;
	    }
	    readBody() {
	        return __awaiter(this, undefined, undefined, function* () {
	            return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
	                let output = Buffer.alloc(0);
	                this.message.on('data', (chunk) => {
	                    output = Buffer.concat([output, chunk]);
	                });
	                this.message.on('end', () => {
	                    resolve(output.toString());
	                });
	            }));
	        });
	    }
	    readBodyBuffer() {
	        return __awaiter(this, undefined, undefined, function* () {
	            return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
	                const chunks = [];
	                this.message.on('data', (chunk) => {
	                    chunks.push(chunk);
	                });
	                this.message.on('end', () => {
	                    resolve(Buffer.concat(chunks));
	                });
	            }));
	        });
	    }
	}
	lib.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
	    const parsedUrl = new URL(requestUrl);
	    return parsedUrl.protocol === 'https:';
	}
	lib.isHttps = isHttps;
	class HttpClient {
	    constructor(userAgent, handlers, requestOptions) {
	        this._ignoreSslError = false;
	        this._allowRedirects = true;
	        this._allowRedirectDowngrade = false;
	        this._maxRedirects = 50;
	        this._allowRetries = false;
	        this._maxRetries = 1;
	        this._keepAlive = false;
	        this._disposed = false;
	        this.userAgent = userAgent;
	        this.handlers = handlers || [];
	        this.requestOptions = requestOptions;
	        if (requestOptions) {
	            if (requestOptions.ignoreSslError != null) {
	                this._ignoreSslError = requestOptions.ignoreSslError;
	            }
	            this._socketTimeout = requestOptions.socketTimeout;
	            if (requestOptions.allowRedirects != null) {
	                this._allowRedirects = requestOptions.allowRedirects;
	            }
	            if (requestOptions.allowRedirectDowngrade != null) {
	                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
	            }
	            if (requestOptions.maxRedirects != null) {
	                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
	            }
	            if (requestOptions.keepAlive != null) {
	                this._keepAlive = requestOptions.keepAlive;
	            }
	            if (requestOptions.allowRetries != null) {
	                this._allowRetries = requestOptions.allowRetries;
	            }
	            if (requestOptions.maxRetries != null) {
	                this._maxRetries = requestOptions.maxRetries;
	            }
	        }
	    }
	    options(requestUrl, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    get(requestUrl, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('GET', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    del(requestUrl, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    post(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('POST', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    patch(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    put(requestUrl, data, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('PUT', requestUrl, data, additionalHeaders || {});
	        });
	    }
	    head(requestUrl, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
	        });
	    }
	    sendStream(verb, requestUrl, stream, additionalHeaders) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return this.request(verb, requestUrl, stream, additionalHeaders);
	        });
	    }
	    /**
	     * Gets a typed object from an endpoint
	     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
	     */
	    getJson(requestUrl, additionalHeaders = {}) {
	        return __awaiter(this, undefined, undefined, function* () {
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            const res = yield this.get(requestUrl, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    postJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, undefined, undefined, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.post(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    putJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, undefined, undefined, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.put(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    patchJson(requestUrl, obj, additionalHeaders = {}) {
	        return __awaiter(this, undefined, undefined, function* () {
	            const data = JSON.stringify(obj, null, 2);
	            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
	            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
	            const res = yield this.patch(requestUrl, data, additionalHeaders);
	            return this._processResponse(res, this.requestOptions);
	        });
	    }
	    /**
	     * Makes a raw http request.
	     * All other methods such as get, post, patch, and request ultimately call this.
	     * Prefer get, del, post and patch
	     */
	    request(verb, requestUrl, data, headers) {
	        return __awaiter(this, undefined, undefined, function* () {
	            if (this._disposed) {
	                throw new Error('Client has already been disposed.');
	            }
	            const parsedUrl = new URL(requestUrl);
	            let info = this._prepareRequest(verb, parsedUrl, headers);
	            // Only perform retries on reads since writes may not be idempotent.
	            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
	                ? this._maxRetries + 1
	                : 1;
	            let numTries = 0;
	            let response;
	            do {
	                response = yield this.requestRaw(info, data);
	                // Check if it's an authentication challenge
	                if (response &&
	                    response.message &&
	                    response.message.statusCode === HttpCodes.Unauthorized) {
	                    let authenticationHandler;
	                    for (const handler of this.handlers) {
	                        if (handler.canHandleAuthentication(response)) {
	                            authenticationHandler = handler;
	                            break;
	                        }
	                    }
	                    if (authenticationHandler) {
	                        return authenticationHandler.handleAuthentication(this, info, data);
	                    }
	                    else {
	                        // We have received an unauthorized response but have no handlers to handle it.
	                        // Let the response return to the caller.
	                        return response;
	                    }
	                }
	                let redirectsRemaining = this._maxRedirects;
	                while (response.message.statusCode &&
	                    HttpRedirectCodes.includes(response.message.statusCode) &&
	                    this._allowRedirects &&
	                    redirectsRemaining > 0) {
	                    const redirectUrl = response.message.headers['location'];
	                    if (!redirectUrl) {
	                        // if there's no location to redirect to, we won't
	                        break;
	                    }
	                    const parsedRedirectUrl = new URL(redirectUrl);
	                    if (parsedUrl.protocol === 'https:' &&
	                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
	                        !this._allowRedirectDowngrade) {
	                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
	                    }
	                    // we need to finish reading the response before reassigning response
	                    // which will leak the open socket.
	                    yield response.readBody();
	                    // strip authorization header if redirected to a different hostname
	                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
	                        for (const header in headers) {
	                            // header names are case insensitive
	                            if (header.toLowerCase() === 'authorization') {
	                                delete headers[header];
	                            }
	                        }
	                    }
	                    // let's make the request with the new redirectUrl
	                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
	                    response = yield this.requestRaw(info, data);
	                    redirectsRemaining--;
	                }
	                if (!response.message.statusCode ||
	                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
	                    // If not a retry code, return immediately instead of retrying
	                    return response;
	                }
	                numTries += 1;
	                if (numTries < maxTries) {
	                    yield response.readBody();
	                    yield this._performExponentialBackoff(numTries);
	                }
	            } while (numTries < maxTries);
	            return response;
	        });
	    }
	    /**
	     * Needs to be called if keepAlive is set to true in request options.
	     */
	    dispose() {
	        if (this._agent) {
	            this._agent.destroy();
	        }
	        this._disposed = true;
	    }
	    /**
	     * Raw request.
	     * @param info
	     * @param data
	     */
	    requestRaw(info, data) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return new Promise((resolve, reject) => {
	                function callbackForResult(err, res) {
	                    if (err) {
	                        reject(err);
	                    }
	                    else if (!res) {
	                        // If `err` is not passed, then `res` must be passed.
	                        reject(new Error('Unknown error'));
	                    }
	                    else {
	                        resolve(res);
	                    }
	                }
	                this.requestRawWithCallback(info, data, callbackForResult);
	            });
	        });
	    }
	    /**
	     * Raw request with callback.
	     * @param info
	     * @param data
	     * @param onResult
	     */
	    requestRawWithCallback(info, data, onResult) {
	        if (typeof data === 'string') {
	            if (!info.options.headers) {
	                info.options.headers = {};
	            }
	            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
	        }
	        let callbackCalled = false;
	        function handleResult(err, res) {
	            if (!callbackCalled) {
	                callbackCalled = true;
	                onResult(err, res);
	            }
	        }
	        const req = info.httpModule.request(info.options, (msg) => {
	            const res = new HttpClientResponse(msg);
	            handleResult(undefined, res);
	        });
	        let socket;
	        req.on('socket', sock => {
	            socket = sock;
	        });
	        // If we ever get disconnected, we want the socket to timeout eventually
	        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
	            if (socket) {
	                socket.end();
	            }
	            handleResult(new Error(`Request timeout: ${info.options.path}`));
	        });
	        req.on('error', function (err) {
	            // err has statusCode property
	            // res should have headers
	            handleResult(err);
	        });
	        if (data && typeof data === 'string') {
	            req.write(data, 'utf8');
	        }
	        if (data && typeof data !== 'string') {
	            data.on('close', function () {
	                req.end();
	            });
	            data.pipe(req);
	        }
	        else {
	            req.end();
	        }
	    }
	    /**
	     * Gets an http agent. This function is useful when you need an http agent that handles
	     * routing through a proxy server - depending upon the url and proxy environment variables.
	     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	     */
	    getAgent(serverUrl) {
	        const parsedUrl = new URL(serverUrl);
	        return this._getAgent(parsedUrl);
	    }
	    getAgentDispatcher(serverUrl) {
	        const parsedUrl = new URL(serverUrl);
	        const proxyUrl = pm.getProxyUrl(parsedUrl);
	        const useProxy = proxyUrl && proxyUrl.hostname;
	        if (!useProxy) {
	            return;
	        }
	        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
	    }
	    _prepareRequest(method, requestUrl, headers) {
	        const info = {};
	        info.parsedUrl = requestUrl;
	        const usingSsl = info.parsedUrl.protocol === 'https:';
	        info.httpModule = usingSsl ? https : http;
	        const defaultPort = usingSsl ? 443 : 80;
	        info.options = {};
	        info.options.host = info.parsedUrl.hostname;
	        info.options.port = info.parsedUrl.port
	            ? parseInt(info.parsedUrl.port)
	            : defaultPort;
	        info.options.path =
	            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
	        info.options.method = method;
	        info.options.headers = this._mergeHeaders(headers);
	        if (this.userAgent != null) {
	            info.options.headers['user-agent'] = this.userAgent;
	        }
	        info.options.agent = this._getAgent(info.parsedUrl);
	        // gives handlers an opportunity to participate
	        if (this.handlers) {
	            for (const handler of this.handlers) {
	                handler.prepareRequest(info.options);
	            }
	        }
	        return info;
	    }
	    _mergeHeaders(headers) {
	        if (this.requestOptions && this.requestOptions.headers) {
	            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
	        }
	        return lowercaseKeys(headers || {});
	    }
	    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
	        let clientHeader;
	        if (this.requestOptions && this.requestOptions.headers) {
	            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
	        }
	        return additionalHeaders[header] || clientHeader || _default;
	    }
	    _getAgent(parsedUrl) {
	        let agent;
	        const proxyUrl = pm.getProxyUrl(parsedUrl);
	        const useProxy = proxyUrl && proxyUrl.hostname;
	        if (this._keepAlive && useProxy) {
	            agent = this._proxyAgent;
	        }
	        if (!useProxy) {
	            agent = this._agent;
	        }
	        // if agent is already assigned use that agent.
	        if (agent) {
	            return agent;
	        }
	        const usingSsl = parsedUrl.protocol === 'https:';
	        let maxSockets = 100;
	        if (this.requestOptions) {
	            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
	        }
	        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
	        if (proxyUrl && proxyUrl.hostname) {
	            const agentOptions = {
	                maxSockets,
	                keepAlive: this._keepAlive,
	                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
	                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
	                })), { host: proxyUrl.hostname, port: proxyUrl.port })
	            };
	            let tunnelAgent;
	            const overHttps = proxyUrl.protocol === 'https:';
	            if (usingSsl) {
	                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
	            }
	            else {
	                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
	            }
	            agent = tunnelAgent(agentOptions);
	            this._proxyAgent = agent;
	        }
	        // if tunneling agent isn't assigned create a new agent
	        if (!agent) {
	            const options = { keepAlive: this._keepAlive, maxSockets };
	            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
	            this._agent = agent;
	        }
	        if (usingSsl && this._ignoreSslError) {
	            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
	            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
	            // we have to cast it to any and change it directly
	            agent.options = Object.assign(agent.options || {}, {
	                rejectUnauthorized: false
	            });
	        }
	        return agent;
	    }
	    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
	        let proxyAgent;
	        if (this._keepAlive) {
	            proxyAgent = this._proxyAgentDispatcher;
	        }
	        // if agent is already assigned use that agent.
	        if (proxyAgent) {
	            return proxyAgent;
	        }
	        const usingSsl = parsedUrl.protocol === 'https:';
	        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, ((proxyUrl.username || proxyUrl.password) && {
	            token: `${proxyUrl.username}:${proxyUrl.password}`
	        })));
	        this._proxyAgentDispatcher = proxyAgent;
	        if (usingSsl && this._ignoreSslError) {
	            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
	            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
	            // we have to cast it to any and change it directly
	            proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
	                rejectUnauthorized: false
	            });
	        }
	        return proxyAgent;
	    }
	    _performExponentialBackoff(retryNumber) {
	        return __awaiter(this, undefined, undefined, function* () {
	            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
	            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
	            return new Promise(resolve => setTimeout(() => resolve(), ms));
	        });
	    }
	    _processResponse(res, options) {
	        return __awaiter(this, undefined, undefined, function* () {
	            return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
	                const statusCode = res.message.statusCode || 0;
	                const response = {
	                    statusCode,
	                    result: null,
	                    headers: {}
	                };
	                // not found leads to null obj returned
	                if (statusCode === HttpCodes.NotFound) {
	                    resolve(response);
	                }
	                // get the result from the body
	                function dateTimeDeserializer(key, value) {
	                    if (typeof value === 'string') {
	                        const a = new Date(value);
	                        if (!isNaN(a.valueOf())) {
	                            return a;
	                        }
	                    }
	                    return value;
	                }
	                let obj;
	                let contents;
	                try {
	                    contents = yield res.readBody();
	                    if (contents && contents.length > 0) {
	                        if (options && options.deserializeDates) {
	                            obj = JSON.parse(contents, dateTimeDeserializer);
	                        }
	                        else {
	                            obj = JSON.parse(contents);
	                        }
	                        response.result = obj;
	                    }
	                    response.headers = res.message.headers;
	                }
	                catch (err) {
	                    // Invalid resource (contents not json);  leaving result obj null
	                }
	                // note that 3xx redirects are handled by the http layer.
	                if (statusCode > 299) {
	                    let msg;
	                    // if exception/error in body, attempt to get better error
	                    if (obj && obj.message) {
	                        msg = obj.message;
	                    }
	                    else if (contents && contents.length > 0) {
	                        // it may be the case that the exception is in the body message as string
	                        msg = contents;
	                    }
	                    else {
	                        msg = `Failed request: (${statusCode})`;
	                    }
	                    const err = new HttpClientError(msg, statusCode);
	                    err.result = response.result;
	                    reject(err);
	                }
	                else {
	                    resolve(response);
	                }
	            }));
	        });
	    }
	}
	lib.HttpClient = HttpClient;
	const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
	
	return lib;
}

var auth$1 = {};

var hasRequiredAuth;

function requireAuth () {
	if (hasRequiredAuth) return auth$1;
	hasRequiredAuth = 1;
	var __awaiter = (auth$1.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(auth$1, "__esModule", { value: true });
	auth$1.PersonalAccessTokenCredentialHandler = auth$1.BearerCredentialHandler = auth$1.BasicCredentialHandler = undefined;
	class BasicCredentialHandler {
	    constructor(username, password) {
	        this.username = username;
	        this.password = password;
	    }
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, undefined, undefined, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth$1.BasicCredentialHandler = BasicCredentialHandler;
	class BearerCredentialHandler {
	    constructor(token) {
	        this.token = token;
	    }
	    // currently implements pre-authorization
	    // TODO: support preAuth = false where it hooks on 401
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Bearer ${this.token}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, undefined, undefined, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth$1.BearerCredentialHandler = BearerCredentialHandler;
	class PersonalAccessTokenCredentialHandler {
	    constructor(token) {
	        this.token = token;
	    }
	    // currently implements pre-authorization
	    // TODO: support preAuth = false where it hooks on 401
	    prepareRequest(options) {
	        if (!options.headers) {
	            throw Error('The request has no headers');
	        }
	        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
	    }
	    // This handler cannot handle 401
	    canHandleAuthentication() {
	        return false;
	    }
	    handleAuthentication() {
	        return __awaiter(this, undefined, undefined, function* () {
	            throw new Error('not implemented');
	        });
	    }
	}
	auth$1.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
	
	return auth$1;
}

var hasRequiredOidcUtils;

function requireOidcUtils () {
	if (hasRequiredOidcUtils) return oidcUtils;
	hasRequiredOidcUtils = 1;
	var __awaiter = (oidcUtils.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(oidcUtils, "__esModule", { value: true });
	oidcUtils.OidcClient = undefined;
	const http_client_1 = requireLib();
	const auth_1 = requireAuth();
	const core_1 = requireCore();
	class OidcClient {
	    static createHttpClient(allowRetry = true, maxRetry = 10) {
	        const requestOptions = {
	            allowRetries: allowRetry,
	            maxRetries: maxRetry
	        };
	        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
	    }
	    static getRequestToken() {
	        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
	        if (!token) {
	            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
	        }
	        return token;
	    }
	    static getIDTokenUrl() {
	        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
	        if (!runtimeUrl) {
	            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
	        }
	        return runtimeUrl;
	    }
	    static getCall(id_token_url) {
	        var _a;
	        return __awaiter(this, undefined, undefined, function* () {
	            const httpclient = OidcClient.createHttpClient();
	            const res = yield httpclient
	                .getJson(id_token_url)
	                .catch(error => {
	                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.message}`);
	            });
	            const id_token = (_a = res.result) === null || _a === undefined ? undefined : _a.value;
	            if (!id_token) {
	                throw new Error('Response json body do not have ID Token field');
	            }
	            return id_token;
	        });
	    }
	    static getIDToken(audience) {
	        return __awaiter(this, undefined, undefined, function* () {
	            try {
	                // New ID Token is requested from action service
	                let id_token_url = OidcClient.getIDTokenUrl();
	                if (audience) {
	                    const encodedAudience = encodeURIComponent(audience);
	                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
	                }
	                (0, core_1.debug)(`ID token url is ${id_token_url}`);
	                const id_token = yield OidcClient.getCall(id_token_url);
	                (0, core_1.setSecret)(id_token);
	                return id_token;
	            }
	            catch (error) {
	                throw new Error(`Error message: ${error.message}`);
	            }
	        });
	    }
	}
	oidcUtils.OidcClient = OidcClient;
	
	return oidcUtils;
}

var summary = {};

var hasRequiredSummary;

function requireSummary () {
	if (hasRequiredSummary) return summary;
	hasRequiredSummary = 1;
	(function (exports) {
		var __awaiter = (summary.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = undefined;
		const os_1 = require$$0$3;
		const fs_1 = require$$0$5;
		const { access, appendFile, writeFile } = fs_1.promises;
		exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
		exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
		class Summary {
		    constructor() {
		        this._buffer = '';
		    }
		    /**
		     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		     * Also checks r/w permissions.
		     *
		     * @returns step summary file path
		     */
		    filePath() {
		        return __awaiter(this, undefined, undefined, function* () {
		            if (this._filePath) {
		                return this._filePath;
		            }
		            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
		            if (!pathFromEnv) {
		                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
		            }
		            try {
		                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
		            }
		            catch (_a) {
		                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
		            }
		            this._filePath = pathFromEnv;
		            return this._filePath;
		        });
		    }
		    /**
		     * Wraps content in an HTML tag, adding any HTML attributes
		     *
		     * @param {string} tag HTML tag to wrap
		     * @param {string | null} content content within the tag
		     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		     *
		     * @returns {string} content wrapped in HTML element
		     */
		    wrap(tag, content, attrs = {}) {
		        const htmlAttrs = Object.entries(attrs)
		            .map(([key, value]) => ` ${key}="${value}"`)
		            .join('');
		        if (!content) {
		            return `<${tag}${htmlAttrs}>`;
		        }
		        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
		    }
		    /**
		     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		     *
		     * @param {SummaryWriteOptions} [options] (optional) options for write operation
		     *
		     * @returns {Promise<Summary>} summary instance
		     */
		    write(options) {
		        return __awaiter(this, undefined, undefined, function* () {
		            const overwrite = !!(options === null || options === undefined ? undefined : options.overwrite);
		            const filePath = yield this.filePath();
		            const writeFunc = overwrite ? writeFile : appendFile;
		            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
		            return this.emptyBuffer();
		        });
		    }
		    /**
		     * Clears the summary buffer and wipes the summary file
		     *
		     * @returns {Summary} summary instance
		     */
		    clear() {
		        return __awaiter(this, undefined, undefined, function* () {
		            return this.emptyBuffer().write({ overwrite: true });
		        });
		    }
		    /**
		     * Returns the current summary buffer as a string
		     *
		     * @returns {string} string of summary buffer
		     */
		    stringify() {
		        return this._buffer;
		    }
		    /**
		     * If the summary buffer is empty
		     *
		     * @returns {boolen} true if the buffer is empty
		     */
		    isEmptyBuffer() {
		        return this._buffer.length === 0;
		    }
		    /**
		     * Resets the summary buffer without writing to summary file
		     *
		     * @returns {Summary} summary instance
		     */
		    emptyBuffer() {
		        this._buffer = '';
		        return this;
		    }
		    /**
		     * Adds raw text to the summary buffer
		     *
		     * @param {string} text content to add
		     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		     *
		     * @returns {Summary} summary instance
		     */
		    addRaw(text, addEOL = false) {
		        this._buffer += text;
		        return addEOL ? this.addEOL() : this;
		    }
		    /**
		     * Adds the operating system-specific end-of-line marker to the buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addEOL() {
		        return this.addRaw(os_1.EOL);
		    }
		    /**
		     * Adds an HTML codeblock to the summary buffer
		     *
		     * @param {string} code content to render within fenced code block
		     * @param {string} lang (optional) language to syntax highlight code
		     *
		     * @returns {Summary} summary instance
		     */
		    addCodeBlock(code, lang) {
		        const attrs = Object.assign({}, (lang && { lang }));
		        const element = this.wrap('pre', this.wrap('code', code), attrs);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML list to the summary buffer
		     *
		     * @param {string[]} items list of items to render
		     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		     *
		     * @returns {Summary} summary instance
		     */
		    addList(items, ordered = false) {
		        const tag = ordered ? 'ol' : 'ul';
		        const listItems = items.map(item => this.wrap('li', item)).join('');
		        const element = this.wrap(tag, listItems);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML table to the summary buffer
		     *
		     * @param {SummaryTableCell[]} rows table rows
		     *
		     * @returns {Summary} summary instance
		     */
		    addTable(rows) {
		        const tableBody = rows
		            .map(row => {
		            const cells = row
		                .map(cell => {
		                if (typeof cell === 'string') {
		                    return this.wrap('td', cell);
		                }
		                const { header, data, colspan, rowspan } = cell;
		                const tag = header ? 'th' : 'td';
		                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
		                return this.wrap(tag, data, attrs);
		            })
		                .join('');
		            return this.wrap('tr', cells);
		        })
		            .join('');
		        const element = this.wrap('table', tableBody);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds a collapsable HTML details element to the summary buffer
		     *
		     * @param {string} label text for the closed state
		     * @param {string} content collapsable content
		     *
		     * @returns {Summary} summary instance
		     */
		    addDetails(label, content) {
		        const element = this.wrap('details', this.wrap('summary', label) + content);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML image tag to the summary buffer
		     *
		     * @param {string} src path to the image you to embed
		     * @param {string} alt text description of the image
		     * @param {SummaryImageOptions} options (optional) addition image attributes
		     *
		     * @returns {Summary} summary instance
		     */
		    addImage(src, alt, options) {
		        const { width, height } = options || {};
		        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
		        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML section heading element
		     *
		     * @param {string} text heading text
		     * @param {number | string} [level=1] (optional) the heading level, default: 1
		     *
		     * @returns {Summary} summary instance
		     */
		    addHeading(text, level) {
		        const tag = `h${level}`;
		        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
		            ? tag
		            : 'h1';
		        const element = this.wrap(allowedTag, text);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML thematic break (<hr>) to the summary buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addSeparator() {
		        const element = this.wrap('hr', null);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML line break (<br>) to the summary buffer
		     *
		     * @returns {Summary} summary instance
		     */
		    addBreak() {
		        const element = this.wrap('br', null);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML blockquote to the summary buffer
		     *
		     * @param {string} text quote text
		     * @param {string} cite (optional) citation url
		     *
		     * @returns {Summary} summary instance
		     */
		    addQuote(text, cite) {
		        const attrs = Object.assign({}, (cite && { cite }));
		        const element = this.wrap('blockquote', text, attrs);
		        return this.addRaw(element).addEOL();
		    }
		    /**
		     * Adds an HTML anchor tag to the summary buffer
		     *
		     * @param {string} text link text/content
		     * @param {string} href hyperlink
		     *
		     * @returns {Summary} summary instance
		     */
		    addLink(text, href) {
		        const element = this.wrap('a', text, { href });
		        return this.addRaw(element).addEOL();
		    }
		}
		const _summary = new Summary();
		/**
		 * @deprecated use `core.summary`
		 */
		exports.markdownSummary = _summary;
		exports.summary = _summary;
		
	} (summary));
	return summary;
}

var pathUtils = {};

var hasRequiredPathUtils;

function requirePathUtils () {
	if (hasRequiredPathUtils) return pathUtils;
	hasRequiredPathUtils = 1;
	var __createBinding = (pathUtils.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (pathUtils.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (pathUtils.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(pathUtils, "__esModule", { value: true });
	pathUtils.toPlatformPath = pathUtils.toWin32Path = pathUtils.toPosixPath = undefined;
	const path = __importStar(require$$1$6);
	/**
	 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
	 * replaced with /.
	 *
	 * @param pth. Path to transform.
	 * @return string Posix path.
	 */
	function toPosixPath(pth) {
	    return pth.replace(/[\\]/g, '/');
	}
	pathUtils.toPosixPath = toPosixPath;
	/**
	 * toWin32Path converts the given path to the win32 form. On Linux, / will be
	 * replaced with \\.
	 *
	 * @param pth. Path to transform.
	 * @return string Win32 path.
	 */
	function toWin32Path(pth) {
	    return pth.replace(/[/]/g, '\\');
	}
	pathUtils.toWin32Path = toWin32Path;
	/**
	 * toPlatformPath converts the given path to a platform-specific path. It does
	 * this by replacing instances of / and \ with the platform-specific path
	 * separator.
	 *
	 * @param pth The path to platformize.
	 * @return string The platform-specific path.
	 */
	function toPlatformPath(pth) {
	    return pth.replace(/[/\\]/g, path.sep);
	}
	pathUtils.toPlatformPath = toPlatformPath;
	
	return pathUtils;
}

var platform = {};

var exec = {};

var toolrunner = {};

var io = {};

var ioUtil = {};

var hasRequiredIoUtil;

function requireIoUtil () {
	if (hasRequiredIoUtil) return ioUtil;
	hasRequiredIoUtil = 1;
	(function (exports) {
		var __createBinding = (ioUtil.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (ioUtil.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (ioUtil.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (ioUtil.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var _a;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rename = exports.readlink = exports.readdir = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = undefined;
		const fs = __importStar(require$$0$5);
		const path = __importStar(require$$1$6);
		_a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
		exports.IS_WINDOWS = process.platform === 'win32';
		function exists(fsPath) {
		    return __awaiter(this, undefined, undefined, function* () {
		        try {
		            yield exports.stat(fsPath);
		        }
		        catch (err) {
		            if (err.code === 'ENOENT') {
		                return false;
		            }
		            throw err;
		        }
		        return true;
		    });
		}
		exports.exists = exists;
		function isDirectory(fsPath, useStat = false) {
		    return __awaiter(this, undefined, undefined, function* () {
		        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
		        return stats.isDirectory();
		    });
		}
		exports.isDirectory = isDirectory;
		/**
		 * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
		 * \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
		 */
		function isRooted(p) {
		    p = normalizeSeparators(p);
		    if (!p) {
		        throw new Error('isRooted() parameter "p" cannot be empty');
		    }
		    if (exports.IS_WINDOWS) {
		        return (p.startsWith('\\') || /^[A-Z]:/i.test(p) // e.g. \ or \hello or \\hello
		        ); // e.g. C: or C:\hello
		    }
		    return p.startsWith('/');
		}
		exports.isRooted = isRooted;
		/**
		 * Best effort attempt to determine whether a file exists and is executable.
		 * @param filePath    file path to check
		 * @param extensions  additional file extensions to try
		 * @return if file exists and is executable, returns the file path. otherwise empty string.
		 */
		function tryGetExecutablePath(filePath, extensions) {
		    return __awaiter(this, undefined, undefined, function* () {
		        let stats = undefined;
		        try {
		            // test file exists
		            stats = yield exports.stat(filePath);
		        }
		        catch (err) {
		            if (err.code !== 'ENOENT') {
		                // eslint-disable-next-line no-console
		                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
		            }
		        }
		        if (stats && stats.isFile()) {
		            if (exports.IS_WINDOWS) {
		                // on Windows, test for valid extension
		                const upperExt = path.extname(filePath).toUpperCase();
		                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {
		                    return filePath;
		                }
		            }
		            else {
		                if (isUnixExecutable(stats)) {
		                    return filePath;
		                }
		            }
		        }
		        // try each extension
		        const originalFilePath = filePath;
		        for (const extension of extensions) {
		            filePath = originalFilePath + extension;
		            stats = undefined;
		            try {
		                stats = yield exports.stat(filePath);
		            }
		            catch (err) {
		                if (err.code !== 'ENOENT') {
		                    // eslint-disable-next-line no-console
		                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
		                }
		            }
		            if (stats && stats.isFile()) {
		                if (exports.IS_WINDOWS) {
		                    // preserve the case of the actual file (since an extension was appended)
		                    try {
		                        const directory = path.dirname(filePath);
		                        const upperName = path.basename(filePath).toUpperCase();
		                        for (const actualName of yield exports.readdir(directory)) {
		                            if (upperName === actualName.toUpperCase()) {
		                                filePath = path.join(directory, actualName);
		                                break;
		                            }
		                        }
		                    }
		                    catch (err) {
		                        // eslint-disable-next-line no-console
		                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
		                    }
		                    return filePath;
		                }
		                else {
		                    if (isUnixExecutable(stats)) {
		                        return filePath;
		                    }
		                }
		            }
		        }
		        return '';
		    });
		}
		exports.tryGetExecutablePath = tryGetExecutablePath;
		function normalizeSeparators(p) {
		    p = p || '';
		    if (exports.IS_WINDOWS) {
		        // convert slashes on Windows
		        p = p.replace(/\//g, '\\');
		        // remove redundant slashes
		        return p.replace(/\\\\+/g, '\\');
		    }
		    // remove redundant slashes
		    return p.replace(/\/\/+/g, '/');
		}
		// on Mac/Linux, test the execute bit
		//     R   W  X  R  W X R W X
		//   256 128 64 32 16 8 4 2 1
		function isUnixExecutable(stats) {
		    return ((stats.mode & 1) > 0 ||
		        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||
		        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));
		}
		// Get the path of cmd.exe in windows
		function getCmdPath() {
		    var _a;
		    return (_a = process.env['COMSPEC']) !== null && _a !== undefined ? _a : `cmd.exe`;
		}
		exports.getCmdPath = getCmdPath;
		
	} (ioUtil));
	return ioUtil;
}

var hasRequiredIo;

function requireIo () {
	if (hasRequiredIo) return io;
	hasRequiredIo = 1;
	var __createBinding = (io.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (io.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (io.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (io.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(io, "__esModule", { value: true });
	io.findInPath = io.which = io.mkdirP = io.rmRF = io.mv = io.cp = undefined;
	const assert_1 = require$$0$8;
	const childProcess = __importStar(require$$1$7);
	const path = __importStar(require$$1$6);
	const util_1 = require$$0$7;
	const ioUtil = __importStar(requireIoUtil());
	const exec = util_1.promisify(childProcess.exec);
	const execFile = util_1.promisify(childProcess.execFile);
	/**
	 * Copies a file or folder.
	 * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	 *
	 * @param     source    source path
	 * @param     dest      destination path
	 * @param     options   optional. See CopyOptions.
	 */
	function cp(source, dest, options = {}) {
	    return __awaiter(this, undefined, undefined, function* () {
	        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
	        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
	        // Dest is an existing file, but not forcing
	        if (destStat && destStat.isFile() && !force) {
	            return;
	        }
	        // If dest is an existing directory, should copy inside.
	        const newDest = destStat && destStat.isDirectory() && copySourceDirectory
	            ? path.join(dest, path.basename(source))
	            : dest;
	        if (!(yield ioUtil.exists(source))) {
	            throw new Error(`no such file or directory: ${source}`);
	        }
	        const sourceStat = yield ioUtil.stat(source);
	        if (sourceStat.isDirectory()) {
	            if (!recursive) {
	                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
	            }
	            else {
	                yield cpDirRecursive(source, newDest, 0, force);
	            }
	        }
	        else {
	            if (path.relative(source, newDest) === '') {
	                // a file cannot be copied to itself
	                throw new Error(`'${newDest}' and '${source}' are the same file`);
	            }
	            yield copyFile(source, newDest, force);
	        }
	    });
	}
	io.cp = cp;
	/**
	 * Moves a path.
	 *
	 * @param     source    source path
	 * @param     dest      destination path
	 * @param     options   optional. See MoveOptions.
	 */
	function mv(source, dest, options = {}) {
	    return __awaiter(this, undefined, undefined, function* () {
	        if (yield ioUtil.exists(dest)) {
	            let destExists = true;
	            if (yield ioUtil.isDirectory(dest)) {
	                // If dest is directory copy src into dest
	                dest = path.join(dest, path.basename(source));
	                destExists = yield ioUtil.exists(dest);
	            }
	            if (destExists) {
	                if (options.force == null || options.force) {
	                    yield rmRF(dest);
	                }
	                else {
	                    throw new Error('Destination already exists');
	                }
	            }
	        }
	        yield mkdirP(path.dirname(dest));
	        yield ioUtil.rename(source, dest);
	    });
	}
	io.mv = mv;
	/**
	 * Remove a path recursively with force
	 *
	 * @param inputPath path to remove
	 */
	function rmRF(inputPath) {
	    return __awaiter(this, undefined, undefined, function* () {
	        if (ioUtil.IS_WINDOWS) {
	            // Node doesn't provide a delete operation, only an unlink function. This means that if the file is being used by another
	            // program (e.g. antivirus), it won't be deleted. To address this, we shell out the work to rd/del.
	            // Check for invalid characters
	            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file
	            if (/[*"<>|]/.test(inputPath)) {
	                throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
	            }
	            try {
	                const cmdPath = ioUtil.getCmdPath();
	                if (yield ioUtil.isDirectory(inputPath, true)) {
	                    yield exec(`${cmdPath} /s /c "rd /s /q "%inputPath%""`, {
	                        env: { inputPath }
	                    });
	                }
	                else {
	                    yield exec(`${cmdPath} /s /c "del /f /a "%inputPath%""`, {
	                        env: { inputPath }
	                    });
	                }
	            }
	            catch (err) {
	                // if you try to delete a file that doesn't exist, desired result is achieved
	                // other errors are valid
	                if (err.code !== 'ENOENT')
	                    throw err;
	            }
	            // Shelling out fails to remove a symlink folder with missing source, this unlink catches that
	            try {
	                yield ioUtil.unlink(inputPath);
	            }
	            catch (err) {
	                // if you try to delete a file that doesn't exist, desired result is achieved
	                // other errors are valid
	                if (err.code !== 'ENOENT')
	                    throw err;
	            }
	        }
	        else {
	            let isDir = false;
	            try {
	                isDir = yield ioUtil.isDirectory(inputPath);
	            }
	            catch (err) {
	                // if you try to delete a file that doesn't exist, desired result is achieved
	                // other errors are valid
	                if (err.code !== 'ENOENT')
	                    throw err;
	                return;
	            }
	            if (isDir) {
	                yield execFile(`rm`, [`-rf`, `${inputPath}`]);
	            }
	            else {
	                yield ioUtil.unlink(inputPath);
	            }
	        }
	    });
	}
	io.rmRF = rmRF;
	/**
	 * Make a directory.  Creates the full path with folders in between
	 * Will throw if it fails
	 *
	 * @param   fsPath        path to create
	 * @returns Promise<void>
	 */
	function mkdirP(fsPath) {
	    return __awaiter(this, undefined, undefined, function* () {
	        assert_1.ok(fsPath, 'a path argument must be provided');
	        yield ioUtil.mkdir(fsPath, { recursive: true });
	    });
	}
	io.mkdirP = mkdirP;
	/**
	 * Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	 * If you check and the tool does not exist, it will throw.
	 *
	 * @param     tool              name of the tool
	 * @param     check             whether to check if tool exists
	 * @returns   Promise<string>   path to tool
	 */
	function which(tool, check) {
	    return __awaiter(this, undefined, undefined, function* () {
	        if (!tool) {
	            throw new Error("parameter 'tool' is required");
	        }
	        // recursive when check=true
	        if (check) {
	            const result = yield which(tool, false);
	            if (!result) {
	                if (ioUtil.IS_WINDOWS) {
	                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
	                }
	                else {
	                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
	                }
	            }
	            return result;
	        }
	        const matches = yield findInPath(tool);
	        if (matches && matches.length > 0) {
	            return matches[0];
	        }
	        return '';
	    });
	}
	io.which = which;
	/**
	 * Returns a list of all occurrences of the given tool on the system path.
	 *
	 * @returns   Promise<string[]>  the paths of the tool
	 */
	function findInPath(tool) {
	    return __awaiter(this, undefined, undefined, function* () {
	        if (!tool) {
	            throw new Error("parameter 'tool' is required");
	        }
	        // build the list of extensions to try
	        const extensions = [];
	        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {
	            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {
	                if (extension) {
	                    extensions.push(extension);
	                }
	            }
	        }
	        // if it's rooted, return it if exists. otherwise return empty.
	        if (ioUtil.isRooted(tool)) {
	            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
	            if (filePath) {
	                return [filePath];
	            }
	            return [];
	        }
	        // if any path separators, return empty
	        if (tool.includes(path.sep)) {
	            return [];
	        }
	        // build the list of directories
	        //
	        // Note, technically "where" checks the current directory on Windows. From a toolkit perspective,
	        // it feels like we should not do this. Checking the current directory seems like more of a use
	        // case of a shell, and the which() function exposed by the toolkit should strive for consistency
	        // across platforms.
	        const directories = [];
	        if (process.env.PATH) {
	            for (const p of process.env.PATH.split(path.delimiter)) {
	                if (p) {
	                    directories.push(p);
	                }
	            }
	        }
	        // find all matches
	        const matches = [];
	        for (const directory of directories) {
	            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
	            if (filePath) {
	                matches.push(filePath);
	            }
	        }
	        return matches;
	    });
	}
	io.findInPath = findInPath;
	function readCopyOptions(options) {
	    const force = options.force == null ? true : options.force;
	    const recursive = Boolean(options.recursive);
	    const copySourceDirectory = options.copySourceDirectory == null
	        ? true
	        : Boolean(options.copySourceDirectory);
	    return { force, recursive, copySourceDirectory };
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
	    return __awaiter(this, undefined, undefined, function* () {
	        // Ensure there is not a run away recursive copy
	        if (currentDepth >= 255)
	            return;
	        currentDepth++;
	        yield mkdirP(destDir);
	        const files = yield ioUtil.readdir(sourceDir);
	        for (const fileName of files) {
	            const srcFile = `${sourceDir}/${fileName}`;
	            const destFile = `${destDir}/${fileName}`;
	            const srcFileStat = yield ioUtil.lstat(srcFile);
	            if (srcFileStat.isDirectory()) {
	                // Recurse
	                yield cpDirRecursive(srcFile, destFile, currentDepth, force);
	            }
	            else {
	                yield copyFile(srcFile, destFile, force);
	            }
	        }
	        // Change the mode for the newly created directory
	        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
	    });
	}
	// Buffered file copy
	function copyFile(srcFile, destFile, force) {
	    return __awaiter(this, undefined, undefined, function* () {
	        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
	            // unlink/re-link it
	            try {
	                yield ioUtil.lstat(destFile);
	                yield ioUtil.unlink(destFile);
	            }
	            catch (e) {
	                // Try to override file permission
	                if (e.code === 'EPERM') {
	                    yield ioUtil.chmod(destFile, '0666');
	                    yield ioUtil.unlink(destFile);
	                }
	                // other errors = it doesn't exist, no work to do
	            }
	            // Copy over symlink
	            const symlinkFull = yield ioUtil.readlink(srcFile);
	            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);
	        }
	        else if (!(yield ioUtil.exists(destFile)) || force) {
	            yield ioUtil.copyFile(srcFile, destFile);
	        }
	    });
	}
	
	return io;
}

var hasRequiredToolrunner;

function requireToolrunner () {
	if (hasRequiredToolrunner) return toolrunner;
	hasRequiredToolrunner = 1;
	var __createBinding = (toolrunner.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (toolrunner.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (toolrunner.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (toolrunner.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(toolrunner, "__esModule", { value: true });
	toolrunner.argStringToArray = toolrunner.ToolRunner = undefined;
	const os = __importStar(require$$0$3);
	const events = __importStar(require$$0$6);
	const child = __importStar(require$$1$7);
	const path = __importStar(require$$1$6);
	const io = __importStar(requireIo());
	const ioUtil = __importStar(requireIoUtil());
	const timers_1 = require$$6$2;
	/* eslint-disable @typescript-eslint/unbound-method */
	const IS_WINDOWS = process.platform === 'win32';
	/*
	 * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.
	 */
	class ToolRunner extends events.EventEmitter {
	    constructor(toolPath, args, options) {
	        super();
	        if (!toolPath) {
	            throw new Error("Parameter 'toolPath' cannot be null or empty.");
	        }
	        this.toolPath = toolPath;
	        this.args = args || [];
	        this.options = options || {};
	    }
	    _debug(message) {
	        if (this.options.listeners && this.options.listeners.debug) {
	            this.options.listeners.debug(message);
	        }
	    }
	    _getCommandString(options, noPrefix) {
	        const toolPath = this._getSpawnFileName();
	        const args = this._getSpawnArgs(options);
	        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool
	        if (IS_WINDOWS) {
	            // Windows + cmd file
	            if (this._isCmdFile()) {
	                cmd += toolPath;
	                for (const a of args) {
	                    cmd += ` ${a}`;
	                }
	            }
	            // Windows + verbatim
	            else if (options.windowsVerbatimArguments) {
	                cmd += `"${toolPath}"`;
	                for (const a of args) {
	                    cmd += ` ${a}`;
	                }
	            }
	            // Windows (regular)
	            else {
	                cmd += this._windowsQuoteCmdArg(toolPath);
	                for (const a of args) {
	                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;
	                }
	            }
	        }
	        else {
	            // OSX/Linux - this can likely be improved with some form of quoting.
	            // creating processes on Unix is fundamentally different than Windows.
	            // on Unix, execvp() takes an arg array.
	            cmd += toolPath;
	            for (const a of args) {
	                cmd += ` ${a}`;
	            }
	        }
	        return cmd;
	    }
	    _processLineBuffer(data, strBuffer, onLine) {
	        try {
	            let s = strBuffer + data.toString();
	            let n = s.indexOf(os.EOL);
	            while (n > -1) {
	                const line = s.substring(0, n);
	                onLine(line);
	                // the rest of the string ...
	                s = s.substring(n + os.EOL.length);
	                n = s.indexOf(os.EOL);
	            }
	            return s;
	        }
	        catch (err) {
	            // streaming lines to console is best effort.  Don't fail a build.
	            this._debug(`error processing line. Failed with error ${err}`);
	            return '';
	        }
	    }
	    _getSpawnFileName() {
	        if (IS_WINDOWS) {
	            if (this._isCmdFile()) {
	                return process.env['COMSPEC'] || 'cmd.exe';
	            }
	        }
	        return this.toolPath;
	    }
	    _getSpawnArgs(options) {
	        if (IS_WINDOWS) {
	            if (this._isCmdFile()) {
	                let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
	                for (const a of this.args) {
	                    argline += ' ';
	                    argline += options.windowsVerbatimArguments
	                        ? a
	                        : this._windowsQuoteCmdArg(a);
	                }
	                argline += '"';
	                return [argline];
	            }
	        }
	        return this.args;
	    }
	    _endsWith(str, end) {
	        return str.endsWith(end);
	    }
	    _isCmdFile() {
	        const upperToolPath = this.toolPath.toUpperCase();
	        return (this._endsWith(upperToolPath, '.CMD') ||
	            this._endsWith(upperToolPath, '.BAT'));
	    }
	    _windowsQuoteCmdArg(arg) {
	        // for .exe, apply the normal quoting rules that libuv applies
	        if (!this._isCmdFile()) {
	            return this._uvQuoteCmdArg(arg);
	        }
	        // otherwise apply quoting rules specific to the cmd.exe command line parser.
	        // the libuv rules are generic and are not designed specifically for cmd.exe
	        // command line parser.
	        //
	        // for a detailed description of the cmd.exe command line parser, refer to
	        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912
	        // need quotes for empty arg
	        if (!arg) {
	            return '""';
	        }
	        // determine whether the arg needs to be quoted
	        const cmdSpecialChars = [
	            ' ',
	            '\t',
	            '&',
	            '(',
	            ')',
	            '[',
	            ']',
	            '{',
	            '}',
	            '^',
	            '=',
	            ';',
	            '!',
	            "'",
	            '+',
	            ',',
	            '`',
	            '~',
	            '|',
	            '<',
	            '>',
	            '"'
	        ];
	        let needsQuotes = false;
	        for (const char of arg) {
	            if (cmdSpecialChars.some(x => x === char)) {
	                needsQuotes = true;
	                break;
	            }
	        }
	        // short-circuit if quotes not needed
	        if (!needsQuotes) {
	            return arg;
	        }
	        // the following quoting rules are very similar to the rules that by libuv applies.
	        //
	        // 1) wrap the string in quotes
	        //
	        // 2) double-up quotes - i.e. " => ""
	        //
	        //    this is different from the libuv quoting rules. libuv replaces " with \", which unfortunately
	        //    doesn't work well with a cmd.exe command line.
	        //
	        //    note, replacing " with "" also works well if the arg is passed to a downstream .NET console app.
	        //    for example, the command line:
	        //          foo.exe "myarg:""my val"""
	        //    is parsed by a .NET console app into an arg array:
	        //          [ "myarg:\"my val\"" ]
	        //    which is the same end result when applying libuv quoting rules. although the actual
	        //    command line from libuv quoting rules would look like:
	        //          foo.exe "myarg:\"my val\""
	        //
	        // 3) double-up slashes that precede a quote,
	        //    e.g.  hello \world    => "hello \world"
	        //          hello\"world    => "hello\\""world"
	        //          hello\\"world   => "hello\\\\""world"
	        //          hello world\    => "hello world\\"
	        //
	        //    technically this is not required for a cmd.exe command line, or the batch argument parser.
	        //    the reasons for including this as a .cmd quoting rule are:
	        //
	        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an
	        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.
	        //
	        //    b) it's what we've been doing previously (by deferring to node default behavior) and we
	        //       haven't heard any complaints about that aspect.
	        //
	        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be
	        // escaped when used on the command line directly - even though within a .cmd file % can be escaped
	        // by using %%.
	        //
	        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts
	        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.
	        //
	        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would
	        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the
	        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args
	        // to an external program.
	        //
	        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.
	        // % can be escaped within a .cmd file.
	        let reverse = '"';
	        let quoteHit = true;
	        for (let i = arg.length; i > 0; i--) {
	            // walk the string in reverse
	            reverse += arg[i - 1];
	            if (quoteHit && arg[i - 1] === '\\') {
	                reverse += '\\'; // double the slash
	            }
	            else if (arg[i - 1] === '"') {
	                quoteHit = true;
	                reverse += '"'; // double the quote
	            }
	            else {
	                quoteHit = false;
	            }
	        }
	        reverse += '"';
	        return reverse
	            .split('')
	            .reverse()
	            .join('');
	    }
	    _uvQuoteCmdArg(arg) {
	        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as
	        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments
	        // is used.
	        //
	        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,
	        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),
	        // pasting copyright notice from Node within this function:
	        //
	        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.
	        //
	        //      Permission is hereby granted, free of charge, to any person obtaining a copy
	        //      of this software and associated documentation files (the "Software"), to
	        //      deal in the Software without restriction, including without limitation the
	        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	        //      sell copies of the Software, and to permit persons to whom the Software is
	        //      furnished to do so, subject to the following conditions:
	        //
	        //      The above copyright notice and this permission notice shall be included in
	        //      all copies or substantial portions of the Software.
	        //
	        //      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	        //      IN THE SOFTWARE.
	        if (!arg) {
	            // Need double quotation for empty argument
	            return '""';
	        }
	        if (!arg.includes(' ') && !arg.includes('\t') && !arg.includes('"')) {
	            // No quotation needed
	            return arg;
	        }
	        if (!arg.includes('"') && !arg.includes('\\')) {
	            // No embedded double quotes or backslashes, so I can just wrap
	            // quote marks around the whole thing.
	            return `"${arg}"`;
	        }
	        // Expected input/output:
	        //   input : hello"world
	        //   output: "hello\"world"
	        //   input : hello""world
	        //   output: "hello\"\"world"
	        //   input : hello\world
	        //   output: hello\world
	        //   input : hello\\world
	        //   output: hello\\world
	        //   input : hello\"world
	        //   output: "hello\\\"world"
	        //   input : hello\\"world
	        //   output: "hello\\\\\"world"
	        //   input : hello world\
	        //   output: "hello world\\" - note the comment in libuv actually reads "hello world\"
	        //                             but it appears the comment is wrong, it should be "hello world\\"
	        let reverse = '"';
	        let quoteHit = true;
	        for (let i = arg.length; i > 0; i--) {
	            // walk the string in reverse
	            reverse += arg[i - 1];
	            if (quoteHit && arg[i - 1] === '\\') {
	                reverse += '\\';
	            }
	            else if (arg[i - 1] === '"') {
	                quoteHit = true;
	                reverse += '\\';
	            }
	            else {
	                quoteHit = false;
	            }
	        }
	        reverse += '"';
	        return reverse
	            .split('')
	            .reverse()
	            .join('');
	    }
	    _cloneExecOptions(options) {
	        options = options || {};
	        const result = {
	            cwd: options.cwd || process.cwd(),
	            env: options.env || process.env,
	            silent: options.silent || false,
	            windowsVerbatimArguments: options.windowsVerbatimArguments || false,
	            failOnStdErr: options.failOnStdErr || false,
	            ignoreReturnCode: options.ignoreReturnCode || false,
	            delay: options.delay || 10000
	        };
	        result.outStream = options.outStream || process.stdout;
	        result.errStream = options.errStream || process.stderr;
	        return result;
	    }
	    _getSpawnOptions(options, toolPath) {
	        options = options || {};
	        const result = {};
	        result.cwd = options.cwd;
	        result.env = options.env;
	        result['windowsVerbatimArguments'] =
	            options.windowsVerbatimArguments || this._isCmdFile();
	        if (options.windowsVerbatimArguments) {
	            result.argv0 = `"${toolPath}"`;
	        }
	        return result;
	    }
	    /**
	     * Exec a tool.
	     * Output will be streamed to the live console.
	     * Returns promise with return code
	     *
	     * @param     tool     path to tool to exec
	     * @param     options  optional exec options.  See ExecOptions
	     * @returns   number
	     */
	    exec() {
	        return __awaiter(this, undefined, undefined, function* () {
	            // root the tool path if it is unrooted and contains relative pathing
	            if (!ioUtil.isRooted(this.toolPath) &&
	                (this.toolPath.includes('/') ||
	                    (IS_WINDOWS && this.toolPath.includes('\\')))) {
	                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted
	                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
	            }
	            // if the tool is only a file name, then resolve it from the PATH
	            // otherwise verify it exists (add extension on Windows if necessary)
	            this.toolPath = yield io.which(this.toolPath, true);
	            return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
	                this._debug(`exec tool: ${this.toolPath}`);
	                this._debug('arguments:');
	                for (const arg of this.args) {
	                    this._debug(`   ${arg}`);
	                }
	                const optionsNonNull = this._cloneExecOptions(this.options);
	                if (!optionsNonNull.silent && optionsNonNull.outStream) {
	                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
	                }
	                const state = new ExecState(optionsNonNull, this.toolPath);
	                state.on('debug', (message) => {
	                    this._debug(message);
	                });
	                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
	                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
	                }
	                const fileName = this._getSpawnFileName();
	                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
	                let stdbuffer = '';
	                if (cp.stdout) {
	                    cp.stdout.on('data', (data) => {
	                        if (this.options.listeners && this.options.listeners.stdout) {
	                            this.options.listeners.stdout(data);
	                        }
	                        if (!optionsNonNull.silent && optionsNonNull.outStream) {
	                            optionsNonNull.outStream.write(data);
	                        }
	                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
	                            if (this.options.listeners && this.options.listeners.stdline) {
	                                this.options.listeners.stdline(line);
	                            }
	                        });
	                    });
	                }
	                let errbuffer = '';
	                if (cp.stderr) {
	                    cp.stderr.on('data', (data) => {
	                        state.processStderr = true;
	                        if (this.options.listeners && this.options.listeners.stderr) {
	                            this.options.listeners.stderr(data);
	                        }
	                        if (!optionsNonNull.silent &&
	                            optionsNonNull.errStream &&
	                            optionsNonNull.outStream) {
	                            const s = optionsNonNull.failOnStdErr
	                                ? optionsNonNull.errStream
	                                : optionsNonNull.outStream;
	                            s.write(data);
	                        }
	                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
	                            if (this.options.listeners && this.options.listeners.errline) {
	                                this.options.listeners.errline(line);
	                            }
	                        });
	                    });
	                }
	                cp.on('error', (err) => {
	                    state.processError = err.message;
	                    state.processExited = true;
	                    state.processClosed = true;
	                    state.CheckComplete();
	                });
	                cp.on('exit', (code) => {
	                    state.processExitCode = code;
	                    state.processExited = true;
	                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
	                    state.CheckComplete();
	                });
	                cp.on('close', (code) => {
	                    state.processExitCode = code;
	                    state.processExited = true;
	                    state.processClosed = true;
	                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
	                    state.CheckComplete();
	                });
	                state.on('done', (error, exitCode) => {
	                    if (stdbuffer.length > 0) {
	                        this.emit('stdline', stdbuffer);
	                    }
	                    if (errbuffer.length > 0) {
	                        this.emit('errline', errbuffer);
	                    }
	                    cp.removeAllListeners();
	                    if (error) {
	                        reject(error);
	                    }
	                    else {
	                        resolve(exitCode);
	                    }
	                });
	                if (this.options.input) {
	                    if (!cp.stdin) {
	                        throw new Error('child process missing stdin');
	                    }
	                    cp.stdin.end(this.options.input);
	                }
	            }));
	        });
	    }
	}
	toolrunner.ToolRunner = ToolRunner;
	/**
	 * Convert an arg string to an array of args. Handles escaping
	 *
	 * @param    argString   string of arguments
	 * @returns  string[]    array of arguments
	 */
	function argStringToArray(argString) {
	    const args = [];
	    let inQuotes = false;
	    let escaped = false;
	    let arg = '';
	    function append(c) {
	        // we only escape double quotes.
	        if (escaped && c !== '"') {
	            arg += '\\';
	        }
	        arg += c;
	        escaped = false;
	    }
	    for (let i = 0; i < argString.length; i++) {
	        const c = argString.charAt(i);
	        if (c === '"') {
	            if (!escaped) {
	                inQuotes = !inQuotes;
	            }
	            else {
	                append(c);
	            }
	            continue;
	        }
	        if (c === '\\' && escaped) {
	            append(c);
	            continue;
	        }
	        if (c === '\\' && inQuotes) {
	            escaped = true;
	            continue;
	        }
	        if (c === ' ' && !inQuotes) {
	            if (arg.length > 0) {
	                args.push(arg);
	                arg = '';
	            }
	            continue;
	        }
	        append(c);
	    }
	    if (arg.length > 0) {
	        args.push(arg.trim());
	    }
	    return args;
	}
	toolrunner.argStringToArray = argStringToArray;
	class ExecState extends events.EventEmitter {
	    constructor(options, toolPath) {
	        super();
	        this.processClosed = false; // tracks whether the process has exited and stdio is closed
	        this.processError = '';
	        this.processExitCode = 0;
	        this.processExited = false; // tracks whether the process has exited
	        this.processStderr = false; // tracks whether stderr was written to
	        this.delay = 10000; // 10 seconds
	        this.done = false;
	        this.timeout = null;
	        if (!toolPath) {
	            throw new Error('toolPath must not be empty');
	        }
	        this.options = options;
	        this.toolPath = toolPath;
	        if (options.delay) {
	            this.delay = options.delay;
	        }
	    }
	    CheckComplete() {
	        if (this.done) {
	            return;
	        }
	        if (this.processClosed) {
	            this._setResult();
	        }
	        else if (this.processExited) {
	            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
	        }
	    }
	    _debug(message) {
	        this.emit('debug', message);
	    }
	    _setResult() {
	        // determine whether there is an error
	        let error;
	        if (this.processExited) {
	            if (this.processError) {
	                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
	            }
	            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
	                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
	            }
	            else if (this.processStderr && this.options.failOnStdErr) {
	                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
	            }
	        }
	        // clear the timeout
	        if (this.timeout) {
	            clearTimeout(this.timeout);
	            this.timeout = null;
	        }
	        this.done = true;
	        this.emit('done', error, this.processExitCode);
	    }
	    static HandleTimeout(state) {
	        if (state.done) {
	            return;
	        }
	        if (!state.processClosed && state.processExited) {
	            const message = `The STDIO streams did not close within ${state.delay /
	                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
	            state._debug(message);
	        }
	        state._setResult();
	    }
	}
	
	return toolrunner;
}

var hasRequiredExec;

function requireExec () {
	if (hasRequiredExec) return exec;
	hasRequiredExec = 1;
	var __createBinding = (exec.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (exec.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (exec.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (exec.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(exec, "__esModule", { value: true });
	exec.getExecOutput = exec.exec = undefined;
	const string_decoder_1 = require$$6$1;
	const tr = __importStar(requireToolrunner());
	/**
	 * Exec a command.
	 * Output will be streamed to the live console.
	 * Returns promise with return code
	 *
	 * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	 * @param     args               optional arguments for tool. Escaping is handled by the lib.
	 * @param     options            optional exec options.  See ExecOptions
	 * @returns   Promise<number>    exit code
	 */
	function exec$1(commandLine, args, options) {
	    return __awaiter(this, undefined, undefined, function* () {
	        const commandArgs = tr.argStringToArray(commandLine);
	        if (commandArgs.length === 0) {
	            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
	        }
	        // Path to tool to execute should be first arg
	        const toolPath = commandArgs[0];
	        args = commandArgs.slice(1).concat(args || []);
	        const runner = new tr.ToolRunner(toolPath, args, options);
	        return runner.exec();
	    });
	}
	exec.exec = exec$1;
	/**
	 * Exec a command and get the output.
	 * Output will be streamed to the live console.
	 * Returns promise with the exit code and collected stdout and stderr
	 *
	 * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	 * @param     args                  optional arguments for tool. Escaping is handled by the lib.
	 * @param     options               optional exec options.  See ExecOptions
	 * @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	 */
	function getExecOutput(commandLine, args, options) {
	    var _a, _b;
	    return __awaiter(this, undefined, undefined, function* () {
	        let stdout = '';
	        let stderr = '';
	        //Using string decoder covers the case where a mult-byte character is split
	        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');
	        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');
	        const originalStdoutListener = (_a = options === null || options === undefined ? undefined : options.listeners) === null || _a === undefined ? undefined : _a.stdout;
	        const originalStdErrListener = (_b = options === null || options === undefined ? undefined : options.listeners) === null || _b === undefined ? undefined : _b.stderr;
	        const stdErrListener = (data) => {
	            stderr += stderrDecoder.write(data);
	            if (originalStdErrListener) {
	                originalStdErrListener(data);
	            }
	        };
	        const stdOutListener = (data) => {
	            stdout += stdoutDecoder.write(data);
	            if (originalStdoutListener) {
	                originalStdoutListener(data);
	            }
	        };
	        const listeners = Object.assign(Object.assign({}, options === null || options === undefined ? undefined : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
	        const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
	        //flush any remaining characters
	        stdout += stdoutDecoder.end();
	        stderr += stderrDecoder.end();
	        return {
	            exitCode,
	            stdout,
	            stderr
	        };
	    });
	}
	exec.getExecOutput = getExecOutput;
	
	return exec;
}

var hasRequiredPlatform;

function requirePlatform () {
	if (hasRequiredPlatform) return platform;
	hasRequiredPlatform = 1;
	(function (exports) {
		var __createBinding = (platform.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (platform.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (platform.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (platform.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		var __importDefault = (platform.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = undefined;
		const os_1 = __importDefault(require$$0$3);
		const exec = __importStar(requireExec());
		const getWindowsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
		    const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', undefined, {
		        silent: true
		    });
		    const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', undefined, {
		        silent: true
		    });
		    return {
		        name: name.trim(),
		        version: version.trim()
		    };
		});
		const getMacOsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
		    var _a, _b, _c, _d;
		    const { stdout } = yield exec.getExecOutput('sw_vers', undefined, {
		        silent: true
		    });
		    const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === undefined ? undefined : _a[1]) !== null && _b !== undefined ? _b : '';
		    const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === undefined ? undefined : _c[1]) !== null && _d !== undefined ? _d : '';
		    return {
		        name,
		        version
		    };
		});
		const getLinuxInfo = () => __awaiter(undefined, undefined, undefined, function* () {
		    const { stdout } = yield exec.getExecOutput('lsb_release', ['-i', '-r', '-s'], {
		        silent: true
		    });
		    const [name, version] = stdout.trim().split('\n');
		    return {
		        name,
		        version
		    };
		});
		exports.platform = os_1.default.platform();
		exports.arch = os_1.default.arch();
		exports.isWindows = exports.platform === 'win32';
		exports.isMacOS = exports.platform === 'darwin';
		exports.isLinux = exports.platform === 'linux';
		function getDetails() {
		    return __awaiter(this, undefined, undefined, function* () {
		        return Object.assign(Object.assign({}, (yield (exports.isWindows
		            ? getWindowsInfo()
		            : exports.isMacOS
		                ? getMacOsInfo()
		                : getLinuxInfo()))), { platform: exports.platform,
		            arch: exports.arch,
		            isWindows: exports.isWindows,
		            isMacOS: exports.isMacOS,
		            isLinux: exports.isLinux });
		    });
		}
		exports.getDetails = getDetails;
		
	} (platform));
	return platform;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core;
	hasRequiredCore = 1;
	(function (exports) {
		var __createBinding = (core.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (core.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (core.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __awaiter = (core.__awaiter) || function (thisArg, _arguments, P, generator) {
		    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
		    return new (P || (P = Promise))(function (resolve, reject) {
		        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
		        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
		        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
		        step((generator = generator.apply(thisArg, _arguments || [])).next());
		    });
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = undefined;
		const command_1 = requireCommand();
		const file_command_1 = requireFileCommand();
		const utils_1 = requireUtils$3();
		const os = __importStar(require$$0$3);
		const path = __importStar(require$$1$6);
		const oidc_utils_1 = requireOidcUtils();
		/**
		 * The code to exit an action
		 */
		var ExitCode;
		(function (ExitCode) {
		    /**
		     * A code indicating that the action was successful
		     */
		    ExitCode[ExitCode["Success"] = 0] = "Success";
		    /**
		     * A code indicating that the action was a failure
		     */
		    ExitCode[ExitCode["Failure"] = 1] = "Failure";
		})(ExitCode || (exports.ExitCode = ExitCode = {}));
		//-----------------------------------------------------------------------
		// Variables
		//-----------------------------------------------------------------------
		/**
		 * Sets env variable for this action and future actions in the job
		 * @param name the name of the variable to set
		 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function exportVariable(name, val) {
		    const convertedVal = (0, utils_1.toCommandValue)(val);
		    process.env[name] = convertedVal;
		    const filePath = process.env['GITHUB_ENV'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('ENV', (0, file_command_1.prepareKeyValueMessage)(name, val));
		    }
		    (0, command_1.issueCommand)('set-env', { name }, convertedVal);
		}
		exports.exportVariable = exportVariable;
		/**
		 * Registers a secret which will get masked from logs
		 * @param secret value of the secret
		 */
		function setSecret(secret) {
		    (0, command_1.issueCommand)('add-mask', {}, secret);
		}
		exports.setSecret = setSecret;
		/**
		 * Prepends inputPath to the PATH (for this action and future actions)
		 * @param inputPath
		 */
		function addPath(inputPath) {
		    const filePath = process.env['GITHUB_PATH'] || '';
		    if (filePath) {
		        (0, file_command_1.issueFileCommand)('PATH', inputPath);
		    }
		    else {
		        (0, command_1.issueCommand)('add-path', {}, inputPath);
		    }
		    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
		}
		exports.addPath = addPath;
		/**
		 * Gets the value of an input.
		 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
		 * Returns an empty string if the value is not defined.
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   string
		 */
		function getInput(name, options) {
		    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
		    if (options && options.required && !val) {
		        throw new Error(`Input required and not supplied: ${name}`);
		    }
		    if (options && options.trimWhitespace === false) {
		        return val;
		    }
		    return val.trim();
		}
		exports.getInput = getInput;
		/**
		 * Gets the values of an multiline input.  Each value is also trimmed.
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   string[]
		 *
		 */
		function getMultilineInput(name, options) {
		    const inputs = getInput(name, options)
		        .split('\n')
		        .filter(x => x !== '');
		    if (options && options.trimWhitespace === false) {
		        return inputs;
		    }
		    return inputs.map(input => input.trim());
		}
		exports.getMultilineInput = getMultilineInput;
		/**
		 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
		 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
		 * The return value is also in boolean type.
		 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
		 *
		 * @param     name     name of the input to get
		 * @param     options  optional. See InputOptions.
		 * @returns   boolean
		 */
		function getBooleanInput(name, options) {
		    const trueValue = ['true', 'True', 'TRUE'];
		    const falseValue = ['false', 'False', 'FALSE'];
		    const val = getInput(name, options);
		    if (trueValue.includes(val))
		        return true;
		    if (falseValue.includes(val))
		        return false;
		    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
		        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
		}
		exports.getBooleanInput = getBooleanInput;
		/**
		 * Sets the value of an output.
		 *
		 * @param     name     name of the output to set
		 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function setOutput(name, value) {
		    const filePath = process.env['GITHUB_OUTPUT'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('OUTPUT', (0, file_command_1.prepareKeyValueMessage)(name, value));
		    }
		    process.stdout.write(os.EOL);
		    (0, command_1.issueCommand)('set-output', { name }, (0, utils_1.toCommandValue)(value));
		}
		exports.setOutput = setOutput;
		/**
		 * Enables or disables the echoing of commands into stdout for the rest of the step.
		 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
		 *
		 */
		function setCommandEcho(enabled) {
		    (0, command_1.issue)('echo', enabled ? 'on' : 'off');
		}
		exports.setCommandEcho = setCommandEcho;
		//-----------------------------------------------------------------------
		// Results
		//-----------------------------------------------------------------------
		/**
		 * Sets the action status to failed.
		 * When the action exits it will be with an exit code of 1
		 * @param message add error issue message
		 */
		function setFailed(message) {
		    process.exitCode = ExitCode.Failure;
		    error(message);
		}
		exports.setFailed = setFailed;
		//-----------------------------------------------------------------------
		// Logging Commands
		//-----------------------------------------------------------------------
		/**
		 * Gets whether Actions Step Debug is on or not
		 */
		function isDebug() {
		    return process.env['RUNNER_DEBUG'] === '1';
		}
		exports.isDebug = isDebug;
		/**
		 * Writes debug message to user log
		 * @param message debug message
		 */
		function debug(message) {
		    (0, command_1.issueCommand)('debug', {}, message);
		}
		exports.debug = debug;
		/**
		 * Adds an error issue
		 * @param message error issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function error(message, properties = {}) {
		    (0, command_1.issueCommand)('error', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.error = error;
		/**
		 * Adds a warning issue
		 * @param message warning issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function warning(message, properties = {}) {
		    (0, command_1.issueCommand)('warning', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.warning = warning;
		/**
		 * Adds a notice issue
		 * @param message notice issue message. Errors will be converted to string via toString()
		 * @param properties optional properties to add to the annotation.
		 */
		function notice(message, properties = {}) {
		    (0, command_1.issueCommand)('notice', (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
		}
		exports.notice = notice;
		/**
		 * Writes info to log with console.log.
		 * @param message info message
		 */
		function info(message) {
		    process.stdout.write(message + os.EOL);
		}
		exports.info = info;
		/**
		 * Begin an output group.
		 *
		 * Output until the next `groupEnd` will be foldable in this group
		 *
		 * @param name The name of the output group
		 */
		function startGroup(name) {
		    (0, command_1.issue)('group', name);
		}
		exports.startGroup = startGroup;
		/**
		 * End an output group.
		 */
		function endGroup() {
		    (0, command_1.issue)('endgroup');
		}
		exports.endGroup = endGroup;
		/**
		 * Wrap an asynchronous function call in a group.
		 *
		 * Returns the same type as the function itself.
		 *
		 * @param name The name of the group
		 * @param fn The function to wrap in the group
		 */
		function group(name, fn) {
		    return __awaiter(this, undefined, undefined, function* () {
		        startGroup(name);
		        let result;
		        try {
		            result = yield fn();
		        }
		        finally {
		            endGroup();
		        }
		        return result;
		    });
		}
		exports.group = group;
		//-----------------------------------------------------------------------
		// Wrapper action state
		//-----------------------------------------------------------------------
		/**
		 * Saves state for current action, the state can only be retrieved by this action's post job execution.
		 *
		 * @param     name     name of the state to store
		 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		function saveState(name, value) {
		    const filePath = process.env['GITHUB_STATE'] || '';
		    if (filePath) {
		        return (0, file_command_1.issueFileCommand)('STATE', (0, file_command_1.prepareKeyValueMessage)(name, value));
		    }
		    (0, command_1.issueCommand)('save-state', { name }, (0, utils_1.toCommandValue)(value));
		}
		exports.saveState = saveState;
		/**
		 * Gets the value of an state set by this action's main execution.
		 *
		 * @param     name     name of the state to get
		 * @returns   string
		 */
		function getState(name) {
		    return process.env[`STATE_${name}`] || '';
		}
		exports.getState = getState;
		function getIDToken(aud) {
		    return __awaiter(this, undefined, undefined, function* () {
		        return yield oidc_utils_1.OidcClient.getIDToken(aud);
		    });
		}
		exports.getIDToken = getIDToken;
		/**
		 * Summary exports
		 */
		var summary_1 = requireSummary();
		Object.defineProperty(exports, "summary", { enumerable: true, get: function () { return summary_1.summary; } });
		/**
		 * @deprecated use core.summary
		 */
		var summary_2 = requireSummary();
		Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function () { return summary_2.markdownSummary; } });
		/**
		 * Path exports
		 */
		var path_utils_1 = requirePathUtils();
		Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });
		Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });
		Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });
		/**
		 * Platform utilities exports
		 */
		exports.platform = __importStar(requirePlatform());
		
	} (core));
	return core;
}

var coreExports = requireCore();

var github = {};

var context$1 = {};

var hasRequiredContext;

function requireContext () {
	if (hasRequiredContext) return context$1;
	hasRequiredContext = 1;
	Object.defineProperty(context$1, "__esModule", { value: true });
	context$1.Context = undefined;
	const fs_1 = require$$0$5;
	const os_1 = require$$0$3;
	class Context {
	    /**
	     * Hydrate the context from the environment
	     */
	    constructor() {
	        var _a, _b, _c;
	        this.payload = {};
	        if (process.env.GITHUB_EVENT_PATH) {
	            if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
	                this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
	            }
	            else {
	                const path = process.env.GITHUB_EVENT_PATH;
	                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
	            }
	        }
	        this.eventName = process.env.GITHUB_EVENT_NAME;
	        this.sha = process.env.GITHUB_SHA;
	        this.ref = process.env.GITHUB_REF;
	        this.workflow = process.env.GITHUB_WORKFLOW;
	        this.action = process.env.GITHUB_ACTION;
	        this.actor = process.env.GITHUB_ACTOR;
	        this.job = process.env.GITHUB_JOB;
	        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
	        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
	        this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== undefined ? _a : `https://api.github.com`;
	        this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== undefined ? _b : `https://github.com`;
	        this.graphqlUrl =
	            (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== undefined ? _c : `https://api.github.com/graphql`;
	    }
	    get issue() {
	        const payload = this.payload;
	        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
	    }
	    get repo() {
	        if (process.env.GITHUB_REPOSITORY) {
	            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
	            return { owner, repo };
	        }
	        if (this.payload.repository) {
	            return {
	                owner: this.payload.repository.owner.login,
	                repo: this.payload.repository.name
	            };
	        }
	        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
	    }
	}
	context$1.Context = Context;
	
	return context$1;
}

var utils$1 = {};

var utils = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils;
	hasRequiredUtils$1 = 1;
	var __createBinding = (utils.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (utils.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (utils.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __awaiter = (utils.__awaiter) || function (thisArg, _arguments, P, generator) {
	    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	};
	Object.defineProperty(utils, "__esModule", { value: true });
	utils.getApiBaseUrl = utils.getProxyFetch = utils.getProxyAgentDispatcher = utils.getProxyAgent = utils.getAuthString = undefined;
	const httpClient = __importStar(requireLib());
	const undici_1 = requireUndici();
	function getAuthString(token, options) {
	    if (!token && !options.auth) {
	        throw new Error('Parameter token or opts.auth is required');
	    }
	    else if (token && options.auth) {
	        throw new Error('Parameters token and opts.auth may not both be specified');
	    }
	    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
	}
	utils.getAuthString = getAuthString;
	function getProxyAgent(destinationUrl) {
	    const hc = new httpClient.HttpClient();
	    return hc.getAgent(destinationUrl);
	}
	utils.getProxyAgent = getProxyAgent;
	function getProxyAgentDispatcher(destinationUrl) {
	    const hc = new httpClient.HttpClient();
	    return hc.getAgentDispatcher(destinationUrl);
	}
	utils.getProxyAgentDispatcher = getProxyAgentDispatcher;
	function getProxyFetch(destinationUrl) {
	    const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
	    const proxyFetch = (url, opts) => __awaiter(this, undefined, undefined, function* () {
	        return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
	    });
	    return proxyFetch;
	}
	utils.getProxyFetch = getProxyFetch;
	function getApiBaseUrl() {
	    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
	}
	utils.getApiBaseUrl = getApiBaseUrl;
	
	return utils;
}

function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
    }
    if (typeof process === "object" && "version" in process) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
}

var beforeAfterHook = {exports: {}};

var register_1;
var hasRequiredRegister;

function requireRegister () {
	if (hasRequiredRegister) return register_1;
	hasRequiredRegister = 1;
	register_1 = register;

	function register(state, name, method, options) {
	  if (typeof method !== "function") {
	    throw new Error("method for before hook must be a function");
	  }

	  if (!options) {
	    options = {};
	  }

	  if (Array.isArray(name)) {
	    return name.reverse().reduce(function (callback, name) {
	      return register.bind(null, state, name, callback, options);
	    }, method)();
	  }

	  return Promise.resolve().then(function () {
	    if (!state.registry[name]) {
	      return method(options);
	    }

	    return state.registry[name].reduce(function (method, registered) {
	      return registered.hook.bind(null, method, options);
	    }, method)();
	  });
	}
	return register_1;
}

var add;
var hasRequiredAdd;

function requireAdd () {
	if (hasRequiredAdd) return add;
	hasRequiredAdd = 1;
	add = addHook;

	function addHook(state, kind, name, hook) {
	  var orig = hook;
	  if (!state.registry[name]) {
	    state.registry[name] = [];
	  }

	  if (kind === "before") {
	    hook = function (method, options) {
	      return Promise.resolve()
	        .then(orig.bind(null, options))
	        .then(method.bind(null, options));
	    };
	  }

	  if (kind === "after") {
	    hook = function (method, options) {
	      var result;
	      return Promise.resolve()
	        .then(method.bind(null, options))
	        .then(function (result_) {
	          result = result_;
	          return orig(result, options);
	        })
	        .then(function () {
	          return result;
	        });
	    };
	  }

	  if (kind === "error") {
	    hook = function (method, options) {
	      return Promise.resolve()
	        .then(method.bind(null, options))
	        .catch(function (error) {
	          return orig(error, options);
	        });
	    };
	  }

	  state.registry[name].push({
	    hook: hook,
	    orig: orig,
	  });
	}
	return add;
}

var remove;
var hasRequiredRemove;

function requireRemove () {
	if (hasRequiredRemove) return remove;
	hasRequiredRemove = 1;
	remove = removeHook;

	function removeHook(state, name, method) {
	  if (!state.registry[name]) {
	    return;
	  }

	  var index = state.registry[name]
	    .map(function (registered) {
	      return registered.orig;
	    })
	    .indexOf(method);

	  if (index === -1) {
	    return;
	  }

	  state.registry[name].splice(index, 1);
	}
	return remove;
}

var hasRequiredBeforeAfterHook;

function requireBeforeAfterHook () {
	if (hasRequiredBeforeAfterHook) return beforeAfterHook.exports;
	hasRequiredBeforeAfterHook = 1;
	var register = requireRegister();
	var addHook = requireAdd();
	var removeHook = requireRemove();

	// bind with array of arguments: https://stackoverflow.com/a/21792913
	var bind = Function.bind;
	var bindable = bind.bind(bind);

	function bindApi (hook, state, name) {
	  var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
	  hook.api = { remove: removeHookRef };
	  hook.remove = removeHookRef

	  ;['before', 'error', 'after', 'wrap'].forEach(function (kind) {
	    var args = name ? [state, kind, name] : [state, kind];
	    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
	  });
	}

	function HookSingular () {
	  var singularHookName = 'h';
	  var singularHookState = {
	    registry: {}
	  };
	  var singularHook = register.bind(null, singularHookState, singularHookName);
	  bindApi(singularHook, singularHookState, singularHookName);
	  return singularHook
	}

	function HookCollection () {
	  var state = {
	    registry: {}
	  };

	  var hook = register.bind(null, state);
	  bindApi(hook, state);

	  return hook
	}

	var collectionHookDeprecationMessageDisplayed = false;
	function Hook () {
	  if (!collectionHookDeprecationMessageDisplayed) {
	    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
	    collectionHookDeprecationMessageDisplayed = true;
	  }
	  return HookCollection()
	}

	Hook.Singular = HookSingular.bind();
	Hook.Collection = HookCollection.bind();

	beforeAfterHook.exports = Hook;
	// expose constructors as a named property for TypeScript
	beforeAfterHook.exports.Hook = Hook;
	beforeAfterHook.exports.Singular = Hook.Singular;
	beforeAfterHook.exports.Collection = Hook.Collection;
	return beforeAfterHook.exports;
}

var beforeAfterHookExports = requireBeforeAfterHook();

const VERSION$9 = "9.0.5";

const userAgent = `octokit-endpoint.js/${VERSION$9} ${getUserAgent()}`;
const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};

function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}

function isPlainObject$2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}

function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject$2(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}

function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}

function merge$1(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(
        (preview) => !mergedOptions.mediaType.previews.includes(preview)
      ).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}

function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}

const urlVariableRegex = /\{[^}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}

function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(
    /\{([^\{\}]+)\}|([^\{\}]+)/g,
    function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    }
  );
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}

function parse(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map(
        (format) => format.replace(
          /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
          `application/vnd$1$2.${options.mediaType.format}`
        )
      ).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign(
    { method, url, headers },
    typeof body !== "undefined" ? { body } : null,
    options.request ? { request: options.request } : null
  );
}

function endpointWithDefaults(defaults, route, options) {
  return parse(merge$1(defaults, route, options));
}

function withDefaults$2(oldDefaults, newDefaults) {
  const DEFAULTS = merge$1(oldDefaults, newDefaults);
  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
  return Object.assign(endpoint, {
    DEFAULTS,
    defaults: withDefaults$2.bind(null, DEFAULTS),
    merge: merge$1.bind(null, DEFAULTS),
    parse
  });
}

const endpoint = withDefaults$2(null, DEFAULTS);

const VERSION$8 = "8.4.0";

function isPlainObject$1(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}

class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}

var once$1 = {exports: {}};

var wrappy_1;
var hasRequiredWrappy;

function requireWrappy () {
	if (hasRequiredWrappy) return wrappy_1;
	hasRequiredWrappy = 1;
	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	wrappy_1 = wrappy;
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k];
	  });

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    var ret = fn.apply(this, args);
	    var cb = args[args.length-1];
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k];
	      });
	    }
	    return ret
	  }
	}
	return wrappy_1;
}

var hasRequiredOnce;

function requireOnce () {
	if (hasRequiredOnce) return once$1.exports;
	hasRequiredOnce = 1;
	var wrappy = requireWrappy();
	once$1.exports = wrappy(once);
	once$1.exports.strict = wrappy(onceStrict);

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  });

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  });
	});

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  f.called = false;
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true;
	    return f.value = fn.apply(this, arguments)
	  };
	  var name = fn.name || 'Function wrapped with `once`';
	  f.onceError = name + " shouldn't be called more than once";
	  f.called = false;
	  return f
	}
	return once$1.exports;
}

var onceExports = requireOnce();
var once = /*@__PURE__*/getDefaultExportFromCjs(onceExports);

const logOnceCode = once((deprecation) => console.warn(deprecation));
const logOnceHeaders = once((deprecation) => console.warn(deprecation));
class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "HttpError";
    this.status = statusCode;
    let headers;
    if ("headers" in options && typeof options.headers !== "undefined") {
      headers = options.headers;
    }
    if ("response" in options) {
      this.response = options.response;
      headers = options.response.headers;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(
          / .*$/,
          " [REDACTED]"
        )
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
    Object.defineProperty(this, "code", {
      get() {
        logOnceCode(
          new Deprecation(
            "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
          )
        );
        return statusCode;
      }
    });
    Object.defineProperty(this, "headers", {
      get() {
        logOnceHeaders(
          new Deprecation(
            "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
          )
        );
        return headers || {};
      }
    });
  }
}

function getBufferResponse(response) {
  return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  if (isPlainObject$1(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  if (requestOptions.request?.fetch) {
    fetch = requestOptions.request.fetch;
  }
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    redirect: requestOptions.request?.redirect,
    headers: requestOptions.headers,
    signal: requestOptions.request?.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: undefined
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (/application\/json/.test(contentType)) {
    return response.json().catch(() => response.text()).catch(() => "");
  }
  if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
    return response.text();
  }
  return getBufferResponse(response);
}
function toErrorMessage(data) {
  if (typeof data === "string")
    return data;
  let suffix;
  if ("documentation_url" in data) {
    suffix = ` - ${data.documentation_url}`;
  } else {
    suffix = "";
  }
  if ("message" in data) {
    if (Array.isArray(data.errors)) {
      return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
    }
    return `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}

function withDefaults$1(oldEndpoint, newDefaults) {
  const endpoint = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters) {
    const endpointOptions = endpoint.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint.parse(endpointOptions));
    }
    const request = (route2, parameters2) => {
      return fetchWrapper(
        endpoint.parse(endpoint.merge(route2, parameters2))
      );
    };
    Object.assign(request, {
      endpoint,
      defaults: withDefaults$1.bind(null, endpoint)
    });
    return endpointOptions.request.hook(request, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint,
    defaults: withDefaults$1.bind(null, endpoint)
  });
}

const request = withDefaults$1(endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION$8} ${getUserAgent()}`
  }
});

// pkg/dist-src/index.js

// pkg/dist-src/version.js
var VERSION$7 = "7.1.0";

// pkg/dist-src/error.js
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
  constructor(request2, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request2;
    this.headers = headers;
    this.response = response;
    this.name = "GraphqlResponseError";
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};

// pkg/dist-src/graphql.js
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(
        new Error(`[@octokit/graphql] "query" cannot be used as variable name`)
      );
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(
        new Error(
          `[@octokit/graphql] "${key}" cannot be used as variable name`
        )
      );
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(
    parsedOptions
  ).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(
        requestOptions,
        headers,
        response.data
      );
    }
    return response.data.data;
  });
}

// pkg/dist-src/with-defaults.js
function withDefaults(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}

// pkg/dist-src/index.js
withDefaults(request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION$7} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

const REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
const REGEX_IS_INSTALLATION = /^ghs_/;
const REGEX_IS_USER_TO_SERVER = /^ghu_/;
async function auth(token) {
  const isApp = token.split(/\./).length === 3;
  const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
  const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}

function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}

async function hook(token, request, route, parameters) {
  const endpoint = request.endpoint.merge(
    route,
    parameters
  );
  endpoint.headers.authorization = withAuthorizationPrefix(token);
  return request(endpoint);
}

const createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error(
      "[@octokit/auth-token] Token passed to createTokenAuth is not a string"
    );
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// pkg/dist-src/version.js
var VERSION$6 = "5.2.0";

// pkg/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION$6} ${getUserAgent()}`;
var Octokit = class {
  static {
    this.VERSION = VERSION$6;
  }
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(
          Object.assign(
            {},
            defaults,
            options,
            options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null
          )
        );
      }
    };
    return OctokitWithDefaults;
  }
  static {
    this.plugins = [];
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static {
        this.plugins = currentPlugins.concat(
          newPlugins.filter((plugin) => !currentPlugins.includes(plugin))
        );
      }
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook = new beforeAfterHookExports.Collection();
    const requestDefaults = {
      baseUrl: request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        // @ts-ignore internal usage only, no need to type
        hook: hook.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign(
      {
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      },
      options.log
    );
    this.hook = hook;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth = createTokenAuth(options.auth);
        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth = authStrategy(
        Object.assign(
          {
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          },
          options.auth
        )
      );
      hook.wrap("request", auth.hook);
      this.auth = auth;
    }
    const classConstructor = this.constructor;
    for (let i = 0; i < classConstructor.plugins.length; ++i) {
      Object.assign(this, classConstructor.plugins[i](this, options));
    }
  }
};

var distWeb$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Octokit: Octokit
});

var require$$2$2 = /*@__PURE__*/getAugmentedNamespace(distWeb$1);

const VERSION$5 = "10.4.1";

const Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    createOrUpdateEnvironmentSecret: [
      "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repositories/{repository_id}/environments/{environment_name}/variables"
    ],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: [
      "DELETE /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
      }
    ],
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getCommitAuthors: [
      "GET /repos/{owner}/{repo}/import/authors",
      {},
      {
        deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
      }
    ],
    getImportStatus: [
      "GET /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
      }
    ],
    getLargeFiles: [
      "GET /repos/{owner}/{repo}/import/large_files",
      {},
      {
        deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
      }
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    mapCommitAuthor: [
      "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
      {},
      {
        deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
      }
    ],
    setLfsPreference: [
      "PATCH /repos/{owner}/{repo}/import/lfs",
      {},
      {
        deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
      }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: [
      "PUT /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
      }
    ],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    updateImport: [
      "PATCH /repos/{owner}/{repo}/import",
      {},
      {
        deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
      }
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteCustomOrganizationRole: [
      "DELETE /orgs/{org}/organization-roles/{role_id}"
    ],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}"
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    patchCustomOrganizationRole: [
      "PATCH /orgs/{org}/organization-roles/{role_id}"
    ],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
    createCard: ["POST /projects/columns/{column_id}/cards"],
    createColumn: ["POST /projects/{project_id}/columns"],
    createForAuthenticatedUser: ["POST /user/projects"],
    createForOrg: ["POST /orgs/{org}/projects"],
    createForRepo: ["POST /repos/{owner}/{repo}/projects"],
    delete: ["DELETE /projects/{project_id}"],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
    deleteColumn: ["DELETE /projects/columns/{column_id}"],
    get: ["GET /projects/{project_id}"],
    getCard: ["GET /projects/columns/cards/{card_id}"],
    getColumn: ["GET /projects/columns/{column_id}"],
    getPermissionForUser: [
      "GET /projects/{project_id}/collaborators/{username}/permission"
    ],
    listCards: ["GET /projects/columns/{column_id}/cards"],
    listCollaborators: ["GET /projects/{project_id}/collaborators"],
    listColumns: ["GET /projects/{project_id}/columns"],
    listForOrg: ["GET /orgs/{org}/projects"],
    listForRepo: ["GET /repos/{owner}/{repo}/projects"],
    listForUser: ["GET /users/{username}/projects"],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
    moveColumn: ["POST /projects/columns/{column_id}/moves"],
    removeCollaborator: [
      "DELETE /projects/{project_id}/collaborators/{username}"
    ],
    update: ["PATCH /projects/{project_id}"],
    updateCard: ["PATCH /projects/columns/cards/{card_id}"],
    updateColumn: ["PATCH /projects/columns/{column_id}"]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteTagProtection: [
      "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
    ],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateProjectPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForProjectInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeProjectInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

const endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign(
      {
        method,
        url
      },
      defaults
    );
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
const handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      // ensures method is in the cache
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return target.cache[methodName] = value;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return undefined;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(
        octokit,
        scope,
        methodName,
        endpointDefaults,
        decorations
      );
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(
        `octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`
      );
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(
        decorations.renamedParameters
      )) {
        if (name in options2) {
          octokit.log.warn(
            `"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`
          );
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION$5;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION$5;

var distSrc = /*#__PURE__*/Object.freeze({
	__proto__: null,
	legacyRestEndpointMethods: legacyRestEndpointMethods,
	restEndpointMethods: restEndpointMethods
});

var require$$3$1 = /*@__PURE__*/getAugmentedNamespace(distSrc);

// pkg/dist-src/version.js
var VERSION$4 = "9.2.1";

// pkg/dist-src/normalize-paginated-list-response.js
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}

// pkg/dist-src/iterator.js
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(
            /<([^>]+)>;\s*rel="next"/
          ) || [])[1];
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}

// pkg/dist-src/paginate.js
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = undefined;
  }
  return gather(
    octokit,
    [],
    iterator(octokit, route, parameters)[Symbol.asyncIterator](),
    mapFn
  );
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(
      mapFn ? mapFn(result.value, done) : result.value.data
    );
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}

// pkg/dist-src/compose-paginate.js
var composePaginateRest = Object.assign(paginate, {
  iterator
});

// pkg/dist-src/generated/paginating-endpoints.js
var paginatingEndpoints = [
  "GET /advisories",
  "GET /app/hook/deliveries",
  "GET /app/installation-requests",
  "GET /app/installations",
  "GET /assignments/{assignment_id}/accepted_assignments",
  "GET /classrooms",
  "GET /classrooms/{classroom_id}/assignments",
  "GET /enterprises/{enterprise}/dependabot/alerts",
  "GET /enterprises/{enterprise}/secret-scanning/alerts",
  "GET /events",
  "GET /gists",
  "GET /gists/public",
  "GET /gists/starred",
  "GET /gists/{gist_id}/comments",
  "GET /gists/{gist_id}/commits",
  "GET /gists/{gist_id}/forks",
  "GET /installation/repositories",
  "GET /issues",
  "GET /licenses",
  "GET /marketplace_listing/plans",
  "GET /marketplace_listing/plans/{plan_id}/accounts",
  "GET /marketplace_listing/stubbed/plans",
  "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
  "GET /networks/{owner}/{repo}/events",
  "GET /notifications",
  "GET /organizations",
  "GET /orgs/{org}/actions/cache/usage-by-repository",
  "GET /orgs/{org}/actions/permissions/repositories",
  "GET /orgs/{org}/actions/runners",
  "GET /orgs/{org}/actions/secrets",
  "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/actions/variables",
  "GET /orgs/{org}/actions/variables/{name}/repositories",
  "GET /orgs/{org}/blocks",
  "GET /orgs/{org}/code-scanning/alerts",
  "GET /orgs/{org}/codespaces",
  "GET /orgs/{org}/codespaces/secrets",
  "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/copilot/billing/seats",
  "GET /orgs/{org}/dependabot/alerts",
  "GET /orgs/{org}/dependabot/secrets",
  "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
  "GET /orgs/{org}/events",
  "GET /orgs/{org}/failed_invitations",
  "GET /orgs/{org}/hooks",
  "GET /orgs/{org}/hooks/{hook_id}/deliveries",
  "GET /orgs/{org}/installations",
  "GET /orgs/{org}/invitations",
  "GET /orgs/{org}/invitations/{invitation_id}/teams",
  "GET /orgs/{org}/issues",
  "GET /orgs/{org}/members",
  "GET /orgs/{org}/members/{username}/codespaces",
  "GET /orgs/{org}/migrations",
  "GET /orgs/{org}/migrations/{migration_id}/repositories",
  "GET /orgs/{org}/organization-roles/{role_id}/teams",
  "GET /orgs/{org}/organization-roles/{role_id}/users",
  "GET /orgs/{org}/outside_collaborators",
  "GET /orgs/{org}/packages",
  "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
  "GET /orgs/{org}/personal-access-token-requests",
  "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
  "GET /orgs/{org}/personal-access-tokens",
  "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
  "GET /orgs/{org}/projects",
  "GET /orgs/{org}/properties/values",
  "GET /orgs/{org}/public_members",
  "GET /orgs/{org}/repos",
  "GET /orgs/{org}/rulesets",
  "GET /orgs/{org}/rulesets/rule-suites",
  "GET /orgs/{org}/secret-scanning/alerts",
  "GET /orgs/{org}/security-advisories",
  "GET /orgs/{org}/teams",
  "GET /orgs/{org}/teams/{team_slug}/discussions",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
  "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
  "GET /orgs/{org}/teams/{team_slug}/invitations",
  "GET /orgs/{org}/teams/{team_slug}/members",
  "GET /orgs/{org}/teams/{team_slug}/projects",
  "GET /orgs/{org}/teams/{team_slug}/repos",
  "GET /orgs/{org}/teams/{team_slug}/teams",
  "GET /projects/columns/{column_id}/cards",
  "GET /projects/{project_id}/collaborators",
  "GET /projects/{project_id}/columns",
  "GET /repos/{owner}/{repo}/actions/artifacts",
  "GET /repos/{owner}/{repo}/actions/caches",
  "GET /repos/{owner}/{repo}/actions/organization-secrets",
  "GET /repos/{owner}/{repo}/actions/organization-variables",
  "GET /repos/{owner}/{repo}/actions/runners",
  "GET /repos/{owner}/{repo}/actions/runs",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
  "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
  "GET /repos/{owner}/{repo}/actions/secrets",
  "GET /repos/{owner}/{repo}/actions/variables",
  "GET /repos/{owner}/{repo}/actions/workflows",
  "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
  "GET /repos/{owner}/{repo}/activity",
  "GET /repos/{owner}/{repo}/assignees",
  "GET /repos/{owner}/{repo}/branches",
  "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
  "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
  "GET /repos/{owner}/{repo}/code-scanning/alerts",
  "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
  "GET /repos/{owner}/{repo}/code-scanning/analyses",
  "GET /repos/{owner}/{repo}/codespaces",
  "GET /repos/{owner}/{repo}/codespaces/devcontainers",
  "GET /repos/{owner}/{repo}/codespaces/secrets",
  "GET /repos/{owner}/{repo}/collaborators",
  "GET /repos/{owner}/{repo}/comments",
  "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/commits",
  "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
  "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
  "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
  "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
  "GET /repos/{owner}/{repo}/commits/{ref}/status",
  "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
  "GET /repos/{owner}/{repo}/contributors",
  "GET /repos/{owner}/{repo}/dependabot/alerts",
  "GET /repos/{owner}/{repo}/dependabot/secrets",
  "GET /repos/{owner}/{repo}/deployments",
  "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
  "GET /repos/{owner}/{repo}/environments",
  "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
  "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
  "GET /repos/{owner}/{repo}/events",
  "GET /repos/{owner}/{repo}/forks",
  "GET /repos/{owner}/{repo}/hooks",
  "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
  "GET /repos/{owner}/{repo}/invitations",
  "GET /repos/{owner}/{repo}/issues",
  "GET /repos/{owner}/{repo}/issues/comments",
  "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/issues/events",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
  "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
  "GET /repos/{owner}/{repo}/keys",
  "GET /repos/{owner}/{repo}/labels",
  "GET /repos/{owner}/{repo}/milestones",
  "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
  "GET /repos/{owner}/{repo}/notifications",
  "GET /repos/{owner}/{repo}/pages/builds",
  "GET /repos/{owner}/{repo}/projects",
  "GET /repos/{owner}/{repo}/pulls",
  "GET /repos/{owner}/{repo}/pulls/comments",
  "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
  "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
  "GET /repos/{owner}/{repo}/releases",
  "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
  "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
  "GET /repos/{owner}/{repo}/rules/branches/{branch}",
  "GET /repos/{owner}/{repo}/rulesets",
  "GET /repos/{owner}/{repo}/rulesets/rule-suites",
  "GET /repos/{owner}/{repo}/secret-scanning/alerts",
  "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
  "GET /repos/{owner}/{repo}/security-advisories",
  "GET /repos/{owner}/{repo}/stargazers",
  "GET /repos/{owner}/{repo}/subscribers",
  "GET /repos/{owner}/{repo}/tags",
  "GET /repos/{owner}/{repo}/teams",
  "GET /repos/{owner}/{repo}/topics",
  "GET /repositories",
  "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
  "GET /repositories/{repository_id}/environments/{environment_name}/variables",
  "GET /search/code",
  "GET /search/commits",
  "GET /search/issues",
  "GET /search/labels",
  "GET /search/repositories",
  "GET /search/topics",
  "GET /search/users",
  "GET /teams/{team_id}/discussions",
  "GET /teams/{team_id}/discussions/{discussion_number}/comments",
  "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
  "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
  "GET /teams/{team_id}/invitations",
  "GET /teams/{team_id}/members",
  "GET /teams/{team_id}/projects",
  "GET /teams/{team_id}/repos",
  "GET /teams/{team_id}/teams",
  "GET /user/blocks",
  "GET /user/codespaces",
  "GET /user/codespaces/secrets",
  "GET /user/emails",
  "GET /user/followers",
  "GET /user/following",
  "GET /user/gpg_keys",
  "GET /user/installations",
  "GET /user/installations/{installation_id}/repositories",
  "GET /user/issues",
  "GET /user/keys",
  "GET /user/marketplace_purchases",
  "GET /user/marketplace_purchases/stubbed",
  "GET /user/memberships/orgs",
  "GET /user/migrations",
  "GET /user/migrations/{migration_id}/repositories",
  "GET /user/orgs",
  "GET /user/packages",
  "GET /user/packages/{package_type}/{package_name}/versions",
  "GET /user/public_emails",
  "GET /user/repos",
  "GET /user/repository_invitations",
  "GET /user/social_accounts",
  "GET /user/ssh_signing_keys",
  "GET /user/starred",
  "GET /user/subscriptions",
  "GET /user/teams",
  "GET /users",
  "GET /users/{username}/events",
  "GET /users/{username}/events/orgs/{org}",
  "GET /users/{username}/events/public",
  "GET /users/{username}/followers",
  "GET /users/{username}/following",
  "GET /users/{username}/gists",
  "GET /users/{username}/gpg_keys",
  "GET /users/{username}/keys",
  "GET /users/{username}/orgs",
  "GET /users/{username}/packages",
  "GET /users/{username}/projects",
  "GET /users/{username}/received_events",
  "GET /users/{username}/received_events/public",
  "GET /users/{username}/repos",
  "GET /users/{username}/social_accounts",
  "GET /users/{username}/ssh_signing_keys",
  "GET /users/{username}/starred",
  "GET /users/{username}/subscriptions"
];

// pkg/dist-src/paginating-endpoints.js
function isPaginatingEndpoint(arg) {
  if (typeof arg === "string") {
    return paginatingEndpoints.includes(arg);
  } else {
    return false;
  }
}

// pkg/dist-src/index.js
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION$4;

var distWeb = /*#__PURE__*/Object.freeze({
	__proto__: null,
	composePaginateRest: composePaginateRest,
	isPaginatingEndpoint: isPaginatingEndpoint,
	paginateRest: paginateRest,
	paginatingEndpoints: paginatingEndpoints
});

var require$$4$1 = /*@__PURE__*/getAugmentedNamespace(distWeb);

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$1;
	hasRequiredUtils = 1;
	(function (exports) {
		var __createBinding = (utils$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (utils$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (utils$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = undefined;
		const Context = __importStar(requireContext());
		const Utils = __importStar(requireUtils$1());
		// octokit + plugins
		const core_1 = require$$2$2;
		const plugin_rest_endpoint_methods_1 = require$$3$1;
		const plugin_paginate_rest_1 = require$$4$1;
		exports.context = new Context.Context();
		const baseUrl = Utils.getApiBaseUrl();
		exports.defaults = {
		    baseUrl,
		    request: {
		        agent: Utils.getProxyAgent(baseUrl),
		        fetch: Utils.getProxyFetch(baseUrl)
		    }
		};
		exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
		/**
		 * Convience function to correctly format Octokit Options to pass into the constructor.
		 *
		 * @param     token    the repo PAT or GITHUB_TOKEN
		 * @param     options  other options to set
		 */
		function getOctokitOptions(token, options) {
		    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
		    // Auth
		    const auth = Utils.getAuthString(token, opts);
		    if (auth) {
		        opts.auth = auth;
		    }
		    return opts;
		}
		exports.getOctokitOptions = getOctokitOptions;
		
	} (utils$1));
	return utils$1;
}

var hasRequiredGithub;

function requireGithub () {
	if (hasRequiredGithub) return github;
	hasRequiredGithub = 1;
	var __createBinding = (github.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (github.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (github.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(github, "__esModule", { value: true });
	github.getOctokit = github.context = undefined;
	const Context = __importStar(requireContext());
	const utils_1 = requireUtils();
	github.context = new Context.Context();
	/**
	 * Returns a hydrated octokit ready to use for GitHub Actions
	 *
	 * @param     token    the repo PAT or GITHUB_TOKEN
	 * @param     options  other options to set
	 */
	function getOctokit(token, options, ...additionalPlugins) {
	    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
	    return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
	}
	github.getOctokit = getOctokit;
	
	return github;
}

var githubExports = requireGithub();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TMP_EXCEPTION_TYPE = 'exception.type';
var TMP_EXCEPTION_MESSAGE = 'exception.message';
var TMP_EXCEPTION_STACKTRACE = 'exception.stacktrace';
/**
 * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
 *
 * @deprecated Use ATTR_EXCEPTION_TYPE.
 */
var SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
/**
 * The exception message.
 *
 * @deprecated Use ATTR_EXCEPTION_MESSAGE.
 */
var SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
/**
 * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
 *
 * @deprecated Use ATTR_EXCEPTION_STACKTRACE.
 */
var SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TMP_PROCESS_RUNTIME_NAME = 'process.runtime.name';
var TMP_SERVICE_NAME = 'service.name';
var TMP_TELEMETRY_SDK_NAME = 'telemetry.sdk.name';
var TMP_TELEMETRY_SDK_LANGUAGE = 'telemetry.sdk.language';
var TMP_TELEMETRY_SDK_VERSION = 'telemetry.sdk.version';
/**
 * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
 *
 * @deprecated Use ATTR_PROCESS_RUNTIME_NAME in [incubating entry-point]({@link https://github.com/open-telemetry/opentelemetry-js/blob/main/semantic-conventions/README.md#unstable-semconv}).
 */
var SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
/**
 * Logical name of the service.
 *
 * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
 *
 * @deprecated Use ATTR_SERVICE_NAME.
 */
var SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
/**
 * The name of the telemetry SDK as defined above.
 *
 * @deprecated Use ATTR_TELEMETRY_SDK_NAME.
 */
var SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
/**
 * The language of the telemetry SDK.
 *
 * @deprecated Use ATTR_TELEMETRY_SDK_LANGUAGE.
 */
var SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
/**
 * The version string of the telemetry SDK.
 *
 * @deprecated Use ATTR_TELEMETRY_SDK_VERSION.
 */
var SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = 'nodejs';
/**
 * The language of the telemetry SDK.
 *
 * @deprecated Use TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS.
 */
var TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * Rate-limiting result, shows whether the lease was acquired or contains a rejection reason
 *
 * @example acquired
 * @example request_canceled
 */
/**
 * Logical name of the service.
 *
 * @example shoppingcart
 *
 * @note **MUST** be the same for all instances of horizontally scaled services. If the value was not specified, SDKs **MUST** fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value **MUST** be set to `unknown_service`.
 */
var ATTR_SERVICE_NAME = 'service.name';
/**
 * The version string of the service API or implementation. The format is not defined by these conventions.
 *
 * @example 2.0.0
 * @example a01dbef8a
 */
var ATTR_SERVICE_VERSION = 'service.version';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//----------------------------------------------------------------------------------------------------------
// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates/registry/stable/attributes.ts.j2
//----------------------------------------------------------------------------------------------------------
/**
 * The ID of a running ECS task. The ID **MUST** be extracted from `task.arn`.
 *
 * @example 10838bed-421f-43ef-870a-f43feacbbb5b
 * @example 23ebb8ac-c18f-46c6-8bbe-d55d0e37cfbd
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
/**
 * The human readable name of the pipeline within a CI/CD system.
 *
 * @example Build and Test
 * @example Lint
 * @example Deploy Go Project
 * @example deploy_to_environment
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_CICD_PIPELINE_NAME = 'cicd.pipeline.name';
/**
 * The unique identifier of a pipeline run within a CI/CD system.
 *
 * @example 120912
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_CICD_PIPELINE_RUN_ID = 'cicd.pipeline.run.id';
/**
 * The human readable name of a task within a pipeline. Task here most closely aligns with a [computing process](https://en.wikipedia.org/wiki/Pipeline_(computing)) in a pipeline. Other terms for tasks include commands, steps, and procedures.
 *
 * @example Run GoLang Linter
 * @example Go Build
 * @example go-test
 * @example deploy_binary
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_CICD_PIPELINE_TASK_NAME = 'cicd.pipeline.task.name';
/**
 * The unique identifier of a task run within a pipeline.
 *
 * @example 12097
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_CICD_PIPELINE_TASK_RUN_ID = 'cicd.pipeline.task.run.id';
/**
 * The [URL](https://en.wikipedia.org/wiki/URL) of the pipeline run providing the complete address in order to locate and identify the pipeline run.
 *
 * @example https://github.com/open-telemetry/semantic-conventions/actions/runs/9753949763/job/26920038674?pr=1075
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_CICD_PIPELINE_TASK_RUN_URL_FULL = 'cicd.pipeline.task.run.url.full';
/**
 * The type of the task within a pipeline.
 *
 * @example build
 * @example test
 * @example deploy
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_CICD_PIPELINE_TASK_TYPE = 'cicd.pipeline.task.type';
/**
  * Enum value "build" for attribute {@link ATTR_CICD_PIPELINE_TASK_TYPE}.
  */
var CICD_PIPELINE_TASK_TYPE_VALUE_BUILD = "build";
/**
  * Enum value "deploy" for attribute {@link ATTR_CICD_PIPELINE_TASK_TYPE}.
  */
var CICD_PIPELINE_TASK_TYPE_VALUE_DEPLOY = "deploy";
/**
  * Enum value "test" for attribute {@link ATTR_CICD_PIPELINE_TASK_TYPE}.
  */
var CICD_PIPELINE_TASK_TYPE_VALUE_TEST = "test";
/**
 * The string ID of the service instance.
 *
 * @example 627cc493-f310-47de-96bd-71410b7dec09
 *
 * @note **MUST** be unique for each instance of the same `service.namespace,service.name` pair (in other words
 * `service.namespace,service.name,service.instance.id` triplet **MUST** be globally unique). The ID helps to
 * distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled
 * service).
 *
 * Implementations, such as SDKs, are recommended to generate a random Version 1 or Version 4 [RFC
 * 4122](https://www.ietf.org/rfc/rfc4122.txt) UUID, but are free to use an inherent unique ID as the source of
 * this value if stability is desirable. In that case, the ID **SHOULD** be used as source of a UUID Version 5 and
 * **SHOULD** use the following UUID as the namespace: `4d63009a-8d0f-11ee-aad7-4c796ed8e320`.
 *
 * UUIDs are typically recommended, as only an opaque value for the purposes of identifying a service instance is
 * needed. Similar to what can be seen in the man page for the
 * [`/etc/machine-id`](https://www.freedesktop.org/software/systemd/man/machine-id.html) file, the underlying
 * data, such as pod name and namespace should be treated as confidential, being the user's choice to expose it
 * or not via another resource attribute.
 *
 * For applications running behind an application server (like unicorn), we do not recommend using one identifier
 * for all processes participating in the application. Instead, it's recommended each division (e.g. a worker
 * thread in unicorn) to have its own instance.id.
 *
 * It's not recommended for a Collector to set `service.instance.id` if it can't unambiguously determine the
 * service instance that is generating that telemetry. For instance, creating an UUID based on `pod.name` will
 * likely be wrong, as the Collector might not know from which container within that pod the telemetry originated.
 * However, Collectors can set the `service.instance.id` if they can unambiguously determine the service instance
 * for that telemetry. This is typically the case for scraping receivers, as they know the target address and
 * port.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_SERVICE_INSTANCE_ID = 'service.instance.id';
/**
 * A namespace for `service.name`.
 *
 * @example Shop
 *
 * @note A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
 *
 * @experimental This attribute is experimental and is subject to breaking changes in minor releases of `@opentelemetry/semantic-conventions`.
 */
var ATTR_SERVICE_NAMESPACE = 'service.namespace';

async function getWorkflowRun(context, octokit, runId) {
    const res = await octokit.rest.actions.getWorkflowRun({
        ...context.repo,
        run_id: runId,
    });
    return res.data;
}
async function listJobsForWorkflowRun(context, octokit, runId) {
    return await octokit.paginate(octokit.rest.actions.listJobsForWorkflowRun, {
        ...context.repo,
        run_id: runId,
        filter: "latest", // risk of missing a run if re-run happens between Action trigger and this query
        per_page: 100,
    });
}
async function getJobsAnnotations(context, octokit, jobIds) {
    const annotations = {};
    for (const jobId of jobIds) {
        annotations[jobId] = await listAnnotations(context, octokit, jobId);
    }
    return annotations;
}
async function listAnnotations(context, octokit, checkRunId) {
    return await octokit.paginate(octokit.rest.checks.listAnnotations, {
        ...context.repo,
        check_run_id: checkRunId,
    });
}
async function getPRsLabels(context, octokit, prNumbers) {
    const labels = {};
    for (const prNumber of prNumbers) {
        labels[prNumber] = await listLabelsOnIssue(context, octokit, prNumber);
    }
    return labels;
}
async function listLabelsOnIssue(context, octokit, prNumber) {
    return await octokit.paginate(octokit.rest.issues.listLabelsOnIssue, {
        ...context.repo,
        issue_number: prNumber,
    }, (response) => response.data.map((issue) => issue.name));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins
var _globalThis$1 = typeof globalThis === 'object' ? globalThis : global;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION$3 = '1.9.0';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */
function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([ownVersion]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
        // we cannot guarantee compatibility so we always return noop
        return function () { return false; };
    }
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4],
    };
    // if ownVersion has a prerelease tag, versions must match exactly
    if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
            return globalVersion === ownVersion;
        };
    }
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
            return true;
        }
        if (rejectedVersions.has(globalVersion)) {
            return false;
        }
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
            // cannot parse other version
            // we cannot guarantee compatibility so we always noop
            return _reject(globalVersion);
        }
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3],
            prerelease: globalVersionMatch[4],
        };
        // if globalVersion has a prerelease tag, versions must match exactly
        if (globalVersionParsed.prerelease != null) {
            return _reject(globalVersion);
        }
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) {
            return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor &&
                ownVersionParsed.patch <= globalVersionParsed.patch) {
                return _accept(globalVersion);
            }
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
            return _accept(globalVersion);
        }
        return _reject(globalVersion);
    };
}
/**
 * Test an API version to see if it is compatible with this API.
 *
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param version version of the API requesting an instance of the global API
 */
var isCompatible = _makeCompatibilityCheck(VERSION$3);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var major = VERSION$3.split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis$1;
function registerGlobal(type, instance, diag, allowOverride) {
    var _a;
    if (allowOverride === undefined) { allowOverride = false; }
    var api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== undefined ? _a : {
        version: VERSION$3,
    });
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        diag.error(err.stack || err.message);
        return false;
    }
    if (api.version !== VERSION$3) {
        // All registered APIs must be of the same version exactly
        var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION$3);
        diag.error(err.stack || err.message);
        return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION$3 + ".");
    return true;
}
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === undefined ? undefined : _a.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
        return;
    }
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === undefined ? undefined : _b[type];
}
function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION$3 + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
        delete api[type];
    }
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$e = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$6 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Component Logger which is meant to be used as part of any component which
 * will add automatically additional namespace in front of the log message.
 * It will then forward all message to global diag logger
 * @example
 * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });
 * cLogger.debug('test');
 * // @opentelemetry/instrumentation-http test
 */
var DiagComponentLogger = /** @class */ (function () {
    function DiagComponentLogger(props) {
        this._namespace = props.namespace || 'DiagComponentLogger';
    }
    DiagComponentLogger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('debug', this._namespace, args);
    };
    DiagComponentLogger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('error', this._namespace, args);
    };
    DiagComponentLogger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('info', this._namespace, args);
    };
    DiagComponentLogger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('warn', this._namespace, args);
    };
    DiagComponentLogger.prototype.verbose = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return logProxy('verbose', this._namespace, args);
    };
    return DiagComponentLogger;
}());
function logProxy(funcName, namespace, args) {
    var logger = getGlobal('diag');
    // shortcut if logger not set
    if (!logger) {
        return;
    }
    args.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray$6([], __read$e(args), false));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */
var DiagLogLevel;
(function (DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */
    DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */
    DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */
    DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */
    DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */
    DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */
    DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */
    DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
        maxLevel = DiagLogLevel.NONE;
    }
    else if (maxLevel > DiagLogLevel.ALL) {
        maxLevel = DiagLogLevel.ALL;
    }
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) {
            return theFunc.bind(logger);
        }
        return function () { };
    }
    return {
        error: _filterFunc('error', DiagLogLevel.ERROR),
        warn: _filterFunc('warn', DiagLogLevel.WARN),
        info: _filterFunc('info', DiagLogLevel.INFO),
        debug: _filterFunc('debug', DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$d = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$5 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$4 = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */
var DiagAPI = /** @class */ (function () {
    /**
     * Private internal constructor
     * @private
     */
    function DiagAPI() {
        function _logProxy(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var logger = getGlobal('diag');
                // shortcut if logger not set
                if (!logger)
                    return;
                return logger[funcName].apply(logger, __spreadArray$5([], __read$d(args), false));
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        var setLogger = function (logger, optionsOrLogLevel) {
            var _a, _b, _c;
            if (optionsOrLogLevel === undefined) { optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }; }
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== undefined ? _a : err.message);
                return false;
            }
            if (typeof optionsOrLogLevel === 'number') {
                optionsOrLogLevel = {
                    logLevel: optionsOrLogLevel,
                };
            }
            var oldLogger = getGlobal('diag');
            var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== undefined ? _b : DiagLogLevel.INFO, logger);
            // There already is an logger registered. We'll let it know before overwriting it.
            if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
                var stack = (_c = new Error().stack) !== null && _c !== undefined ? _c : '<failed to generate stacktrace>';
                oldLogger.warn("Current logger will be overwritten from " + stack);
                newLogger.warn("Current logger will overwrite one already registered from " + stack);
            }
            return registerGlobal('diag', newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function () {
            unregisterGlobal(API_NAME$4, self);
        };
        self.createComponentLogger = function (options) {
            return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */
    DiagAPI.instance = function () {
        if (!this._instance) {
            this._instance = new DiagAPI();
        }
        return this._instance;
    };
    return DiagAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$c = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values$8 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = /** @class */ (function () {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function (key) {
        var entry = this._entries.get(key);
        if (!entry) {
            return undefined;
        }
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function () {
        return Array.from(this._entries.entries()).map(function (_a) {
            var _b = __read$c(_a, 2), k = _b[0], v = _b[1];
            return [k, v];
        });
    };
    BaggageImpl.prototype.setEntry = function (key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function (key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function () {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl(this._entries);
        try {
            for (var keys_1 = __values$8(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                newBaggage._entries.delete(key);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function () {
        return new BaggageImpl();
    };
    return BaggageImpl;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Symbol used to make BaggageEntryMetadata an opaque type
 */
var baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var diag$1 = DiagAPI.instance();
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */
function createBaggage(entries) {
    if (entries === undefined) { entries = {}; }
    return new BaggageImpl(new Map(Object.entries(entries)));
}
/**
 * Create a serializable BaggageEntryMetadata object from a string.
 *
 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
 *
 */
function baggageEntryMetadataFromString(str) {
    if (typeof str !== 'string') {
        diag$1.error("Cannot create baggage metadata from unknown type: " + typeof str);
        str = '';
    }
    return {
        __TYPE__: baggageEntryMetadataSymbol,
        toString: function () {
            return str;
        },
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Get a key to uniquely identify a context value */
function createContextKey(description) {
    // The specification states that for the same input, multiple calls should
    // return different keys. Due to the nature of the JS dependency management
    // system, this creates problems where multiple versions of some package
    // could hold different keys for the same property.
    //
    // Therefore, we use Symbol.for which returns the same key for the same input.
    return Symbol.for(description);
}
var BaseContext = /** @class */ (function () {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */
    function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function (key) { return self._currentContext.get(key); };
        self.setValue = function (key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function (key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}());
/** The root context is used as the default parent context when there is no active context */
var ROOT_CONTEXT = new BaseContext();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var consoleMap = [
    { n: 'error', c: 'error' },
    { n: 'warn', c: 'warn' },
    { n: 'info', c: 'info' },
    { n: 'debug', c: 'debug' },
    { n: 'verbose', c: 'trace' },
];
/**
 * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
 * If you want to limit the amount of logging to a specific level or lower use the
 * {@link createLogLevelDiagLogger}
 */
var DiagConsoleLogger = /** @class */ (function () {
    function DiagConsoleLogger() {
        function _consoleFunc(funcName) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (console) {
                    // Some environments only expose the console when the F12 developer console is open
                    // eslint-disable-next-line no-console
                    var theFunc = console[funcName];
                    if (typeof theFunc !== 'function') {
                        // Not all environments support all functions
                        // eslint-disable-next-line no-console
                        theFunc = console.log;
                    }
                    // One last final check
                    if (typeof theFunc === 'function') {
                        return theFunc.apply(console, args);
                    }
                }
            };
        }
        for (var i = 0; i < consoleMap.length; i++) {
            this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
    }
    return DiagConsoleLogger;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */
var NoopMeter = /** @class */ (function () {
    function NoopMeter() {
    }
    /**
     * @see {@link Meter.createGauge}
     */
    NoopMeter.prototype.createGauge = function (_name, _options) {
        return NOOP_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createHistogram}
     */
    NoopMeter.prototype.createHistogram = function (_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
    };
    /**
     * @see {@link Meter.createCounter}
     */
    NoopMeter.prototype.createCounter = function (_name, _options) {
        return NOOP_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createUpDownCounter}
     */
    NoopMeter.prototype.createUpDownCounter = function (_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableGauge}
     */
    NoopMeter.prototype.createObservableGauge = function (_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    /**
     * @see {@link Meter.createObservableCounter}
     */
    NoopMeter.prototype.createObservableCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.createObservableUpDownCounter}
     */
    NoopMeter.prototype.createObservableUpDownCounter = function (_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    /**
     * @see {@link Meter.addBatchObservableCallback}
     */
    NoopMeter.prototype.addBatchObservableCallback = function (_callback, _observables) { };
    /**
     * @see {@link Meter.removeBatchObservableCallback}
     */
    NoopMeter.prototype.removeBatchObservableCallback = function (_callback) { };
    return NoopMeter;
}());
var NoopMetric = /** @class */ (function () {
    function NoopMetric() {
    }
    return NoopMetric;
}());
var NoopCounterMetric = /** @class */ (function (_super) {
    __extends$5(NoopCounterMetric, _super);
    function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopCounterMetric;
}(NoopMetric));
var NoopUpDownCounterMetric = /** @class */ (function (_super) {
    __extends$5(NoopUpDownCounterMetric, _super);
    function NoopUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric.prototype.add = function (_value, _attributes) { };
    return NoopUpDownCounterMetric;
}(NoopMetric));
var NoopGaugeMetric = /** @class */ (function (_super) {
    __extends$5(NoopGaugeMetric, _super);
    function NoopGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopGaugeMetric.prototype.record = function (_value, _attributes) { };
    return NoopGaugeMetric;
}(NoopMetric));
var NoopHistogramMetric = /** @class */ (function (_super) {
    __extends$5(NoopHistogramMetric, _super);
    function NoopHistogramMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric.prototype.record = function (_value, _attributes) { };
    return NoopHistogramMetric;
}(NoopMetric));
var NoopObservableMetric = /** @class */ (function () {
    function NoopObservableMetric() {
    }
    NoopObservableMetric.prototype.addCallback = function (_callback) { };
    NoopObservableMetric.prototype.removeCallback = function (_callback) { };
    return NoopObservableMetric;
}());
var NoopObservableCounterMetric = /** @class */ (function (_super) {
    __extends$5(NoopObservableCounterMetric, _super);
    function NoopObservableCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric;
}(NoopObservableMetric));
var NoopObservableGaugeMetric = /** @class */ (function (_super) {
    __extends$5(NoopObservableGaugeMetric, _super);
    function NoopObservableGaugeMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric;
}(NoopObservableMetric));
var NoopObservableUpDownCounterMetric = /** @class */ (function (_super) {
    __extends$5(NoopObservableUpDownCounterMetric, _super);
    function NoopObservableUpDownCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric;
}(NoopObservableMetric));
var NOOP_METER = new NoopMeter();
// Synchronous instruments
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_GAUGE_METRIC = new NoopGaugeMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
// Asynchronous instruments
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
/**
 * Create a no-op Meter
 */
function createNoopMeter() {
    return NOOP_METER;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The Type of value. It describes how the data is reported. */
var ValueType;
(function (ValueType) {
    ValueType[ValueType["INT"] = 0] = "INT";
    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(ValueType || (ValueType = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var defaultTextMapGetter = {
    get: function (carrier, key) {
        if (carrier == null) {
            return undefined;
        }
        return carrier[key];
    },
    keys: function (carrier) {
        if (carrier == null) {
            return [];
        }
        return Object.keys(carrier);
    },
};
var defaultTextMapSetter = {
    set: function (carrier, key, value) {
        if (carrier == null) {
            return;
        }
        carrier[key] = value;
    },
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$b = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$4 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = /** @class */ (function () {
    function NoopContextManager() {
    }
    NoopContextManager.prototype.active = function () {
        return ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function (_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray$4([thisArg], __read$b(args), false));
    };
    NoopContextManager.prototype.bind = function (_context, target) {
        return target;
    };
    NoopContextManager.prototype.enable = function () {
        return this;
    };
    NoopContextManager.prototype.disable = function () {
        return this;
    };
    return NoopContextManager;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$a = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$3 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME$3 = 'context';
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */
var ContextAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function ContextAPI() {
    }
    /** Get the singleton instance of the Context API */
    ContextAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new ContextAPI();
        }
        return this._instance;
    };
    /**
     * Set the current context manager.
     *
     * @returns true if the context manager was successfully registered, else false
     */
    ContextAPI.prototype.setGlobalContextManager = function (contextManager) {
        return registerGlobal(API_NAME$3, contextManager, DiagAPI.instance());
    };
    /**
     * Get the currently active context
     */
    ContextAPI.prototype.active = function () {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */
    ContextAPI.prototype.with = function (context, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray$3([context, fn, thisArg], __read$a(args), false));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     * @param target function or event emitter to bind
     */
    ContextAPI.prototype.bind = function (context, target) {
        return this._getContextManager().bind(context, target);
    };
    ContextAPI.prototype._getContextManager = function () {
        return getGlobal(API_NAME$3) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */
    ContextAPI.prototype.disable = function () {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$3, DiagAPI.instance());
    };
    return ContextAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TraceFlags;
(function (TraceFlags) {
    /** Represents no flag set. */
    TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */
    TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var INVALID_SPANID = '0000000000000000';
var INVALID_TRACEID = '00000000000000000000000000000000';
var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE,
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The NonRecordingSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */
var NonRecordingSpan = /** @class */ (function () {
    function NonRecordingSpan(_spanContext) {
        if (_spanContext === undefined) { _spanContext = INVALID_SPAN_CONTEXT; }
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NonRecordingSpan.prototype.spanContext = function () {
        return this._spanContext;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttribute = function (_key, _value) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setAttributes = function (_attributes) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.addEvent = function (_name, _attributes) {
        return this;
    };
    NonRecordingSpan.prototype.addLink = function (_link) {
        return this;
    };
    NonRecordingSpan.prototype.addLinks = function (_links) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.setStatus = function (_status) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.updateName = function (_name) {
        return this;
    };
    // By default does nothing
    NonRecordingSpan.prototype.end = function (_endTime) { };
    // isRecording always returns false for NonRecordingSpan.
    NonRecordingSpan.prototype.isRecording = function () {
        return false;
    };
    // By default does nothing
    NonRecordingSpan.prototype.recordException = function (_exception, _time) { };
    return NonRecordingSpan;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * span key
 */
var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */
function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
/**
 * Gets the span from the current context, if one exists.
 */
function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
}
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */
function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
/**
 * Remove current span stored in the context
 *
 * @param context context to delete span from
 */
function deleteSpan(context) {
    return context.deleteValue(SPAN_KEY);
}
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */
function setSpanContext(context, spanContext) {
    return setSpan(context, new NonRecordingSpan(spanContext));
}
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */
function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === undefined ? undefined : _a.spanContext();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */
function isSpanContextValid(spanContext) {
    return (isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId));
}
/**
 * Wrap the given {@link SpanContext} in a new non-recording {@link Span}
 *
 * @param spanContext span context to be wrapped
 * @returns a new non-recording {@link Span} with the provided context
 */
function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var contextApi = ContextAPI.getInstance();
/**
 * No-op implementations of {@link Tracer}.
 */
var NoopTracer = /** @class */ (function () {
    function NoopTracer() {
    }
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function (name, options, context) {
        if (context === undefined) { context = contextApi.active(); }
        var root = Boolean(options === null || options === undefined ? undefined : options.root);
        if (root) {
            return new NonRecordingSpan();
        }
        var parentFromContext = context && getSpanContext(context);
        if (isSpanContext(parentFromContext) &&
            isSpanContextValid(parentFromContext)) {
            return new NonRecordingSpan(parentFromContext);
        }
        else {
            return new NonRecordingSpan();
        }
    };
    NoopTracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== undefined ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, undefined, span);
    };
    return NoopTracer;
}());
function isSpanContext(spanContext) {
    return (typeof spanContext === 'object' &&
        typeof spanContext['spanId'] === 'string' &&
        typeof spanContext['traceId'] === 'string' &&
        typeof spanContext['traceFlags'] === 'number');
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER = new NoopTracer();
/**
 * Proxy tracer provided by the proxy tracer provider
 */
var ProxyTracer = /** @class */ (function () {
    function ProxyTracer(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
    }
    ProxyTracer.prototype.startSpan = function (name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    ProxyTracer.prototype.startActiveSpan = function (_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */
    ProxyTracer.prototype._getTracer = function () {
        if (this._delegate) {
            return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
            return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */
var NoopTracerProvider = /** @class */ (function () {
    function NoopTracerProvider() {
    }
    NoopTracerProvider.prototype.getTracer = function (_name, _version, _options) {
        return new NoopTracer();
    };
    return NoopTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */
var ProxyTracerProvider = /** @class */ (function () {
    function ProxyTracerProvider() {
    }
    /**
     * Get a {@link ProxyTracer}
     */
    ProxyTracerProvider.prototype.getTracer = function (name, version, options) {
        var _a;
        return ((_a = this.getDelegateTracer(name, version, options)) !== null && _a !== undefined ? _a : new ProxyTracer(this, name, version, options));
    };
    ProxyTracerProvider.prototype.getDelegate = function () {
        var _a;
        return (_a = this._delegate) !== null && _a !== undefined ? _a : NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */
    ProxyTracerProvider.prototype.setDelegate = function (delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function (name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === undefined ? undefined : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated use the one declared in @opentelemetry/sdk-trace-base instead.
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var SamplingDecision$1;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision$1 || (SamplingDecision$1 = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SpanKind;
(function (SpanKind) {
    /** Default value. Indicates that the span is used internally. */
    SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */
    SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */
    SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */
    SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

/**
 * An enumeration of status codes.
 */
var SpanStatusCode;
(function (SpanStatusCode) {
    /**
     * The default status.
     */
    SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */
    SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */
    SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_KEY_CHAR_RANGE$1 = '[_0-9a-z-*/]';
var VALID_KEY$1 = "[a-z]" + VALID_KEY_CHAR_RANGE$1 + "{0,255}";
var VALID_VENDOR_KEY$1 = "[a-z0-9]" + VALID_KEY_CHAR_RANGE$1 + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE$1 + "{0,13}";
var VALID_KEY_REGEX$1 = new RegExp("^(?:" + VALID_KEY$1 + "|" + VALID_VENDOR_KEY$1 + ")$");
var VALID_VALUE_BASE_REGEX$1 = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX$1 = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function validateKey$1(key) {
    return VALID_KEY_REGEX$1.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function validateValue$1(value) {
    return (VALID_VALUE_BASE_REGEX$1.test(value) &&
        !INVALID_VALUE_COMMA_EQUAL_REGEX$1.test(value));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MAX_TRACE_STATE_ITEMS$1 = 32;
var MAX_TRACE_STATE_LEN$1 = 512;
var LIST_MEMBERS_SEPARATOR$1 = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER$1 = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var TraceStateImpl = /** @class */ (function () {
    function TraceStateImpl(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceStateImpl.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceStateImpl.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceStateImpl.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceStateImpl.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER$1 + _this.get(key));
            return agg;
        }, [])
            .join(LIST_MEMBERS_SEPARATOR$1);
    };
    TraceStateImpl.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN$1)
            return;
        this._internalState = rawTraceState
            .split(LIST_MEMBERS_SEPARATOR$1)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER$1);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (validateKey$1(key) && validateValue$1(value)) {
                    agg.set(key, value);
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS$1) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, MAX_TRACE_STATE_ITEMS$1));
        }
    };
    TraceStateImpl.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceStateImpl.prototype._clone = function () {
        var traceState = new TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceStateImpl;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createTraceState(rawTraceState) {
    return new TraceStateImpl(rawTraceState);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for context API */
var context = ContextAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/**
 * Entrypoint for Diag API.
 * Defines Diagnostic handler used for internal diagnostic logging operations.
 * The default provides a Noop DiagLogger implementation which may be changed via the
 * diag.setLogger(logger: DiagLogger) function.
 */
var diag = DiagAPI.instance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */
var NoopMeterProvider = /** @class */ (function () {
    function NoopMeterProvider() {
    }
    NoopMeterProvider.prototype.getMeter = function (_name, _version, _options) {
        return NOOP_METER;
    };
    return NoopMeterProvider;
}());
var NOOP_METER_PROVIDER = new NoopMeterProvider();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$2 = 'metrics';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */
var MetricsAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function MetricsAPI() {
    }
    /** Get the singleton instance of the Metrics API */
    MetricsAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new MetricsAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global meter provider.
     * Returns true if the meter provider was successfully registered, else false.
     */
    MetricsAPI.prototype.setGlobalMeterProvider = function (provider) {
        return registerGlobal(API_NAME$2, provider, DiagAPI.instance());
    };
    /**
     * Returns the global meter provider.
     */
    MetricsAPI.prototype.getMeterProvider = function () {
        return getGlobal(API_NAME$2) || NOOP_METER_PROVIDER;
    };
    /**
     * Returns a meter from the global meter provider.
     */
    MetricsAPI.prototype.getMeter = function (name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
    };
    /** Remove the global meter provider */
    MetricsAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$2, DiagAPI.instance());
    };
    return MetricsAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for metrics API */
var metrics = MetricsAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * No-op implementations of {@link TextMapPropagator}.
 */
var NoopTextMapPropagator = /** @class */ (function () {
    function NoopTextMapPropagator() {
    }
    /** Noop inject function does nothing */
    NoopTextMapPropagator.prototype.inject = function (_context, _carrier) { };
    /** Noop extract function does nothing and returns the input context */
    NoopTextMapPropagator.prototype.extract = function (context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function () {
        return [];
    };
    return NoopTextMapPropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Baggage key
 */
var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
/**
 * Retrieve the current baggage from the given context
 *
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */
function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
/**
 * Retrieve the current baggage from the active/current context
 *
 * @returns {Baggage} Extracted baggage from the context
 */
function getActiveBaggage() {
    return getBaggage(ContextAPI.getInstance().active());
}
/**
 * Store a baggage in the given context
 *
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */
function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
/**
 * Delete the baggage stored in the given context
 *
 * @param {Context} Context that manage all context values
 */
function deleteBaggage(context) {
    return context.deleteValue(BAGGAGE_KEY);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME$1 = 'propagation';
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */
var PropagationAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function PropagationAPI() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
    }
    /** Get the singleton instance of the Propagator API */
    PropagationAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new PropagationAPI();
        }
        return this._instance;
    };
    /**
     * Set the current propagator.
     *
     * @returns true if the propagator was successfully registered, else false
     */
    PropagationAPI.prototype.setGlobalPropagator = function (propagator) {
        return registerGlobal(API_NAME$1, propagator, DiagAPI.instance());
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */
    PropagationAPI.prototype.inject = function (context, carrier, setter) {
        if (setter === undefined) { setter = defaultTextMapSetter; }
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */
    PropagationAPI.prototype.extract = function (context, carrier, getter) {
        if (getter === undefined) { getter = defaultTextMapGetter; }
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */
    PropagationAPI.prototype.fields = function () {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */
    PropagationAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
    };
    PropagationAPI.prototype._getGlobalPropagator = function () {
        return getGlobal(API_NAME$1) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for propagation API */
var propagation = PropagationAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var API_NAME = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */
var TraceAPI = /** @class */ (function () {
    /** Empty private constructor prevents end users from constructing a new instance of the API */
    function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
    }
    /** Get the singleton instance of the Trace API */
    TraceAPI.getInstance = function () {
        if (!this._instance) {
            this._instance = new TraceAPI();
        }
        return this._instance;
    };
    /**
     * Set the current global tracer.
     *
     * @returns true if the tracer provider was successfully registered, else false
     */
    TraceAPI.prototype.setGlobalTracerProvider = function (provider) {
        var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
            this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
    };
    /**
     * Returns the global tracer provider.
     */
    TraceAPI.prototype.getTracerProvider = function () {
        return getGlobal(API_NAME) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */
    TraceAPI.prototype.getTracer = function (name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */
    TraceAPI.prototype.disable = function () {
        unregisterGlobal(API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Split module-level variable definition into separate files to allow
// tree-shaking on each api instance.
/** Entrypoint for trace API */
var trace = TraceAPI.getInstance();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Default export.
var index = {
    context: context,
    diag: diag,
    metrics: metrics,
    propagation: propagation,
    trace: trace,
};

var esm$4 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DiagConsoleLogger: DiagConsoleLogger,
	get DiagLogLevel () { return DiagLogLevel; },
	INVALID_SPANID: INVALID_SPANID,
	INVALID_SPAN_CONTEXT: INVALID_SPAN_CONTEXT,
	INVALID_TRACEID: INVALID_TRACEID,
	ProxyTracer: ProxyTracer,
	ProxyTracerProvider: ProxyTracerProvider,
	ROOT_CONTEXT: ROOT_CONTEXT,
	get SamplingDecision () { return SamplingDecision$1; },
	get SpanKind () { return SpanKind; },
	get SpanStatusCode () { return SpanStatusCode; },
	get TraceFlags () { return TraceFlags; },
	get ValueType () { return ValueType; },
	baggageEntryMetadataFromString: baggageEntryMetadataFromString,
	context: context,
	createContextKey: createContextKey,
	createNoopMeter: createNoopMeter,
	createTraceState: createTraceState,
	default: index,
	defaultTextMapGetter: defaultTextMapGetter,
	defaultTextMapSetter: defaultTextMapSetter,
	diag: diag,
	isSpanContextValid: isSpanContextValid,
	isValidSpanId: isValidSpanId,
	isValidTraceId: isValidTraceId,
	metrics: metrics,
	propagation: propagation,
	trace: trace
});

async function traceStep(step) {
    const tracer = trace.getTracer("otel-cicd-action");
    if (!step.completed_at || !step.started_at) {
        coreExports.info(`Step ${step.name} is not completed yet.`);
        return;
    }
    if (step.conclusion === "skipped") {
        coreExports.info(`Step ${step.name} did not run.`);
        return;
    }
    const startTime = new Date(step.started_at);
    const completedTime = new Date(step.completed_at);
    const attributes = stepToAttributes(step);
    await tracer.startActiveSpan(step.name, { attributes, startTime }, async (span) => {
        const code = step.conclusion === "failure" ? SpanStatusCode.ERROR : SpanStatusCode.OK;
        span.setStatus({ code });
        // Some skipped and post jobs return completed_at dates that are older than started_at
        span.end(new Date(Math.max(startTime.getTime(), completedTime.getTime())));
    });
}
function stepToAttributes(step) {
    return {
        "github.job.step.status": step.status,
        "github.job.step.conclusion": step.conclusion ?? undefined,
        "github.job.step.name": step.name,
        "github.job.step.number": step.number,
        "github.job.step.started_at": step.started_at ?? undefined,
        "github.job.step.completed_at": step.completed_at ?? undefined,
        error: step.conclusion === "failure",
    };
}

async function traceJob(job, annotations) {
    const tracer = trace.getTracer("otel-cicd-action");
    if (!job.completed_at) {
        coreExports.info(`Job ${job.id} is not completed yet`);
        return;
    }
    const startTime = new Date(job.started_at);
    const completedTime = new Date(job.completed_at);
    const attributes = {
        ...jobToAttributes(job),
        ...annotationsToAttributes(annotations),
    };
    await tracer.startActiveSpan(job.name, { attributes, startTime }, async (span) => {
        const code = job.conclusion === "failure" ? SpanStatusCode.ERROR : SpanStatusCode.OK;
        span.setStatus({ code });
        for (const step of job.steps ?? []) {
            await traceStep(step);
        }
        // Some skipped and post jobs return completed_at dates that are older than started_at
        span.end(new Date(Math.max(startTime.getTime(), completedTime.getTime())));
    });
}
function jobToAttributes(job) {
    // Heuristic for task type
    let taskType;
    if (job.name.toLowerCase().includes("build")) {
        taskType = CICD_PIPELINE_TASK_TYPE_VALUE_BUILD;
    }
    else if (job.name.toLowerCase().includes("test")) {
        taskType = CICD_PIPELINE_TASK_TYPE_VALUE_TEST;
    }
    else if (job.name.toLowerCase().includes("deploy")) {
        taskType = CICD_PIPELINE_TASK_TYPE_VALUE_DEPLOY;
    }
    return {
        // OpenTelemetry semantic convention CICD Pipeline Attributes
        // https://opentelemetry.io/docs/specs/semconv/attributes-registry/cicd/
        [ATTR_CICD_PIPELINE_TASK_NAME]: job.name,
        [ATTR_CICD_PIPELINE_TASK_RUN_ID]: job.id,
        [ATTR_CICD_PIPELINE_TASK_RUN_URL_FULL]: job.html_url ?? undefined,
        [ATTR_CICD_PIPELINE_TASK_TYPE]: taskType,
        "github.job.id": job.id,
        "github.job.name": job.name,
        "github.job.run_id": job.run_id,
        "github.job.run_url": job.run_url,
        "github.job.run_attempt": job.run_attempt ?? 1,
        "github.job.node_id": job.node_id,
        "github.job.head_sha": job.head_sha,
        "github.job.url": job.url,
        "github.job.html_url": job.html_url ?? undefined,
        "github.job.status": job.status,
        "github.job.runner_id": job.runner_id ?? undefined,
        "github.job.runner_group_id": job.runner_group_id ?? undefined,
        "github.job.runner_group_name": job.runner_group_name ?? undefined,
        "github.job.runner_name": job.runner_name ?? undefined,
        "github.job.conclusion": job.conclusion ?? undefined,
        "github.job.labels": job.labels.join(", "),
        "github.job.created_at": job.created_at,
        "github.job.started_at": job.started_at,
        "github.job.completed_at": job.completed_at ?? undefined,
        "github.conclusion": job.conclusion ?? undefined, // FIXME: it overrides the workflow conclusion
        "github.job.check_run_url": job.check_run_url,
        "github.job.workflow_name": job.workflow_name ?? undefined,
        "github.job.head_branch": job.head_branch ?? undefined,
        error: job.conclusion === "failure",
    };
}
function annotationsToAttributes(annotations) {
    const attributes = {};
    for (let i = 0; annotations && i < annotations.length; i++) {
        const annotation = annotations[i];
        const prefix = `github.job.annotations.${i}`;
        attributes[`${prefix}.level`] = annotation.annotation_level ?? undefined;
        attributes[`${prefix}.message`] = annotation.message ?? undefined;
    }
    return attributes;
}

async function traceWorkflowRun(workflowRun, jobs, jobAnnotations, prLabels) {
    const tracer = trace.getTracer("otel-cicd-action");
    const startTime = new Date(workflowRun.run_started_at ?? workflowRun.created_at);
    const attributes = workflowRunToAttributes(workflowRun, prLabels);
    return await tracer.startActiveSpan(workflowRun.name ?? workflowRun.display_title, { attributes, root: true, startTime }, async (rootSpan) => {
        const code = workflowRun.conclusion === "failure" ? SpanStatusCode.ERROR : SpanStatusCode.OK;
        rootSpan.setStatus({ code });
        if (jobs.length > 0) {
            // "Queued" span represent the time between the workflow has been started_at and
            // the first job has been picked up by a runner
            const queuedSpan = tracer.startSpan("Queued", { startTime }, context.active());
            queuedSpan.end(new Date(jobs[0].started_at));
        }
        for (const job of jobs) {
            await traceJob(job, jobAnnotations[job.id]);
        }
        rootSpan.end(new Date(workflowRun.updated_at));
        return rootSpan.spanContext().traceId;
    });
}
function workflowRunToAttributes(workflowRun, prLabels) {
    return {
        // OpenTelemetry semantic convention CICD Pipeline Attributes
        // https://opentelemetry.io/docs/specs/semconv/attributes-registry/cicd/
        [ATTR_CICD_PIPELINE_NAME]: workflowRun.name ?? undefined,
        [ATTR_CICD_PIPELINE_RUN_ID]: workflowRun.id,
        "github.workflow_id": workflowRun.workflow_id,
        "github.run_id": workflowRun.id,
        "github.run_number": workflowRun.run_number,
        "github.run_attempt": workflowRun.run_attempt ?? 1,
        ...referencedWorkflowsToAttributes(workflowRun.referenced_workflows),
        "github.url": workflowRun.url,
        "github.html_url": workflowRun.html_url,
        "github.workflow_url": workflowRun.workflow_url,
        "github.event": workflowRun.event,
        "github.status": workflowRun.status ?? undefined,
        "github.workflow": workflowRun.name ?? undefined,
        "github.node_id": workflowRun.node_id,
        "github.check_suite_id": workflowRun.check_suite_id,
        "github.check_suite_node_id": workflowRun.check_suite_node_id,
        "github.conclusion": workflowRun.conclusion ?? undefined,
        "github.created_at": workflowRun.created_at,
        "github.updated_at": workflowRun.updated_at,
        "github.run_started_at": workflowRun.run_started_at,
        "github.jobs_url": workflowRun.jobs_url,
        "github.logs_url": workflowRun.logs_url,
        "github.check_suite_url": workflowRun.check_suite_url,
        "github.artifacts_url": workflowRun.artifacts_url,
        "github.cancel_url": workflowRun.cancel_url,
        "github.rerun_url": workflowRun.rerun_url,
        "github.previous_attempt_url": workflowRun.previous_attempt_url ?? undefined,
        ...headCommitToAttributes(workflowRun.head_commit),
        "github.head_branch": workflowRun.head_branch ?? undefined,
        "github.head_sha": workflowRun.head_sha,
        "github.path": workflowRun.path,
        "github.display_title": workflowRun.display_title,
        error: workflowRun.conclusion === "failure",
        ...prsToAttributes(workflowRun.pull_requests, prLabels),
    };
}
function referencedWorkflowsToAttributes(refs) {
    const attributes = {};
    for (let i = 0; refs && i < refs.length; i++) {
        const ref = refs[i];
        const prefix = `github.referenced_workflows.${i}`;
        attributes[`${prefix}.path`] = ref.path;
        attributes[`${prefix}.sha`] = ref.sha;
        attributes[`${prefix}.ref`] = ref.ref;
    }
    return attributes;
}
function headCommitToAttributes(head_commit) {
    return {
        "github.head_commit.id": head_commit?.id,
        "github.head_commit.tree_id": head_commit?.tree_id,
        "github.head_commit.author.name": head_commit?.author?.name,
        "github.head_commit.author.email": head_commit?.author?.email,
        "github.head_commit.committer.name": head_commit?.committer?.name,
        "github.head_commit.committer.email": head_commit?.committer?.email,
        "github.head_commit.message": head_commit?.message,
        "github.head_commit.timestamp": head_commit?.timestamp,
    };
}
function prsToAttributes(pullRequests, prLabels) {
    const attributes = {
        "github.head_ref": pullRequests?.[0]?.head?.ref,
        "github.base_ref": pullRequests?.[0]?.base?.ref,
        "github.base_sha": pullRequests?.[0]?.base?.sha,
    };
    for (let i = 0; pullRequests && i < pullRequests.length; i++) {
        const pr = pullRequests[i];
        const prefix = `github.pull_requests.${i}`;
        attributes[`${prefix}.id`] = pr.id;
        attributes[`${prefix}.url`] = pr.url;
        attributes[`${prefix}.number`] = pr.number;
        attributes[`${prefix}.labels`] = prLabels[pr.number];
        attributes[`${prefix}.head.sha`] = pr.head.sha;
        attributes[`${prefix}.head.ref`] = pr.head.ref;
        attributes[`${prefix}.head.repo.id`] = pr.head.repo.id;
        attributes[`${prefix}.head.repo.url`] = pr.head.repo.url;
        attributes[`${prefix}.head.repo.name`] = pr.head.repo.name;
        attributes[`${prefix}.base.ref`] = pr.base.ref;
        attributes[`${prefix}.base.sha`] = pr.base.sha;
        attributes[`${prefix}.base.repo.id`] = pr.base.repo.id;
        attributes[`${prefix}.base.repo.url`] = pr.base.repo.url;
        attributes[`${prefix}.base.repo.name`] = pr.base.repo.name;
    }
    return attributes;
}

var src$5 = {};

var callCredentials = {};

var metadata = {};

var logging = {};

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = constants.DEFAULT_MAX_SEND_MESSAGE_LENGTH = constants.Propagate = constants.LogVerbosity = constants.Status = undefined;
	var Status;
	(function (Status) {
	    Status[Status["OK"] = 0] = "OK";
	    Status[Status["CANCELLED"] = 1] = "CANCELLED";
	    Status[Status["UNKNOWN"] = 2] = "UNKNOWN";
	    Status[Status["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
	    Status[Status["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
	    Status[Status["NOT_FOUND"] = 5] = "NOT_FOUND";
	    Status[Status["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
	    Status[Status["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
	    Status[Status["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
	    Status[Status["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
	    Status[Status["ABORTED"] = 10] = "ABORTED";
	    Status[Status["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
	    Status[Status["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
	    Status[Status["INTERNAL"] = 13] = "INTERNAL";
	    Status[Status["UNAVAILABLE"] = 14] = "UNAVAILABLE";
	    Status[Status["DATA_LOSS"] = 15] = "DATA_LOSS";
	    Status[Status["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
	})(Status || (constants.Status = Status = {}));
	var LogVerbosity;
	(function (LogVerbosity) {
	    LogVerbosity[LogVerbosity["DEBUG"] = 0] = "DEBUG";
	    LogVerbosity[LogVerbosity["INFO"] = 1] = "INFO";
	    LogVerbosity[LogVerbosity["ERROR"] = 2] = "ERROR";
	    LogVerbosity[LogVerbosity["NONE"] = 3] = "NONE";
	})(LogVerbosity || (constants.LogVerbosity = LogVerbosity = {}));
	/**
	 * NOTE: This enum is not currently used in any implemented API in this
	 * library. It is included only for type parity with the other implementation.
	 */
	var Propagate;
	(function (Propagate) {
	    Propagate[Propagate["DEADLINE"] = 1] = "DEADLINE";
	    Propagate[Propagate["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
	    Propagate[Propagate["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
	    Propagate[Propagate["CANCELLATION"] = 8] = "CANCELLATION";
	    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43
	    Propagate[Propagate["DEFAULTS"] = 65535] = "DEFAULTS";
	})(Propagate || (constants.Propagate = Propagate = {}));
	// -1 means unlimited
	constants.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
	// 4 MB default
	constants.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
	
	return constants;
}

var name = "@grpc/grpc-js";
var version$1 = "1.12.5";
var description = "gRPC Library for Node - pure JS implementation";
var homepage = "https://grpc.io/";
var repository = "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js";
var main = "build/src/index.js";
var engines = {
	node: ">=12.10.0"
};
var keywords = [
];
var author = {
	name: "Google Inc."
};
var types$1 = "build/src/index.d.ts";
var license = "Apache-2.0";
var devDependencies = {
	"@grpc/proto-loader": "file:../proto-loader",
	"@types/gulp": "^4.0.17",
	"@types/gulp-mocha": "0.0.37",
	"@types/lodash": "^4.14.202",
	"@types/mocha": "^10.0.6",
	"@types/ncp": "^2.0.8",
	"@types/node": ">=20.11.20",
	"@types/pify": "^5.0.4",
	"@types/semver": "^7.5.8",
	"@typescript-eslint/eslint-plugin": "^7.1.0",
	"@typescript-eslint/parser": "^7.1.0",
	"@typescript-eslint/typescript-estree": "^7.1.0",
	"clang-format": "^1.8.0",
	eslint: "^8.42.0",
	"eslint-config-prettier": "^8.8.0",
	"eslint-plugin-node": "^11.1.0",
	"eslint-plugin-prettier": "^4.2.1",
	execa: "^2.0.3",
	gulp: "^4.0.2",
	"gulp-mocha": "^6.0.0",
	lodash: "^4.17.21",
	madge: "^5.0.1",
	"mocha-jenkins-reporter": "^0.4.1",
	ncp: "^2.0.0",
	pify: "^4.0.1",
	prettier: "^2.8.8",
	rimraf: "^3.0.2",
	semver: "^7.6.0",
	"ts-node": "^10.9.2",
	typescript: "^5.3.3"
};
var contributors = [
	{
		name: "Google Inc."
	}
];
var scripts = {
	build: "npm run compile",
	clean: "rimraf ./build",
	compile: "tsc -p .",
	format: "clang-format -i -style=\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\" src/*.ts test/*.ts",
	lint: "eslint src/*.ts test/*.ts",
	prepare: "npm run generate-types && npm run compile",
	test: "gulp test",
	check: "npm run lint",
	fix: "eslint --fix src/*.ts test/*.ts",
	pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
	posttest: "npm run check && madge -c ./build/src",
	"generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
	"generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
};
var dependencies = {
	"@grpc/proto-loader": "^0.7.13",
	"@js-sdsl/ordered-map": "^4.4.2"
};
var files = [
	"src/**/*.ts",
	"build/src/**/*.{js,d.ts,js.map}",
	"proto/*.proto",
	"LICENSE",
	"deps/envoy-api/envoy/api/v2/**/*.proto",
	"deps/envoy-api/envoy/config/**/*.proto",
	"deps/envoy-api/envoy/service/**/*.proto",
	"deps/envoy-api/envoy/type/**/*.proto",
	"deps/udpa/udpa/**/*.proto",
	"deps/googleapis/google/api/*.proto",
	"deps/googleapis/google/rpc/*.proto",
	"deps/protoc-gen-validate/validate/**/*.proto"
];
var require$$12 = {
	name: name,
	version: version$1,
	description: description,
	homepage: homepage,
	repository: repository,
	main: main,
	engines: engines,
	keywords: keywords,
	author: author,
	types: types$1,
	license: license,
	devDependencies: devDependencies,
	contributors: contributors,
	scripts: scripts,
	dependencies: dependencies,
	files: files
};

var hasRequiredLogging;

function requireLogging () {
	if (hasRequiredLogging) return logging;
	hasRequiredLogging = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		var _a, _b, _c, _d;
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = undefined;
		const constants_1 = requireConstants();
		const process_1 = process$1;
		const clientVersion = require$$12.version;
		const DEFAULT_LOGGER = {
		    error: (message, ...optionalParams) => {
		        console.error('E ' + message, ...optionalParams);
		    },
		    info: (message, ...optionalParams) => {
		        console.error('I ' + message, ...optionalParams);
		    },
		    debug: (message, ...optionalParams) => {
		        console.error('D ' + message, ...optionalParams);
		    },
		};
		let _logger = DEFAULT_LOGGER;
		let _logVerbosity = constants_1.LogVerbosity.ERROR;
		const verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== undefined ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== undefined ? _b : '';
		switch (verbosityString.toUpperCase()) {
		    case 'DEBUG':
		        _logVerbosity = constants_1.LogVerbosity.DEBUG;
		        break;
		    case 'INFO':
		        _logVerbosity = constants_1.LogVerbosity.INFO;
		        break;
		    case 'ERROR':
		        _logVerbosity = constants_1.LogVerbosity.ERROR;
		        break;
		    case 'NONE':
		        _logVerbosity = constants_1.LogVerbosity.NONE;
		        break;
		    // Ignore any other values
		}
		const getLogger = () => {
		    return _logger;
		};
		exports.getLogger = getLogger;
		const setLogger = (logger) => {
		    _logger = logger;
		};
		exports.setLogger = setLogger;
		const setLoggerVerbosity = (verbosity) => {
		    _logVerbosity = verbosity;
		};
		exports.setLoggerVerbosity = setLoggerVerbosity;
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const log = (severity, ...args) => {
		    let logFunction;
		    if (severity >= _logVerbosity) {
		        switch (severity) {
		            case constants_1.LogVerbosity.DEBUG:
		                logFunction = _logger.debug;
		                break;
		            case constants_1.LogVerbosity.INFO:
		                logFunction = _logger.info;
		                break;
		            case constants_1.LogVerbosity.ERROR:
		                logFunction = _logger.error;
		                break;
		        }
		        /* Fall back to _logger.error when other methods are not available for
		         * compatiblity with older behavior that always logged to _logger.error */
		        if (!logFunction) {
		            logFunction = _logger.error;
		        }
		        if (logFunction) {
		            logFunction.bind(_logger)(...args);
		        }
		    }
		};
		exports.log = log;
		const tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== undefined ? _c : process.env.GRPC_TRACE) !== null && _d !== undefined ? _d : '';
		const enabledTracers = new Set();
		const disabledTracers = new Set();
		for (const tracerName of tracersString.split(',')) {
		    if (tracerName.startsWith('-')) {
		        disabledTracers.add(tracerName.substring(1));
		    }
		    else {
		        enabledTracers.add(tracerName);
		    }
		}
		const allEnabled = enabledTracers.has('all');
		function trace(severity, tracer, text) {
		    if (isTracerEnabled(tracer)) {
		        (0, exports.log)(severity, new Date().toISOString() +
		            ' | v' +
		            clientVersion +
		            ' ' +
		            process_1.pid +
		            ' | ' +
		            tracer +
		            ' | ' +
		            text);
		    }
		}
		exports.trace = trace;
		function isTracerEnabled(tracer) {
		    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));
		}
		exports.isTracerEnabled = isTracerEnabled;
		
	} (logging));
	return logging;
}

var error = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(error, "__esModule", { value: true });
	error.getErrorCode = error.getErrorMessage = undefined;
	function getErrorMessage(error) {
	    if (error instanceof Error) {
	        return error.message;
	    }
	    else {
	        return String(error);
	    }
	}
	error.getErrorMessage = getErrorMessage;
	function getErrorCode(error) {
	    if (typeof error === 'object' &&
	        error !== null &&
	        'code' in error &&
	        typeof error.code === 'number') {
	        return error.code;
	    }
	    else {
	        return null;
	    }
	}
	error.getErrorCode = getErrorCode;
	
	return error;
}

var hasRequiredMetadata;

function requireMetadata () {
	if (hasRequiredMetadata) return metadata;
	hasRequiredMetadata = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(metadata, "__esModule", { value: true });
	metadata.Metadata = undefined;
	const logging_1 = requireLogging();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	const LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
	const LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
	function isLegalKey(key) {
	    return LEGAL_KEY_REGEX.test(key);
	}
	function isLegalNonBinaryValue(value) {
	    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
	}
	function isBinaryKey(key) {
	    return key.endsWith('-bin');
	}
	function isCustomMetadata(key) {
	    return !key.startsWith('grpc-');
	}
	function normalizeKey(key) {
	    return key.toLowerCase();
	}
	function validate(key, value) {
	    if (!isLegalKey(key)) {
	        throw new Error('Metadata key "' + key + '" contains illegal characters');
	    }
	    if (value !== null && value !== undefined) {
	        if (isBinaryKey(key)) {
	            if (!Buffer.isBuffer(value)) {
	                throw new Error("keys that end with '-bin' must have Buffer values");
	            }
	        }
	        else {
	            if (Buffer.isBuffer(value)) {
	                throw new Error("keys that don't end with '-bin' must have String values");
	            }
	            if (!isLegalNonBinaryValue(value)) {
	                throw new Error('Metadata string value "' + value + '" contains illegal characters');
	            }
	        }
	    }
	}
	/**
	 * A class for storing metadata. Keys are normalized to lowercase ASCII.
	 */
	class Metadata {
	    constructor(options = {}) {
	        this.internalRepr = new Map();
	        this.options = options;
	    }
	    /**
	     * Sets the given value for the given key by replacing any other values
	     * associated with that key. Normalizes the key.
	     * @param key The key to whose value should be set.
	     * @param value The value to set. Must be a buffer if and only
	     *   if the normalized key ends with '-bin'.
	     */
	    set(key, value) {
	        key = normalizeKey(key);
	        validate(key, value);
	        this.internalRepr.set(key, [value]);
	    }
	    /**
	     * Adds the given value for the given key by appending to a list of previous
	     * values associated with that key. Normalizes the key.
	     * @param key The key for which a new value should be appended.
	     * @param value The value to add. Must be a buffer if and only
	     *   if the normalized key ends with '-bin'.
	     */
	    add(key, value) {
	        key = normalizeKey(key);
	        validate(key, value);
	        const existingValue = this.internalRepr.get(key);
	        if (existingValue === undefined) {
	            this.internalRepr.set(key, [value]);
	        }
	        else {
	            existingValue.push(value);
	        }
	    }
	    /**
	     * Removes the given key and any associated values. Normalizes the key.
	     * @param key The key whose values should be removed.
	     */
	    remove(key) {
	        key = normalizeKey(key);
	        // validate(key);
	        this.internalRepr.delete(key);
	    }
	    /**
	     * Gets a list of all values associated with the key. Normalizes the key.
	     * @param key The key whose value should be retrieved.
	     * @return A list of values associated with the given key.
	     */
	    get(key) {
	        key = normalizeKey(key);
	        // validate(key);
	        return this.internalRepr.get(key) || [];
	    }
	    /**
	     * Gets a plain object mapping each key to the first value associated with it.
	     * This reflects the most common way that people will want to see metadata.
	     * @return A key/value mapping of the metadata.
	     */
	    getMap() {
	        const result = {};
	        for (const [key, values] of this.internalRepr) {
	            if (values.length > 0) {
	                const v = values[0];
	                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
	            }
	        }
	        return result;
	    }
	    /**
	     * Clones the metadata object.
	     * @return The newly cloned object.
	     */
	    clone() {
	        const newMetadata = new Metadata(this.options);
	        const newInternalRepr = newMetadata.internalRepr;
	        for (const [key, value] of this.internalRepr) {
	            const clonedValue = value.map(v => {
	                if (Buffer.isBuffer(v)) {
	                    return Buffer.from(v);
	                }
	                else {
	                    return v;
	                }
	            });
	            newInternalRepr.set(key, clonedValue);
	        }
	        return newMetadata;
	    }
	    /**
	     * Merges all key-value pairs from a given Metadata object into this one.
	     * If both this object and the given object have values in the same key,
	     * values from the other Metadata object will be appended to this object's
	     * values.
	     * @param other A Metadata object.
	     */
	    merge(other) {
	        for (const [key, values] of other.internalRepr) {
	            const mergedValue = (this.internalRepr.get(key) || []).concat(values);
	            this.internalRepr.set(key, mergedValue);
	        }
	    }
	    setOptions(options) {
	        this.options = options;
	    }
	    getOptions() {
	        return this.options;
	    }
	    /**
	     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
	     */
	    toHttp2Headers() {
	        // NOTE: Node <8.9 formats http2 headers incorrectly.
	        const result = {};
	        for (const [key, values] of this.internalRepr) {
	            // We assume that the user's interaction with this object is limited to
	            // through its public API (i.e. keys and values are already validated).
	            result[key] = values.map(bufToString);
	        }
	        return result;
	    }
	    /**
	     * This modifies the behavior of JSON.stringify to show an object
	     * representation of the metadata map.
	     */
	    toJSON() {
	        const result = {};
	        for (const [key, values] of this.internalRepr) {
	            result[key] = values;
	        }
	        return result;
	    }
	    /**
	     * Returns a new Metadata object based fields in a given IncomingHttpHeaders
	     * object.
	     * @param headers An IncomingHttpHeaders object.
	     */
	    static fromHttp2Headers(headers) {
	        const result = new Metadata();
	        for (const key of Object.keys(headers)) {
	            // Reserved headers (beginning with `:`) are not valid keys.
	            if (key.charAt(0) === ':') {
	                continue;
	            }
	            const values = headers[key];
	            try {
	                if (isBinaryKey(key)) {
	                    if (Array.isArray(values)) {
	                        values.forEach(value => {
	                            result.add(key, Buffer.from(value, 'base64'));
	                        });
	                    }
	                    else if (values !== undefined) {
	                        if (isCustomMetadata(key)) {
	                            values.split(',').forEach(v => {
	                                result.add(key, Buffer.from(v.trim(), 'base64'));
	                            });
	                        }
	                        else {
	                            result.add(key, Buffer.from(values, 'base64'));
	                        }
	                    }
	                }
	                else {
	                    if (Array.isArray(values)) {
	                        values.forEach(value => {
	                            result.add(key, value);
	                        });
	                    }
	                    else if (values !== undefined) {
	                        result.add(key, values);
	                    }
	                }
	            }
	            catch (error) {
	                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
	                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
	            }
	        }
	        return result;
	    }
	}
	metadata.Metadata = Metadata;
	const bufToString = (val) => {
	    return Buffer.isBuffer(val) ? val.toString('base64') : val;
	};
	
	return metadata;
}

var hasRequiredCallCredentials;

function requireCallCredentials () {
	if (hasRequiredCallCredentials) return callCredentials;
	hasRequiredCallCredentials = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callCredentials, "__esModule", { value: true });
	callCredentials.CallCredentials = undefined;
	const metadata_1 = requireMetadata();
	function isCurrentOauth2Client(client) {
	    return ('getRequestHeaders' in client &&
	        typeof client.getRequestHeaders === 'function');
	}
	/**
	 * A class that represents a generic method of adding authentication-related
	 * metadata on a per-request basis.
	 */
	class CallCredentials {
	    /**
	     * Creates a new CallCredentials object from a given function that generates
	     * Metadata objects.
	     * @param metadataGenerator A function that accepts a set of options, and
	     * generates a Metadata object based on these options, which is passed back
	     * to the caller via a supplied (err, metadata) callback.
	     */
	    static createFromMetadataGenerator(metadataGenerator) {
	        return new SingleCallCredentials(metadataGenerator);
	    }
	    /**
	     * Create a gRPC credential from a Google credential object.
	     * @param googleCredentials The authentication client to use.
	     * @return The resulting CallCredentials object.
	     */
	    static createFromGoogleCredential(googleCredentials) {
	        return CallCredentials.createFromMetadataGenerator((options, callback) => {
	            let getHeaders;
	            if (isCurrentOauth2Client(googleCredentials)) {
	                getHeaders = googleCredentials.getRequestHeaders(options.service_url);
	            }
	            else {
	                getHeaders = new Promise((resolve, reject) => {
	                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
	                        if (err) {
	                            reject(err);
	                            return;
	                        }
	                        if (!headers) {
	                            reject(new Error('Headers not set by metadata plugin'));
	                            return;
	                        }
	                        resolve(headers);
	                    });
	                });
	            }
	            getHeaders.then(headers => {
	                const metadata = new metadata_1.Metadata();
	                for (const key of Object.keys(headers)) {
	                    metadata.add(key, headers[key]);
	                }
	                callback(null, metadata);
	            }, err => {
	                callback(err);
	            });
	        });
	    }
	    static createEmpty() {
	        return new EmptyCallCredentials();
	    }
	}
	callCredentials.CallCredentials = CallCredentials;
	class ComposedCallCredentials extends CallCredentials {
	    constructor(creds) {
	        super();
	        this.creds = creds;
	    }
	    async generateMetadata(options) {
	        const base = new metadata_1.Metadata();
	        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));
	        for (const gen of generated) {
	            base.merge(gen);
	        }
	        return base;
	    }
	    compose(other) {
	        return new ComposedCallCredentials(this.creds.concat([other]));
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof ComposedCallCredentials) {
	            return this.creds.every((value, index) => value._equals(other.creds[index]));
	        }
	        else {
	            return false;
	        }
	    }
	}
	class SingleCallCredentials extends CallCredentials {
	    constructor(metadataGenerator) {
	        super();
	        this.metadataGenerator = metadataGenerator;
	    }
	    generateMetadata(options) {
	        return new Promise((resolve, reject) => {
	            this.metadataGenerator(options, (err, metadata) => {
	                if (metadata !== undefined) {
	                    resolve(metadata);
	                }
	                else {
	                    reject(err);
	                }
	            });
	        });
	    }
	    compose(other) {
	        return new ComposedCallCredentials([this, other]);
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof SingleCallCredentials) {
	            return this.metadataGenerator === other.metadataGenerator;
	        }
	        else {
	            return false;
	        }
	    }
	}
	class EmptyCallCredentials extends CallCredentials {
	    generateMetadata(options) {
	        return Promise.resolve(new metadata_1.Metadata());
	    }
	    compose(other) {
	        return other;
	    }
	    _equals(other) {
	        return other instanceof EmptyCallCredentials;
	    }
	}
	
	return callCredentials;
}

var channel = {};

var channelCredentials = {};

var tlsHelpers = {};

var hasRequiredTlsHelpers;

function requireTlsHelpers () {
	if (hasRequiredTlsHelpers) return tlsHelpers;
	hasRequiredTlsHelpers = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(tlsHelpers, "__esModule", { value: true });
	tlsHelpers.getDefaultRootsData = tlsHelpers.CIPHER_SUITES = undefined;
	const fs = require$$0$5;
	tlsHelpers.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
	const DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
	let defaultRootsData = null;
	function getDefaultRootsData() {
	    if (DEFAULT_ROOTS_FILE_PATH) {
	        if (defaultRootsData === null) {
	            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
	        }
	        return defaultRootsData;
	    }
	    return null;
	}
	tlsHelpers.getDefaultRootsData = getDefaultRootsData;
	
	return tlsHelpers;
}

var hasRequiredChannelCredentials;

function requireChannelCredentials () {
	if (hasRequiredChannelCredentials) return channelCredentials;
	hasRequiredChannelCredentials = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelCredentials, "__esModule", { value: true });
	channelCredentials.createCertificateProviderChannelCredentials = channelCredentials.ChannelCredentials = undefined;
	const tls_1 = require$$4$2;
	const call_credentials_1 = requireCallCredentials();
	const tls_helpers_1 = requireTlsHelpers();
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	function verifyIsBufferOrNull(obj, friendlyName) {
	    if (obj && !(obj instanceof Buffer)) {
	        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
	    }
	}
	/**
	 * A class that contains credentials for communicating over a channel, as well
	 * as a set of per-call credentials, which are applied to every method call made
	 * over a channel initialized with an instance of this class.
	 */
	class ChannelCredentials {
	    constructor(callCredentials) {
	        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
	    }
	    /**
	     * Gets the set of per-call credentials associated with this instance.
	     */
	    _getCallCredentials() {
	        return this.callCredentials;
	    }
	    _ref() {
	        // Do nothing by default
	    }
	    _unref() {
	        // Do nothing by default
	    }
	    /**
	     * Return a new ChannelCredentials instance with a given set of credentials.
	     * The resulting instance can be used to construct a Channel that communicates
	     * over TLS.
	     * @param rootCerts The root certificate data.
	     * @param privateKey The client certificate private key, if available.
	     * @param certChain The client certificate key chain, if available.
	     * @param verifyOptions Additional options to modify certificate verification
	     */
	    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
	        var _a;
	        verifyIsBufferOrNull(rootCerts, 'Root certificate');
	        verifyIsBufferOrNull(privateKey, 'Private key');
	        verifyIsBufferOrNull(certChain, 'Certificate chain');
	        if (privateKey && !certChain) {
	            throw new Error('Private key must be given with accompanying certificate chain');
	        }
	        if (!privateKey && certChain) {
	            throw new Error('Certificate chain must be given with accompanying private key');
	        }
	        const secureContext = (0, tls_1.createSecureContext)({
	            ca: (_a = rootCerts !== null && rootCerts !== undefined ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== undefined ? _a : undefined,
	            key: privateKey !== null && privateKey !== undefined ? privateKey : undefined,
	            cert: certChain !== null && certChain !== undefined ? certChain : undefined,
	            ciphers: tls_helpers_1.CIPHER_SUITES,
	        });
	        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
	    }
	    /**
	     * Return a new ChannelCredentials instance with credentials created using
	     * the provided secureContext. The resulting instances can be used to
	     * construct a Channel that communicates over TLS. gRPC will not override
	     * anything in the provided secureContext, so the environment variables
	     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
	     * not be applied.
	     * @param secureContext The return value of tls.createSecureContext()
	     * @param verifyOptions Additional options to modify certificate verification
	     */
	    static createFromSecureContext(secureContext, verifyOptions) {
	        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : {});
	    }
	    /**
	     * Return a new ChannelCredentials instance with no credentials.
	     */
	    static createInsecure() {
	        return new InsecureChannelCredentialsImpl();
	    }
	}
	channelCredentials.ChannelCredentials = ChannelCredentials;
	class InsecureChannelCredentialsImpl extends ChannelCredentials {
	    constructor() {
	        super();
	    }
	    compose(callCredentials) {
	        throw new Error('Cannot compose insecure credentials');
	    }
	    _getConnectionOptions() {
	        return {};
	    }
	    _isSecure() {
	        return false;
	    }
	    _equals(other) {
	        return other instanceof InsecureChannelCredentialsImpl;
	    }
	}
	class SecureChannelCredentialsImpl extends ChannelCredentials {
	    constructor(secureContext, verifyOptions) {
	        super();
	        this.secureContext = secureContext;
	        this.verifyOptions = verifyOptions;
	        this.connectionOptions = {
	            secureContext,
	        };
	        // Node asserts that this option is a function, so we cannot pass undefined
	        if (verifyOptions === null || verifyOptions === undefined ? undefined : verifyOptions.checkServerIdentity) {
	            this.connectionOptions.checkServerIdentity =
	                verifyOptions.checkServerIdentity;
	        }
	        if ((verifyOptions === null || verifyOptions === undefined ? undefined : verifyOptions.rejectUnauthorized) !== undefined) {
	            this.connectionOptions.rejectUnauthorized =
	                verifyOptions.rejectUnauthorized;
	        }
	    }
	    compose(callCredentials) {
	        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
	        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
	    }
	    _getConnectionOptions() {
	        // Copy to prevent callers from mutating this.connectionOptions
	        return Object.assign({}, this.connectionOptions);
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof SecureChannelCredentialsImpl) {
	            return (this.secureContext === other.secureContext &&
	                this.verifyOptions.checkServerIdentity ===
	                    other.verifyOptions.checkServerIdentity);
	        }
	        else {
	            return false;
	        }
	    }
	}
	class CertificateProviderChannelCredentialsImpl extends ChannelCredentials {
	    constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {
	        super();
	        this.caCertificateProvider = caCertificateProvider;
	        this.identityCertificateProvider = identityCertificateProvider;
	        this.verifyOptions = verifyOptions;
	        this.refcount = 0;
	        this.latestCaUpdate = null;
	        this.latestIdentityUpdate = null;
	        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
	        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
	    }
	    compose(callCredentials) {
	        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
	        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
	    }
	    _getConnectionOptions() {
	        var _a, _b, _c;
	        if (this.latestCaUpdate === null) {
	            return null;
	        }
	        if (this.identityCertificateProvider !== null && this.latestIdentityUpdate === null) {
	            return null;
	        }
	        const secureContext = (0, tls_1.createSecureContext)({
	            ca: this.latestCaUpdate.caCertificate,
	            key: (_a = this.latestIdentityUpdate) === null || _a === undefined ? undefined : _a.privateKey,
	            cert: (_b = this.latestIdentityUpdate) === null || _b === undefined ? undefined : _b.certificate,
	            ciphers: tls_helpers_1.CIPHER_SUITES
	        });
	        const options = {
	            secureContext: secureContext
	        };
	        if ((_c = this.verifyOptions) === null || _c === undefined ? undefined : _c.checkServerIdentity) {
	            options.checkServerIdentity = this.verifyOptions.checkServerIdentity;
	        }
	        return options;
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        var _a, _b;
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof CertificateProviderChannelCredentialsImpl) {
	            return this.caCertificateProvider === other.caCertificateProvider &&
	                this.identityCertificateProvider === other.identityCertificateProvider &&
	                ((_a = this.verifyOptions) === null || _a === undefined ? undefined : _a.checkServerIdentity) === ((_b = other.verifyOptions) === null || _b === undefined ? undefined : _b.checkServerIdentity);
	        }
	        else {
	            return false;
	        }
	    }
	    _ref() {
	        var _a;
	        if (this.refcount === 0) {
	            this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);
	            (_a = this.identityCertificateProvider) === null || _a === undefined ? undefined : _a.addIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	        this.refcount += 1;
	    }
	    _unref() {
	        var _a;
	        this.refcount -= 1;
	        if (this.refcount === 0) {
	            this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);
	            (_a = this.identityCertificateProvider) === null || _a === undefined ? undefined : _a.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	    }
	    handleCaCertificateUpdate(update) {
	        this.latestCaUpdate = update;
	    }
	    handleIdentityCertitificateUpdate(update) {
	        this.latestIdentityUpdate = update;
	    }
	}
	function createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {
	    return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== undefined ? verifyOptions : null);
	}
	channelCredentials.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;
	class ComposedChannelCredentialsImpl extends ChannelCredentials {
	    constructor(channelCredentials, callCreds) {
	        super(callCreds);
	        this.channelCredentials = channelCredentials;
	        if (!channelCredentials._isSecure()) {
	            throw new Error('Cannot compose insecure credentials');
	        }
	    }
	    compose(callCredentials) {
	        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
	        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
	    }
	    _getConnectionOptions() {
	        return this.channelCredentials._getConnectionOptions();
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (other instanceof ComposedChannelCredentialsImpl) {
	            return (this.channelCredentials._equals(other.channelCredentials) &&
	                this.callCredentials._equals(other.callCredentials));
	        }
	        else {
	            return false;
	        }
	    }
	}
	
	return channelCredentials;
}

var internalChannel = {};

var resolvingLoadBalancer = {};

var loadBalancer = {};

var hasRequiredLoadBalancer;

function requireLoadBalancer () {
	if (hasRequiredLoadBalancer) return loadBalancer;
	hasRequiredLoadBalancer = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancer, "__esModule", { value: true });
	loadBalancer.selectLbConfigFromList = loadBalancer.getDefaultConfig = loadBalancer.parseLoadBalancingConfig = loadBalancer.isLoadBalancerNameRegistered = loadBalancer.createLoadBalancer = loadBalancer.registerDefaultLoadBalancerType = loadBalancer.registerLoadBalancerType = loadBalancer.createChildChannelControlHelper = undefined;
	const logging_1 = requireLogging();
	const constants_1 = requireConstants();
	/**
	 * Create a child ChannelControlHelper that overrides some methods of the
	 * parent while letting others pass through to the parent unmodified. This
	 * allows other code to create these children without needing to know about
	 * all of the methods to be passed through.
	 * @param parent
	 * @param overrides
	 */
	function createChildChannelControlHelper(parent, overrides) {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
	    return {
	        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === undefined ? undefined : _a.bind(overrides)) !== null && _b !== undefined ? _b : parent.createSubchannel.bind(parent),
	        updateState: (_d = (_c = overrides.updateState) === null || _c === undefined ? undefined : _c.bind(overrides)) !== null && _d !== undefined ? _d : parent.updateState.bind(parent),
	        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === undefined ? undefined : _e.bind(overrides)) !== null && _f !== undefined ? _f : parent.requestReresolution.bind(parent),
	        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === undefined ? undefined : _g.bind(overrides)) !== null && _h !== undefined ? _h : parent.addChannelzChild.bind(parent),
	        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === undefined ? undefined : _j.bind(overrides)) !== null && _k !== undefined ? _k : parent.removeChannelzChild.bind(parent),
	    };
	}
	loadBalancer.createChildChannelControlHelper = createChildChannelControlHelper;
	const registeredLoadBalancerTypes = {};
	let defaultLoadBalancerType = null;
	function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
	    registeredLoadBalancerTypes[typeName] = {
	        LoadBalancer: loadBalancerType,
	        LoadBalancingConfig: loadBalancingConfigType,
	    };
	}
	loadBalancer.registerLoadBalancerType = registerLoadBalancerType;
	function registerDefaultLoadBalancerType(typeName) {
	    defaultLoadBalancerType = typeName;
	}
	loadBalancer.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
	function createLoadBalancer(config, channelControlHelper, credentials, options) {
	    const typeName = config.getLoadBalancerName();
	    if (typeName in registeredLoadBalancerTypes) {
	        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper, credentials, options);
	    }
	    else {
	        return null;
	    }
	}
	loadBalancer.createLoadBalancer = createLoadBalancer;
	function isLoadBalancerNameRegistered(typeName) {
	    return typeName in registeredLoadBalancerTypes;
	}
	loadBalancer.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
	function parseLoadBalancingConfig(rawConfig) {
	    const keys = Object.keys(rawConfig);
	    if (keys.length !== 1) {
	        throw new Error('Provided load balancing config has multiple conflicting entries');
	    }
	    const typeName = keys[0];
	    if (typeName in registeredLoadBalancerTypes) {
	        try {
	            return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
	        }
	        catch (e) {
	            throw new Error(`${typeName}: ${e.message}`);
	        }
	    }
	    else {
	        throw new Error(`Unrecognized load balancing config name ${typeName}`);
	    }
	}
	loadBalancer.parseLoadBalancingConfig = parseLoadBalancingConfig;
	function getDefaultConfig() {
	    if (!defaultLoadBalancerType) {
	        throw new Error('No default load balancer type registered');
	    }
	    return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
	}
	loadBalancer.getDefaultConfig = getDefaultConfig;
	function selectLbConfigFromList(configs, fallbackTodefault = false) {
	    for (const config of configs) {
	        try {
	            return parseLoadBalancingConfig(config);
	        }
	        catch (e) {
	            (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, 'Config parsing failed with error', e.message);
	            continue;
	        }
	    }
	    if (fallbackTodefault) {
	        if (defaultLoadBalancerType) {
	            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
	        }
	        else {
	            return null;
	        }
	    }
	    else {
	        return null;
	    }
	}
	loadBalancer.selectLbConfigFromList = selectLbConfigFromList;
	
	return loadBalancer;
}

var serviceConfig = {};

var hasRequiredServiceConfig;

function requireServiceConfig () {
	if (hasRequiredServiceConfig) return serviceConfig;
	hasRequiredServiceConfig = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serviceConfig, "__esModule", { value: true });
	serviceConfig.extractAndSelectServiceConfig = serviceConfig.validateServiceConfig = serviceConfig.validateRetryThrottling = undefined;
	/* This file implements gRFC A2 and the service config spec:
	 * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md
	 * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each
	 * function here takes an object with unknown structure and returns its
	 * specific object type if the input has the right structure, and throws an
	 * error otherwise. */
	/* The any type is purposely used here. All functions validate their input at
	 * runtime */
	/* eslint-disable @typescript-eslint/no-explicit-any */
	const os = require$$0$3;
	const constants_1 = requireConstants();
	/**
	 * Recognizes a number with up to 9 digits after the decimal point, followed by
	 * an "s", representing a number of seconds.
	 */
	const DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
	/**
	 * Client language name used for determining whether this client matches a
	 * `ServiceConfigCanaryConfig`'s `clientLanguage` list.
	 */
	const CLIENT_LANGUAGE_STRING = 'node';
	function validateName(obj) {
	    // In this context, and unset field and '' are considered the same
	    if ('service' in obj && obj.service !== '') {
	        if (typeof obj.service !== 'string') {
	            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
	        }
	        if ('method' in obj && obj.method !== '') {
	            if (typeof obj.method !== 'string') {
	                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
	            }
	            return {
	                service: obj.service,
	                method: obj.method,
	            };
	        }
	        else {
	            return {
	                service: obj.service,
	            };
	        }
	    }
	    else {
	        if ('method' in obj && obj.method !== undefined) {
	            throw new Error(`Invalid method config name: method set with empty or unset service`);
	        }
	        return {};
	    }
	}
	function validateRetryPolicy(obj) {
	    if (!('maxAttempts' in obj) ||
	        !Number.isInteger(obj.maxAttempts) ||
	        obj.maxAttempts < 2) {
	        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');
	    }
	    if (!('initialBackoff' in obj) ||
	        typeof obj.initialBackoff !== 'string' ||
	        !DURATION_REGEX.test(obj.initialBackoff)) {
	        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s');
	    }
	    if (!('maxBackoff' in obj) ||
	        typeof obj.maxBackoff !== 'string' ||
	        !DURATION_REGEX.test(obj.maxBackoff)) {
	        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s');
	    }
	    if (!('backoffMultiplier' in obj) ||
	        typeof obj.backoffMultiplier !== 'number' ||
	        obj.backoffMultiplier <= 0) {
	        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');
	    }
	    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {
	        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');
	    }
	    if (obj.retryableStatusCodes.length === 0) {
	        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');
	    }
	    for (const value of obj.retryableStatusCodes) {
	        if (typeof value === 'number') {
	            if (!Object.values(constants_1.Status).includes(value)) {
	                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');
	            }
	        }
	        else if (typeof value === 'string') {
	            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
	                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');
	            }
	        }
	        else {
	            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');
	        }
	    }
	    return {
	        maxAttempts: obj.maxAttempts,
	        initialBackoff: obj.initialBackoff,
	        maxBackoff: obj.maxBackoff,
	        backoffMultiplier: obj.backoffMultiplier,
	        retryableStatusCodes: obj.retryableStatusCodes,
	    };
	}
	function validateHedgingPolicy(obj) {
	    if (!('maxAttempts' in obj) ||
	        !Number.isInteger(obj.maxAttempts) ||
	        obj.maxAttempts < 2) {
	        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');
	    }
	    if ('hedgingDelay' in obj &&
	        (typeof obj.hedgingDelay !== 'string' ||
	            !DURATION_REGEX.test(obj.hedgingDelay))) {
	        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');
	    }
	    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {
	        for (const value of obj.nonFatalStatusCodes) {
	            if (typeof value === 'number') {
	                if (!Object.values(constants_1.Status).includes(value)) {
	                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not in status code range');
	                }
	            }
	            else if (typeof value === 'string') {
	                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
	                    throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value not a status code name');
	                }
	            }
	            else {
	                throw new Error('Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number');
	            }
	        }
	    }
	    const result = {
	        maxAttempts: obj.maxAttempts,
	    };
	    if (obj.hedgingDelay) {
	        result.hedgingDelay = obj.hedgingDelay;
	    }
	    if (obj.nonFatalStatusCodes) {
	        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
	    }
	    return result;
	}
	function validateMethodConfig(obj) {
	    var _a;
	    const result = {
	        name: [],
	    };
	    if (!('name' in obj) || !Array.isArray(obj.name)) {
	        throw new Error('Invalid method config: invalid name array');
	    }
	    for (const name of obj.name) {
	        result.name.push(validateName(name));
	    }
	    if ('waitForReady' in obj) {
	        if (typeof obj.waitForReady !== 'boolean') {
	            throw new Error('Invalid method config: invalid waitForReady');
	        }
	        result.waitForReady = obj.waitForReady;
	    }
	    if ('timeout' in obj) {
	        if (typeof obj.timeout === 'object') {
	            if (!('seconds' in obj.timeout) ||
	                !(typeof obj.timeout.seconds === 'number')) {
	                throw new Error('Invalid method config: invalid timeout.seconds');
	            }
	            if (!('nanos' in obj.timeout) ||
	                !(typeof obj.timeout.nanos === 'number')) {
	                throw new Error('Invalid method config: invalid timeout.nanos');
	            }
	            result.timeout = obj.timeout;
	        }
	        else if (typeof obj.timeout === 'string' &&
	            DURATION_REGEX.test(obj.timeout)) {
	            const timeoutParts = obj.timeout
	                .substring(0, obj.timeout.length - 1)
	                .split('.');
	            result.timeout = {
	                seconds: timeoutParts[0] | 0,
	                nanos: ((_a = timeoutParts[1]) !== null && _a !== undefined ? _a : 0) | 0,
	            };
	        }
	        else {
	            throw new Error('Invalid method config: invalid timeout');
	        }
	    }
	    if ('maxRequestBytes' in obj) {
	        if (typeof obj.maxRequestBytes !== 'number') {
	            throw new Error('Invalid method config: invalid maxRequestBytes');
	        }
	        result.maxRequestBytes = obj.maxRequestBytes;
	    }
	    if ('maxResponseBytes' in obj) {
	        if (typeof obj.maxResponseBytes !== 'number') {
	            throw new Error('Invalid method config: invalid maxRequestBytes');
	        }
	        result.maxResponseBytes = obj.maxResponseBytes;
	    }
	    if ('retryPolicy' in obj) {
	        if ('hedgingPolicy' in obj) {
	            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');
	        }
	        else {
	            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
	        }
	    }
	    else if ('hedgingPolicy' in obj) {
	        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
	    }
	    return result;
	}
	function validateRetryThrottling(obj) {
	    if (!('maxTokens' in obj) ||
	        typeof obj.maxTokens !== 'number' ||
	        obj.maxTokens <= 0 ||
	        obj.maxTokens > 1000) {
	        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');
	    }
	    if (!('tokenRatio' in obj) ||
	        typeof obj.tokenRatio !== 'number' ||
	        obj.tokenRatio <= 0) {
	        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');
	    }
	    return {
	        maxTokens: +obj.maxTokens.toFixed(3),
	        tokenRatio: +obj.tokenRatio.toFixed(3),
	    };
	}
	serviceConfig.validateRetryThrottling = validateRetryThrottling;
	function validateLoadBalancingConfig(obj) {
	    if (!(typeof obj === 'object' && obj !== null)) {
	        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
	    }
	    const keys = Object.keys(obj);
	    if (keys.length > 1) {
	        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);
	    }
	    if (keys.length === 0) {
	        throw new Error('Invalid loadBalancingConfig: load balancing policy name required');
	    }
	    return {
	        [keys[0]]: obj[keys[0]],
	    };
	}
	function validateServiceConfig(obj) {
	    const result = {
	        loadBalancingConfig: [],
	        methodConfig: [],
	    };
	    if ('loadBalancingPolicy' in obj) {
	        if (typeof obj.loadBalancingPolicy === 'string') {
	            result.loadBalancingPolicy = obj.loadBalancingPolicy;
	        }
	        else {
	            throw new Error('Invalid service config: invalid loadBalancingPolicy');
	        }
	    }
	    if ('loadBalancingConfig' in obj) {
	        if (Array.isArray(obj.loadBalancingConfig)) {
	            for (const config of obj.loadBalancingConfig) {
	                result.loadBalancingConfig.push(validateLoadBalancingConfig(config));
	            }
	        }
	        else {
	            throw new Error('Invalid service config: invalid loadBalancingConfig');
	        }
	    }
	    if ('methodConfig' in obj) {
	        if (Array.isArray(obj.methodConfig)) {
	            for (const methodConfig of obj.methodConfig) {
	                result.methodConfig.push(validateMethodConfig(methodConfig));
	            }
	        }
	    }
	    if ('retryThrottling' in obj) {
	        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
	    }
	    // Validate method name uniqueness
	    const seenMethodNames = [];
	    for (const methodConfig of result.methodConfig) {
	        for (const name of methodConfig.name) {
	            for (const seenName of seenMethodNames) {
	                if (name.service === seenName.service &&
	                    name.method === seenName.method) {
	                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
	                }
	            }
	            seenMethodNames.push(name);
	        }
	    }
	    return result;
	}
	serviceConfig.validateServiceConfig = validateServiceConfig;
	function validateCanaryConfig(obj) {
	    if (!('serviceConfig' in obj)) {
	        throw new Error('Invalid service config choice: missing service config');
	    }
	    const result = {
	        serviceConfig: validateServiceConfig(obj.serviceConfig),
	    };
	    if ('clientLanguage' in obj) {
	        if (Array.isArray(obj.clientLanguage)) {
	            result.clientLanguage = [];
	            for (const lang of obj.clientLanguage) {
	                if (typeof lang === 'string') {
	                    result.clientLanguage.push(lang);
	                }
	                else {
	                    throw new Error('Invalid service config choice: invalid clientLanguage');
	                }
	            }
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid clientLanguage');
	        }
	    }
	    if ('clientHostname' in obj) {
	        if (Array.isArray(obj.clientHostname)) {
	            result.clientHostname = [];
	            for (const lang of obj.clientHostname) {
	                if (typeof lang === 'string') {
	                    result.clientHostname.push(lang);
	                }
	                else {
	                    throw new Error('Invalid service config choice: invalid clientHostname');
	                }
	            }
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid clientHostname');
	        }
	    }
	    if ('percentage' in obj) {
	        if (typeof obj.percentage === 'number' &&
	            0 <= obj.percentage &&
	            obj.percentage <= 100) {
	            result.percentage = obj.percentage;
	        }
	        else {
	            throw new Error('Invalid service config choice: invalid percentage');
	        }
	    }
	    // Validate that no unexpected fields are present
	    const allowedFields = [
	        'clientLanguage',
	        'percentage',
	        'clientHostname',
	        'serviceConfig',
	    ];
	    for (const field in obj) {
	        if (!allowedFields.includes(field)) {
	            throw new Error(`Invalid service config choice: unexpected field ${field}`);
	        }
	    }
	    return result;
	}
	function validateAndSelectCanaryConfig(obj, percentage) {
	    if (!Array.isArray(obj)) {
	        throw new Error('Invalid service config list');
	    }
	    for (const config of obj) {
	        const validatedConfig = validateCanaryConfig(config);
	        /* For each field, we check if it is present, then only discard the
	         * config if the field value does not match the current client */
	        if (typeof validatedConfig.percentage === 'number' &&
	            percentage > validatedConfig.percentage) {
	            continue;
	        }
	        if (Array.isArray(validatedConfig.clientHostname)) {
	            let hostnameMatched = false;
	            for (const hostname of validatedConfig.clientHostname) {
	                if (hostname === os.hostname()) {
	                    hostnameMatched = true;
	                }
	            }
	            if (!hostnameMatched) {
	                continue;
	            }
	        }
	        if (Array.isArray(validatedConfig.clientLanguage)) {
	            let languageMatched = false;
	            for (const language of validatedConfig.clientLanguage) {
	                if (language === CLIENT_LANGUAGE_STRING) {
	                    languageMatched = true;
	                }
	            }
	            if (!languageMatched) {
	                continue;
	            }
	        }
	        return validatedConfig.serviceConfig;
	    }
	    throw new Error('No matching service config found');
	}
	/**
	 * Find the "grpc_config" record among the TXT records, parse its value as JSON, validate its contents,
	 * and select a service config with selection fields that all match this client. Most of these steps
	 * can fail with an error; the caller must handle any errors thrown this way.
	 * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt
	 * @param percentage A number chosen from the range [0, 100) that is used to select which config to use
	 * @return The service configuration to use, given the percentage value, or null if the service config
	 *     data has a valid format but none of the options match the current client.
	 */
	function extractAndSelectServiceConfig(txtRecord, percentage) {
	    for (const record of txtRecord) {
	        if (record.length > 0 && record[0].startsWith('grpc_config=')) {
	            /* Treat the list of strings in this record as a single string and remove
	             * "grpc_config=" from the beginning. The rest should be a JSON string */
	            const recordString = record.join('').substring('grpc_config='.length);
	            const recordJson = JSON.parse(recordString);
	            return validateAndSelectCanaryConfig(recordJson, percentage);
	        }
	    }
	    return null;
	}
	serviceConfig.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
	
	return serviceConfig;
}

var connectivityState = {};

var hasRequiredConnectivityState;

function requireConnectivityState () {
	if (hasRequiredConnectivityState) return connectivityState;
	hasRequiredConnectivityState = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(connectivityState, "__esModule", { value: true });
	connectivityState.ConnectivityState = undefined;
	var ConnectivityState;
	(function (ConnectivityState) {
	    ConnectivityState[ConnectivityState["IDLE"] = 0] = "IDLE";
	    ConnectivityState[ConnectivityState["CONNECTING"] = 1] = "CONNECTING";
	    ConnectivityState[ConnectivityState["READY"] = 2] = "READY";
	    ConnectivityState[ConnectivityState["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
	    ConnectivityState[ConnectivityState["SHUTDOWN"] = 4] = "SHUTDOWN";
	})(ConnectivityState || (connectivityState.ConnectivityState = ConnectivityState = {}));
	
	return connectivityState;
}

var resolver = {};

var uriParser = {};

var hasRequiredUriParser;

function requireUriParser () {
	if (hasRequiredUriParser) return uriParser;
	hasRequiredUriParser = 1;
	/*
	 * Copyright 2020 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(uriParser, "__esModule", { value: true });
	uriParser.uriToString = uriParser.combineHostPort = uriParser.splitHostPort = uriParser.parseUri = undefined;
	/*
	 * The groups correspond to URI parts as follows:
	 * 1. scheme
	 * 2. authority
	 * 3. path
	 */
	const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
	function parseUri(uriString) {
	    const parsedUri = URI_REGEX.exec(uriString);
	    if (parsedUri === null) {
	        return null;
	    }
	    return {
	        scheme: parsedUri[1],
	        authority: parsedUri[2],
	        path: parsedUri[3],
	    };
	}
	uriParser.parseUri = parseUri;
	const NUMBER_REGEX = /^\d+$/;
	function splitHostPort(path) {
	    if (path.startsWith('[')) {
	        const hostEnd = path.indexOf(']');
	        if (hostEnd === -1) {
	            return null;
	        }
	        const host = path.substring(1, hostEnd);
	        /* Only an IPv6 address should be in bracketed notation, and an IPv6
	         * address should have at least one colon */
	        if (host.indexOf(':') === -1) {
	            return null;
	        }
	        if (path.length > hostEnd + 1) {
	            if (path[hostEnd + 1] === ':') {
	                const portString = path.substring(hostEnd + 2);
	                if (NUMBER_REGEX.test(portString)) {
	                    return {
	                        host: host,
	                        port: +portString,
	                    };
	                }
	                else {
	                    return null;
	                }
	            }
	            else {
	                return null;
	            }
	        }
	        else {
	            return {
	                host,
	            };
	        }
	    }
	    else {
	        const splitPath = path.split(':');
	        /* Exactly one colon means that this is host:port. Zero colons means that
	         * there is no port. And multiple colons means that this is a bare IPv6
	         * address with no port */
	        if (splitPath.length === 2) {
	            if (NUMBER_REGEX.test(splitPath[1])) {
	                return {
	                    host: splitPath[0],
	                    port: +splitPath[1],
	                };
	            }
	            else {
	                return null;
	            }
	        }
	        else {
	            return {
	                host: path,
	            };
	        }
	    }
	}
	uriParser.splitHostPort = splitHostPort;
	function combineHostPort(hostPort) {
	    if (hostPort.port === undefined) {
	        return hostPort.host;
	    }
	    else {
	        // Only an IPv6 host should include a colon
	        if (hostPort.host.includes(':')) {
	            return `[${hostPort.host}]:${hostPort.port}`;
	        }
	        else {
	            return `${hostPort.host}:${hostPort.port}`;
	        }
	    }
	}
	uriParser.combineHostPort = combineHostPort;
	function uriToString(uri) {
	    let result = '';
	    if (uri.scheme !== undefined) {
	        result += uri.scheme + ':';
	    }
	    if (uri.authority !== undefined) {
	        result += '//' + uri.authority + '/';
	    }
	    result += uri.path;
	    return result;
	}
	uriParser.uriToString = uriToString;
	
	return uriParser;
}

var hasRequiredResolver;

function requireResolver () {
	if (hasRequiredResolver) return resolver;
	hasRequiredResolver = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(resolver, "__esModule", { value: true });
	resolver.mapUriDefaultScheme = resolver.getDefaultAuthority = resolver.createResolver = resolver.registerDefaultScheme = resolver.registerResolver = undefined;
	const uri_parser_1 = requireUriParser();
	const registeredResolvers = {};
	let defaultScheme = null;
	/**
	 * Register a resolver class to handle target names prefixed with the `prefix`
	 * string. This prefix should correspond to a URI scheme name listed in the
	 * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)
	 * @param prefix
	 * @param resolverClass
	 */
	function registerResolver(scheme, resolverClass) {
	    registeredResolvers[scheme] = resolverClass;
	}
	resolver.registerResolver = registerResolver;
	/**
	 * Register a default resolver to handle target names that do not start with
	 * any registered prefix.
	 * @param resolverClass
	 */
	function registerDefaultScheme(scheme) {
	    defaultScheme = scheme;
	}
	resolver.registerDefaultScheme = registerDefaultScheme;
	/**
	 * Create a name resolver for the specified target, if possible. Throws an
	 * error if no such name resolver can be created.
	 * @param target
	 * @param listener
	 */
	function createResolver(target, listener, options) {
	    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
	        return new registeredResolvers[target.scheme](target, listener, options);
	    }
	    else {
	        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
	    }
	}
	resolver.createResolver = createResolver;
	/**
	 * Get the default authority for the specified target, if possible. Throws an
	 * error if no registered name resolver can parse that target string.
	 * @param target
	 */
	function getDefaultAuthority(target) {
	    if (target.scheme !== undefined && target.scheme in registeredResolvers) {
	        return registeredResolvers[target.scheme].getDefaultAuthority(target);
	    }
	    else {
	        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
	    }
	}
	resolver.getDefaultAuthority = getDefaultAuthority;
	function mapUriDefaultScheme(target) {
	    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {
	        if (defaultScheme !== null) {
	            return {
	                scheme: defaultScheme,
	                authority: undefined,
	                path: (0, uri_parser_1.uriToString)(target),
	            };
	        }
	        else {
	            return null;
	        }
	    }
	    return target;
	}
	resolver.mapUriDefaultScheme = mapUriDefaultScheme;
	
	return resolver;
}

var picker = {};

var hasRequiredPicker;

function requirePicker () {
	if (hasRequiredPicker) return picker;
	hasRequiredPicker = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(picker, "__esModule", { value: true });
	picker.QueuePicker = picker.UnavailablePicker = picker.PickResultType = undefined;
	const metadata_1 = requireMetadata();
	const constants_1 = requireConstants();
	var PickResultType;
	(function (PickResultType) {
	    PickResultType[PickResultType["COMPLETE"] = 0] = "COMPLETE";
	    PickResultType[PickResultType["QUEUE"] = 1] = "QUEUE";
	    PickResultType[PickResultType["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
	    PickResultType[PickResultType["DROP"] = 3] = "DROP";
	})(PickResultType || (picker.PickResultType = PickResultType = {}));
	/**
	 * A standard picker representing a load balancer in the TRANSIENT_FAILURE
	 * state. Always responds to every pick request with an UNAVAILABLE status.
	 */
	class UnavailablePicker {
	    constructor(status) {
	        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);
	    }
	    pick(pickArgs) {
	        return {
	            pickResultType: PickResultType.TRANSIENT_FAILURE,
	            subchannel: null,
	            status: this.status,
	            onCallStarted: null,
	            onCallEnded: null,
	        };
	    }
	}
	picker.UnavailablePicker = UnavailablePicker;
	/**
	 * A standard picker representing a load balancer in the IDLE or CONNECTING
	 * state. Always responds to every pick request with a QUEUE pick result
	 * indicating that the pick should be tried again with the next `Picker`. Also
	 * reports back to the load balancer that a connection should be established
	 * once any pick is attempted.
	 * If the childPicker is provided, delegate to it instead of returning the
	 * hardcoded QUEUE pick result, but still calls exitIdle.
	 */
	class QueuePicker {
	    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
	    constructor(loadBalancer, childPicker) {
	        this.loadBalancer = loadBalancer;
	        this.childPicker = childPicker;
	        this.calledExitIdle = false;
	    }
	    pick(pickArgs) {
	        if (!this.calledExitIdle) {
	            process.nextTick(() => {
	                this.loadBalancer.exitIdle();
	            });
	            this.calledExitIdle = true;
	        }
	        if (this.childPicker) {
	            return this.childPicker.pick(pickArgs);
	        }
	        else {
	            return {
	                pickResultType: PickResultType.QUEUE,
	                subchannel: null,
	                status: null,
	                onCallStarted: null,
	                onCallEnded: null,
	            };
	        }
	    }
	}
	picker.QueuePicker = QueuePicker;
	
	return picker;
}

var backoffTimeout = {};

var hasRequiredBackoffTimeout;

function requireBackoffTimeout () {
	if (hasRequiredBackoffTimeout) return backoffTimeout;
	hasRequiredBackoffTimeout = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(backoffTimeout, "__esModule", { value: true });
	backoffTimeout.BackoffTimeout = undefined;
	const INITIAL_BACKOFF_MS = 1000;
	const BACKOFF_MULTIPLIER = 1.6;
	const MAX_BACKOFF_MS = 120000;
	const BACKOFF_JITTER = 0.2;
	/**
	 * Get a number uniformly at random in the range [min, max)
	 * @param min
	 * @param max
	 */
	function uniformRandom(min, max) {
	    return Math.random() * (max - min) + min;
	}
	class BackoffTimeout {
	    constructor(callback, options) {
	        this.callback = callback;
	        /**
	         * The delay time at the start, and after each reset.
	         */
	        this.initialDelay = INITIAL_BACKOFF_MS;
	        /**
	         * The exponential backoff multiplier.
	         */
	        this.multiplier = BACKOFF_MULTIPLIER;
	        /**
	         * The maximum delay time
	         */
	        this.maxDelay = MAX_BACKOFF_MS;
	        /**
	         * The maximum fraction by which the delay time can randomly vary after
	         * applying the multiplier.
	         */
	        this.jitter = BACKOFF_JITTER;
	        /**
	         * Indicates whether the timer is currently running.
	         */
	        this.running = false;
	        /**
	         * Indicates whether the timer should keep the Node process running if no
	         * other async operation is doing so.
	         */
	        this.hasRef = true;
	        /**
	         * The time that the currently running timer was started. Only valid if
	         * running is true.
	         */
	        this.startTime = new Date();
	        /**
	         * The approximate time that the currently running timer will end. Only valid
	         * if running is true.
	         */
	        this.endTime = new Date();
	        if (options) {
	            if (options.initialDelay) {
	                this.initialDelay = options.initialDelay;
	            }
	            if (options.multiplier) {
	                this.multiplier = options.multiplier;
	            }
	            if (options.jitter) {
	                this.jitter = options.jitter;
	            }
	            if (options.maxDelay) {
	                this.maxDelay = options.maxDelay;
	            }
	        }
	        this.nextDelay = this.initialDelay;
	        this.timerId = setTimeout(() => { }, 0);
	        clearTimeout(this.timerId);
	    }
	    runTimer(delay) {
	        var _a, _b;
	        this.endTime = this.startTime;
	        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);
	        clearTimeout(this.timerId);
	        this.timerId = setTimeout(() => {
	            this.callback();
	            this.running = false;
	        }, delay);
	        if (!this.hasRef) {
	            (_b = (_a = this.timerId).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	    }
	    /**
	     * Call the callback after the current amount of delay time
	     */
	    runOnce() {
	        this.running = true;
	        this.startTime = new Date();
	        this.runTimer(this.nextDelay);
	        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
	        const jitterMagnitude = nextBackoff * this.jitter;
	        this.nextDelay =
	            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
	    }
	    /**
	     * Stop the timer. The callback will not be called until `runOnce` is called
	     * again.
	     */
	    stop() {
	        clearTimeout(this.timerId);
	        this.running = false;
	    }
	    /**
	     * Reset the delay time to its initial value. If the timer is still running,
	     * retroactively apply that reset to the current timer.
	     */
	    reset() {
	        this.nextDelay = this.initialDelay;
	        if (this.running) {
	            const now = new Date();
	            const newEndTime = this.startTime;
	            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
	            clearTimeout(this.timerId);
	            if (now < newEndTime) {
	                this.runTimer(newEndTime.getTime() - now.getTime());
	            }
	            else {
	                this.running = false;
	            }
	        }
	    }
	    /**
	     * Check whether the timer is currently running.
	     */
	    isRunning() {
	        return this.running;
	    }
	    /**
	     * Set that while the timer is running, it should keep the Node process
	     * running.
	     */
	    ref() {
	        var _a, _b;
	        this.hasRef = true;
	        (_b = (_a = this.timerId).ref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    /**
	     * Set that while the timer is running, it should not keep the Node process
	     * running.
	     */
	    unref() {
	        var _a, _b;
	        this.hasRef = false;
	        (_b = (_a = this.timerId).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    /**
	     * Get the approximate timestamp of when the timer will fire. Only valid if
	     * this.isRunning() is true.
	     */
	    getEndTime() {
	        return this.endTime;
	    }
	}
	backoffTimeout.BackoffTimeout = BackoffTimeout;
	
	return backoffTimeout;
}

var loadBalancerChildHandler = {};

var hasRequiredLoadBalancerChildHandler;

function requireLoadBalancerChildHandler () {
	if (hasRequiredLoadBalancerChildHandler) return loadBalancerChildHandler;
	hasRequiredLoadBalancerChildHandler = 1;
	/*
	 * Copyright 2020 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerChildHandler, "__esModule", { value: true });
	loadBalancerChildHandler.ChildLoadBalancerHandler = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = requireConnectivityState();
	const TYPE_NAME = 'child_load_balancer_helper';
	class ChildLoadBalancerHandler {
	    constructor(channelControlHelper, credentials, options) {
	        this.channelControlHelper = channelControlHelper;
	        this.credentials = credentials;
	        this.options = options;
	        this.currentChild = null;
	        this.pendingChild = null;
	        this.latestConfig = null;
	        this.ChildPolicyHelper = class {
	            constructor(parent) {
	                this.parent = parent;
	                this.child = null;
	            }
	            createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride) {
	                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
	            }
	            updateState(connectivityState, picker) {
	                var _a;
	                if (this.calledByPendingChild()) {
	                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
	                        return;
	                    }
	                    (_a = this.parent.currentChild) === null || _a === undefined ? undefined : _a.destroy();
	                    this.parent.currentChild = this.parent.pendingChild;
	                    this.parent.pendingChild = null;
	                }
	                else if (!this.calledByCurrentChild()) {
	                    return;
	                }
	                this.parent.channelControlHelper.updateState(connectivityState, picker);
	            }
	            requestReresolution() {
	                var _a;
	                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== undefined ? _a : this.parent.currentChild;
	                if (this.child === latestChild) {
	                    this.parent.channelControlHelper.requestReresolution();
	                }
	            }
	            setChild(newChild) {
	                this.child = newChild;
	            }
	            addChannelzChild(child) {
	                this.parent.channelControlHelper.addChannelzChild(child);
	            }
	            removeChannelzChild(child) {
	                this.parent.channelControlHelper.removeChannelzChild(child);
	            }
	            calledByPendingChild() {
	                return this.child === this.parent.pendingChild;
	            }
	            calledByCurrentChild() {
	                return this.child === this.parent.currentChild;
	            }
	        };
	    }
	    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
	        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
	    }
	    /**
	     * Prerequisites: lbConfig !== null and lbConfig.name is registered
	     * @param endpointList
	     * @param lbConfig
	     * @param attributes
	     */
	    updateAddressList(endpointList, lbConfig, attributes) {
	        let childToUpdate;
	        if (this.currentChild === null ||
	            this.latestConfig === null ||
	            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
	            const newHelper = new this.ChildPolicyHelper(this);
	            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper, this.credentials, this.options);
	            newHelper.setChild(newChild);
	            if (this.currentChild === null) {
	                this.currentChild = newChild;
	                childToUpdate = this.currentChild;
	            }
	            else {
	                if (this.pendingChild) {
	                    this.pendingChild.destroy();
	                }
	                this.pendingChild = newChild;
	                childToUpdate = this.pendingChild;
	            }
	        }
	        else {
	            if (this.pendingChild === null) {
	                childToUpdate = this.currentChild;
	            }
	            else {
	                childToUpdate = this.pendingChild;
	            }
	        }
	        this.latestConfig = lbConfig;
	        childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
	    }
	    exitIdle() {
	        if (this.currentChild) {
	            this.currentChild.exitIdle();
	            if (this.pendingChild) {
	                this.pendingChild.exitIdle();
	            }
	        }
	    }
	    resetBackoff() {
	        if (this.currentChild) {
	            this.currentChild.resetBackoff();
	            if (this.pendingChild) {
	                this.pendingChild.resetBackoff();
	            }
	        }
	    }
	    destroy() {
	        /* Note: state updates are only propagated from the child balancer if that
	         * object is equal to this.currentChild or this.pendingChild. Since this
	         * function sets both of those to null, no further state updates will
	         * occur after this function returns. */
	        if (this.currentChild) {
	            this.currentChild.destroy();
	            this.currentChild = null;
	        }
	        if (this.pendingChild) {
	            this.pendingChild.destroy();
	            this.pendingChild = null;
	        }
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerChildHandler.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
	
	return loadBalancerChildHandler;
}

var hasRequiredResolvingLoadBalancer;

function requireResolvingLoadBalancer () {
	if (hasRequiredResolvingLoadBalancer) return resolvingLoadBalancer;
	hasRequiredResolvingLoadBalancer = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(resolvingLoadBalancer, "__esModule", { value: true });
	resolvingLoadBalancer.ResolvingLoadBalancer = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const service_config_1 = requireServiceConfig();
	const connectivity_state_1 = requireConnectivityState();
	const resolver_1 = requireResolver();
	const picker_1 = requirePicker();
	const backoff_timeout_1 = requireBackoffTimeout();
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const logging = requireLogging();
	const constants_2 = requireConstants();
	const uri_parser_1 = requireUriParser();
	const load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
	const TRACER_NAME = 'resolving_load_balancer';
	function trace(text) {
	    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	/**
	 * Name match levels in order from most to least specific. This is the order in
	 * which searches will be performed.
	 */
	const NAME_MATCH_LEVEL_ORDER = [
	    'SERVICE_AND_METHOD',
	    'SERVICE',
	    'EMPTY',
	];
	function hasMatchingName(service, method, methodConfig, matchLevel) {
	    for (const name of methodConfig.name) {
	        switch (matchLevel) {
	            case 'EMPTY':
	                if (!name.service && !name.method) {
	                    return true;
	                }
	                break;
	            case 'SERVICE':
	                if (name.service === service && !name.method) {
	                    return true;
	                }
	                break;
	            case 'SERVICE_AND_METHOD':
	                if (name.service === service && name.method === method) {
	                    return true;
	                }
	        }
	    }
	    return false;
	}
	function findMatchingConfig(service, method, methodConfigs, matchLevel) {
	    for (const config of methodConfigs) {
	        if (hasMatchingName(service, method, config, matchLevel)) {
	            return config;
	        }
	    }
	    return null;
	}
	function getDefaultConfigSelector(serviceConfig) {
	    return function defaultConfigSelector(methodName, metadata) {
	        var _a, _b;
	        const splitName = methodName.split('/').filter(x => x.length > 0);
	        const service = (_a = splitName[0]) !== null && _a !== undefined ? _a : '';
	        const method = (_b = splitName[1]) !== null && _b !== undefined ? _b : '';
	        if (serviceConfig && serviceConfig.methodConfig) {
	            /* Check for the following in order, and return the first method
	             * config that matches:
	             * 1. A name that exactly matches the service and method
	             * 2. A name with no method set that matches the service
	             * 3. An empty name
	             */
	            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
	                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);
	                if (matchingConfig) {
	                    return {
	                        methodConfig: matchingConfig,
	                        pickInformation: {},
	                        status: constants_1.Status.OK,
	                        dynamicFilterFactories: [],
	                    };
	                }
	            }
	        }
	        return {
	            methodConfig: { name: [] },
	            pickInformation: {},
	            status: constants_1.Status.OK,
	            dynamicFilterFactories: [],
	        };
	    };
	}
	class ResolvingLoadBalancer {
	    /**
	     * Wrapper class that behaves like a `LoadBalancer` and also handles name
	     * resolution internally.
	     * @param target The address of the backend to connect to.
	     * @param channelControlHelper `ChannelControlHelper` instance provided by
	     *     this load balancer's owner.
	     * @param defaultServiceConfig The default service configuration to be used
	     *     if none is provided by the name resolver. A `null` value indicates
	     *     that the default behavior should be the default unconfigured behavior.
	     *     In practice, that means using the "pick first" load balancer
	     *     implmentation
	     */
	    constructor(target, channelControlHelper, credentials, channelOptions, onSuccessfulResolution, onFailedResolution) {
	        this.target = target;
	        this.channelControlHelper = channelControlHelper;
	        this.onSuccessfulResolution = onSuccessfulResolution;
	        this.onFailedResolution = onFailedResolution;
	        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
	        this.latestChildPicker = new picker_1.QueuePicker(this);
	        /**
	         * This resolving load balancer's current connectivity state.
	         */
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The service config object from the last successful resolution, if
	         * available. A value of null indicates that we have not yet received a valid
	         * service config from the resolver.
	         */
	        this.previousServiceConfig = null;
	        /**
	         * Indicates whether we should attempt to resolve again after the backoff
	         * timer runs out.
	         */
	        this.continueResolving = false;
	        if (channelOptions['grpc.service_config']) {
	            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));
	        }
	        else {
	            this.defaultServiceConfig = {
	                loadBalancingConfig: [],
	                methodConfig: [],
	            };
	        }
	        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
	            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
	            requestReresolution: () => {
	                /* If the backoffTimeout is running, we're still backing off from
	                 * making resolve requests, so we shouldn't make another one here.
	                 * In that case, the backoff timer callback will call
	                 * updateResolution */
	                if (this.backoffTimeout.isRunning()) {
	                    trace('requestReresolution delayed by backoff timer until ' +
	                        this.backoffTimeout.getEndTime().toISOString());
	                    this.continueResolving = true;
	                }
	                else {
	                    this.updateResolution();
	                }
	            },
	            updateState: (newState, picker) => {
	                this.latestChildState = newState;
	                this.latestChildPicker = picker;
	                this.updateState(newState, picker);
	            },
	            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
	            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),
	        }, credentials, channelOptions);
	        this.innerResolver = (0, resolver_1.createResolver)(target, {
	            onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
	                var _a;
	                this.backoffTimeout.stop();
	                this.backoffTimeout.reset();
	                let workingServiceConfig = null;
	                /* This first group of conditionals implements the algorithm described
	                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md
	                 * in the section called "Behavior on receiving a new gRPC Config".
	                 */
	                if (serviceConfig === null) {
	                    // Step 4 and 5
	                    if (serviceConfigError === null) {
	                        // Step 5
	                        this.previousServiceConfig = null;
	                        workingServiceConfig = this.defaultServiceConfig;
	                    }
	                    else {
	                        // Step 4
	                        if (this.previousServiceConfig === null) {
	                            // Step 4.ii
	                            this.handleResolutionFailure(serviceConfigError);
	                        }
	                        else {
	                            // Step 4.i
	                            workingServiceConfig = this.previousServiceConfig;
	                        }
	                    }
	                }
	                else {
	                    // Step 3
	                    workingServiceConfig = serviceConfig;
	                    this.previousServiceConfig = serviceConfig;
	                }
	                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === undefined ? undefined : workingServiceConfig.loadBalancingConfig) !== null && _a !== undefined ? _a : [];
	                const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
	                if (loadBalancingConfig === null) {
	                    // There were load balancing configs but none are supported. This counts as a resolution failure
	                    this.handleResolutionFailure({
	                        code: constants_1.Status.UNAVAILABLE,
	                        details: 'All load balancer options in service config are not compatible',
	                        metadata: new metadata_1.Metadata(),
	                    });
	                    return;
	                }
	                this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, attributes);
	                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== undefined ? workingServiceConfig : this.defaultServiceConfig;
	                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== undefined ? configSelector : getDefaultConfigSelector(finalServiceConfig));
	            },
	            onError: (error) => {
	                this.handleResolutionFailure(error);
	            },
	        }, channelOptions);
	        const backoffOptions = {
	            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
	            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
	        };
	        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
	            if (this.continueResolving) {
	                this.updateResolution();
	                this.continueResolving = false;
	            }
	            else {
	                this.updateState(this.latestChildState, this.latestChildPicker);
	            }
	        }, backoffOptions);
	        this.backoffTimeout.unref();
	    }
	    updateResolution() {
	        this.innerResolver.updateResolution();
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
	            /* this.latestChildPicker is initialized as new QueuePicker(this), which
	             * is an appropriate value here if the child LB policy is unset.
	             * Otherwise, we want to delegate to the child here, in case that
	             * triggers something. */
	            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker);
	        }
	        this.backoffTimeout.runOnce();
	    }
	    updateState(connectivityState, picker) {
	        trace((0, uri_parser_1.uriToString)(this.target) +
	            ' ' +
	            connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[connectivityState]);
	        // Ensure that this.exitIdle() is called by the picker
	        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
	            picker = new picker_1.QueuePicker(this, picker);
	        }
	        this.currentState = connectivityState;
	        this.channelControlHelper.updateState(connectivityState, picker);
	    }
	    handleResolutionFailure(error) {
	        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
	            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
	            this.onFailedResolution(error);
	        }
	    }
	    exitIdle() {
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||
	            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	            if (this.backoffTimeout.isRunning()) {
	                this.continueResolving = true;
	            }
	            else {
	                this.updateResolution();
	            }
	        }
	        this.childLoadBalancer.exitIdle();
	    }
	    updateAddressList(endpointList, lbConfig) {
	        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');
	    }
	    resetBackoff() {
	        this.backoffTimeout.reset();
	        this.childLoadBalancer.resetBackoff();
	    }
	    destroy() {
	        this.childLoadBalancer.destroy();
	        this.innerResolver.destroy();
	        this.backoffTimeout.reset();
	        this.backoffTimeout.stop();
	        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
	        this.latestChildPicker = new picker_1.QueuePicker(this);
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        this.previousServiceConfig = null;
	        this.continueResolving = false;
	    }
	    getTypeName() {
	        return 'resolving_load_balancer';
	    }
	}
	resolvingLoadBalancer.ResolvingLoadBalancer = ResolvingLoadBalancer;
	
	return resolvingLoadBalancer;
}

var subchannelPool = {};

var channelOptions = {};

var hasRequiredChannelOptions;

function requireChannelOptions () {
	if (hasRequiredChannelOptions) return channelOptions;
	hasRequiredChannelOptions = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelOptions, "__esModule", { value: true });
	channelOptions.channelOptionsEqual = channelOptions.recognizedOptions = undefined;
	/**
	 * This is for checking provided options at runtime. This is an object for
	 * easier membership checking.
	 */
	channelOptions.recognizedOptions = {
	    'grpc.ssl_target_name_override': true,
	    'grpc.primary_user_agent': true,
	    'grpc.secondary_user_agent': true,
	    'grpc.default_authority': true,
	    'grpc.keepalive_time_ms': true,
	    'grpc.keepalive_timeout_ms': true,
	    'grpc.keepalive_permit_without_calls': true,
	    'grpc.service_config': true,
	    'grpc.max_concurrent_streams': true,
	    'grpc.initial_reconnect_backoff_ms': true,
	    'grpc.max_reconnect_backoff_ms': true,
	    'grpc.use_local_subchannel_pool': true,
	    'grpc.max_send_message_length': true,
	    'grpc.max_receive_message_length': true,
	    'grpc.enable_http_proxy': true,
	    'grpc.enable_channelz': true,
	    'grpc.dns_min_time_between_resolutions_ms': true,
	    'grpc.enable_retries': true,
	    'grpc.per_rpc_retry_buffer_size': true,
	    'grpc.retry_buffer_size': true,
	    'grpc.max_connection_age_ms': true,
	    'grpc.max_connection_age_grace_ms': true,
	    'grpc-node.max_session_memory': true,
	    'grpc.service_config_disable_resolution': true,
	    'grpc.client_idle_timeout_ms': true,
	    'grpc-node.tls_enable_trace': true,
	    'grpc.lb.ring_hash.ring_size_cap': true,
	    'grpc-node.retry_max_attempts_limit': true,
	};
	function channelOptionsEqual(options1, options2) {
	    const keys1 = Object.keys(options1).sort();
	    const keys2 = Object.keys(options2).sort();
	    if (keys1.length !== keys2.length) {
	        return false;
	    }
	    for (let i = 0; i < keys1.length; i += 1) {
	        if (keys1[i] !== keys2[i]) {
	            return false;
	        }
	        if (options1[keys1[i]] !== options2[keys2[i]]) {
	            return false;
	        }
	    }
	    return true;
	}
	channelOptions.channelOptionsEqual = channelOptionsEqual;
	
	return channelOptions;
}

var subchannel = {};

var subchannelAddress = {};

var hasRequiredSubchannelAddress;

function requireSubchannelAddress () {
	if (hasRequiredSubchannelAddress) return subchannelAddress;
	hasRequiredSubchannelAddress = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelAddress, "__esModule", { value: true });
	subchannelAddress.EndpointMap = subchannelAddress.endpointHasAddress = subchannelAddress.endpointToString = subchannelAddress.endpointEqual = subchannelAddress.stringToSubchannelAddress = subchannelAddress.subchannelAddressToString = subchannelAddress.subchannelAddressEqual = subchannelAddress.isTcpSubchannelAddress = undefined;
	const net_1 = require$$0$a;
	function isTcpSubchannelAddress(address) {
	    return 'port' in address;
	}
	subchannelAddress.isTcpSubchannelAddress = isTcpSubchannelAddress;
	function subchannelAddressEqual(address1, address2) {
	    if (!address1 && !address2) {
	        return true;
	    }
	    if (!address1 || !address2) {
	        return false;
	    }
	    if (isTcpSubchannelAddress(address1)) {
	        return (isTcpSubchannelAddress(address2) &&
	            address1.host === address2.host &&
	            address1.port === address2.port);
	    }
	    else {
	        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
	    }
	}
	subchannelAddress.subchannelAddressEqual = subchannelAddressEqual;
	function subchannelAddressToString(address) {
	    if (isTcpSubchannelAddress(address)) {
	        if ((0, net_1.isIPv6)(address.host)) {
	            return '[' + address.host + ']:' + address.port;
	        }
	        else {
	            return address.host + ':' + address.port;
	        }
	    }
	    else {
	        return address.path;
	    }
	}
	subchannelAddress.subchannelAddressToString = subchannelAddressToString;
	const DEFAULT_PORT = 443;
	function stringToSubchannelAddress(addressString, port) {
	    if ((0, net_1.isIP)(addressString)) {
	        return {
	            host: addressString,
	            port: port !== null && port !== undefined ? port : DEFAULT_PORT,
	        };
	    }
	    else {
	        return {
	            path: addressString,
	        };
	    }
	}
	subchannelAddress.stringToSubchannelAddress = stringToSubchannelAddress;
	function endpointEqual(endpoint1, endpoint2) {
	    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
	        return false;
	    }
	    for (let i = 0; i < endpoint1.addresses.length; i++) {
	        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {
	            return false;
	        }
	    }
	    return true;
	}
	subchannelAddress.endpointEqual = endpointEqual;
	function endpointToString(endpoint) {
	    return ('[' + endpoint.addresses.map(subchannelAddressToString).join(', ') + ']');
	}
	subchannelAddress.endpointToString = endpointToString;
	function endpointHasAddress(endpoint, expectedAddress) {
	    for (const address of endpoint.addresses) {
	        if (subchannelAddressEqual(address, expectedAddress)) {
	            return true;
	        }
	    }
	    return false;
	}
	subchannelAddress.endpointHasAddress = endpointHasAddress;
	function endpointEqualUnordered(endpoint1, endpoint2) {
	    if (endpoint1.addresses.length !== endpoint2.addresses.length) {
	        return false;
	    }
	    for (const address1 of endpoint1.addresses) {
	        let matchFound = false;
	        for (const address2 of endpoint2.addresses) {
	            if (subchannelAddressEqual(address1, address2)) {
	                matchFound = true;
	                break;
	            }
	        }
	        if (!matchFound) {
	            return false;
	        }
	    }
	    return true;
	}
	class EndpointMap {
	    constructor() {
	        this.map = new Set();
	    }
	    get size() {
	        return this.map.size;
	    }
	    getForSubchannelAddress(address) {
	        for (const entry of this.map) {
	            if (endpointHasAddress(entry.key, address)) {
	                return entry.value;
	            }
	        }
	        return undefined;
	    }
	    /**
	     * Delete any entries in this map with keys that are not in endpoints
	     * @param endpoints
	     */
	    deleteMissing(endpoints) {
	        const removedValues = [];
	        for (const entry of this.map) {
	            let foundEntry = false;
	            for (const endpoint of endpoints) {
	                if (endpointEqualUnordered(endpoint, entry.key)) {
	                    foundEntry = true;
	                }
	            }
	            if (!foundEntry) {
	                removedValues.push(entry.value);
	                this.map.delete(entry);
	            }
	        }
	        return removedValues;
	    }
	    get(endpoint) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                return entry.value;
	            }
	        }
	        return undefined;
	    }
	    set(endpoint, mapEntry) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                entry.value = mapEntry;
	                return;
	            }
	        }
	        this.map.add({ key: endpoint, value: mapEntry });
	    }
	    delete(endpoint) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                this.map.delete(entry);
	                return;
	            }
	        }
	    }
	    has(endpoint) {
	        for (const entry of this.map) {
	            if (endpointEqualUnordered(endpoint, entry.key)) {
	                return true;
	            }
	        }
	        return false;
	    }
	    clear() {
	        this.map.clear();
	    }
	    *keys() {
	        for (const entry of this.map) {
	            yield entry.key;
	        }
	    }
	    *values() {
	        for (const entry of this.map) {
	            yield entry.value;
	        }
	    }
	    *entries() {
	        for (const entry of this.map) {
	            yield [entry.key, entry.value];
	        }
	    }
	}
	subchannelAddress.EndpointMap = EndpointMap;
	
	return subchannelAddress;
}

var channelz = {};

var extendStatics = function(e, r) {
    extendStatics = Object.setPrototypeOf || {
        __proto__: []
    } instanceof Array && function(e, r) {
        e.__proto__ = r;
    } || function(e, r) {
        for (var t in r) if (Object.prototype.hasOwnProperty.call(r, t)) e[t] = r[t];
    };
    return extendStatics(e, r);
};

function __extends$4(e, r) {
    if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
    extendStatics(e, r);
    function __() {
        this.constructor = e;
    }
    e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __);
}

function __generator$5(e, r) {
    var t = {
        label: 0,
        sent: function() {
            if (s[0] & 1) throw s[1];
            return s[1];
        },
        trys: [],
        ops: []
    }, i, n, s, h;
    return h = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
    }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
        return this;
    }), h;
    function verb(e) {
        return function(r) {
            return step([ e, r ]);
        };
    }
    function step(a) {
        if (i) throw new TypeError("Generator is already executing.");
        while (h && (h = 0, a[0] && (t = 0)), t) try {
            if (i = 1, n && (s = a[0] & 2 ? n["return"] : a[0] ? n["throw"] || ((s = n["return"]) && s.call(n), 
            0) : n.next) && !(s = s.call(n, a[1])).done) return s;
            if (n = 0, s) a = [ a[0] & 2, s.value ];
            switch (a[0]) {
              case 0:
              case 1:
                s = a;
                break;

              case 4:
                t.label++;
                return {
                    value: a[1],
                    done: false
                };

              case 5:
                t.label++;
                n = a[1];
                a = [ 0 ];
                continue;

              case 7:
                a = t.ops.pop();
                t.trys.pop();
                continue;

              default:
                if (!(s = t.trys, s = s.length > 0 && s[s.length - 1]) && (a[0] === 6 || a[0] === 2)) {
                    t = 0;
                    continue;
                }
                if (a[0] === 3 && (!s || a[1] > s[0] && a[1] < s[3])) {
                    t.label = a[1];
                    break;
                }
                if (a[0] === 6 && t.label < s[1]) {
                    t.label = s[1];
                    s = a;
                    break;
                }
                if (s && t.label < s[2]) {
                    t.label = s[2];
                    t.ops.push(a);
                    break;
                }
                if (s[2]) t.ops.pop();
                t.trys.pop();
                continue;
            }
            a = r.call(e, t);
        } catch (e) {
            a = [ 6, e ];
            n = 0;
        } finally {
            i = s = 0;
        }
        if (a[0] & 5) throw a[1];
        return {
            value: a[0] ? a[1] : undefined,
            done: true
        };
    }
}

typeof SuppressedError === "function" ? SuppressedError : function(e, r, t) {
    var i = new Error(t);
    return i.name = "SuppressedError", i.error = e, i.suppressed = r, i;
};

var TreeNode = function() {
    function TreeNode(e, r, t) {
        if (t === undefined) {
            t = 1;
        }
        this.t = undefined;
        this.i = undefined;
        this.h = undefined;
        this.u = e;
        this.o = r;
        this.l = t;
    }
    TreeNode.prototype.v = function() {
        var e = this;
        var r = e.h.h === e;
        if (r && e.l === 1) {
            e = e.i;
        } else if (e.t) {
            e = e.t;
            while (e.i) {
                e = e.i;
            }
        } else {
            if (r) {
                return e.h;
            }
            var t = e.h;
            while (t.t === e) {
                e = t;
                t = e.h;
            }
            e = t;
        }
        return e;
    };
    TreeNode.prototype.p = function() {
        var e = this;
        if (e.i) {
            e = e.i;
            while (e.t) {
                e = e.t;
            }
            return e;
        } else {
            var r = e.h;
            while (r.i === e) {
                e = r;
                r = e.h;
            }
            if (e.i !== r) {
                return r;
            } else return e;
        }
    };
    TreeNode.prototype.T = function() {
        var e = this.h;
        var r = this.i;
        var t = r.t;
        if (e.h === this) e.h = r; else if (e.t === this) e.t = r; else e.i = r;
        r.h = e;
        r.t = this;
        this.h = r;
        this.i = t;
        if (t) t.h = this;
        return r;
    };
    TreeNode.prototype.I = function() {
        var e = this.h;
        var r = this.t;
        var t = r.i;
        if (e.h === this) e.h = r; else if (e.t === this) e.t = r; else e.i = r;
        r.h = e;
        r.i = this;
        this.h = r;
        this.t = t;
        if (t) t.h = this;
        return r;
    };
    return TreeNode;
}();

var TreeNodeEnableIndex = function(e) {
    __extends$4(TreeNodeEnableIndex, e);
    function TreeNodeEnableIndex() {
        var r = e !== null && e.apply(this, arguments) || this;
        r.O = 1;
        return r;
    }
    TreeNodeEnableIndex.prototype.T = function() {
        var r = e.prototype.T.call(this);
        this.M();
        r.M();
        return r;
    };
    TreeNodeEnableIndex.prototype.I = function() {
        var r = e.prototype.I.call(this);
        this.M();
        r.M();
        return r;
    };
    TreeNodeEnableIndex.prototype.M = function() {
        this.O = 1;
        if (this.t) {
            this.O += this.t.O;
        }
        if (this.i) {
            this.O += this.i.O;
        }
    };
    return TreeNodeEnableIndex;
}(TreeNode);

var ContainerIterator = function() {
    function ContainerIterator(e) {
        if (e === undefined) {
            e = 0;
        }
        this.iteratorType = e;
    }
    ContainerIterator.prototype.equals = function(e) {
        return this.C === e.C;
    };
    return ContainerIterator;
}();

var Base = function() {
    function Base() {
        this._ = 0;
    }
    Object.defineProperty(Base.prototype, "length", {
        get: function() {
            return this._;
        },
        enumerable: false,
        configurable: true
    });
    Base.prototype.size = function() {
        return this._;
    };
    Base.prototype.empty = function() {
        return this._ === 0;
    };
    return Base;
}();

var Container = function(e) {
    __extends$4(Container, e);
    function Container() {
        return e !== null && e.apply(this, arguments) || this;
    }
    return Container;
}(Base);

function throwIteratorAccessError() {
    throw new RangeError("Iterator access denied!");
}

var TreeContainer = function(e) {
    __extends$4(TreeContainer, e);
    function TreeContainer(r, t) {
        if (r === undefined) {
            r = function(e, r) {
                if (e < r) return -1;
                if (e > r) return 1;
                return 0;
            };
        }
        if (t === undefined) {
            t = false;
        }
        var i = e.call(this) || this;
        i.N = undefined;
        i.g = r;
        i.enableIndex = t;
        i.S = t ? TreeNodeEnableIndex : TreeNode;
        i.A = new i.S;
        return i;
    }
    TreeContainer.prototype.m = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                e = e.i;
            } else if (i > 0) {
                t = e;
                e = e.t;
            } else return e;
        }
        return t;
    };
    TreeContainer.prototype.B = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i <= 0) {
                e = e.i;
            } else {
                t = e;
                e = e.t;
            }
        }
        return t;
    };
    TreeContainer.prototype.j = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                t = e;
                e = e.i;
            } else if (i > 0) {
                e = e.t;
            } else return e;
        }
        return t;
    };
    TreeContainer.prototype.k = function(e, r) {
        var t = this.A;
        while (e) {
            var i = this.g(e.u, r);
            if (i < 0) {
                t = e;
                e = e.i;
            } else {
                e = e.t;
            }
        }
        return t;
    };
    TreeContainer.prototype.R = function(e) {
        while (true) {
            var r = e.h;
            if (r === this.A) return;
            if (e.l === 1) {
                e.l = 0;
                return;
            }
            if (e === r.t) {
                var t = r.i;
                if (t.l === 1) {
                    t.l = 0;
                    r.l = 1;
                    if (r === this.N) {
                        this.N = r.T();
                    } else r.T();
                } else {
                    if (t.i && t.i.l === 1) {
                        t.l = r.l;
                        r.l = 0;
                        t.i.l = 0;
                        if (r === this.N) {
                            this.N = r.T();
                        } else r.T();
                        return;
                    } else if (t.t && t.t.l === 1) {
                        t.l = 1;
                        t.t.l = 0;
                        t.I();
                    } else {
                        t.l = 1;
                        e = r;
                    }
                }
            } else {
                var t = r.t;
                if (t.l === 1) {
                    t.l = 0;
                    r.l = 1;
                    if (r === this.N) {
                        this.N = r.I();
                    } else r.I();
                } else {
                    if (t.t && t.t.l === 1) {
                        t.l = r.l;
                        r.l = 0;
                        t.t.l = 0;
                        if (r === this.N) {
                            this.N = r.I();
                        } else r.I();
                        return;
                    } else if (t.i && t.i.l === 1) {
                        t.l = 1;
                        t.i.l = 0;
                        t.T();
                    } else {
                        t.l = 1;
                        e = r;
                    }
                }
            }
        }
    };
    TreeContainer.prototype.G = function(e) {
        if (this._ === 1) {
            this.clear();
            return;
        }
        var r = e;
        while (r.t || r.i) {
            if (r.i) {
                r = r.i;
                while (r.t) r = r.t;
            } else {
                r = r.t;
            }
            var t = e.u;
            e.u = r.u;
            r.u = t;
            var i = e.o;
            e.o = r.o;
            r.o = i;
            e = r;
        }
        if (this.A.t === r) {
            this.A.t = r.h;
        } else if (this.A.i === r) {
            this.A.i = r.h;
        }
        this.R(r);
        var n = r.h;
        if (r === n.t) {
            n.t = undefined;
        } else n.i = undefined;
        this._ -= 1;
        this.N.l = 0;
        if (this.enableIndex) {
            while (n !== this.A) {
                n.O -= 1;
                n = n.h;
            }
        }
    };
    TreeContainer.prototype.P = function(e) {
        var r = typeof e === "number" ? e : undefined;
        var t = typeof e === "function" ? e : undefined;
        var i = typeof e === "undefined" ? [] : undefined;
        var n = 0;
        var s = this.N;
        var h = [];
        while (h.length || s) {
            if (s) {
                h.push(s);
                s = s.t;
            } else {
                s = h.pop();
                if (n === r) return s;
                i && i.push(s);
                t && t(s, n, this);
                n += 1;
                s = s.i;
            }
        }
        return i;
    };
    TreeContainer.prototype.q = function(e) {
        while (true) {
            var r = e.h;
            if (r.l === 0) return;
            var t = r.h;
            if (r === t.t) {
                var i = t.i;
                if (i && i.l === 1) {
                    i.l = r.l = 0;
                    if (t === this.N) return;
                    t.l = 1;
                    e = t;
                    continue;
                } else if (e === r.i) {
                    e.l = 0;
                    if (e.t) {
                        e.t.h = r;
                    }
                    if (e.i) {
                        e.i.h = t;
                    }
                    r.i = e.t;
                    t.t = e.i;
                    e.t = r;
                    e.i = t;
                    if (t === this.N) {
                        this.N = e;
                        this.A.h = e;
                    } else {
                        var n = t.h;
                        if (n.t === t) {
                            n.t = e;
                        } else n.i = e;
                    }
                    e.h = t.h;
                    r.h = e;
                    t.h = e;
                    t.l = 1;
                } else {
                    r.l = 0;
                    if (t === this.N) {
                        this.N = t.I();
                    } else t.I();
                    t.l = 1;
                    return;
                }
            } else {
                var i = t.t;
                if (i && i.l === 1) {
                    i.l = r.l = 0;
                    if (t === this.N) return;
                    t.l = 1;
                    e = t;
                    continue;
                } else if (e === r.t) {
                    e.l = 0;
                    if (e.t) {
                        e.t.h = t;
                    }
                    if (e.i) {
                        e.i.h = r;
                    }
                    t.i = e.t;
                    r.t = e.i;
                    e.t = t;
                    e.i = r;
                    if (t === this.N) {
                        this.N = e;
                        this.A.h = e;
                    } else {
                        var n = t.h;
                        if (n.t === t) {
                            n.t = e;
                        } else n.i = e;
                    }
                    e.h = t.h;
                    r.h = e;
                    t.h = e;
                    t.l = 1;
                } else {
                    r.l = 0;
                    if (t === this.N) {
                        this.N = t.T();
                    } else t.T();
                    t.l = 1;
                    return;
                }
            }
            if (this.enableIndex) {
                r.M();
                t.M();
                e.M();
            }
            return;
        }
    };
    TreeContainer.prototype.D = function(e, r, t) {
        if (this.N === undefined) {
            this._ += 1;
            this.N = new this.S(e, r, 0);
            this.N.h = this.A;
            this.A.h = this.A.t = this.A.i = this.N;
            return this._;
        }
        var i;
        var n = this.A.t;
        var s = this.g(n.u, e);
        if (s === 0) {
            n.o = r;
            return this._;
        } else if (s > 0) {
            n.t = new this.S(e, r);
            n.t.h = n;
            i = n.t;
            this.A.t = i;
        } else {
            var h = this.A.i;
            var a = this.g(h.u, e);
            if (a === 0) {
                h.o = r;
                return this._;
            } else if (a < 0) {
                h.i = new this.S(e, r);
                h.i.h = h;
                i = h.i;
                this.A.i = i;
            } else {
                if (t !== undefined) {
                    var u = t.C;
                    if (u !== this.A) {
                        var f = this.g(u.u, e);
                        if (f === 0) {
                            u.o = r;
                            return this._;
                        } else if (f > 0) {
                            var o = u.v();
                            var d = this.g(o.u, e);
                            if (d === 0) {
                                o.o = r;
                                return this._;
                            } else if (d < 0) {
                                i = new this.S(e, r);
                                if (o.i === undefined) {
                                    o.i = i;
                                    i.h = o;
                                } else {
                                    u.t = i;
                                    i.h = u;
                                }
                            }
                        }
                    }
                }
                if (i === undefined) {
                    i = this.N;
                    while (true) {
                        var c = this.g(i.u, e);
                        if (c > 0) {
                            if (i.t === undefined) {
                                i.t = new this.S(e, r);
                                i.t.h = i;
                                i = i.t;
                                break;
                            }
                            i = i.t;
                        } else if (c < 0) {
                            if (i.i === undefined) {
                                i.i = new this.S(e, r);
                                i.i.h = i;
                                i = i.i;
                                break;
                            }
                            i = i.i;
                        } else {
                            i.o = r;
                            return this._;
                        }
                    }
                }
            }
        }
        if (this.enableIndex) {
            var l = i.h;
            while (l !== this.A) {
                l.O += 1;
                l = l.h;
            }
        }
        this.q(i);
        this._ += 1;
        return this._;
    };
    TreeContainer.prototype.F = function(e, r) {
        while (e) {
            var t = this.g(e.u, r);
            if (t < 0) {
                e = e.i;
            } else if (t > 0) {
                e = e.t;
            } else return e;
        }
        return e || this.A;
    };
    TreeContainer.prototype.clear = function() {
        this._ = 0;
        this.N = undefined;
        this.A.h = undefined;
        this.A.t = this.A.i = undefined;
    };
    TreeContainer.prototype.updateKeyByIterator = function(e, r) {
        var t = e.C;
        if (t === this.A) {
            throwIteratorAccessError();
        }
        if (this._ === 1) {
            t.u = r;
            return true;
        }
        var i = t.p().u;
        if (t === this.A.t) {
            if (this.g(i, r) > 0) {
                t.u = r;
                return true;
            }
            return false;
        }
        var n = t.v().u;
        if (t === this.A.i) {
            if (this.g(n, r) < 0) {
                t.u = r;
                return true;
            }
            return false;
        }
        if (this.g(n, r) >= 0 || this.g(i, r) <= 0) return false;
        t.u = r;
        return true;
    };
    TreeContainer.prototype.eraseElementByPos = function(e) {
        if (e < 0 || e > this._ - 1) {
            throw new RangeError;
        }
        var r = this.P(e);
        this.G(r);
        return this._;
    };
    TreeContainer.prototype.eraseElementByKey = function(e) {
        if (this._ === 0) return false;
        var r = this.F(this.N, e);
        if (r === this.A) return false;
        this.G(r);
        return true;
    };
    TreeContainer.prototype.eraseElementByIterator = function(e) {
        var r = e.C;
        if (r === this.A) {
            throwIteratorAccessError();
        }
        var t = r.i === undefined;
        var i = e.iteratorType === 0;
        if (i) {
            if (t) e.next();
        } else {
            if (!t || r.t === undefined) e.next();
        }
        this.G(r);
        return e;
    };
    TreeContainer.prototype.getHeight = function() {
        if (this._ === 0) return 0;
        function traversal(e) {
            if (!e) return 0;
            return Math.max(traversal(e.t), traversal(e.i)) + 1;
        }
        return traversal(this.N);
    };
    return TreeContainer;
}(Container);

var TreeIterator = function(e) {
    __extends$4(TreeIterator, e);
    function TreeIterator(r, t, i) {
        var n = e.call(this, i) || this;
        n.C = r;
        n.A = t;
        if (n.iteratorType === 0) {
            n.pre = function() {
                if (this.C === this.A.t) {
                    throwIteratorAccessError();
                }
                this.C = this.C.v();
                return this;
            };
            n.next = function() {
                if (this.C === this.A) {
                    throwIteratorAccessError();
                }
                this.C = this.C.p();
                return this;
            };
        } else {
            n.pre = function() {
                if (this.C === this.A.i) {
                    throwIteratorAccessError();
                }
                this.C = this.C.p();
                return this;
            };
            n.next = function() {
                if (this.C === this.A) {
                    throwIteratorAccessError();
                }
                this.C = this.C.v();
                return this;
            };
        }
        return n;
    }
    Object.defineProperty(TreeIterator.prototype, "index", {
        get: function() {
            var e = this.C;
            var r = this.A.h;
            if (e === this.A) {
                if (r) {
                    return r.O - 1;
                }
                return 0;
            }
            var t = 0;
            if (e.t) {
                t += e.t.O;
            }
            while (e !== r) {
                var i = e.h;
                if (e === i.i) {
                    t += 1;
                    if (i.t) {
                        t += i.t.O;
                    }
                }
                e = i;
            }
            return t;
        },
        enumerable: false,
        configurable: true
    });
    TreeIterator.prototype.isAccessible = function() {
        return this.C !== this.A;
    };
    return TreeIterator;
}(ContainerIterator);

var OrderedMapIterator = function(e) {
    __extends$4(OrderedMapIterator, e);
    function OrderedMapIterator(r, t, i, n) {
        var s = e.call(this, r, t, n) || this;
        s.container = i;
        return s;
    }
    Object.defineProperty(OrderedMapIterator.prototype, "pointer", {
        get: function() {
            if (this.C === this.A) {
                throwIteratorAccessError();
            }
            var e = this;
            return new Proxy([], {
                get: function(r, t) {
                    if (t === "0") return e.C.u; else if (t === "1") return e.C.o;
                    r[0] = e.C.u;
                    r[1] = e.C.o;
                    return r[t];
                },
                set: function(r, t, i) {
                    if (t !== "1") {
                        throw new TypeError("prop must be 1");
                    }
                    e.C.o = i;
                    return true;
                }
            });
        },
        enumerable: false,
        configurable: true
    });
    OrderedMapIterator.prototype.copy = function() {
        return new OrderedMapIterator(this.C, this.A, this.container, this.iteratorType);
    };
    return OrderedMapIterator;
}(TreeIterator);

var OrderedMap = function(e) {
    __extends$4(OrderedMap, e);
    function OrderedMap(r, t, i) {
        if (r === undefined) {
            r = [];
        }
        var n = e.call(this, t, i) || this;
        var s = n;
        r.forEach((function(e) {
            s.setElement(e[0], e[1]);
        }));
        return n;
    }
    OrderedMap.prototype.begin = function() {
        return new OrderedMapIterator(this.A.t || this.A, this.A, this);
    };
    OrderedMap.prototype.end = function() {
        return new OrderedMapIterator(this.A, this.A, this);
    };
    OrderedMap.prototype.rBegin = function() {
        return new OrderedMapIterator(this.A.i || this.A, this.A, this, 1);
    };
    OrderedMap.prototype.rEnd = function() {
        return new OrderedMapIterator(this.A, this.A, this, 1);
    };
    OrderedMap.prototype.front = function() {
        if (this._ === 0) return;
        var e = this.A.t;
        return [ e.u, e.o ];
    };
    OrderedMap.prototype.back = function() {
        if (this._ === 0) return;
        var e = this.A.i;
        return [ e.u, e.o ];
    };
    OrderedMap.prototype.lowerBound = function(e) {
        var r = this.m(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.upperBound = function(e) {
        var r = this.B(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.reverseLowerBound = function(e) {
        var r = this.j(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.reverseUpperBound = function(e) {
        var r = this.k(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.forEach = function(e) {
        this.P((function(r, t, i) {
            e([ r.u, r.o ], t, i);
        }));
    };
    OrderedMap.prototype.setElement = function(e, r, t) {
        return this.D(e, r, t);
    };
    OrderedMap.prototype.getElementByPos = function(e) {
        if (e < 0 || e > this._ - 1) {
            throw new RangeError;
        }
        var r = this.P(e);
        return [ r.u, r.o ];
    };
    OrderedMap.prototype.find = function(e) {
        var r = this.F(this.N, e);
        return new OrderedMapIterator(r, this.A, this);
    };
    OrderedMap.prototype.getElementByKey = function(e) {
        var r = this.F(this.N, e);
        return r.o;
    };
    OrderedMap.prototype.union = function(e) {
        var r = this;
        e.forEach((function(e) {
            r.setElement(e[0], e[1]);
        }));
        return this._;
    };
    OrderedMap.prototype[Symbol.iterator] = function() {
        var e, r, t, i;
        return __generator$5(this, (function(n) {
            switch (n.label) {
              case 0:
                e = this._;
                r = this.P();
                t = 0;
                n.label = 1;

              case 1:
                if (!(t < e)) return [ 3, 4 ];
                i = r[t];
                return [ 4, [ i.u, i.o ] ];

              case 2:
                n.sent();
                n.label = 3;

              case 3:
                ++t;
                return [ 3, 1 ];

              case 4:
                return [ 2 ];
            }
        }));
    };
    return OrderedMap;
}(TreeContainer);

var esm$3 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	OrderedMap: OrderedMap
});

var require$$1$1 = /*@__PURE__*/getAugmentedNamespace(esm$3);

var admin = {};

var hasRequiredAdmin;

function requireAdmin () {
	if (hasRequiredAdmin) return admin;
	hasRequiredAdmin = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(admin, "__esModule", { value: true });
	admin.addAdminServicesToServer = admin.registerAdminService = undefined;
	const registeredAdminServices = [];
	function registerAdminService(getServiceDefinition, getHandlers) {
	    registeredAdminServices.push({ getServiceDefinition, getHandlers });
	}
	admin.registerAdminService = registerAdminService;
	function addAdminServicesToServer(server) {
	    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
	        server.addService(getServiceDefinition(), getHandlers());
	    }
	}
	admin.addAdminServicesToServer = addAdminServicesToServer;
	
	return admin;
}

var makeClient = {};

var client = {};

var call = {};

var hasRequiredCall;

function requireCall () {
	if (hasRequiredCall) return call;
	hasRequiredCall = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(call, "__esModule", { value: true });
	call.ClientDuplexStreamImpl = call.ClientWritableStreamImpl = call.ClientReadableStreamImpl = call.ClientUnaryCallImpl = call.callErrorFromStatus = undefined;
	const events_1 = require$$0$6;
	const stream_1 = require$$0$9;
	const constants_1 = requireConstants();
	/**
	 * Construct a ServiceError from a StatusObject. This function exists primarily
	 * as an attempt to make the error stack trace clearly communicate that the
	 * error is not necessarily a problem in gRPC itself.
	 * @param status
	 */
	function callErrorFromStatus(status, callerStack) {
	    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
	    const error = new Error(message);
	    const stack = `${error.stack}\nfor call at\n${callerStack}`;
	    return Object.assign(new Error(message), status, { stack });
	}
	call.callErrorFromStatus = callErrorFromStatus;
	class ClientUnaryCallImpl extends events_1.EventEmitter {
	    constructor() {
	        super();
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	}
	call.ClientUnaryCallImpl = ClientUnaryCallImpl;
	class ClientReadableStreamImpl extends stream_1.Readable {
	    constructor(deserialize) {
	        super({ objectMode: true });
	        this.deserialize = deserialize;
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	    _read(_size) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.startRead();
	    }
	}
	call.ClientReadableStreamImpl = ClientReadableStreamImpl;
	class ClientWritableStreamImpl extends stream_1.Writable {
	    constructor(serialize) {
	        super({ objectMode: true });
	        this.serialize = serialize;
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	    _write(chunk, encoding, cb) {
	        var _a;
	        const context = {
	            callback: cb,
	        };
	        const flags = Number(encoding);
	        if (!Number.isNaN(flags)) {
	            context.flags = flags;
	        }
	        (_a = this.call) === null || _a === undefined ? undefined : _a.sendMessageWithContext(context, chunk);
	    }
	    _final(cb) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.halfClose();
	        cb();
	    }
	}
	call.ClientWritableStreamImpl = ClientWritableStreamImpl;
	class ClientDuplexStreamImpl extends stream_1.Duplex {
	    constructor(serialize, deserialize) {
	        super({ objectMode: true });
	        this.serialize = serialize;
	        this.deserialize = deserialize;
	    }
	    cancel() {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.call) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : 'unknown';
	    }
	    _read(_size) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.startRead();
	    }
	    _write(chunk, encoding, cb) {
	        var _a;
	        const context = {
	            callback: cb,
	        };
	        const flags = Number(encoding);
	        if (!Number.isNaN(flags)) {
	            context.flags = flags;
	        }
	        (_a = this.call) === null || _a === undefined ? undefined : _a.sendMessageWithContext(context, chunk);
	    }
	    _final(cb) {
	        var _a;
	        (_a = this.call) === null || _a === undefined ? undefined : _a.halfClose();
	        cb();
	    }
	}
	call.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
	
	return call;
}

var clientInterceptors = {};

var callInterface = {};

var hasRequiredCallInterface;

function requireCallInterface () {
	if (hasRequiredCallInterface) return callInterface;
	hasRequiredCallInterface = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callInterface, "__esModule", { value: true });
	callInterface.InterceptingListenerImpl = callInterface.isInterceptingListener = undefined;
	function isInterceptingListener(listener) {
	    return (listener.onReceiveMetadata !== undefined &&
	        listener.onReceiveMetadata.length === 1);
	}
	callInterface.isInterceptingListener = isInterceptingListener;
	class InterceptingListenerImpl {
	    constructor(listener, nextListener) {
	        this.listener = listener;
	        this.nextListener = nextListener;
	        this.processingMetadata = false;
	        this.hasPendingMessage = false;
	        this.processingMessage = false;
	        this.pendingStatus = null;
	    }
	    processPendingMessage() {
	        if (this.hasPendingMessage) {
	            this.nextListener.onReceiveMessage(this.pendingMessage);
	            this.pendingMessage = null;
	            this.hasPendingMessage = false;
	        }
	    }
	    processPendingStatus() {
	        if (this.pendingStatus) {
	            this.nextListener.onReceiveStatus(this.pendingStatus);
	        }
	    }
	    onReceiveMetadata(metadata) {
	        this.processingMetadata = true;
	        this.listener.onReceiveMetadata(metadata, metadata => {
	            this.processingMetadata = false;
	            this.nextListener.onReceiveMetadata(metadata);
	            this.processPendingMessage();
	            this.processPendingStatus();
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    onReceiveMessage(message) {
	        /* If this listener processes messages asynchronously, the last message may
	         * be reordered with respect to the status */
	        this.processingMessage = true;
	        this.listener.onReceiveMessage(message, msg => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessage = msg;
	                this.hasPendingMessage = true;
	            }
	            else {
	                this.nextListener.onReceiveMessage(msg);
	                this.processPendingStatus();
	            }
	        });
	    }
	    onReceiveStatus(status) {
	        this.listener.onReceiveStatus(status, processedStatus => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingStatus = processedStatus;
	            }
	            else {
	                this.nextListener.onReceiveStatus(processedStatus);
	            }
	        });
	    }
	}
	callInterface.InterceptingListenerImpl = InterceptingListenerImpl;
	
	return callInterface;
}

var hasRequiredClientInterceptors;

function requireClientInterceptors () {
	if (hasRequiredClientInterceptors) return clientInterceptors;
	hasRequiredClientInterceptors = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(clientInterceptors, "__esModule", { value: true });
	clientInterceptors.getInterceptingCall = clientInterceptors.InterceptingCall = clientInterceptors.RequesterBuilder = clientInterceptors.ListenerBuilder = clientInterceptors.InterceptorConfigurationError = undefined;
	const metadata_1 = requireMetadata();
	const call_interface_1 = requireCallInterface();
	const constants_1 = requireConstants();
	const error_1 = requireError();
	/**
	 * Error class associated with passing both interceptors and interceptor
	 * providers to a client constructor or as call options.
	 */
	class InterceptorConfigurationError extends Error {
	    constructor(message) {
	        super(message);
	        this.name = 'InterceptorConfigurationError';
	        Error.captureStackTrace(this, InterceptorConfigurationError);
	    }
	}
	clientInterceptors.InterceptorConfigurationError = InterceptorConfigurationError;
	class ListenerBuilder {
	    constructor() {
	        this.metadata = undefined;
	        this.message = undefined;
	        this.status = undefined;
	    }
	    withOnReceiveMetadata(onReceiveMetadata) {
	        this.metadata = onReceiveMetadata;
	        return this;
	    }
	    withOnReceiveMessage(onReceiveMessage) {
	        this.message = onReceiveMessage;
	        return this;
	    }
	    withOnReceiveStatus(onReceiveStatus) {
	        this.status = onReceiveStatus;
	        return this;
	    }
	    build() {
	        return {
	            onReceiveMetadata: this.metadata,
	            onReceiveMessage: this.message,
	            onReceiveStatus: this.status,
	        };
	    }
	}
	clientInterceptors.ListenerBuilder = ListenerBuilder;
	class RequesterBuilder {
	    constructor() {
	        this.start = undefined;
	        this.message = undefined;
	        this.halfClose = undefined;
	        this.cancel = undefined;
	    }
	    withStart(start) {
	        this.start = start;
	        return this;
	    }
	    withSendMessage(sendMessage) {
	        this.message = sendMessage;
	        return this;
	    }
	    withHalfClose(halfClose) {
	        this.halfClose = halfClose;
	        return this;
	    }
	    withCancel(cancel) {
	        this.cancel = cancel;
	        return this;
	    }
	    build() {
	        return {
	            start: this.start,
	            sendMessage: this.message,
	            halfClose: this.halfClose,
	            cancel: this.cancel,
	        };
	    }
	}
	clientInterceptors.RequesterBuilder = RequesterBuilder;
	/**
	 * A Listener with a default pass-through implementation of each method. Used
	 * for filling out Listeners with some methods omitted.
	 */
	const defaultListener = {
	    onReceiveMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    onReceiveMessage: (message, next) => {
	        next(message);
	    },
	    onReceiveStatus: (status, next) => {
	        next(status);
	    },
	};
	/**
	 * A Requester with a default pass-through implementation of each method. Used
	 * for filling out Requesters with some methods omitted.
	 */
	const defaultRequester = {
	    start: (metadata, listener, next) => {
	        next(metadata, listener);
	    },
	    sendMessage: (message, next) => {
	        next(message);
	    },
	    halfClose: next => {
	        next();
	    },
	    cancel: next => {
	        next();
	    },
	};
	class InterceptingCall {
	    constructor(nextCall, requester) {
	        var _a, _b, _c, _d;
	        this.nextCall = nextCall;
	        /**
	         * Indicates that metadata has been passed to the requester's start
	         * method but it has not been passed to the corresponding next callback
	         */
	        this.processingMetadata = false;
	        /**
	         * Message context for a pending message that is waiting for
	         */
	        this.pendingMessageContext = null;
	        /**
	         * Indicates that a message has been passed to the requester's sendMessage
	         * method but it has not been passed to the corresponding next callback
	         */
	        this.processingMessage = false;
	        /**
	         * Indicates that a status was received but could not be propagated because
	         * a message was still being processed.
	         */
	        this.pendingHalfClose = false;
	        if (requester) {
	            this.requester = {
	                start: (_a = requester.start) !== null && _a !== undefined ? _a : defaultRequester.start,
	                sendMessage: (_b = requester.sendMessage) !== null && _b !== undefined ? _b : defaultRequester.sendMessage,
	                halfClose: (_c = requester.halfClose) !== null && _c !== undefined ? _c : defaultRequester.halfClose,
	                cancel: (_d = requester.cancel) !== null && _d !== undefined ? _d : defaultRequester.cancel,
	            };
	        }
	        else {
	            this.requester = defaultRequester;
	        }
	    }
	    cancelWithStatus(status, details) {
	        this.requester.cancel(() => {
	            this.nextCall.cancelWithStatus(status, details);
	        });
	    }
	    getPeer() {
	        return this.nextCall.getPeer();
	    }
	    processPendingMessage() {
	        if (this.pendingMessageContext) {
	            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
	            this.pendingMessageContext = null;
	            this.pendingMessage = null;
	        }
	    }
	    processPendingHalfClose() {
	        if (this.pendingHalfClose) {
	            this.nextCall.halfClose();
	        }
	    }
	    start(metadata, interceptingListener) {
	        var _a, _b, _c, _d, _e, _f;
	        const fullInterceptingListener = {
	            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.bind(interceptingListener)) !== null && _b !== undefined ? _b : (metadata => { }),
	            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMessage) === null || _c === undefined ? undefined : _c.bind(interceptingListener)) !== null && _d !== undefined ? _d : (message => { }),
	            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _e === undefined ? undefined : _e.bind(interceptingListener)) !== null && _f !== undefined ? _f : (status => { }),
	        };
	        this.processingMetadata = true;
	        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
	            var _a, _b, _c;
	            this.processingMetadata = false;
	            let finalInterceptingListener;
	            if ((0, call_interface_1.isInterceptingListener)(listener)) {
	                finalInterceptingListener = listener;
	            }
	            else {
	                const fullListener = {
	                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== undefined ? _a : defaultListener.onReceiveMetadata,
	                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== undefined ? _b : defaultListener.onReceiveMessage,
	                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== undefined ? _c : defaultListener.onReceiveStatus,
	                };
	                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
	            }
	            this.nextCall.start(md, finalInterceptingListener);
	            this.processPendingMessage();
	            this.processPendingHalfClose();
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessageWithContext(context, message) {
	        this.processingMessage = true;
	        this.requester.sendMessage(message, finalMessage => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessageContext = context;
	                this.pendingMessage = message;
	            }
	            else {
	                this.nextCall.sendMessageWithContext(context, finalMessage);
	                this.processPendingHalfClose();
	            }
	        });
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessage(message) {
	        this.sendMessageWithContext({}, message);
	    }
	    startRead() {
	        this.nextCall.startRead();
	    }
	    halfClose() {
	        this.requester.halfClose(() => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingHalfClose = true;
	            }
	            else {
	                this.nextCall.halfClose();
	            }
	        });
	    }
	}
	clientInterceptors.InterceptingCall = InterceptingCall;
	function getCall(channel, path, options) {
	    var _a, _b;
	    const deadline = (_a = options.deadline) !== null && _a !== undefined ? _a : Infinity;
	    const host = options.host;
	    const parent = (_b = options.parent) !== null && _b !== undefined ? _b : null;
	    const propagateFlags = options.propagate_flags;
	    const credentials = options.credentials;
	    const call = channel.createCall(path, deadline, host, parent, propagateFlags);
	    if (credentials) {
	        call.setCredentials(credentials);
	    }
	    return call;
	}
	/**
	 * InterceptingCall implementation that directly owns the underlying Call
	 * object and handles serialization and deseraizliation.
	 */
	class BaseInterceptingCall {
	    constructor(call, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    methodDefinition) {
	        this.call = call;
	        this.methodDefinition = methodDefinition;
	    }
	    cancelWithStatus(status, details) {
	        this.call.cancelWithStatus(status, details);
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessageWithContext(context, message) {
	        let serialized;
	        try {
	            serialized = this.methodDefinition.requestSerialize(message);
	        }
	        catch (e) {
	            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);
	            return;
	        }
	        this.call.sendMessageWithContext(context, serialized);
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    sendMessage(message) {
	        this.sendMessageWithContext({}, message);
	    }
	    start(metadata, interceptingListener) {
	        let readError = null;
	        this.call.start(metadata, {
	            onReceiveMetadata: metadata => {
	                var _a;
	                (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.call(interceptingListener, metadata);
	            },
	            onReceiveMessage: message => {
	                var _a;
	                // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                let deserialized;
	                try {
	                    deserialized = this.methodDefinition.responseDeserialize(message);
	                }
	                catch (e) {
	                    readError = {
	                        code: constants_1.Status.INTERNAL,
	                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,
	                        metadata: new metadata_1.Metadata(),
	                    };
	                    this.call.cancelWithStatus(readError.code, readError.details);
	                    return;
	                }
	                (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveMessage) === null || _a === undefined ? undefined : _a.call(interceptingListener, deserialized);
	            },
	            onReceiveStatus: status => {
	                var _a, _b;
	                if (readError) {
	                    (_a = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _a === undefined ? undefined : _a.call(interceptingListener, readError);
	                }
	                else {
	                    (_b = interceptingListener === null || interceptingListener === undefined ? undefined : interceptingListener.onReceiveStatus) === null || _b === undefined ? undefined : _b.call(interceptingListener, status);
	                }
	            },
	        });
	    }
	    startRead() {
	        this.call.startRead();
	    }
	    halfClose() {
	        this.call.halfClose();
	    }
	}
	/**
	 * BaseInterceptingCall with special-cased behavior for methods with unary
	 * responses.
	 */
	class BaseUnaryInterceptingCall extends BaseInterceptingCall {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    constructor(call, methodDefinition) {
	        super(call, methodDefinition);
	    }
	    start(metadata, listener) {
	        var _a, _b;
	        let receivedMessage = false;
	        const wrapperListener = {
	            onReceiveMetadata: (_b = (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMetadata) === null || _a === undefined ? undefined : _a.bind(listener)) !== null && _b !== undefined ? _b : (metadata => { }),
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage: (message) => {
	                var _a;
	                receivedMessage = true;
	                (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMessage) === null || _a === undefined ? undefined : _a.call(listener, message);
	            },
	            onReceiveStatus: (status) => {
	                var _a, _b;
	                if (!receivedMessage) {
	                    (_a = listener === null || listener === undefined ? undefined : listener.onReceiveMessage) === null || _a === undefined ? undefined : _a.call(listener, null);
	                }
	                (_b = listener === null || listener === undefined ? undefined : listener.onReceiveStatus) === null || _b === undefined ? undefined : _b.call(listener, status);
	            },
	        };
	        super.start(metadata, wrapperListener);
	        this.call.startRead();
	    }
	}
	/**
	 * BaseInterceptingCall with special-cased behavior for methods with streaming
	 * responses.
	 */
	class BaseStreamingInterceptingCall extends BaseInterceptingCall {
	}
	function getBottomInterceptingCall(channel, options, 
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	methodDefinition) {
	    const call = getCall(channel, methodDefinition.path, options);
	    if (methodDefinition.responseStream) {
	        return new BaseStreamingInterceptingCall(call, methodDefinition);
	    }
	    else {
	        return new BaseUnaryInterceptingCall(call, methodDefinition);
	    }
	}
	function getInterceptingCall(interceptorArgs, 
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	methodDefinition, options, channel) {
	    if (interceptorArgs.clientInterceptors.length > 0 &&
	        interceptorArgs.clientInterceptorProviders.length > 0) {
	        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +
	            'to the client constructor. Only one of these is allowed.');
	    }
	    if (interceptorArgs.callInterceptors.length > 0 &&
	        interceptorArgs.callInterceptorProviders.length > 0) {
	        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +
	            'options. Only one of these is allowed.');
	    }
	    let interceptors = [];
	    // Interceptors passed to the call override interceptors passed to the client constructor
	    if (interceptorArgs.callInterceptors.length > 0 ||
	        interceptorArgs.callInterceptorProviders.length > 0) {
	        interceptors = []
	            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))
	            .filter(interceptor => interceptor);
	        // Filter out falsy values when providers return nothing
	    }
	    else {
	        interceptors = []
	            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))
	            .filter(interceptor => interceptor);
	        // Filter out falsy values when providers return nothing
	    }
	    const interceptorOptions = Object.assign({}, options, {
	        method_definition: methodDefinition,
	    });
	    /* For each interceptor in the list, the nextCall function passed to it is
	     * based on the next interceptor in the list, using a nextCall function
	     * constructed with the following interceptor in the list, and so on. The
	     * initialValue, which is effectively at the end of the list, is a nextCall
	     * function that invokes getBottomInterceptingCall, the result of which
	     * handles (de)serialization and also gets the underlying call from the
	     * channel. */
	    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {
	        return currentOptions => nextInterceptor(currentOptions, nextCall);
	    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
	    return getCall(interceptorOptions);
	}
	clientInterceptors.getInterceptingCall = getInterceptingCall;
	
	return clientInterceptors;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client;
	hasRequiredClient = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(client, "__esModule", { value: true });
	client.Client = undefined;
	const call_1 = requireCall();
	const channel_1 = requireChannel();
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const client_interceptors_1 = requireClientInterceptors();
	const CHANNEL_SYMBOL = Symbol();
	const INTERCEPTOR_SYMBOL = Symbol();
	const INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
	const CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
	function isFunction(arg) {
	    return typeof arg === 'function';
	}
	function getErrorStackString(error) {
	    var _a;
	    return ((_a = error.stack) === null || _a === undefined ? undefined : _a.split('\n').slice(1).join('\n')) || 'no stack trace available';
	}
	/**
	 * A generic gRPC client. Primarily useful as a base class for all generated
	 * clients.
	 */
	class Client {
	    constructor(address, credentials, options = {}) {
	        var _a, _b;
	        options = Object.assign({}, options);
	        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== undefined ? _a : [];
	        delete options.interceptors;
	        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== undefined ? _b : [];
	        delete options.interceptor_providers;
	        if (this[INTERCEPTOR_SYMBOL].length > 0 &&
	            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
	            throw new Error('Both interceptors and interceptor_providers were passed as options ' +
	                'to the client constructor. Only one of these is allowed.');
	        }
	        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =
	            options.callInvocationTransformer;
	        delete options.callInvocationTransformer;
	        if (options.channelOverride) {
	            this[CHANNEL_SYMBOL] = options.channelOverride;
	        }
	        else if (options.channelFactoryOverride) {
	            const channelFactoryOverride = options.channelFactoryOverride;
	            delete options.channelFactoryOverride;
	            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
	        }
	        else {
	            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
	        }
	    }
	    close() {
	        this[CHANNEL_SYMBOL].close();
	    }
	    getChannel() {
	        return this[CHANNEL_SYMBOL];
	    }
	    waitForReady(deadline, callback) {
	        const checkState = (err) => {
	            if (err) {
	                callback(new Error('Failed to connect before the deadline'));
	                return;
	            }
	            let newState;
	            try {
	                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
	            }
	            catch (e) {
	                callback(new Error('The channel has been closed'));
	                return;
	            }
	            if (newState === connectivity_state_1.ConnectivityState.READY) {
	                callback();
	            }
	            else {
	                try {
	                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
	                }
	                catch (e) {
	                    callback(new Error('The channel has been closed'));
	                }
	            }
	        };
	        setImmediate(checkState);
	    }
	    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
	        if (isFunction(arg1)) {
	            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
	        }
	        else if (isFunction(arg2)) {
	            if (arg1 instanceof metadata_1.Metadata) {
	                return { metadata: arg1, options: {}, callback: arg2 };
	            }
	            else {
	                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
	            }
	        }
	        else {
	            if (!(arg1 instanceof metadata_1.Metadata &&
	                arg2 instanceof Object &&
	                isFunction(arg3))) {
	                throw new Error('Incorrect arguments passed');
	            }
	            return { metadata: arg1, options: arg2, callback: arg3 };
	        }
	    }
	    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
	        var _a, _b;
	        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
	        const methodDefinition = {
	            path: method,
	            requestStream: false,
	            responseStream: false,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            argument: argument,
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientUnaryCallImpl(),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	            callback: checkedArguments.callback,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const emitter = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        emitter.call = call;
	        let responseMessage = null;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata: metadata => {
	                emitter.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                if (responseMessage !== null) {
	                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');
	                }
	                responseMessage = message;
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                if (status.code === constants_1.Status.OK) {
	                    if (responseMessage === null) {
	                        const callerStack = getErrorStackString(callerStackError);
	                        callProperties.callback((0, call_1.callErrorFromStatus)({
	                            code: constants_1.Status.UNIMPLEMENTED,
	                            details: 'No message received',
	                            metadata: status.metadata,
	                        }, callerStack));
	                    }
	                    else {
	                        callProperties.callback(null, responseMessage);
	                    }
	                }
	                else {
	                    const callerStack = getErrorStackString(callerStackError);
	                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                emitter.emit('status', status);
	            },
	        });
	        call.sendMessage(argument);
	        call.halfClose();
	        return emitter;
	    }
	    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
	        var _a, _b;
	        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
	        const methodDefinition = {
	            path: method,
	            requestStream: true,
	            responseStream: false,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientWritableStreamImpl(serialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	            callback: checkedArguments.callback,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const emitter = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        emitter.call = call;
	        let responseMessage = null;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata: metadata => {
	                emitter.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                if (responseMessage !== null) {
	                    call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, 'Too many responses received');
	                }
	                responseMessage = message;
	                call.startRead();
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                if (status.code === constants_1.Status.OK) {
	                    if (responseMessage === null) {
	                        const callerStack = getErrorStackString(callerStackError);
	                        callProperties.callback((0, call_1.callErrorFromStatus)({
	                            code: constants_1.Status.UNIMPLEMENTED,
	                            details: 'No message received',
	                            metadata: status.metadata,
	                        }, callerStack));
	                    }
	                    else {
	                        callProperties.callback(null, responseMessage);
	                    }
	                }
	                else {
	                    const callerStack = getErrorStackString(callerStackError);
	                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                emitter.emit('status', status);
	            },
	        });
	        return emitter;
	    }
	    checkMetadataAndOptions(arg1, arg2) {
	        let metadata;
	        let options;
	        if (arg1 instanceof metadata_1.Metadata) {
	            metadata = arg1;
	            if (arg2) {
	                options = arg2;
	            }
	            else {
	                options = {};
	            }
	        }
	        else {
	            if (arg1) {
	                options = arg1;
	            }
	            else {
	                options = {};
	            }
	            metadata = new metadata_1.Metadata();
	        }
	        return { metadata, options };
	    }
	    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
	        var _a, _b;
	        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
	        const methodDefinition = {
	            path: method,
	            requestStream: false,
	            responseStream: true,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            argument: argument,
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientReadableStreamImpl(deserialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const stream = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        stream.call = call;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata(metadata) {
	                stream.emit('metadata', metadata);
	            },
	            // eslint-disable-next-line @typescript-eslint/no-explicit-any
	            onReceiveMessage(message) {
	                stream.push(message);
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                stream.push(null);
	                if (status.code !== constants_1.Status.OK) {
	                    const callerStack = getErrorStackString(callerStackError);
	                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                stream.emit('status', status);
	            },
	        });
	        call.sendMessage(argument);
	        call.halfClose();
	        return stream;
	    }
	    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
	        var _a, _b;
	        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
	        const methodDefinition = {
	            path: method,
	            requestStream: true,
	            responseStream: true,
	            requestSerialize: serialize,
	            responseDeserialize: deserialize,
	        };
	        let callProperties = {
	            metadata: checkedArguments.metadata,
	            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
	            channel: this[CHANNEL_SYMBOL],
	            methodDefinition: methodDefinition,
	            callOptions: checkedArguments.options,
	        };
	        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
	            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
	        }
	        const stream = callProperties.call;
	        const interceptorArgs = {
	            clientInterceptors: this[INTERCEPTOR_SYMBOL],
	            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
	            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== undefined ? _a : [],
	            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== undefined ? _b : [],
	        };
	        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
	        /* This needs to happen before the emitter is used. Unfortunately we can't
	         * enforce this with the type system. We need to construct this emitter
	         * before calling the CallInvocationTransformer, and we need to create the
	         * call after that. */
	        stream.call = call;
	        let receivedStatus = false;
	        let callerStackError = new Error();
	        call.start(callProperties.metadata, {
	            onReceiveMetadata(metadata) {
	                stream.emit('metadata', metadata);
	            },
	            onReceiveMessage(message) {
	                stream.push(message);
	            },
	            onReceiveStatus(status) {
	                if (receivedStatus) {
	                    return;
	                }
	                receivedStatus = true;
	                stream.push(null);
	                if (status.code !== constants_1.Status.OK) {
	                    const callerStack = getErrorStackString(callerStackError);
	                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));
	                }
	                /* Avoid retaining the callerStackError object in the call context of
	                 * the status event handler. */
	                callerStackError = null;
	                stream.emit('status', status);
	            },
	        });
	        return stream;
	    }
	}
	client.Client = Client;
	
	return client;
}

var hasRequiredMakeClient;

function requireMakeClient () {
	if (hasRequiredMakeClient) return makeClient;
	hasRequiredMakeClient = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(makeClient, "__esModule", { value: true });
	makeClient.loadPackageDefinition = makeClient.makeClientConstructor = undefined;
	const client_1 = requireClient();
	/**
	 * Map with short names for each of the requester maker functions. Used in
	 * makeClientConstructor
	 * @private
	 */
	const requesterFuncs = {
	    unary: client_1.Client.prototype.makeUnaryRequest,
	    server_stream: client_1.Client.prototype.makeServerStreamRequest,
	    client_stream: client_1.Client.prototype.makeClientStreamRequest,
	    bidi: client_1.Client.prototype.makeBidiStreamRequest,
	};
	/**
	 * Returns true, if given key is included in the blacklisted
	 * keys.
	 * @param key key for check, string.
	 */
	function isPrototypePolluted(key) {
	    return ['__proto__', 'prototype', 'constructor'].includes(key);
	}
	/**
	 * Creates a constructor for a client with the given methods, as specified in
	 * the methods argument. The resulting class will have an instance method for
	 * each method in the service, which is a partial application of one of the
	 * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`
	 * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`
	 * arguments predefined.
	 * @param methods An object mapping method names to
	 *     method attributes
	 * @param serviceName The fully qualified name of the service
	 * @param classOptions An options object.
	 * @return New client constructor, which is a subclass of
	 *     {@link grpc.Client}, and has the same arguments as that constructor.
	 */
	function makeClientConstructor(methods, serviceName, classOptions) {
	    class ServiceClientImpl extends client_1.Client {
	    }
	    Object.keys(methods).forEach(name => {
	        if (isPrototypePolluted(name)) {
	            return;
	        }
	        const attrs = methods[name];
	        let methodType;
	        // TODO(murgatroid99): Verify that we don't need this anymore
	        if (typeof name === 'string' && name.charAt(0) === '$') {
	            throw new Error('Method names cannot start with $');
	        }
	        if (attrs.requestStream) {
	            if (attrs.responseStream) {
	                methodType = 'bidi';
	            }
	            else {
	                methodType = 'client_stream';
	            }
	        }
	        else {
	            if (attrs.responseStream) {
	                methodType = 'server_stream';
	            }
	            else {
	                methodType = 'unary';
	            }
	        }
	        const serialize = attrs.requestSerialize;
	        const deserialize = attrs.responseDeserialize;
	        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
	        ServiceClientImpl.prototype[name] = methodFunc;
	        // Associate all provided attributes with the method
	        Object.assign(ServiceClientImpl.prototype[name], attrs);
	        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
	            ServiceClientImpl.prototype[attrs.originalName] =
	                ServiceClientImpl.prototype[name];
	        }
	    });
	    ServiceClientImpl.service = methods;
	    ServiceClientImpl.serviceName = serviceName;
	    return ServiceClientImpl;
	}
	makeClient.makeClientConstructor = makeClientConstructor;
	function partial(fn, path, serialize, deserialize) {
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    return function (...args) {
	        return fn.call(this, path, serialize, deserialize, ...args);
	    };
	}
	function isProtobufTypeDefinition(obj) {
	    return 'format' in obj;
	}
	/**
	 * Load a gRPC package definition as a gRPC object hierarchy.
	 * @param packageDef The package definition object.
	 * @return The resulting gRPC object.
	 */
	function loadPackageDefinition(packageDef) {
	    const result = {};
	    for (const serviceFqn in packageDef) {
	        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
	            const service = packageDef[serviceFqn];
	            const nameComponents = serviceFqn.split('.');
	            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
	                continue;
	            }
	            const serviceName = nameComponents[nameComponents.length - 1];
	            let current = result;
	            for (const packageName of nameComponents.slice(0, -1)) {
	                if (!current[packageName]) {
	                    current[packageName] = {};
	                }
	                current = current[packageName];
	            }
	            if (isProtobufTypeDefinition(service)) {
	                current[serviceName] = service;
	            }
	            else {
	                current[serviceName] = makeClientConstructor(service, serviceName);
	            }
	        }
	    }
	    return result;
	}
	makeClient.loadPackageDefinition = loadPackageDefinition;
	
	return makeClient;
}

var src$4 = {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_camelcase;
var hasRequiredLodash_camelcase;

function requireLodash_camelcase () {
	if (hasRequiredLodash_camelcase) return lodash_camelcase;
	hasRequiredLodash_camelcase = 1;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match words composed of alphanumeric characters. */
	var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	/** Used to match Latin Unicode letters (excluding mathematical operators). */
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f\\ufe20-\\ufe23',
	    rsComboSymbolsRange = '\\u20d0-\\u20f0',
	    rsDingbatRange = '\\u2700-\\u27bf',
	    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	    rsPunctuationRange = '\\u2000-\\u206f',
	    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	    rsVarRange = '\\ufe0e\\ufe0f',
	    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	/** Used to compose unicode capture groups. */
	var rsApos = "['\u2019]",
	    rsAstral = '[' + rsAstralRange + ']',
	    rsBreak = '[' + rsBreakRange + ']',
	    rsCombo = '[' + rsComboMarksRange + rsComboSymbolsRange + ']',
	    rsDigits = '\\d+',
	    rsDingbat = '[' + rsDingbatRange + ']',
	    rsLower = '[' + rsLowerRange + ']',
	    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsUpper = '[' + rsUpperRange + ']',
	    rsZWJ = '\\u200d';

	/** Used to compose unicode regexes. */
	var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',
	    rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',
	    rsOptLowerContr = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	    rsOptUpperContr = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	    reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	/** Used to match apostrophes. */
	var reApos = RegExp(rsApos, 'g');

	/**
	 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	 */
	var reComboMark = RegExp(rsCombo, 'g');

	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	/** Used to match complex or compound words. */
	var reUnicodeWord = RegExp([
	  rsUpper + '?' + rsLower + '+' + rsOptLowerContr + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	  rsUpperMisc + '+' + rsOptUpperContr + '(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',
	  rsUpper + '?' + rsLowerMisc + '+' + rsOptLowerContr,
	  rsUpper + '+' + rsOptUpperContr,
	  rsDigits,
	  rsEmoji
	].join('|'), 'g');

	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');

	/** Used to detect strings that need a more robust regexp to match words. */
	var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	/** Used to map Latin Unicode letters to basic Latin letters. */
	var deburredLetters = {
	  // Latin-1 Supplement block.
	  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	  '\xc7': 'C',  '\xe7': 'c',
	  '\xd0': 'D',  '\xf0': 'd',
	  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	  '\xd1': 'N',  '\xf1': 'n',
	  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	  '\xc6': 'Ae', '\xe6': 'ae',
	  '\xde': 'Th', '\xfe': 'th',
	  '\xdf': 'ss',
	  // Latin Extended-A block.
	  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	  '\u0134': 'J',  '\u0135': 'j',
	  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	  '\u0174': 'W',  '\u0175': 'w',
	  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	  '\u0132': 'IJ', '\u0133': 'ij',
	  '\u0152': 'Oe', '\u0153': 'oe',
	  '\u0149': "'n", '\u017f': 'ss'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array ? array.length : 0;
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function asciiToArray(string) {
	  return string.split('');
	}

	/**
	 * Splits an ASCII `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function asciiWords(string) {
	  return string.match(reAsciiWord) || [];
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	 * letters to basic Latin letters.
	 *
	 * @private
	 * @param {string} letter The matched letter to deburr.
	 * @returns {string} Returns the deburred letter.
	 */
	var deburrLetter = basePropertyOf(deburredLetters);

	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}

	/**
	 * Checks if `string` contains a word composed of Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a word is found, else `false`.
	 */
	function hasUnicodeWord(string) {
	  return reHasUnicodeWord.test(string);
	}

	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return hasUnicode(string)
	    ? unicodeToArray(string)
	    : asciiToArray(string);
	}

	/**
	 * Converts a Unicode `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function unicodeToArray(string) {
	  return string.match(reUnicode) || [];
	}

	/**
	 * Splits a Unicode `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function unicodeWords(string) {
	  return string.match(reUnicodeWord) || [];
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol = root.Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return (!start && end >= length) ? array : baseSlice(array, start, end);
	}

	/**
	 * Creates a function like `_.lowerFirst`.
	 *
	 * @private
	 * @param {string} methodName The name of the `String` case method to use.
	 * @returns {Function} Returns the new case function.
	 */
	function createCaseFirst(methodName) {
	  return function(string) {
	    string = toString(string);

	    var strSymbols = hasUnicode(string)
	      ? stringToArray(string)
	      : undefined;

	    var chr = strSymbols
	      ? strSymbols[0]
	      : string.charAt(0);

	    var trailing = strSymbols
	      ? castSlice(strSymbols, 1).join('')
	      : string.slice(1);

	    return chr[methodName]() + trailing;
	  };
	}

	/**
	 * Creates a function like `_.camelCase`.
	 *
	 * @private
	 * @param {Function} callback The function to combine each word.
	 * @returns {Function} Returns the new compounder function.
	 */
	function createCompounder(callback) {
	  return function(string) {
	    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	  };
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the camel cased string.
	 * @example
	 *
	 * _.camelCase('Foo Bar');
	 * // => 'fooBar'
	 *
	 * _.camelCase('--foo-bar--');
	 * // => 'fooBar'
	 *
	 * _.camelCase('__FOO_BAR__');
	 * // => 'fooBar'
	 */
	var camelCase = createCompounder(function(result, word, index) {
	  word = word.toLowerCase();
	  return result + (index ? capitalize(word) : word);
	});

	/**
	 * Converts the first character of `string` to upper case and the remaining
	 * to lower case.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to capitalize.
	 * @returns {string} Returns the capitalized string.
	 * @example
	 *
	 * _.capitalize('FRED');
	 * // => 'Fred'
	 */
	function capitalize(string) {
	  return upperFirst(toString(string).toLowerCase());
	}

	/**
	 * Deburrs `string` by converting
	 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	 * letters to basic Latin letters and removing
	 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to deburr.
	 * @returns {string} Returns the deburred string.
	 * @example
	 *
	 * _.deburr('dj vu');
	 * // => 'deja vu'
	 */
	function deburr(string) {
	  string = toString(string);
	  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}

	/**
	 * Converts the first character of `string` to upper case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.upperFirst('fred');
	 * // => 'Fred'
	 *
	 * _.upperFirst('FRED');
	 * // => 'FRED'
	 */
	var upperFirst = createCaseFirst('toUpperCase');

	/**
	 * Splits `string` into an array of its words.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {RegExp|string} [pattern] The pattern to match words.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the words of `string`.
	 * @example
	 *
	 * _.words('fred, barney, & pebbles');
	 * // => ['fred', 'barney', 'pebbles']
	 *
	 * _.words('fred, barney, & pebbles', /[^, ]+/g);
	 * // => ['fred', 'barney', '&', 'pebbles']
	 */
	function words(string, pattern, guard) {
	  string = toString(string);
	  pattern = pattern;

	  if (pattern === undefined) {
	    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	  }
	  return string.match(pattern) || [];
	}

	lodash_camelcase = camelCase;
	return lodash_camelcase;
}

var src$3 = {exports: {}};

var indexLight = {exports: {}};

var indexMinimal = {};

var minimal$1 = {};

var aspromise;
var hasRequiredAspromise;

function requireAspromise () {
	if (hasRequiredAspromise) return aspromise;
	hasRequiredAspromise = 1;
	aspromise = asPromise;

	/**
	 * Callback as used by {@link util.asPromise}.
	 * @typedef asPromiseCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {...*} params Additional arguments
	 * @returns {undefined}
	 */

	/**
	 * Returns a promise from a node-style callback function.
	 * @memberof util
	 * @param {asPromiseCallback} fn Function to call
	 * @param {*} ctx Function context
	 * @param {...*} params Function arguments
	 * @returns {Promise<*>} Promisified function
	 */
	function asPromise(fn, ctx/*, varargs */) {
	    var params  = new Array(arguments.length - 1),
	        offset  = 0,
	        index   = 2,
	        pending = true;
	    while (index < arguments.length)
	        params[offset++] = arguments[index++];
	    return new Promise(function executor(resolve, reject) {
	        params[offset] = function callback(err/*, varargs */) {
	            if (pending) {
	                pending = false;
	                if (err)
	                    reject(err);
	                else {
	                    var params = new Array(arguments.length - 1),
	                        offset = 0;
	                    while (offset < params.length)
	                        params[offset++] = arguments[offset];
	                    resolve.apply(null, params);
	                }
	            }
	        };
	        try {
	            fn.apply(ctx || null, params);
	        } catch (err) {
	            if (pending) {
	                pending = false;
	                reject(err);
	            }
	        }
	    });
	}
	return aspromise;
}

var base64 = {};

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	(function (exports) {

		/**
		 * A minimal base64 implementation for number arrays.
		 * @memberof util
		 * @namespace
		 */
		var base64 = exports;

		/**
		 * Calculates the byte length of a base64 encoded string.
		 * @param {string} string Base64 encoded string
		 * @returns {number} Byte length
		 */
		base64.length = function length(string) {
		    var p = string.length;
		    if (!p)
		        return 0;
		    var n = 0;
		    while (--p % 4 > 1 && string.charAt(p) === "=")
		        ++n;
		    return Math.ceil(string.length * 3) / 4 - n;
		};

		// Base64 encoding table
		var b64 = new Array(64);

		// Base64 decoding table
		var s64 = new Array(123);

		// 65..90, 97..122, 48..57, 43, 47
		for (var i = 0; i < 64;)
		    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

		/**
		 * Encodes a buffer to a base64 encoded string.
		 * @param {Uint8Array} buffer Source buffer
		 * @param {number} start Source start
		 * @param {number} end Source end
		 * @returns {string} Base64 encoded string
		 */
		base64.encode = function encode(buffer, start, end) {
		    var parts = null,
		        chunk = [];
		    var i = 0, // output index
		        j = 0, // goto index
		        t;     // temporary
		    while (start < end) {
		        var b = buffer[start++];
		        switch (j) {
		            case 0:
		                chunk[i++] = b64[b >> 2];
		                t = (b & 3) << 4;
		                j = 1;
		                break;
		            case 1:
		                chunk[i++] = b64[t | b >> 4];
		                t = (b & 15) << 2;
		                j = 2;
		                break;
		            case 2:
		                chunk[i++] = b64[t | b >> 6];
		                chunk[i++] = b64[b & 63];
		                j = 0;
		                break;
		        }
		        if (i > 8191) {
		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
		            i = 0;
		        }
		    }
		    if (j) {
		        chunk[i++] = b64[t];
		        chunk[i++] = 61;
		        if (j === 1)
		            chunk[i++] = 61;
		    }
		    if (parts) {
		        if (i)
		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
		        return parts.join("");
		    }
		    return String.fromCharCode.apply(String, chunk.slice(0, i));
		};

		var invalidEncoding = "invalid encoding";

		/**
		 * Decodes a base64 encoded string to a buffer.
		 * @param {string} string Source string
		 * @param {Uint8Array} buffer Destination buffer
		 * @param {number} offset Destination offset
		 * @returns {number} Number of bytes written
		 * @throws {Error} If encoding is invalid
		 */
		base64.decode = function decode(string, buffer, offset) {
		    var start = offset;
		    var j = 0, // goto index
		        t;     // temporary
		    for (var i = 0; i < string.length;) {
		        var c = string.charCodeAt(i++);
		        if (c === 61 && j > 1)
		            break;
		        if ((c = s64[c]) === undefined)
		            throw Error(invalidEncoding);
		        switch (j) {
		            case 0:
		                t = c;
		                j = 1;
		                break;
		            case 1:
		                buffer[offset++] = t << 2 | (c & 48) >> 4;
		                t = c;
		                j = 2;
		                break;
		            case 2:
		                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
		                t = c;
		                j = 3;
		                break;
		            case 3:
		                buffer[offset++] = (t & 3) << 6 | c;
		                j = 0;
		                break;
		        }
		    }
		    if (j === 1)
		        throw Error(invalidEncoding);
		    return offset - start;
		};

		/**
		 * Tests if the specified string appears to be base64 encoded.
		 * @param {string} string String to test
		 * @returns {boolean} `true` if probably base64 encoded, otherwise false
		 */
		base64.test = function test(string) {
		    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
		}; 
	} (base64));
	return base64;
}

var eventemitter;
var hasRequiredEventemitter;

function requireEventemitter () {
	if (hasRequiredEventemitter) return eventemitter;
	hasRequiredEventemitter = 1;
	eventemitter = EventEmitter;

	/**
	 * Constructs a new event emitter instance.
	 * @classdesc A minimal event emitter.
	 * @memberof util
	 * @constructor
	 */
	function EventEmitter() {

	    /**
	     * Registered listeners.
	     * @type {Object.<string,*>}
	     * @private
	     */
	    this._listeners = {};
	}

	/**
	 * Registers an event listener.
	 * @param {string} evt Event name
	 * @param {function} fn Listener
	 * @param {*} [ctx] Listener context
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.on = function on(evt, fn, ctx) {
	    (this._listeners[evt] || (this._listeners[evt] = [])).push({
	        fn  : fn,
	        ctx : ctx || this
	    });
	    return this;
	};

	/**
	 * Removes an event listener or any matching listeners if arguments are omitted.
	 * @param {string} [evt] Event name. Removes all listeners if omitted.
	 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.off = function off(evt, fn) {
	    if (evt === undefined)
	        this._listeners = {};
	    else {
	        if (fn === undefined)
	            this._listeners[evt] = [];
	        else {
	            var listeners = this._listeners[evt];
	            for (var i = 0; i < listeners.length;)
	                if (listeners[i].fn === fn)
	                    listeners.splice(i, 1);
	                else
	                    ++i;
	        }
	    }
	    return this;
	};

	/**
	 * Emits an event by calling its listeners with the specified arguments.
	 * @param {string} evt Event name
	 * @param {...*} args Arguments
	 * @returns {util.EventEmitter} `this`
	 */
	EventEmitter.prototype.emit = function emit(evt) {
	    var listeners = this._listeners[evt];
	    if (listeners) {
	        var args = [],
	            i = 1;
	        for (; i < arguments.length;)
	            args.push(arguments[i++]);
	        for (i = 0; i < listeners.length;)
	            listeners[i].fn.apply(listeners[i++].ctx, args);
	    }
	    return this;
	};
	return eventemitter;
}

var float;
var hasRequiredFloat;

function requireFloat () {
	if (hasRequiredFloat) return float;
	hasRequiredFloat = 1;

	float = factory(factory);

	/**
	 * Reads / writes floats / doubles from / to buffers.
	 * @name util.float
	 * @namespace
	 */

	/**
	 * Writes a 32 bit float to a buffer using little endian byte order.
	 * @name util.float.writeFloatLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 32 bit float to a buffer using big endian byte order.
	 * @name util.float.writeFloatBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 32 bit float from a buffer using little endian byte order.
	 * @name util.float.readFloatLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 32 bit float from a buffer using big endian byte order.
	 * @name util.float.readFloatBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Writes a 64 bit double to a buffer using little endian byte order.
	 * @name util.float.writeDoubleLE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Writes a 64 bit double to a buffer using big endian byte order.
	 * @name util.float.writeDoubleBE
	 * @function
	 * @param {number} val Value to write
	 * @param {Uint8Array} buf Target buffer
	 * @param {number} pos Target buffer offset
	 * @returns {undefined}
	 */

	/**
	 * Reads a 64 bit double from a buffer using little endian byte order.
	 * @name util.float.readDoubleLE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	/**
	 * Reads a 64 bit double from a buffer using big endian byte order.
	 * @name util.float.readDoubleBE
	 * @function
	 * @param {Uint8Array} buf Source buffer
	 * @param {number} pos Source buffer offset
	 * @returns {number} Value read
	 */

	// Factory function for the purpose of node-based testing in modified global environments
	function factory(exports) {

	    // float: typed array
	    if (typeof Float32Array !== "undefined") (function() {

	        var f32 = new Float32Array([ -0 ]),
	            f8b = new Uint8Array(f32.buffer),
	            le  = f8b[3] === 128;

	        function writeFloat_f32_cpy(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	        }

	        function writeFloat_f32_rev(val, buf, pos) {
	            f32[0] = val;
	            buf[pos    ] = f8b[3];
	            buf[pos + 1] = f8b[2];
	            buf[pos + 2] = f8b[1];
	            buf[pos + 3] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

	        function readFloat_f32_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            return f32[0];
	        }

	        function readFloat_f32_rev(buf, pos) {
	            f8b[3] = buf[pos    ];
	            f8b[2] = buf[pos + 1];
	            f8b[1] = buf[pos + 2];
	            f8b[0] = buf[pos + 3];
	            return f32[0];
	        }

	        /* istanbul ignore next */
	        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
	        /* istanbul ignore next */
	        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

	    // float: ieee754
	    })(); else (function() {

	        function writeFloat_ieee754(writeUint, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0)
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
	            else if (isNaN(val))
	                writeUint(2143289344, buf, pos);
	            else if (val > 3.4028234663852886e+38) // +-Infinity
	                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
	            else if (val < 1.1754943508222875e-38) // denormal
	                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
	            else {
	                var exponent = Math.floor(Math.log(val) / Math.LN2),
	                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
	                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
	            }
	        }

	        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
	        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

	        function readFloat_ieee754(readUint, buf, pos) {
	            var uint = readUint(buf, pos),
	                sign = (uint >> 31) * 2 + 1,
	                exponent = uint >>> 23 & 255,
	                mantissa = uint & 8388607;
	            return exponent === 255
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 1.401298464324817e-45 * mantissa
	                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
	        }

	        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
	        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

	    })();

	    // double: typed array
	    if (typeof Float64Array !== "undefined") (function() {

	        var f64 = new Float64Array([-0]),
	            f8b = new Uint8Array(f64.buffer),
	            le  = f8b[7] === 128;

	        function writeDouble_f64_cpy(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[0];
	            buf[pos + 1] = f8b[1];
	            buf[pos + 2] = f8b[2];
	            buf[pos + 3] = f8b[3];
	            buf[pos + 4] = f8b[4];
	            buf[pos + 5] = f8b[5];
	            buf[pos + 6] = f8b[6];
	            buf[pos + 7] = f8b[7];
	        }

	        function writeDouble_f64_rev(val, buf, pos) {
	            f64[0] = val;
	            buf[pos    ] = f8b[7];
	            buf[pos + 1] = f8b[6];
	            buf[pos + 2] = f8b[5];
	            buf[pos + 3] = f8b[4];
	            buf[pos + 4] = f8b[3];
	            buf[pos + 5] = f8b[2];
	            buf[pos + 6] = f8b[1];
	            buf[pos + 7] = f8b[0];
	        }

	        /* istanbul ignore next */
	        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

	        function readDouble_f64_cpy(buf, pos) {
	            f8b[0] = buf[pos    ];
	            f8b[1] = buf[pos + 1];
	            f8b[2] = buf[pos + 2];
	            f8b[3] = buf[pos + 3];
	            f8b[4] = buf[pos + 4];
	            f8b[5] = buf[pos + 5];
	            f8b[6] = buf[pos + 6];
	            f8b[7] = buf[pos + 7];
	            return f64[0];
	        }

	        function readDouble_f64_rev(buf, pos) {
	            f8b[7] = buf[pos    ];
	            f8b[6] = buf[pos + 1];
	            f8b[5] = buf[pos + 2];
	            f8b[4] = buf[pos + 3];
	            f8b[3] = buf[pos + 4];
	            f8b[2] = buf[pos + 5];
	            f8b[1] = buf[pos + 6];
	            f8b[0] = buf[pos + 7];
	            return f64[0];
	        }

	        /* istanbul ignore next */
	        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
	        /* istanbul ignore next */
	        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

	    // double: ieee754
	    })(); else (function() {

	        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
	            var sign = val < 0 ? 1 : 0;
	            if (sign)
	                val = -val;
	            if (val === 0) {
	                writeUint(0, buf, pos + off0);
	                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
	            } else if (isNaN(val)) {
	                writeUint(0, buf, pos + off0);
	                writeUint(2146959360, buf, pos + off1);
	            } else if (val > 1.7976931348623157e+308) { // +-Infinity
	                writeUint(0, buf, pos + off0);
	                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
	            } else {
	                var mantissa;
	                if (val < 2.2250738585072014e-308) { // denormal
	                    mantissa = val / 5e-324;
	                    writeUint(mantissa >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
	                } else {
	                    var exponent = Math.floor(Math.log(val) / Math.LN2);
	                    if (exponent === 1024)
	                        exponent = 1023;
	                    mantissa = val * Math.pow(2, -exponent);
	                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
	                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
	                }
	            }
	        }

	        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
	        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

	        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
	            var lo = readUint(buf, pos + off0),
	                hi = readUint(buf, pos + off1);
	            var sign = (hi >> 31) * 2 + 1,
	                exponent = hi >>> 20 & 2047,
	                mantissa = 4294967296 * (hi & 1048575) + lo;
	            return exponent === 2047
	                ? mantissa
	                ? NaN
	                : sign * Infinity
	                : exponent === 0 // denormal
	                ? sign * 5e-324 * mantissa
	                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
	        }

	        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
	        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

	    })();

	    return exports;
	}

	// uint helpers

	function writeUintLE(val, buf, pos) {
	    buf[pos    ] =  val        & 255;
	    buf[pos + 1] =  val >>> 8  & 255;
	    buf[pos + 2] =  val >>> 16 & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	function writeUintBE(val, buf, pos) {
	    buf[pos    ] =  val >>> 24;
	    buf[pos + 1] =  val >>> 16 & 255;
	    buf[pos + 2] =  val >>> 8  & 255;
	    buf[pos + 3] =  val        & 255;
	}

	function readUintLE(buf, pos) {
	    return (buf[pos    ]
	          | buf[pos + 1] << 8
	          | buf[pos + 2] << 16
	          | buf[pos + 3] << 24) >>> 0;
	}

	function readUintBE(buf, pos) {
	    return (buf[pos    ] << 24
	          | buf[pos + 1] << 16
	          | buf[pos + 2] << 8
	          | buf[pos + 3]) >>> 0;
	}
	return float;
}

var inquire_1;
var hasRequiredInquire;

function requireInquire () {
	if (hasRequiredInquire) return inquire_1;
	hasRequiredInquire = 1;
	inquire_1 = inquire;

	/**
	 * Requires a module only if available.
	 * @memberof util
	 * @param {string} moduleName Module to require
	 * @returns {?Object} Required module if available and not empty, otherwise `null`
	 */
	function inquire(moduleName) {
	    try {
	        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
	        if (mod && (mod.length || Object.keys(mod).length))
	            return mod;
	    } catch (e) {} // eslint-disable-line no-empty
	    return null;
	}
	return inquire_1;
}

var utf8 = {};

var hasRequiredUtf8;

function requireUtf8 () {
	if (hasRequiredUtf8) return utf8;
	hasRequiredUtf8 = 1;
	(function (exports) {

		/**
		 * A minimal UTF8 implementation for number arrays.
		 * @memberof util
		 * @namespace
		 */
		var utf8 = exports;

		/**
		 * Calculates the UTF8 byte length of a string.
		 * @param {string} string String
		 * @returns {number} Byte length
		 */
		utf8.length = function utf8_length(string) {
		    var len = 0,
		        c = 0;
		    for (var i = 0; i < string.length; ++i) {
		        c = string.charCodeAt(i);
		        if (c < 128)
		            len += 1;
		        else if (c < 2048)
		            len += 2;
		        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
		            ++i;
		            len += 4;
		        } else
		            len += 3;
		    }
		    return len;
		};

		/**
		 * Reads UTF8 bytes as a string.
		 * @param {Uint8Array} buffer Source buffer
		 * @param {number} start Source start
		 * @param {number} end Source end
		 * @returns {string} String read
		 */
		utf8.read = function utf8_read(buffer, start, end) {
		    var len = end - start;
		    if (len < 1)
		        return "";
		    var parts = null,
		        chunk = [],
		        i = 0, // char offset
		        t;     // temporary
		    while (start < end) {
		        t = buffer[start++];
		        if (t < 128)
		            chunk[i++] = t;
		        else if (t > 191 && t < 224)
		            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
		        else if (t > 239 && t < 365) {
		            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
		            chunk[i++] = 0xD800 + (t >> 10);
		            chunk[i++] = 0xDC00 + (t & 1023);
		        } else
		            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
		        if (i > 8191) {
		            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
		            i = 0;
		        }
		    }
		    if (parts) {
		        if (i)
		            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
		        return parts.join("");
		    }
		    return String.fromCharCode.apply(String, chunk.slice(0, i));
		};

		/**
		 * Writes a string as UTF8 bytes.
		 * @param {string} string Source string
		 * @param {Uint8Array} buffer Destination buffer
		 * @param {number} offset Destination offset
		 * @returns {number} Bytes written
		 */
		utf8.write = function utf8_write(string, buffer, offset) {
		    var start = offset,
		        c1, // character 1
		        c2; // character 2
		    for (var i = 0; i < string.length; ++i) {
		        c1 = string.charCodeAt(i);
		        if (c1 < 128) {
		            buffer[offset++] = c1;
		        } else if (c1 < 2048) {
		            buffer[offset++] = c1 >> 6       | 192;
		            buffer[offset++] = c1       & 63 | 128;
		        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
		            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
		            ++i;
		            buffer[offset++] = c1 >> 18      | 240;
		            buffer[offset++] = c1 >> 12 & 63 | 128;
		            buffer[offset++] = c1 >> 6  & 63 | 128;
		            buffer[offset++] = c1       & 63 | 128;
		        } else {
		            buffer[offset++] = c1 >> 12      | 224;
		            buffer[offset++] = c1 >> 6  & 63 | 128;
		            buffer[offset++] = c1       & 63 | 128;
		        }
		    }
		    return offset - start;
		}; 
	} (utf8));
	return utf8;
}

var pool_1;
var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return pool_1;
	hasRequiredPool = 1;
	pool_1 = pool;

	/**
	 * An allocator as used by {@link util.pool}.
	 * @typedef PoolAllocator
	 * @type {function}
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */

	/**
	 * A slicer as used by {@link util.pool}.
	 * @typedef PoolSlicer
	 * @type {function}
	 * @param {number} start Start offset
	 * @param {number} end End offset
	 * @returns {Uint8Array} Buffer slice
	 * @this {Uint8Array}
	 */

	/**
	 * A general purpose buffer pool.
	 * @memberof util
	 * @function
	 * @param {PoolAllocator} alloc Allocator
	 * @param {PoolSlicer} slice Slicer
	 * @param {number} [size=8192] Slab size
	 * @returns {PoolAllocator} Pooled allocator
	 */
	function pool(alloc, slice, size) {
	    var SIZE   = size || 8192;
	    var MAX    = SIZE >>> 1;
	    var slab   = null;
	    var offset = SIZE;
	    return function pool_alloc(size) {
	        if (size < 1 || size > MAX)
	            return alloc(size);
	        if (offset + size > SIZE) {
	            slab = alloc(SIZE);
	            offset = 0;
	        }
	        var buf = slice.call(slab, offset, offset += size);
	        if (offset & 7) // align to 32 bit
	            offset = (offset | 7) + 1;
	        return buf;
	    };
	}
	return pool_1;
}

var longbits;
var hasRequiredLongbits;

function requireLongbits () {
	if (hasRequiredLongbits) return longbits;
	hasRequiredLongbits = 1;
	longbits = LongBits;

	var util = requireMinimal$1();

	/**
	 * Constructs new long bits.
	 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
	 * @memberof util
	 * @constructor
	 * @param {number} lo Low 32 bits, unsigned
	 * @param {number} hi High 32 bits, unsigned
	 */
	function LongBits(lo, hi) {

	    // note that the casts below are theoretically unnecessary as of today, but older statically
	    // generated converter code might still call the ctor with signed 32bits. kept for compat.

	    /**
	     * Low bits.
	     * @type {number}
	     */
	    this.lo = lo >>> 0;

	    /**
	     * High bits.
	     * @type {number}
	     */
	    this.hi = hi >>> 0;
	}

	/**
	 * Zero bits.
	 * @memberof util.LongBits
	 * @type {util.LongBits}
	 */
	var zero = LongBits.zero = new LongBits(0, 0);

	zero.toNumber = function() { return 0; };
	zero.zzEncode = zero.zzDecode = function() { return this; };
	zero.length = function() { return 1; };

	/**
	 * Zero hash.
	 * @memberof util.LongBits
	 * @type {string}
	 */
	var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

	/**
	 * Constructs new long bits from the specified number.
	 * @param {number} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.fromNumber = function fromNumber(value) {
	    if (value === 0)
	        return zero;
	    var sign = value < 0;
	    if (sign)
	        value = -value;
	    var lo = value >>> 0,
	        hi = (value - lo) / 4294967296 >>> 0;
	    if (sign) {
	        hi = ~hi >>> 0;
	        lo = ~lo >>> 0;
	        if (++lo > 4294967295) {
	            lo = 0;
	            if (++hi > 4294967295)
	                hi = 0;
	        }
	    }
	    return new LongBits(lo, hi);
	};

	/**
	 * Constructs new long bits from a number, long or string.
	 * @param {Long|number|string} value Value
	 * @returns {util.LongBits} Instance
	 */
	LongBits.from = function from(value) {
	    if (typeof value === "number")
	        return LongBits.fromNumber(value);
	    if (util.isString(value)) {
	        /* istanbul ignore else */
	        if (util.Long)
	            value = util.Long.fromString(value);
	        else
	            return LongBits.fromNumber(parseInt(value, 10));
	    }
	    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
	};

	/**
	 * Converts this long bits to a possibly unsafe JavaScript number.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {number} Possibly unsafe number
	 */
	LongBits.prototype.toNumber = function toNumber(unsigned) {
	    if (!unsigned && this.hi >>> 31) {
	        var lo = ~this.lo + 1 >>> 0,
	            hi = ~this.hi     >>> 0;
	        if (!lo)
	            hi = hi + 1 >>> 0;
	        return -(lo + hi * 4294967296);
	    }
	    return this.lo + this.hi * 4294967296;
	};

	/**
	 * Converts this long bits to a long.
	 * @param {boolean} [unsigned=false] Whether unsigned or not
	 * @returns {Long} Long
	 */
	LongBits.prototype.toLong = function toLong(unsigned) {
	    return util.Long
	        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
	        /* istanbul ignore next */
	        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
	};

	var charCodeAt = String.prototype.charCodeAt;

	/**
	 * Constructs new long bits from the specified 8 characters long hash.
	 * @param {string} hash Hash
	 * @returns {util.LongBits} Bits
	 */
	LongBits.fromHash = function fromHash(hash) {
	    if (hash === zeroHash)
	        return zero;
	    return new LongBits(
	        ( charCodeAt.call(hash, 0)
	        | charCodeAt.call(hash, 1) << 8
	        | charCodeAt.call(hash, 2) << 16
	        | charCodeAt.call(hash, 3) << 24) >>> 0
	    ,
	        ( charCodeAt.call(hash, 4)
	        | charCodeAt.call(hash, 5) << 8
	        | charCodeAt.call(hash, 6) << 16
	        | charCodeAt.call(hash, 7) << 24) >>> 0
	    );
	};

	/**
	 * Converts this long bits to a 8 characters long hash.
	 * @returns {string} Hash
	 */
	LongBits.prototype.toHash = function toHash() {
	    return String.fromCharCode(
	        this.lo        & 255,
	        this.lo >>> 8  & 255,
	        this.lo >>> 16 & 255,
	        this.lo >>> 24      ,
	        this.hi        & 255,
	        this.hi >>> 8  & 255,
	        this.hi >>> 16 & 255,
	        this.hi >>> 24
	    );
	};

	/**
	 * Zig-zag encodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzEncode = function zzEncode() {
	    var mask =   this.hi >> 31;
	    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
	    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Zig-zag decodes this long bits.
	 * @returns {util.LongBits} `this`
	 */
	LongBits.prototype.zzDecode = function zzDecode() {
	    var mask = -(this.lo & 1);
	    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
	    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
	    return this;
	};

	/**
	 * Calculates the length of this longbits when encoded as a varint.
	 * @returns {number} Length
	 */
	LongBits.prototype.length = function length() {
	    var part0 =  this.lo,
	        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
	        part2 =  this.hi >>> 24;
	    return part2 === 0
	         ? part1 === 0
	           ? part0 < 16384
	             ? part0 < 128 ? 1 : 2
	             : part0 < 2097152 ? 3 : 4
	           : part1 < 16384
	             ? part1 < 128 ? 5 : 6
	             : part1 < 2097152 ? 7 : 8
	         : part2 < 128 ? 9 : 10;
	};
	return longbits;
}

var hasRequiredMinimal$1;

function requireMinimal$1 () {
	if (hasRequiredMinimal$1) return minimal$1;
	hasRequiredMinimal$1 = 1;
	(function (exports) {
		var util = exports;

		// used to return a Promise where callback is omitted
		util.asPromise = requireAspromise();

		// converts to / from base64 encoded strings
		util.base64 = requireBase64();

		// base class of rpc.Service
		util.EventEmitter = requireEventemitter();

		// float handling accross browsers
		util.float = requireFloat();

		// requires modules optionally and hides the call from bundlers
		util.inquire = requireInquire();

		// converts to / from utf8 encoded strings
		util.utf8 = requireUtf8();

		// provides a node-like buffer pool in the browser
		util.pool = requirePool();

		// utility to work with the low and high bits of a 64 bit value
		util.LongBits = requireLongbits();

		/**
		 * Whether running within node or not.
		 * @memberof util
		 * @type {boolean}
		 */
		util.isNode = Boolean(typeof commonjsGlobal !== "undefined"
		                   && commonjsGlobal
		                   && commonjsGlobal.process
		                   && commonjsGlobal.process.versions
		                   && commonjsGlobal.process.versions.node);

		/**
		 * Global object reference.
		 * @memberof util
		 * @type {Object}
		 */
		util.global = util.isNode && commonjsGlobal
		           || typeof window !== "undefined" && window
		           || typeof self   !== "undefined" && self
		           || minimal$1; // eslint-disable-line no-invalid-this

		/**
		 * An immuable empty array.
		 * @memberof util
		 * @type {Array.<*>}
		 * @const
		 */
		util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

		/**
		 * An immutable empty object.
		 * @type {Object}
		 * @const
		 */
		util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

		/**
		 * Tests if the specified value is an integer.
		 * @function
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is an integer
		 */
		util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
		    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
		};

		/**
		 * Tests if the specified value is a string.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a string
		 */
		util.isString = function isString(value) {
		    return typeof value === "string" || value instanceof String;
		};

		/**
		 * Tests if the specified value is a non-null object.
		 * @param {*} value Value to test
		 * @returns {boolean} `true` if the value is a non-null object
		 */
		util.isObject = function isObject(value) {
		    return value && typeof value === "object";
		};

		/**
		 * Checks if a property on a message is considered to be present.
		 * This is an alias of {@link util.isSet}.
		 * @function
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isset =

		/**
		 * Checks if a property on a message is considered to be present.
		 * @param {Object} obj Plain object or message instance
		 * @param {string} prop Property name
		 * @returns {boolean} `true` if considered to be present, otherwise `false`
		 */
		util.isSet = function isSet(obj, prop) {
		    var value = obj[prop];
		    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
		        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
		    return false;
		};

		/**
		 * Any compatible Buffer instance.
		 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
		 * @interface Buffer
		 * @extends Uint8Array
		 */

		/**
		 * Node's Buffer class if available.
		 * @type {Constructor<Buffer>}
		 */
		util.Buffer = (function() {
		    try {
		        var Buffer = util.inquire("buffer").Buffer;
		        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
		        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
		    } catch (e) {
		        /* istanbul ignore next */
		        return null;
		    }
		})();

		// Internal alias of or polyfull for Buffer.from.
		util._Buffer_from = null;

		// Internal alias of or polyfill for Buffer.allocUnsafe.
		util._Buffer_allocUnsafe = null;

		/**
		 * Creates a new buffer of whatever type supported by the environment.
		 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
		 * @returns {Uint8Array|Buffer} Buffer
		 */
		util.newBuffer = function newBuffer(sizeOrArray) {
		    /* istanbul ignore next */
		    return typeof sizeOrArray === "number"
		        ? util.Buffer
		            ? util._Buffer_allocUnsafe(sizeOrArray)
		            : new util.Array(sizeOrArray)
		        : util.Buffer
		            ? util._Buffer_from(sizeOrArray)
		            : typeof Uint8Array === "undefined"
		                ? sizeOrArray
		                : new Uint8Array(sizeOrArray);
		};

		/**
		 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
		 * @type {Constructor<Uint8Array>}
		 */
		util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

		/**
		 * Any compatible Long instance.
		 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
		 * @interface Long
		 * @property {number} low Low bits
		 * @property {number} high High bits
		 * @property {boolean} unsigned Whether unsigned or not
		 */

		/**
		 * Long.js's Long class if available.
		 * @type {Constructor<Long>}
		 */
		util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
		         || /* istanbul ignore next */ util.global.Long
		         || util.inquire("long");

		/**
		 * Regular expression used to verify 2 bit (`bool`) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key2Re = /^true|false|0|1$/;

		/**
		 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

		/**
		 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
		 * @type {RegExp}
		 * @const
		 */
		util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

		/**
		 * Converts a number or long to an 8 characters long hash string.
		 * @param {Long|number} value Value to convert
		 * @returns {string} Hash
		 */
		util.longToHash = function longToHash(value) {
		    return value
		        ? util.LongBits.from(value).toHash()
		        : util.LongBits.zeroHash;
		};

		/**
		 * Converts an 8 characters long hash string to a long or number.
		 * @param {string} hash Hash
		 * @param {boolean} [unsigned=false] Whether unsigned or not
		 * @returns {Long|number} Original value
		 */
		util.longFromHash = function longFromHash(hash, unsigned) {
		    var bits = util.LongBits.fromHash(hash);
		    if (util.Long)
		        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
		    return bits.toNumber(Boolean(unsigned));
		};

		/**
		 * Merges the properties of the source object into the destination object.
		 * @memberof util
		 * @param {Object.<string,*>} dst Destination object
		 * @param {Object.<string,*>} src Source object
		 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
		 * @returns {Object.<string,*>} Destination object
		 */
		function merge(dst, src, ifNotSet) { // used by converters
		    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
		        if (dst[keys[i]] === undefined || !ifNotSet)
		            dst[keys[i]] = src[keys[i]];
		    return dst;
		}

		util.merge = merge;

		/**
		 * Converts the first character of a string to lower case.
		 * @param {string} str String to convert
		 * @returns {string} Converted string
		 */
		util.lcFirst = function lcFirst(str) {
		    return str.charAt(0).toLowerCase() + str.substring(1);
		};

		/**
		 * Creates a custom error constructor.
		 * @memberof util
		 * @param {string} name Error name
		 * @returns {Constructor<Error>} Custom error constructor
		 */
		function newError(name) {

		    function CustomError(message, properties) {

		        if (!(this instanceof CustomError))
		            return new CustomError(message, properties);

		        // Error.call(this, message);
		        // ^ just returns a new error instance because the ctor can be called as a function

		        Object.defineProperty(this, "message", { get: function() { return message; } });

		        /* istanbul ignore next */
		        if (Error.captureStackTrace) // node
		            Error.captureStackTrace(this, CustomError);
		        else
		            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

		        if (properties)
		            merge(this, properties);
		    }

		    CustomError.prototype = Object.create(Error.prototype, {
		        constructor: {
		            value: CustomError,
		            writable: true,
		            enumerable: false,
		            configurable: true,
		        },
		        name: {
		            get: function get() { return name; },
		            set: undefined,
		            enumerable: false,
		            // configurable: false would accurately preserve the behavior of
		            // the original, but I'm guessing that was not intentional.
		            // For an actual error subclass, this property would
		            // be configurable.
		            configurable: true,
		        },
		        toString: {
		            value: function value() { return this.name + ": " + this.message; },
		            writable: true,
		            enumerable: false,
		            configurable: true,
		        },
		    });

		    return CustomError;
		}

		util.newError = newError;

		/**
		 * Constructs a new protocol error.
		 * @classdesc Error subclass indicating a protocol specifc error.
		 * @memberof util
		 * @extends Error
		 * @template T extends Message<T>
		 * @constructor
		 * @param {string} message Error message
		 * @param {Object.<string,*>} [properties] Additional properties
		 * @example
		 * try {
		 *     MyMessage.decode(someBuffer); // throws if required fields are missing
		 * } catch (e) {
		 *     if (e instanceof ProtocolError && e.instance)
		 *         console.log("decoded so far: " + JSON.stringify(e.instance));
		 * }
		 */
		util.ProtocolError = newError("ProtocolError");

		/**
		 * So far decoded message instance.
		 * @name util.ProtocolError#instance
		 * @type {Message<T>}
		 */

		/**
		 * A OneOf getter as returned by {@link util.oneOfGetter}.
		 * @typedef OneOfGetter
		 * @type {function}
		 * @returns {string|undefined} Set field name, if any
		 */

		/**
		 * Builds a getter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfGetter} Unbound getter
		 */
		util.oneOfGetter = function getOneOf(fieldNames) {
		    var fieldMap = {};
		    for (var i = 0; i < fieldNames.length; ++i)
		        fieldMap[fieldNames[i]] = 1;

		    /**
		     * @returns {string|undefined} Set field name, if any
		     * @this Object
		     * @ignore
		     */
		    return function() { // eslint-disable-line consistent-return
		        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
		            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
		                return keys[i];
		    };
		};

		/**
		 * A OneOf setter as returned by {@link util.oneOfSetter}.
		 * @typedef OneOfSetter
		 * @type {function}
		 * @param {string|undefined} value Field name
		 * @returns {undefined}
		 */

		/**
		 * Builds a setter for a oneof's present field name.
		 * @param {string[]} fieldNames Field names
		 * @returns {OneOfSetter} Unbound setter
		 */
		util.oneOfSetter = function setOneOf(fieldNames) {

		    /**
		     * @param {string} name Field name
		     * @returns {undefined}
		     * @this Object
		     * @ignore
		     */
		    return function(name) {
		        for (var i = 0; i < fieldNames.length; ++i)
		            if (fieldNames[i] !== name)
		                delete this[fieldNames[i]];
		    };
		};

		/**
		 * Default conversion options used for {@link Message#toJSON} implementations.
		 *
		 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
		 *
		 * - Longs become strings
		 * - Enums become string keys
		 * - Bytes become base64 encoded strings
		 * - (Sub-)Messages become plain objects
		 * - Maps become plain objects with all string keys
		 * - Repeated fields become arrays
		 * - NaN and Infinity for float and double fields become strings
		 *
		 * @type {IConversionOptions}
		 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
		 */
		util.toJSONOptions = {
		    longs: String,
		    enums: String,
		    bytes: String,
		    json: true
		};

		// Sets up buffer utility according to the environment (called in index-minimal)
		util._configure = function() {
		    var Buffer = util.Buffer;
		    /* istanbul ignore if */
		    if (!Buffer) {
		        util._Buffer_from = util._Buffer_allocUnsafe = null;
		        return;
		    }
		    // because node 4.x buffers are incompatible & immutable
		    // see: https://github.com/dcodeIO/protobuf.js/pull/665
		    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
		        /* istanbul ignore next */
		        function Buffer_from(value, encoding) {
		            return new Buffer(value, encoding);
		        };
		    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
		        /* istanbul ignore next */
		        function Buffer_allocUnsafe(size) {
		            return new Buffer(size);
		        };
		}; 
	} (minimal$1));
	return minimal$1;
}

var writer;
var hasRequiredWriter;

function requireWriter () {
	if (hasRequiredWriter) return writer;
	hasRequiredWriter = 1;
	writer = Writer;

	var util      = requireMinimal$1();

	var BufferWriter; // cyclic

	var LongBits  = util.LongBits,
	    base64    = util.base64,
	    utf8      = util.utf8;

	/**
	 * Constructs a new writer operation instance.
	 * @classdesc Scheduled writer operation.
	 * @constructor
	 * @param {function(*, Uint8Array, number)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {*} val Value to write
	 * @ignore
	 */
	function Op(fn, len, val) {

	    /**
	     * Function to call.
	     * @type {function(Uint8Array, number, *)}
	     */
	    this.fn = fn;

	    /**
	     * Value byte length.
	     * @type {number}
	     */
	    this.len = len;

	    /**
	     * Next operation.
	     * @type {Writer.Op|undefined}
	     */
	    this.next = undefined;

	    /**
	     * Value to write.
	     * @type {*}
	     */
	    this.val = val; // type varies
	}

	/* istanbul ignore next */
	function noop() {} // eslint-disable-line no-empty-function

	/**
	 * Constructs a new writer state instance.
	 * @classdesc Copied writer state.
	 * @memberof Writer
	 * @constructor
	 * @param {Writer} writer Writer to copy state from
	 * @ignore
	 */
	function State(writer) {

	    /**
	     * Current head.
	     * @type {Writer.Op}
	     */
	    this.head = writer.head;

	    /**
	     * Current tail.
	     * @type {Writer.Op}
	     */
	    this.tail = writer.tail;

	    /**
	     * Current buffer length.
	     * @type {number}
	     */
	    this.len = writer.len;

	    /**
	     * Next state.
	     * @type {State|null}
	     */
	    this.next = writer.states;
	}

	/**
	 * Constructs a new writer instance.
	 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 */
	function Writer() {

	    /**
	     * Current length.
	     * @type {number}
	     */
	    this.len = 0;

	    /**
	     * Operations head.
	     * @type {Object}
	     */
	    this.head = new Op(noop, 0, 0);

	    /**
	     * Operations tail
	     * @type {Object}
	     */
	    this.tail = this.head;

	    /**
	     * Linked forked states.
	     * @type {Object|null}
	     */
	    this.states = null;

	    // When a value is written, the writer calculates its byte length and puts it into a linked
	    // list of operations to perform when finish() is called. This both allows us to allocate
	    // buffers of the exact required size and reduces the amount of work we have to do compared
	    // to first calculating over objects and then encoding over objects. In our case, the encoding
	    // part is just a linked list walk calling operations with already prepared values.
	}

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup() {
	            return (Writer.create = function create_buffer() {
	                return new BufferWriter();
	            })();
	        }
	        /* istanbul ignore next */
	        : function create_array() {
	            return new Writer();
	        };
	};

	/**
	 * Creates a new writer.
	 * @function
	 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
	 */
	Writer.create = create();

	/**
	 * Allocates a buffer of the specified size.
	 * @param {number} size Buffer size
	 * @returns {Uint8Array} Buffer
	 */
	Writer.alloc = function alloc(size) {
	    return new util.Array(size);
	};

	// Use Uint8Array buffer pool in the browser, just like node does with buffers
	/* istanbul ignore else */
	if (util.Array !== Array)
	    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

	/**
	 * Pushes a new operation to the queue.
	 * @param {function(Uint8Array, number, *)} fn Function to call
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @returns {Writer} `this`
	 * @private
	 */
	Writer.prototype._push = function push(fn, len, val) {
	    this.tail = this.tail.next = new Op(fn, len, val);
	    this.len += len;
	    return this;
	};

	function writeByte(val, buf, pos) {
	    buf[pos] = val & 255;
	}

	function writeVarint32(val, buf, pos) {
	    while (val > 127) {
	        buf[pos++] = val & 127 | 128;
	        val >>>= 7;
	    }
	    buf[pos] = val;
	}

	/**
	 * Constructs a new varint writer operation instance.
	 * @classdesc Scheduled varint writer operation.
	 * @extends Op
	 * @constructor
	 * @param {number} len Value byte length
	 * @param {number} val Value to write
	 * @ignore
	 */
	function VarintOp(len, val) {
	    this.len = len;
	    this.next = undefined;
	    this.val = val;
	}

	VarintOp.prototype = Object.create(Op.prototype);
	VarintOp.prototype.fn = writeVarint32;

	/**
	 * Writes an unsigned 32 bit value as a varint.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.uint32 = function write_uint32(value) {
	    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
	    // uint32 is by far the most frequently used operation and benefits significantly from this.
	    this.len += (this.tail = this.tail.next = new VarintOp(
	        (value = value >>> 0)
	                < 128       ? 1
	        : value < 16384     ? 2
	        : value < 2097152   ? 3
	        : value < 268435456 ? 4
	        :                     5,
	    value)).len;
	    return this;
	};

	/**
	 * Writes a signed 32 bit value as a varint.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.int32 = function write_int32(value) {
	    return value < 0
	        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
	        : this.uint32(value);
	};

	/**
	 * Writes a 32 bit value as a varint, zig-zag encoded.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sint32 = function write_sint32(value) {
	    return this.uint32((value << 1 ^ value >> 31) >>> 0);
	};

	function writeVarint64(val, buf, pos) {
	    while (val.hi) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
	        val.hi >>>= 7;
	    }
	    while (val.lo > 127) {
	        buf[pos++] = val.lo & 127 | 128;
	        val.lo = val.lo >>> 7;
	    }
	    buf[pos++] = val.lo;
	}

	/**
	 * Writes an unsigned 64 bit value as a varint.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.uint64 = function write_uint64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a signed 64 bit value as a varint.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.int64 = Writer.prototype.uint64;

	/**
	 * Writes a signed 64 bit value as a varint, zig-zag encoded.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sint64 = function write_sint64(value) {
	    var bits = LongBits.from(value).zzEncode();
	    return this._push(writeVarint64, bits.length(), bits);
	};

	/**
	 * Writes a boolish value as a varint.
	 * @param {boolean} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bool = function write_bool(value) {
	    return this._push(writeByte, 1, value ? 1 : 0);
	};

	function writeFixed32(val, buf, pos) {
	    buf[pos    ] =  val         & 255;
	    buf[pos + 1] =  val >>> 8   & 255;
	    buf[pos + 2] =  val >>> 16  & 255;
	    buf[pos + 3] =  val >>> 24;
	}

	/**
	 * Writes an unsigned 32 bit value as fixed 32 bits.
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fixed32 = function write_fixed32(value) {
	    return this._push(writeFixed32, 4, value >>> 0);
	};

	/**
	 * Writes a signed 32 bit value as fixed 32 bits.
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.sfixed32 = Writer.prototype.fixed32;

	/**
	 * Writes an unsigned 64 bit value as fixed 64 bits.
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.fixed64 = function write_fixed64(value) {
	    var bits = LongBits.from(value);
	    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
	};

	/**
	 * Writes a signed 64 bit value as fixed 64 bits.
	 * @function
	 * @param {Long|number|string} value Value to write
	 * @returns {Writer} `this`
	 * @throws {TypeError} If `value` is a string and no long library is present.
	 */
	Writer.prototype.sfixed64 = Writer.prototype.fixed64;

	/**
	 * Writes a float (32 bit).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.float = function write_float(value) {
	    return this._push(util.float.writeFloatLE, 4, value);
	};

	/**
	 * Writes a double (64 bit float).
	 * @function
	 * @param {number} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.double = function write_double(value) {
	    return this._push(util.float.writeDoubleLE, 8, value);
	};

	var writeBytes = util.Array.prototype.set
	    ? function writeBytes_set(val, buf, pos) {
	        buf.set(val, pos); // also works for plain array values
	    }
	    /* istanbul ignore next */
	    : function writeBytes_for(val, buf, pos) {
	        for (var i = 0; i < val.length; ++i)
	            buf[pos + i] = val[i];
	    };

	/**
	 * Writes a sequence of bytes.
	 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.bytes = function write_bytes(value) {
	    var len = value.length >>> 0;
	    if (!len)
	        return this._push(writeByte, 1, 0);
	    if (util.isString(value)) {
	        var buf = Writer.alloc(len = base64.length(value));
	        base64.decode(value, buf, 0);
	        value = buf;
	    }
	    return this.uint32(len)._push(writeBytes, len, value);
	};

	/**
	 * Writes a string.
	 * @param {string} value Value to write
	 * @returns {Writer} `this`
	 */
	Writer.prototype.string = function write_string(value) {
	    var len = utf8.length(value);
	    return len
	        ? this.uint32(len)._push(utf8.write, len, value)
	        : this._push(writeByte, 1, 0);
	};

	/**
	 * Forks this writer's state by pushing it to a stack.
	 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.fork = function fork() {
	    this.states = new State(this);
	    this.head = this.tail = new Op(noop, 0, 0);
	    this.len = 0;
	    return this;
	};

	/**
	 * Resets this instance to the last state.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.reset = function reset() {
	    if (this.states) {
	        this.head   = this.states.head;
	        this.tail   = this.states.tail;
	        this.len    = this.states.len;
	        this.states = this.states.next;
	    } else {
	        this.head = this.tail = new Op(noop, 0, 0);
	        this.len  = 0;
	    }
	    return this;
	};

	/**
	 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
	 * @returns {Writer} `this`
	 */
	Writer.prototype.ldelim = function ldelim() {
	    var head = this.head,
	        tail = this.tail,
	        len  = this.len;
	    this.reset().uint32(len);
	    if (len) {
	        this.tail.next = head.next; // skip noop
	        this.tail = tail;
	        this.len += len;
	    }
	    return this;
	};

	/**
	 * Finishes the write operation.
	 * @returns {Uint8Array} Finished buffer
	 */
	Writer.prototype.finish = function finish() {
	    var head = this.head.next, // skip noop
	        buf  = this.constructor.alloc(this.len),
	        pos  = 0;
	    while (head) {
	        head.fn(head.val, buf, pos);
	        pos += head.len;
	        head = head.next;
	    }
	    // this.head = this.tail = null;
	    return buf;
	};

	Writer._configure = function(BufferWriter_) {
	    BufferWriter = BufferWriter_;
	    Writer.create = create();
	    BufferWriter._configure();
	};
	return writer;
}

var writer_buffer;
var hasRequiredWriter_buffer;

function requireWriter_buffer () {
	if (hasRequiredWriter_buffer) return writer_buffer;
	hasRequiredWriter_buffer = 1;
	writer_buffer = BufferWriter;

	// extends Writer
	var Writer = requireWriter();
	(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

	var util = requireMinimal$1();

	/**
	 * Constructs a new buffer writer instance.
	 * @classdesc Wire format writer using node buffers.
	 * @extends Writer
	 * @constructor
	 */
	function BufferWriter() {
	    Writer.call(this);
	}

	BufferWriter._configure = function () {
	    /**
	     * Allocates a buffer of the specified size.
	     * @function
	     * @param {number} size Buffer size
	     * @returns {Buffer} Buffer
	     */
	    BufferWriter.alloc = util._Buffer_allocUnsafe;

	    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
	        ? function writeBytesBuffer_set(val, buf, pos) {
	          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
	          // also works for plain array values
	        }
	        /* istanbul ignore next */
	        : function writeBytesBuffer_copy(val, buf, pos) {
	          if (val.copy) // Buffer values
	            val.copy(buf, pos, 0, val.length);
	          else for (var i = 0; i < val.length;) // plain array values
	            buf[pos++] = val[i++];
	        };
	};


	/**
	 * @override
	 */
	BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
	    if (util.isString(value))
	        value = util._Buffer_from(value, "base64");
	    var len = value.length >>> 0;
	    this.uint32(len);
	    if (len)
	        this._push(BufferWriter.writeBytesBuffer, len, value);
	    return this;
	};

	function writeStringBuffer(val, buf, pos) {
	    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
	        util.utf8.write(val, buf, pos);
	    else if (buf.utf8Write)
	        buf.utf8Write(val, pos);
	    else
	        buf.write(val, pos);
	}

	/**
	 * @override
	 */
	BufferWriter.prototype.string = function write_string_buffer(value) {
	    var len = util.Buffer.byteLength(value);
	    this.uint32(len);
	    if (len)
	        this._push(writeStringBuffer, len, value);
	    return this;
	};


	/**
	 * Finishes the write operation.
	 * @name BufferWriter#finish
	 * @function
	 * @returns {Buffer} Finished buffer
	 */

	BufferWriter._configure();
	return writer_buffer;
}

var reader;
var hasRequiredReader;

function requireReader () {
	if (hasRequiredReader) return reader;
	hasRequiredReader = 1;
	reader = Reader;

	var util      = requireMinimal$1();

	var BufferReader; // cyclic

	var LongBits  = util.LongBits,
	    utf8      = util.utf8;

	/* istanbul ignore next */
	function indexOutOfRange(reader, writeLength) {
	    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
	}

	/**
	 * Constructs a new reader instance using the specified buffer.
	 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
	 * @constructor
	 * @param {Uint8Array} buffer Buffer to read from
	 */
	function Reader(buffer) {

	    /**
	     * Read buffer.
	     * @type {Uint8Array}
	     */
	    this.buf = buffer;

	    /**
	     * Read buffer position.
	     * @type {number}
	     */
	    this.pos = 0;

	    /**
	     * Read buffer length.
	     * @type {number}
	     */
	    this.len = buffer.length;
	}

	var create_array = typeof Uint8Array !== "undefined"
	    ? function create_typed_array(buffer) {
	        if (buffer instanceof Uint8Array || Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    }
	    /* istanbul ignore next */
	    : function create_array(buffer) {
	        if (Array.isArray(buffer))
	            return new Reader(buffer);
	        throw Error("illegal buffer");
	    };

	var create = function create() {
	    return util.Buffer
	        ? function create_buffer_setup(buffer) {
	            return (Reader.create = function create_buffer(buffer) {
	                return util.Buffer.isBuffer(buffer)
	                    ? new BufferReader(buffer)
	                    /* istanbul ignore next */
	                    : create_array(buffer);
	            })(buffer);
	        }
	        /* istanbul ignore next */
	        : create_array;
	};

	/**
	 * Creates a new reader using the specified buffer.
	 * @function
	 * @param {Uint8Array|Buffer} buffer Buffer to read from
	 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
	 * @throws {Error} If `buffer` is not a valid buffer
	 */
	Reader.create = create();

	Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

	/**
	 * Reads a varint as an unsigned 32 bit value.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.uint32 = (function read_uint32_setup() {
	    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
	    return function read_uint32() {
	        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
	        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

	        /* istanbul ignore if */
	        if ((this.pos += 5) > this.len) {
	            this.pos = this.len;
	            throw indexOutOfRange(this, 10);
	        }
	        return value;
	    };
	})();

	/**
	 * Reads a varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.int32 = function read_int32() {
	    return this.uint32() | 0;
	};

	/**
	 * Reads a zig-zag encoded varint as a signed 32 bit value.
	 * @returns {number} Value read
	 */
	Reader.prototype.sint32 = function read_sint32() {
	    var value = this.uint32();
	    return value >>> 1 ^ -(value & 1) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readLongVarint() {
	    // tends to deopt with local vars for octet etc.
	    var bits = new LongBits(0, 0);
	    var i = 0;
	    if (this.len - this.pos > 4) { // fast route (lo)
	        for (; i < 4; ++i) {
	            // 1st..4th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 5th
	        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
	        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
	        if (this.buf[this.pos++] < 128)
	            return bits;
	        i = 0;
	    } else {
	        for (; i < 3; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 1st..3th
	            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	        // 4th
	        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
	        return bits;
	    }
	    if (this.len - this.pos > 4) { // fast route (hi)
	        for (; i < 5; ++i) {
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    } else {
	        for (; i < 5; ++i) {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	            // 6th..10th
	            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
	            if (this.buf[this.pos++] < 128)
	                return bits;
	        }
	    }
	    /* istanbul ignore next */
	    throw Error("invalid varint encoding");
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads a varint as a signed 64 bit value.
	 * @name Reader#int64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as an unsigned 64 bit value.
	 * @name Reader#uint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a zig-zag encoded varint as a signed 64 bit value.
	 * @name Reader#sint64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a varint as a boolean.
	 * @returns {boolean} Value read
	 */
	Reader.prototype.bool = function read_bool() {
	    return this.uint32() !== 0;
	};

	function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
	    return (buf[end - 4]
	          | buf[end - 3] << 8
	          | buf[end - 2] << 16
	          | buf[end - 1] << 24) >>> 0;
	}

	/**
	 * Reads fixed 32 bits as an unsigned 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.fixed32 = function read_fixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4);
	};

	/**
	 * Reads fixed 32 bits as a signed 32 bit integer.
	 * @returns {number} Value read
	 */
	Reader.prototype.sfixed32 = function read_sfixed32() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    return readFixed32_end(this.buf, this.pos += 4) | 0;
	};

	/* eslint-disable no-invalid-this */

	function readFixed64(/* this: Reader */) {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 8);

	    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
	}

	/* eslint-enable no-invalid-this */

	/**
	 * Reads fixed 64 bits.
	 * @name Reader#fixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads zig-zag encoded fixed 64 bits.
	 * @name Reader#sfixed64
	 * @function
	 * @returns {Long} Value read
	 */

	/**
	 * Reads a float (32 bit) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.float = function read_float() {

	    /* istanbul ignore if */
	    if (this.pos + 4 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readFloatLE(this.buf, this.pos);
	    this.pos += 4;
	    return value;
	};

	/**
	 * Reads a double (64 bit float) as a number.
	 * @function
	 * @returns {number} Value read
	 */
	Reader.prototype.double = function read_double() {

	    /* istanbul ignore if */
	    if (this.pos + 8 > this.len)
	        throw indexOutOfRange(this, 4);

	    var value = util.float.readDoubleLE(this.buf, this.pos);
	    this.pos += 8;
	    return value;
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @returns {Uint8Array} Value read
	 */
	Reader.prototype.bytes = function read_bytes() {
	    var length = this.uint32(),
	        start  = this.pos,
	        end    = this.pos + length;

	    /* istanbul ignore if */
	    if (end > this.len)
	        throw indexOutOfRange(this, length);

	    this.pos += length;
	    if (Array.isArray(this.buf)) // plain array
	        return this.buf.slice(start, end);

	    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1
	        var nativeBuffer = util.Buffer;
	        return nativeBuffer
	            ? nativeBuffer.alloc(0)
	            : new this.buf.constructor(0);
	    }
	    return this._slice.call(this.buf, start, end);
	};

	/**
	 * Reads a string preceeded by its byte length as a varint.
	 * @returns {string} Value read
	 */
	Reader.prototype.string = function read_string() {
	    var bytes = this.bytes();
	    return utf8.read(bytes, 0, bytes.length);
	};

	/**
	 * Skips the specified number of bytes if specified, otherwise skips a varint.
	 * @param {number} [length] Length if known, otherwise a varint is assumed
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skip = function skip(length) {
	    if (typeof length === "number") {
	        /* istanbul ignore if */
	        if (this.pos + length > this.len)
	            throw indexOutOfRange(this, length);
	        this.pos += length;
	    } else {
	        do {
	            /* istanbul ignore if */
	            if (this.pos >= this.len)
	                throw indexOutOfRange(this);
	        } while (this.buf[this.pos++] & 128);
	    }
	    return this;
	};

	/**
	 * Skips the next element of the specified wire type.
	 * @param {number} wireType Wire type received
	 * @returns {Reader} `this`
	 */
	Reader.prototype.skipType = function(wireType) {
	    switch (wireType) {
	        case 0:
	            this.skip();
	            break;
	        case 1:
	            this.skip(8);
	            break;
	        case 2:
	            this.skip(this.uint32());
	            break;
	        case 3:
	            while ((wireType = this.uint32() & 7) !== 4) {
	                this.skipType(wireType);
	            }
	            break;
	        case 5:
	            this.skip(4);
	            break;

	        /* istanbul ignore next */
	        default:
	            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
	    }
	    return this;
	};

	Reader._configure = function(BufferReader_) {
	    BufferReader = BufferReader_;
	    Reader.create = create();
	    BufferReader._configure();

	    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
	    util.merge(Reader.prototype, {

	        int64: function read_int64() {
	            return readLongVarint.call(this)[fn](false);
	        },

	        uint64: function read_uint64() {
	            return readLongVarint.call(this)[fn](true);
	        },

	        sint64: function read_sint64() {
	            return readLongVarint.call(this).zzDecode()[fn](false);
	        },

	        fixed64: function read_fixed64() {
	            return readFixed64.call(this)[fn](true);
	        },

	        sfixed64: function read_sfixed64() {
	            return readFixed64.call(this)[fn](false);
	        }

	    });
	};
	return reader;
}

var reader_buffer;
var hasRequiredReader_buffer;

function requireReader_buffer () {
	if (hasRequiredReader_buffer) return reader_buffer;
	hasRequiredReader_buffer = 1;
	reader_buffer = BufferReader;

	// extends Reader
	var Reader = requireReader();
	(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

	var util = requireMinimal$1();

	/**
	 * Constructs a new buffer reader instance.
	 * @classdesc Wire format reader using node buffers.
	 * @extends Reader
	 * @constructor
	 * @param {Buffer} buffer Buffer to read from
	 */
	function BufferReader(buffer) {
	    Reader.call(this, buffer);

	    /**
	     * Read buffer.
	     * @name BufferReader#buf
	     * @type {Buffer}
	     */
	}

	BufferReader._configure = function () {
	    /* istanbul ignore else */
	    if (util.Buffer)
	        BufferReader.prototype._slice = util.Buffer.prototype.slice;
	};


	/**
	 * @override
	 */
	BufferReader.prototype.string = function read_string_buffer() {
	    var len = this.uint32(); // modifies pos
	    return this.buf.utf8Slice
	        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
	        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
	};

	/**
	 * Reads a sequence of bytes preceeded by its length as a varint.
	 * @name BufferReader#bytes
	 * @function
	 * @returns {Buffer} Value read
	 */

	BufferReader._configure();
	return reader_buffer;
}

var rpc = {};

var service$1;
var hasRequiredService$1;

function requireService$1 () {
	if (hasRequiredService$1) return service$1;
	hasRequiredService$1 = 1;
	service$1 = Service;

	var util = requireMinimal$1();

	// Extends EventEmitter
	(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

	/**
	 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
	 *
	 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
	 * @typedef rpc.ServiceMethodCallback
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {Error|null} error Error, if any
	 * @param {TRes} [response] Response message
	 * @returns {undefined}
	 */

	/**
	 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
	 * @typedef rpc.ServiceMethod
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 * @type {function}
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
	 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
	 */

	/**
	 * Constructs a new RPC service instance.
	 * @classdesc An RPC service as returned by {@link Service#create}.
	 * @exports rpc.Service
	 * @extends util.EventEmitter
	 * @constructor
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 */
	function Service(rpcImpl, requestDelimited, responseDelimited) {

	    if (typeof rpcImpl !== "function")
	        throw TypeError("rpcImpl must be a function");

	    util.EventEmitter.call(this);

	    /**
	     * RPC implementation. Becomes `null` once the service is ended.
	     * @type {RPCImpl|null}
	     */
	    this.rpcImpl = rpcImpl;

	    /**
	     * Whether requests are length-delimited.
	     * @type {boolean}
	     */
	    this.requestDelimited = Boolean(requestDelimited);

	    /**
	     * Whether responses are length-delimited.
	     * @type {boolean}
	     */
	    this.responseDelimited = Boolean(responseDelimited);
	}

	/**
	 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
	 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
	 * @param {Constructor<TReq>} requestCtor Request constructor
	 * @param {Constructor<TRes>} responseCtor Response constructor
	 * @param {TReq|Properties<TReq>} request Request message or plain object
	 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
	 * @returns {undefined}
	 * @template TReq extends Message<TReq>
	 * @template TRes extends Message<TRes>
	 */
	Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

	    if (!request)
	        throw TypeError("request must be specified");

	    var self = this;
	    if (!callback)
	        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

	    if (!self.rpcImpl) {
	        setTimeout(function() { callback(Error("already ended")); }, 0);
	        return undefined;
	    }

	    try {
	        return self.rpcImpl(
	            method,
	            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
	            function rpcCallback(err, response) {

	                if (err) {
	                    self.emit("error", err, method);
	                    return callback(err);
	                }

	                if (response === null) {
	                    self.end(/* endedByRPC */ true);
	                    return undefined;
	                }

	                if (!(response instanceof responseCtor)) {
	                    try {
	                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
	                    } catch (err) {
	                        self.emit("error", err, method);
	                        return callback(err);
	                    }
	                }

	                self.emit("data", response, method);
	                return callback(null, response);
	            }
	        );
	    } catch (err) {
	        self.emit("error", err, method);
	        setTimeout(function() { callback(err); }, 0);
	        return undefined;
	    }
	};

	/**
	 * Ends this service and emits the `end` event.
	 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
	 * @returns {rpc.Service} `this`
	 */
	Service.prototype.end = function end(endedByRPC) {
	    if (this.rpcImpl) {
	        if (!endedByRPC) // signal end to rpcImpl
	            this.rpcImpl(null, null, null);
	        this.rpcImpl = null;
	        this.emit("end").off();
	    }
	    return this;
	};
	return service$1;
}

var hasRequiredRpc;

function requireRpc () {
	if (hasRequiredRpc) return rpc;
	hasRequiredRpc = 1;
	(function (exports) {

		/**
		 * Streaming RPC helpers.
		 * @namespace
		 */
		var rpc = exports;

		/**
		 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
		 * @typedef RPCImpl
		 * @type {function}
		 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
		 * @param {Uint8Array} requestData Request data
		 * @param {RPCImplCallback} callback Callback function
		 * @returns {undefined}
		 * @example
		 * function rpcImpl(method, requestData, callback) {
		 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
		 *         throw Error("no such method");
		 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
		 *         callback(err, responseData);
		 *     });
		 * }
		 */

		/**
		 * Node-style callback as used by {@link RPCImpl}.
		 * @typedef RPCImplCallback
		 * @type {function}
		 * @param {Error|null} error Error, if any, otherwise `null`
		 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
		 * @returns {undefined}
		 */

		rpc.Service = requireService$1(); 
	} (rpc));
	return rpc;
}

var roots;
var hasRequiredRoots;

function requireRoots () {
	if (hasRequiredRoots) return roots;
	hasRequiredRoots = 1;
	roots = {};

	/**
	 * Named roots.
	 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
	 * Can also be used manually to make roots available across modules.
	 * @name roots
	 * @type {Object.<string,Root>}
	 * @example
	 * // pbjs -r myroot -o compiled.js ...
	 *
	 * // in another module:
	 * require("./compiled.js");
	 *
	 * // in any subsequent module:
	 * var root = protobuf.roots["myroot"];
	 */
	return roots;
}

var hasRequiredIndexMinimal;

function requireIndexMinimal () {
	if (hasRequiredIndexMinimal) return indexMinimal;
	hasRequiredIndexMinimal = 1;
	(function (exports) {
		var protobuf = exports;

		/**
		 * Build type, one of `"full"`, `"light"` or `"minimal"`.
		 * @name build
		 * @type {string}
		 * @const
		 */
		protobuf.build = "minimal";

		// Serialization
		protobuf.Writer       = requireWriter();
		protobuf.BufferWriter = requireWriter_buffer();
		protobuf.Reader       = requireReader();
		protobuf.BufferReader = requireReader_buffer();

		// Utility
		protobuf.util         = requireMinimal$1();
		protobuf.rpc          = requireRpc();
		protobuf.roots        = requireRoots();
		protobuf.configure    = configure;

		/* istanbul ignore next */
		/**
		 * Reconfigures the library according to the environment.
		 * @returns {undefined}
		 */
		function configure() {
		    protobuf.util._configure();
		    protobuf.Writer._configure(protobuf.BufferWriter);
		    protobuf.Reader._configure(protobuf.BufferReader);
		}

		// Set up buffer utility according to the environment
		configure(); 
	} (indexMinimal));
	return indexMinimal;
}

var util$1 = {exports: {}};

var codegen_1;
var hasRequiredCodegen;

function requireCodegen () {
	if (hasRequiredCodegen) return codegen_1;
	hasRequiredCodegen = 1;
	codegen_1 = codegen;

	/**
	 * Begins generating a function.
	 * @memberof util
	 * @param {string[]} functionParams Function parameter names
	 * @param {string} [functionName] Function name if not anonymous
	 * @returns {Codegen} Appender that appends code to the function's body
	 */
	function codegen(functionParams, functionName) {

	    /* istanbul ignore if */
	    if (typeof functionParams === "string") {
	        functionName = functionParams;
	        functionParams = undefined;
	    }

	    var body = [];

	    /**
	     * Appends code to the function's body or finishes generation.
	     * @typedef Codegen
	     * @type {function}
	     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
	     * @param {...*} [formatParams] Format parameters
	     * @returns {Codegen|Function} Itself or the generated function if finished
	     * @throws {Error} If format parameter counts do not match
	     */

	    function Codegen(formatStringOrScope) {
	        // note that explicit array handling below makes this ~50% faster

	        // finish the function
	        if (typeof formatStringOrScope !== "string") {
	            var source = toString();
	            if (codegen.verbose)
	                console.log("codegen: " + source); // eslint-disable-line no-console
	            source = "return " + source;
	            if (formatStringOrScope) {
	                var scopeKeys   = Object.keys(formatStringOrScope),
	                    scopeParams = new Array(scopeKeys.length + 1),
	                    scopeValues = new Array(scopeKeys.length),
	                    scopeOffset = 0;
	                while (scopeOffset < scopeKeys.length) {
	                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
	                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
	                }
	                scopeParams[scopeOffset] = source;
	                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
	            }
	            return Function(source)(); // eslint-disable-line no-new-func
	        }

	        // otherwise append to body
	        var formatParams = new Array(arguments.length - 1),
	            formatOffset = 0;
	        while (formatOffset < formatParams.length)
	            formatParams[formatOffset] = arguments[++formatOffset];
	        formatOffset = 0;
	        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
	            var value = formatParams[formatOffset++];
	            switch ($1) {
	                case "d": case "f": return String(Number(value));
	                case "i": return String(Math.floor(value));
	                case "j": return JSON.stringify(value);
	                case "s": return String(value);
	            }
	            return "%";
	        });
	        if (formatOffset !== formatParams.length)
	            throw Error("parameter count mismatch");
	        body.push(formatStringOrScope);
	        return Codegen;
	    }

	    function toString(functionNameOverride) {
	        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
	    }

	    Codegen.toString = toString;
	    return Codegen;
	}

	/**
	 * Begins generating a function.
	 * @memberof util
	 * @function codegen
	 * @param {string} [functionName] Function name if not anonymous
	 * @returns {Codegen} Appender that appends code to the function's body
	 * @variation 2
	 */

	/**
	 * When set to `true`, codegen will log generated code to console. Useful for debugging.
	 * @name util.codegen.verbose
	 * @type {boolean}
	 */
	codegen.verbose = false;
	return codegen_1;
}

var fetch_1;
var hasRequiredFetch;

function requireFetch () {
	if (hasRequiredFetch) return fetch_1;
	hasRequiredFetch = 1;
	fetch_1 = fetch;

	var asPromise = requireAspromise(),
	    inquire   = requireInquire();

	var fs = inquire("fs");

	/**
	 * Node-style callback as used by {@link util.fetch}.
	 * @typedef FetchCallback
	 * @type {function}
	 * @param {?Error} error Error, if any, otherwise `null`
	 * @param {string} [contents] File contents, if there hasn't been an error
	 * @returns {undefined}
	 */

	/**
	 * Options as used by {@link util.fetch}.
	 * @typedef FetchOptions
	 * @type {Object}
	 * @property {boolean} [binary=false] Whether expecting a binary response
	 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
	 */

	/**
	 * Fetches the contents of a file.
	 * @memberof util
	 * @param {string} filename File path or url
	 * @param {FetchOptions} options Fetch options
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 */
	function fetch(filename, options, callback) {
	    if (typeof options === "function") {
	        callback = options;
	        options = {};
	    } else if (!options)
	        options = {};

	    if (!callback)
	        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

	    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
	    if (!options.xhr && fs && fs.readFile)
	        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
	            return err && typeof XMLHttpRequest !== "undefined"
	                ? fetch.xhr(filename, options, callback)
	                : err
	                ? callback(err)
	                : callback(null, options.binary ? contents : contents.toString("utf8"));
	        });

	    // use the XHR version otherwise.
	    return fetch.xhr(filename, options, callback);
	}

	/**
	 * Fetches the contents of a file.
	 * @name util.fetch
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 * @variation 2
	 */

	/**
	 * Fetches the contents of a file.
	 * @name util.fetch
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchOptions} [options] Fetch options
	 * @returns {Promise<string|Uint8Array>} Promise
	 * @variation 3
	 */

	/**/
	fetch.xhr = function fetch_xhr(filename, options, callback) {
	    var xhr = new XMLHttpRequest();
	    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

	        if (xhr.readyState !== 4)
	            return undefined;

	        // local cors security errors return status 0 / empty string, too. afaik this cannot be
	        // reliably distinguished from an actually empty file for security reasons. feel free
	        // to send a pull request if you are aware of a solution.
	        if (xhr.status !== 0 && xhr.status !== 200)
	            return callback(Error("status " + xhr.status));

	        // if binary data is expected, make sure that some sort of array is returned, even if
	        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
	        if (options.binary) {
	            var buffer = xhr.response;
	            if (!buffer) {
	                buffer = [];
	                for (var i = 0; i < xhr.responseText.length; ++i)
	                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
	            }
	            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
	        }
	        return callback(null, xhr.responseText);
	    };

	    if (options.binary) {
	        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
	        if ("overrideMimeType" in xhr)
	            xhr.overrideMimeType("text/plain; charset=x-user-defined");
	        xhr.responseType = "arraybuffer";
	    }

	    xhr.open("GET", filename);
	    xhr.send();
	};
	return fetch_1;
}

var path = {};

var hasRequiredPath;

function requirePath () {
	if (hasRequiredPath) return path;
	hasRequiredPath = 1;
	(function (exports) {

		/**
		 * A minimal path module to resolve Unix, Windows and URL paths alike.
		 * @memberof util
		 * @namespace
		 */
		var path = exports;

		var isAbsolute =
		/**
		 * Tests if the specified path is absolute.
		 * @param {string} path Path to test
		 * @returns {boolean} `true` if path is absolute
		 */
		path.isAbsolute = function isAbsolute(path) {
		    return /^(?:\/|\w+:)/.test(path);
		};

		var normalize =
		/**
		 * Normalizes the specified path.
		 * @param {string} path Path to normalize
		 * @returns {string} Normalized path
		 */
		path.normalize = function normalize(path) {
		    path = path.replace(/\\/g, "/")
		               .replace(/\/{2,}/g, "/");
		    var parts    = path.split("/"),
		        absolute = isAbsolute(path),
		        prefix   = "";
		    if (absolute)
		        prefix = parts.shift() + "/";
		    for (var i = 0; i < parts.length;) {
		        if (parts[i] === "..") {
		            if (i > 0 && parts[i - 1] !== "..")
		                parts.splice(--i, 2);
		            else if (absolute)
		                parts.splice(i, 1);
		            else
		                ++i;
		        } else if (parts[i] === ".")
		            parts.splice(i, 1);
		        else
		            ++i;
		    }
		    return prefix + parts.join("/");
		};

		/**
		 * Resolves the specified include path against the specified origin path.
		 * @param {string} originPath Path to the origin file
		 * @param {string} includePath Include path relative to origin path
		 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
		 * @returns {string} Path to the include file
		 */
		path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
		    if (!alreadyNormalized)
		        includePath = normalize(includePath);
		    if (isAbsolute(includePath))
		        return includePath;
		    if (!alreadyNormalized)
		        originPath = normalize(originPath);
		    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
		}; 
	} (path));
	return path;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	(function (exports) {

		/**
		 * Common type constants.
		 * @namespace
		 */
		var types = exports;

		var util = requireUtil$1();

		var s = [
		    "double",   // 0
		    "float",    // 1
		    "int32",    // 2
		    "uint32",   // 3
		    "sint32",   // 4
		    "fixed32",  // 5
		    "sfixed32", // 6
		    "int64",    // 7
		    "uint64",   // 8
		    "sint64",   // 9
		    "fixed64",  // 10
		    "sfixed64", // 11
		    "bool",     // 12
		    "string",   // 13
		    "bytes"     // 14
		];

		function bake(values, offset) {
		    var i = 0, o = {};
		    offset |= 0;
		    while (i < values.length) o[s[i + offset]] = values[i++];
		    return o;
		}

		/**
		 * Basic type wire types.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} double=1 Fixed64 wire type
		 * @property {number} float=5 Fixed32 wire type
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 * @property {number} string=2 Ldelim wire type
		 * @property {number} bytes=2 Ldelim wire type
		 */
		types.basic = bake([
		    /* double   */ 1,
		    /* float    */ 5,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0,
		    /* string   */ 2,
		    /* bytes    */ 2
		]);

		/**
		 * Basic type defaults.
		 * @type {Object.<string,*>}
		 * @const
		 * @property {number} double=0 Double default
		 * @property {number} float=0 Float default
		 * @property {number} int32=0 Int32 default
		 * @property {number} uint32=0 Uint32 default
		 * @property {number} sint32=0 Sint32 default
		 * @property {number} fixed32=0 Fixed32 default
		 * @property {number} sfixed32=0 Sfixed32 default
		 * @property {number} int64=0 Int64 default
		 * @property {number} uint64=0 Uint64 default
		 * @property {number} sint64=0 Sint32 default
		 * @property {number} fixed64=0 Fixed64 default
		 * @property {number} sfixed64=0 Sfixed64 default
		 * @property {boolean} bool=false Bool default
		 * @property {string} string="" String default
		 * @property {Array.<number>} bytes=Array(0) Bytes default
		 * @property {null} message=null Message default
		 */
		types.defaults = bake([
		    /* double   */ 0,
		    /* float    */ 0,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 0,
		    /* sfixed32 */ 0,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 0,
		    /* sfixed64 */ 0,
		    /* bool     */ false,
		    /* string   */ "",
		    /* bytes    */ util.emptyArray,
		    /* message  */ null
		]);

		/**
		 * Basic long type wire types.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 */
		types.long = bake([
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1
		], 7);

		/**
		 * Allowed types for map keys with their associated wire type.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 * @property {number} string=2 Ldelim wire type
		 */
		types.mapKey = bake([
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0,
		    /* string   */ 2
		], 2);

		/**
		 * Allowed types for packed repeated fields with their associated wire type.
		 * @type {Object.<string,number>}
		 * @const
		 * @property {number} double=1 Fixed64 wire type
		 * @property {number} float=5 Fixed32 wire type
		 * @property {number} int32=0 Varint wire type
		 * @property {number} uint32=0 Varint wire type
		 * @property {number} sint32=0 Varint wire type
		 * @property {number} fixed32=5 Fixed32 wire type
		 * @property {number} sfixed32=5 Fixed32 wire type
		 * @property {number} int64=0 Varint wire type
		 * @property {number} uint64=0 Varint wire type
		 * @property {number} sint64=0 Varint wire type
		 * @property {number} fixed64=1 Fixed64 wire type
		 * @property {number} sfixed64=1 Fixed64 wire type
		 * @property {number} bool=0 Varint wire type
		 */
		types.packed = bake([
		    /* double   */ 1,
		    /* float    */ 5,
		    /* int32    */ 0,
		    /* uint32   */ 0,
		    /* sint32   */ 0,
		    /* fixed32  */ 5,
		    /* sfixed32 */ 5,
		    /* int64    */ 0,
		    /* uint64   */ 0,
		    /* sint64   */ 0,
		    /* fixed64  */ 1,
		    /* sfixed64 */ 1,
		    /* bool     */ 0
		]); 
	} (types));
	return types;
}

var field;
var hasRequiredField;

function requireField () {
	if (hasRequiredField) return field;
	hasRequiredField = 1;
	field = Field;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

	var Enum  = require_enum(),
	    types = requireTypes(),
	    util  = requireUtil$1();

	var Type; // cyclic

	var ruleRe = /^required|optional|repeated$/;

	/**
	 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
	 * @name Field
	 * @classdesc Reflected message field.
	 * @extends FieldBase
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} type Value type
	 * @param {string|Object.<string,*>} [rule="optional"] Field rule
	 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
	 * @param {Object.<string,*>} [options] Declared options
	 */

	/**
	 * Constructs a field from a field descriptor.
	 * @param {string} name Field name
	 * @param {IField} json Field descriptor
	 * @returns {Field} Created field
	 * @throws {TypeError} If arguments are invalid
	 */
	Field.fromJSON = function fromJSON(name, json) {
	    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
	};

	/**
	 * Not an actual constructor. Use {@link Field} instead.
	 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
	 * @exports FieldBase
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} type Value type
	 * @param {string|Object.<string,*>} [rule="optional"] Field rule
	 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function Field(name, id, type, rule, extend, options, comment) {

	    if (util.isObject(rule)) {
	        comment = extend;
	        options = rule;
	        rule = extend = undefined;
	    } else if (util.isObject(extend)) {
	        comment = options;
	        options = extend;
	        extend = undefined;
	    }

	    ReflectionObject.call(this, name, options);

	    if (!util.isInteger(id) || id < 0)
	        throw TypeError("id must be a non-negative integer");

	    if (!util.isString(type))
	        throw TypeError("type must be a string");

	    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
	        throw TypeError("rule must be a string rule");

	    if (extend !== undefined && !util.isString(extend))
	        throw TypeError("extend must be a string");

	    /**
	     * Field rule, if any.
	     * @type {string|undefined}
	     */
	    if (rule === "proto3_optional") {
	        rule = "optional";
	    }
	    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

	    /**
	     * Field type.
	     * @type {string}
	     */
	    this.type = type; // toJSON

	    /**
	     * Unique field id.
	     * @type {number}
	     */
	    this.id = id; // toJSON, marker

	    /**
	     * Extended type if different from parent.
	     * @type {string|undefined}
	     */
	    this.extend = extend || undefined; // toJSON

	    /**
	     * Whether this field is required.
	     * @type {boolean}
	     */
	    this.required = rule === "required";

	    /**
	     * Whether this field is optional.
	     * @type {boolean}
	     */
	    this.optional = !this.required;

	    /**
	     * Whether this field is repeated.
	     * @type {boolean}
	     */
	    this.repeated = rule === "repeated";

	    /**
	     * Whether this field is a map or not.
	     * @type {boolean}
	     */
	    this.map = false;

	    /**
	     * Message this field belongs to.
	     * @type {Type|null}
	     */
	    this.message = null;

	    /**
	     * OneOf this field belongs to, if any,
	     * @type {OneOf|null}
	     */
	    this.partOf = null;

	    /**
	     * The field type's default value.
	     * @type {*}
	     */
	    this.typeDefault = null;

	    /**
	     * The field's default value on prototypes.
	     * @type {*}
	     */
	    this.defaultValue = null;

	    /**
	     * Whether this field's value should be treated as a long.
	     * @type {boolean}
	     */
	    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

	    /**
	     * Whether this field's value is a buffer.
	     * @type {boolean}
	     */
	    this.bytes = type === "bytes";

	    /**
	     * Resolved type if not a basic type.
	     * @type {Type|Enum|null}
	     */
	    this.resolvedType = null;

	    /**
	     * Sister-field within the extended type if a declaring extension field.
	     * @type {Field|null}
	     */
	    this.extensionField = null;

	    /**
	     * Sister-field within the declaring namespace if an extended field.
	     * @type {Field|null}
	     */
	    this.declaringField = null;

	    /**
	     * Internally remembers whether this field is packed.
	     * @type {boolean|null}
	     * @private
	     */
	    this._packed = null;

	    /**
	     * Comment for this field.
	     * @type {string|null}
	     */
	    this.comment = comment;
	}

	/**
	 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
	 * @name Field#packed
	 * @type {boolean}
	 * @readonly
	 */
	Object.defineProperty(Field.prototype, "packed", {
	    get: function() {
	        // defaults to packed=true if not explicity set to false
	        if (this._packed === null)
	            this._packed = this.getOption("packed") !== false;
	        return this._packed;
	    }
	});

	/**
	 * @override
	 */
	Field.prototype.setOption = function setOption(name, value, ifNotSet) {
	    if (name === "packed") // clear cached before setting
	        this._packed = null;
	    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
	};

	/**
	 * Field descriptor.
	 * @interface IField
	 * @property {string} [rule="optional"] Field rule
	 * @property {string} type Field type
	 * @property {number} id Field id
	 * @property {Object.<string,*>} [options] Field options
	 */

	/**
	 * Extension field descriptor.
	 * @interface IExtensionField
	 * @extends IField
	 * @property {string} extend Extended type
	 */

	/**
	 * Converts this field to a field descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IField} Field descriptor
	 */
	Field.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "rule"    , this.rule !== "optional" && this.rule || undefined,
	        "type"    , this.type,
	        "id"      , this.id,
	        "extend"  , this.extend,
	        "options" , this.options,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Resolves this field's type references.
	 * @returns {Field} `this`
	 * @throws {Error} If any reference cannot be resolved
	 */
	Field.prototype.resolve = function resolve() {

	    if (this.resolved)
	        return this;

	    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
	        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
	        if (this.resolvedType instanceof Type)
	            this.typeDefault = null;
	        else // instanceof Enum
	            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
	    } else if (this.options && this.options.proto3_optional) {
	        // proto3 scalar value marked optional; should default to null
	        this.typeDefault = null;
	    }

	    // use explicitly set default value if present
	    if (this.options && this.options["default"] != null) {
	        this.typeDefault = this.options["default"];
	        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
	            this.typeDefault = this.resolvedType.values[this.typeDefault];
	    }

	    // remove unnecessary options
	    if (this.options) {
	        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
	            delete this.options.packed;
	        if (!Object.keys(this.options).length)
	            this.options = undefined;
	    }

	    // convert to internal data type if necesssary
	    if (this.long) {
	        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

	        /* istanbul ignore else */
	        if (Object.freeze)
	            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

	    } else if (this.bytes && typeof this.typeDefault === "string") {
	        var buf;
	        if (util.base64.test(this.typeDefault))
	            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
	        else
	            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
	        this.typeDefault = buf;
	    }

	    // take special care of maps and repeated fields
	    if (this.map)
	        this.defaultValue = util.emptyObject;
	    else if (this.repeated)
	        this.defaultValue = util.emptyArray;
	    else
	        this.defaultValue = this.typeDefault;

	    // ensure proper value on prototype
	    if (this.parent instanceof Type)
	        this.parent.ctor.prototype[this.name] = this.defaultValue;

	    return ReflectionObject.prototype.resolve.call(this);
	};

	/**
	 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
	 * @typedef FieldDecorator
	 * @type {function}
	 * @param {Object} prototype Target prototype
	 * @param {string} fieldName Field name
	 * @returns {undefined}
	 */

	/**
	 * Field decorator (TypeScript).
	 * @name Field.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
	 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
	 * @param {T} [defaultValue] Default value
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
	 */
	Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

	    // submessage: decorate the submessage and use its name as the type
	    if (typeof fieldType === "function")
	        fieldType = util.decorateType(fieldType).name;

	    // enum reference: create a reflected copy of the enum and keep reuseing it
	    else if (fieldType && typeof fieldType === "object")
	        fieldType = util.decorateEnum(fieldType).name;

	    return function fieldDecorator(prototype, fieldName) {
	        util.decorateType(prototype.constructor)
	            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
	    };
	};

	/**
	 * Field decorator (TypeScript).
	 * @name Field.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {Constructor<T>|string} fieldType Field type
	 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends Message<T>
	 * @variation 2
	 */
	// like Field.d but without a default value

	// Sets up cyclic dependencies (called in index-light)
	Field._configure = function configure(Type_) {
	    Type = Type_;
	};
	return field;
}

var oneof;
var hasRequiredOneof;

function requireOneof () {
	if (hasRequiredOneof) return oneof;
	hasRequiredOneof = 1;
	oneof = OneOf;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

	var Field = requireField(),
	    util  = requireUtil$1();

	/**
	 * Constructs a new oneof instance.
	 * @classdesc Reflected oneof.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Oneof name
	 * @param {string[]|Object.<string,*>} [fieldNames] Field names
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function OneOf(name, fieldNames, options, comment) {
	    if (!Array.isArray(fieldNames)) {
	        options = fieldNames;
	        fieldNames = undefined;
	    }
	    ReflectionObject.call(this, name, options);

	    /* istanbul ignore if */
	    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
	        throw TypeError("fieldNames must be an Array");

	    /**
	     * Field names that belong to this oneof.
	     * @type {string[]}
	     */
	    this.oneof = fieldNames || []; // toJSON, marker

	    /**
	     * Fields that belong to this oneof as an array for iteration.
	     * @type {Field[]}
	     * @readonly
	     */
	    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

	    /**
	     * Comment for this field.
	     * @type {string|null}
	     */
	    this.comment = comment;
	}

	/**
	 * Oneof descriptor.
	 * @interface IOneOf
	 * @property {Array.<string>} oneof Oneof field names
	 * @property {Object.<string,*>} [options] Oneof options
	 */

	/**
	 * Constructs a oneof from a oneof descriptor.
	 * @param {string} name Oneof name
	 * @param {IOneOf} json Oneof descriptor
	 * @returns {OneOf} Created oneof
	 * @throws {TypeError} If arguments are invalid
	 */
	OneOf.fromJSON = function fromJSON(name, json) {
	    return new OneOf(name, json.oneof, json.options, json.comment);
	};

	/**
	 * Converts this oneof to a oneof descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IOneOf} Oneof descriptor
	 */
	OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options" , this.options,
	        "oneof"   , this.oneof,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Adds the fields of the specified oneof to the parent if not already done so.
	 * @param {OneOf} oneof The oneof
	 * @returns {undefined}
	 * @inner
	 * @ignore
	 */
	function addFieldsToParent(oneof) {
	    if (oneof.parent)
	        for (var i = 0; i < oneof.fieldsArray.length; ++i)
	            if (!oneof.fieldsArray[i].parent)
	                oneof.parent.add(oneof.fieldsArray[i]);
	}

	/**
	 * Adds a field to this oneof and removes it from its current parent, if any.
	 * @param {Field} field Field to add
	 * @returns {OneOf} `this`
	 */
	OneOf.prototype.add = function add(field) {

	    /* istanbul ignore if */
	    if (!(field instanceof Field))
	        throw TypeError("field must be a Field");

	    if (field.parent && field.parent !== this.parent)
	        field.parent.remove(field);
	    this.oneof.push(field.name);
	    this.fieldsArray.push(field);
	    field.partOf = this; // field.parent remains null
	    addFieldsToParent(this);
	    return this;
	};

	/**
	 * Removes a field from this oneof and puts it back to the oneof's parent.
	 * @param {Field} field Field to remove
	 * @returns {OneOf} `this`
	 */
	OneOf.prototype.remove = function remove(field) {

	    /* istanbul ignore if */
	    if (!(field instanceof Field))
	        throw TypeError("field must be a Field");

	    var index = this.fieldsArray.indexOf(field);

	    /* istanbul ignore if */
	    if (index < 0)
	        throw Error(field + " is not a member of " + this);

	    this.fieldsArray.splice(index, 1);
	    index = this.oneof.indexOf(field.name);

	    /* istanbul ignore else */
	    if (index > -1) // theoretical
	        this.oneof.splice(index, 1);

	    field.partOf = null;
	    return this;
	};

	/**
	 * @override
	 */
	OneOf.prototype.onAdd = function onAdd(parent) {
	    ReflectionObject.prototype.onAdd.call(this, parent);
	    var self = this;
	    // Collect present fields
	    for (var i = 0; i < this.oneof.length; ++i) {
	        var field = parent.get(this.oneof[i]);
	        if (field && !field.partOf) {
	            field.partOf = self;
	            self.fieldsArray.push(field);
	        }
	    }
	    // Add not yet present fields
	    addFieldsToParent(this);
	};

	/**
	 * @override
	 */
	OneOf.prototype.onRemove = function onRemove(parent) {
	    for (var i = 0, field; i < this.fieldsArray.length; ++i)
	        if ((field = this.fieldsArray[i]).parent)
	            field.parent.remove(field);
	    ReflectionObject.prototype.onRemove.call(this, parent);
	};

	/**
	 * Decorator function as returned by {@link OneOf.d} (TypeScript).
	 * @typedef OneOfDecorator
	 * @type {function}
	 * @param {Object} prototype Target prototype
	 * @param {string} oneofName OneOf name
	 * @returns {undefined}
	 */

	/**
	 * OneOf decorator (TypeScript).
	 * @function
	 * @param {...string} fieldNames Field names
	 * @returns {OneOfDecorator} Decorator function
	 * @template T extends string
	 */
	OneOf.d = function decorateOneOf() {
	    var fieldNames = new Array(arguments.length),
	        index = 0;
	    while (index < arguments.length)
	        fieldNames[index] = arguments[index++];
	    return function oneOfDecorator(prototype, oneofName) {
	        util.decorateType(prototype.constructor)
	            .add(new OneOf(oneofName, fieldNames));
	        Object.defineProperty(prototype, oneofName, {
	            get: util.oneOfGetter(fieldNames),
	            set: util.oneOfSetter(fieldNames)
	        });
	    };
	};
	return oneof;
}

var namespace;
var hasRequiredNamespace;

function requireNamespace () {
	if (hasRequiredNamespace) return namespace;
	hasRequiredNamespace = 1;
	namespace = Namespace;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

	var Field    = requireField(),
	    util     = requireUtil$1(),
	    OneOf    = requireOneof();

	var Type,    // cyclic
	    Service,
	    Enum;

	/**
	 * Constructs a new namespace instance.
	 * @name Namespace
	 * @classdesc Reflected namespace.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} [options] Declared options
	 */

	/**
	 * Constructs a namespace from JSON.
	 * @memberof Namespace
	 * @function
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} json JSON object
	 * @returns {Namespace} Created namespace
	 * @throws {TypeError} If arguments are invalid
	 */
	Namespace.fromJSON = function fromJSON(name, json) {
	    return new Namespace(name, json.options).addJSON(json.nested);
	};

	/**
	 * Converts an array of reflection objects to JSON.
	 * @memberof Namespace
	 * @param {ReflectionObject[]} array Object array
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
	 */
	function arrayToJSON(array, toJSONOptions) {
	    if (!(array && array.length))
	        return undefined;
	    var obj = {};
	    for (var i = 0; i < array.length; ++i)
	        obj[array[i].name] = array[i].toJSON(toJSONOptions);
	    return obj;
	}

	Namespace.arrayToJSON = arrayToJSON;

	/**
	 * Tests if the specified id is reserved.
	 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Namespace.isReservedId = function isReservedId(reserved, id) {
	    if (reserved)
	        for (var i = 0; i < reserved.length; ++i)
	            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
	                return true;
	    return false;
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Namespace.isReservedName = function isReservedName(reserved, name) {
	    if (reserved)
	        for (var i = 0; i < reserved.length; ++i)
	            if (reserved[i] === name)
	                return true;
	    return false;
	};

	/**
	 * Not an actual constructor. Use {@link Namespace} instead.
	 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
	 * @exports NamespaceBase
	 * @extends ReflectionObject
	 * @abstract
	 * @constructor
	 * @param {string} name Namespace name
	 * @param {Object.<string,*>} [options] Declared options
	 * @see {@link Namespace}
	 */
	function Namespace(name, options) {
	    ReflectionObject.call(this, name, options);

	    /**
	     * Nested objects by name.
	     * @type {Object.<string,ReflectionObject>|undefined}
	     */
	    this.nested = undefined; // toJSON

	    /**
	     * Cached nested objects as an array.
	     * @type {ReflectionObject[]|null}
	     * @private
	     */
	    this._nestedArray = null;
	}

	function clearCache(namespace) {
	    namespace._nestedArray = null;
	    return namespace;
	}

	/**
	 * Nested objects of this namespace as an array for iteration.
	 * @name NamespaceBase#nestedArray
	 * @type {ReflectionObject[]}
	 * @readonly
	 */
	Object.defineProperty(Namespace.prototype, "nestedArray", {
	    get: function() {
	        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
	    }
	});

	/**
	 * Namespace descriptor.
	 * @interface INamespace
	 * @property {Object.<string,*>} [options] Namespace options
	 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
	 */

	/**
	 * Any extension field descriptor.
	 * @typedef AnyExtensionField
	 * @type {IExtensionField|IExtensionMapField}
	 */

	/**
	 * Any nested object descriptor.
	 * @typedef AnyNestedObject
	 * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}
	 */

	/**
	 * Converts this namespace to a namespace descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {INamespace} Namespace descriptor
	 */
	Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
	    return util.toObject([
	        "options" , this.options,
	        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
	    ]);
	};

	/**
	 * Adds nested objects to this namespace from nested object descriptors.
	 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
	 * @returns {Namespace} `this`
	 */
	Namespace.prototype.addJSON = function addJSON(nestedJson) {
	    var ns = this;
	    /* istanbul ignore else */
	    if (nestedJson) {
	        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
	            nested = nestedJson[names[i]];
	            ns.add( // most to least likely
	                ( nested.fields !== undefined
	                ? Type.fromJSON
	                : nested.values !== undefined
	                ? Enum.fromJSON
	                : nested.methods !== undefined
	                ? Service.fromJSON
	                : nested.id !== undefined
	                ? Field.fromJSON
	                : Namespace.fromJSON )(names[i], nested)
	            );
	        }
	    }
	    return this;
	};

	/**
	 * Gets the nested object of the specified name.
	 * @param {string} name Nested object name
	 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
	 */
	Namespace.prototype.get = function get(name) {
	    return this.nested && this.nested[name]
	        || null;
	};

	/**
	 * Gets the values of the nested {@link Enum|enum} of the specified name.
	 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
	 * @param {string} name Nested enum name
	 * @returns {Object.<string,number>} Enum values
	 * @throws {Error} If there is no such enum
	 */
	Namespace.prototype.getEnum = function getEnum(name) {
	    if (this.nested && this.nested[name] instanceof Enum)
	        return this.nested[name].values;
	    throw Error("no such enum: " + name);
	};

	/**
	 * Adds a nested object to this namespace.
	 * @param {ReflectionObject} object Nested object to add
	 * @returns {Namespace} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a nested object with this name
	 */
	Namespace.prototype.add = function add(object) {

	    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type  || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
	        throw TypeError("object must be a valid nested object");

	    if (!this.nested)
	        this.nested = {};
	    else {
	        var prev = this.get(object.name);
	        if (prev) {
	            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
	                // replace plain namespace but keep existing nested elements and options
	                var nested = prev.nestedArray;
	                for (var i = 0; i < nested.length; ++i)
	                    object.add(nested[i]);
	                this.remove(prev);
	                if (!this.nested)
	                    this.nested = {};
	                object.setOptions(prev.options, true);

	            } else
	                throw Error("duplicate name '" + object.name + "' in " + this);
	        }
	    }
	    this.nested[object.name] = object;
	    object.onAdd(this);
	    return clearCache(this);
	};

	/**
	 * Removes a nested object from this namespace.
	 * @param {ReflectionObject} object Nested object to remove
	 * @returns {Namespace} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `object` is not a member of this namespace
	 */
	Namespace.prototype.remove = function remove(object) {

	    if (!(object instanceof ReflectionObject))
	        throw TypeError("object must be a ReflectionObject");
	    if (object.parent !== this)
	        throw Error(object + " is not a member of " + this);

	    delete this.nested[object.name];
	    if (!Object.keys(this.nested).length)
	        this.nested = undefined;

	    object.onRemove(this);
	    return clearCache(this);
	};

	/**
	 * Defines additial namespaces within this one if not yet existing.
	 * @param {string|string[]} path Path to create
	 * @param {*} [json] Nested types to create from JSON
	 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
	 */
	Namespace.prototype.define = function define(path, json) {

	    if (util.isString(path))
	        path = path.split(".");
	    else if (!Array.isArray(path))
	        throw TypeError("illegal path");
	    if (path && path.length && path[0] === "")
	        throw Error("path must be relative");

	    var ptr = this;
	    while (path.length > 0) {
	        var part = path.shift();
	        if (ptr.nested && ptr.nested[part]) {
	            ptr = ptr.nested[part];
	            if (!(ptr instanceof Namespace))
	                throw Error("path conflicts with non-namespace objects");
	        } else
	            ptr.add(ptr = new Namespace(part));
	    }
	    if (json)
	        ptr.addJSON(json);
	    return ptr;
	};

	/**
	 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
	 * @returns {Namespace} `this`
	 */
	Namespace.prototype.resolveAll = function resolveAll() {
	    var nested = this.nestedArray, i = 0;
	    while (i < nested.length)
	        if (nested[i] instanceof Namespace)
	            nested[i++].resolveAll();
	        else
	            nested[i++].resolve();
	    return this.resolve();
	};

	/**
	 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
	 * @param {string|string[]} path Path to look up
	 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
	 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
	 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
	 */
	Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

	    /* istanbul ignore next */
	    if (typeof filterTypes === "boolean") {
	        parentAlreadyChecked = filterTypes;
	        filterTypes = undefined;
	    } else if (filterTypes && !Array.isArray(filterTypes))
	        filterTypes = [ filterTypes ];

	    if (util.isString(path) && path.length) {
	        if (path === ".")
	            return this.root;
	        path = path.split(".");
	    } else if (!path.length)
	        return this;

	    // Start at root if path is absolute
	    if (path[0] === "")
	        return this.root.lookup(path.slice(1), filterTypes);

	    // Test if the first part matches any nested object, and if so, traverse if path contains more
	    var found = this.get(path[0]);
	    if (found) {
	        if (path.length === 1) {
	            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
	                return found;
	        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
	            return found;

	    // Otherwise try each nested namespace
	    } else
	        for (var i = 0; i < this.nestedArray.length; ++i)
	            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
	                return found;

	    // If there hasn't been a match, try again at the parent
	    if (this.parent === null || parentAlreadyChecked)
	        return null;
	    return this.parent.lookup(path, filterTypes);
	};

	/**
	 * Looks up the reflection object at the specified path, relative to this namespace.
	 * @name NamespaceBase#lookup
	 * @function
	 * @param {string|string[]} path Path to look up
	 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
	 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
	 * @variation 2
	 */
	// lookup(path: string, [parentAlreadyChecked: boolean])

	/**
	 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Type} Looked up type
	 * @throws {Error} If `path` does not point to a type
	 */
	Namespace.prototype.lookupType = function lookupType(path) {
	    var found = this.lookup(path, [ Type ]);
	    if (!found)
	        throw Error("no such type: " + path);
	    return found;
	};

	/**
	 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Enum} Looked up enum
	 * @throws {Error} If `path` does not point to an enum
	 */
	Namespace.prototype.lookupEnum = function lookupEnum(path) {
	    var found = this.lookup(path, [ Enum ]);
	    if (!found)
	        throw Error("no such Enum '" + path + "' in " + this);
	    return found;
	};

	/**
	 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Type} Looked up type or enum
	 * @throws {Error} If `path` does not point to a type or enum
	 */
	Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
	    var found = this.lookup(path, [ Type, Enum ]);
	    if (!found)
	        throw Error("no such Type or Enum '" + path + "' in " + this);
	    return found;
	};

	/**
	 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
	 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
	 * @param {string|string[]} path Path to look up
	 * @returns {Service} Looked up service
	 * @throws {Error} If `path` does not point to a service
	 */
	Namespace.prototype.lookupService = function lookupService(path) {
	    var found = this.lookup(path, [ Service ]);
	    if (!found)
	        throw Error("no such Service '" + path + "' in " + this);
	    return found;
	};

	// Sets up cyclic dependencies (called in index-light)
	Namespace._configure = function(Type_, Service_, Enum_) {
	    Type    = Type_;
	    Service = Service_;
	    Enum    = Enum_;
	};
	return namespace;
}

var mapfield;
var hasRequiredMapfield;

function requireMapfield () {
	if (hasRequiredMapfield) return mapfield;
	hasRequiredMapfield = 1;
	mapfield = MapField;

	// extends Field
	var Field = requireField();
	((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

	var types   = requireTypes(),
	    util    = requireUtil$1();

	/**
	 * Constructs a new map field instance.
	 * @classdesc Reflected map field.
	 * @extends FieldBase
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {number} id Unique id within its namespace
	 * @param {string} keyType Key type
	 * @param {string} type Value type
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] Comment associated with this field
	 */
	function MapField(name, id, keyType, type, options, comment) {
	    Field.call(this, name, id, type, undefined, undefined, options, comment);

	    /* istanbul ignore if */
	    if (!util.isString(keyType))
	        throw TypeError("keyType must be a string");

	    /**
	     * Key type.
	     * @type {string}
	     */
	    this.keyType = keyType; // toJSON, marker

	    /**
	     * Resolved key type if not a basic type.
	     * @type {ReflectionObject|null}
	     */
	    this.resolvedKeyType = null;

	    // Overrides Field#map
	    this.map = true;
	}

	/**
	 * Map field descriptor.
	 * @interface IMapField
	 * @extends {IField}
	 * @property {string} keyType Key type
	 */

	/**
	 * Extension map field descriptor.
	 * @interface IExtensionMapField
	 * @extends IMapField
	 * @property {string} extend Extended type
	 */

	/**
	 * Constructs a map field from a map field descriptor.
	 * @param {string} name Field name
	 * @param {IMapField} json Map field descriptor
	 * @returns {MapField} Created map field
	 * @throws {TypeError} If arguments are invalid
	 */
	MapField.fromJSON = function fromJSON(name, json) {
	    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
	};

	/**
	 * Converts this map field to a map field descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IMapField} Map field descriptor
	 */
	MapField.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "keyType" , this.keyType,
	        "type"    , this.type,
	        "id"      , this.id,
	        "extend"  , this.extend,
	        "options" , this.options,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * @override
	 */
	MapField.prototype.resolve = function resolve() {
	    if (this.resolved)
	        return this;

	    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
	    if (types.mapKey[this.keyType] === undefined)
	        throw Error("invalid key type: " + this.keyType);

	    return Field.prototype.resolve.call(this);
	};

	/**
	 * Map field decorator (TypeScript).
	 * @name MapField.d
	 * @function
	 * @param {number} fieldId Field id
	 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
	 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
	 * @returns {FieldDecorator} Decorator function
	 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
	 */
	MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

	    // submessage value: decorate the submessage and use its name as the type
	    if (typeof fieldValueType === "function")
	        fieldValueType = util.decorateType(fieldValueType).name;

	    // enum reference value: create a reflected copy of the enum and keep reuseing it
	    else if (fieldValueType && typeof fieldValueType === "object")
	        fieldValueType = util.decorateEnum(fieldValueType).name;

	    return function mapFieldDecorator(prototype, fieldName) {
	        util.decorateType(prototype.constructor)
	            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
	    };
	};
	return mapfield;
}

var method;
var hasRequiredMethod;

function requireMethod () {
	if (hasRequiredMethod) return method;
	hasRequiredMethod = 1;
	method = Method;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

	var util = requireUtil$1();

	/**
	 * Constructs a new service method instance.
	 * @classdesc Reflected service method.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Method name
	 * @param {string|undefined} type Method type, usually `"rpc"`
	 * @param {string} requestType Request message type
	 * @param {string} responseType Response message type
	 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
	 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] The comment for this method
	 * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object
	 */
	function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {

	    /* istanbul ignore next */
	    if (util.isObject(requestStream)) {
	        options = requestStream;
	        requestStream = responseStream = undefined;
	    } else if (util.isObject(responseStream)) {
	        options = responseStream;
	        responseStream = undefined;
	    }

	    /* istanbul ignore if */
	    if (!(type === undefined || util.isString(type)))
	        throw TypeError("type must be a string");

	    /* istanbul ignore if */
	    if (!util.isString(requestType))
	        throw TypeError("requestType must be a string");

	    /* istanbul ignore if */
	    if (!util.isString(responseType))
	        throw TypeError("responseType must be a string");

	    ReflectionObject.call(this, name, options);

	    /**
	     * Method type.
	     * @type {string}
	     */
	    this.type = type || "rpc"; // toJSON

	    /**
	     * Request type.
	     * @type {string}
	     */
	    this.requestType = requestType; // toJSON, marker

	    /**
	     * Whether requests are streamed or not.
	     * @type {boolean|undefined}
	     */
	    this.requestStream = requestStream ? true : undefined; // toJSON

	    /**
	     * Response type.
	     * @type {string}
	     */
	    this.responseType = responseType; // toJSON

	    /**
	     * Whether responses are streamed or not.
	     * @type {boolean|undefined}
	     */
	    this.responseStream = responseStream ? true : undefined; // toJSON

	    /**
	     * Resolved request type.
	     * @type {Type|null}
	     */
	    this.resolvedRequestType = null;

	    /**
	     * Resolved response type.
	     * @type {Type|null}
	     */
	    this.resolvedResponseType = null;

	    /**
	     * Comment for this method
	     * @type {string|null}
	     */
	    this.comment = comment;

	    /**
	     * Options properly parsed into an object
	     */
	    this.parsedOptions = parsedOptions;
	}

	/**
	 * Method descriptor.
	 * @interface IMethod
	 * @property {string} [type="rpc"] Method type
	 * @property {string} requestType Request type
	 * @property {string} responseType Response type
	 * @property {boolean} [requestStream=false] Whether requests are streamed
	 * @property {boolean} [responseStream=false] Whether responses are streamed
	 * @property {Object.<string,*>} [options] Method options
	 * @property {string} comment Method comments
	 * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object
	 */

	/**
	 * Constructs a method from a method descriptor.
	 * @param {string} name Method name
	 * @param {IMethod} json Method descriptor
	 * @returns {Method} Created method
	 * @throws {TypeError} If arguments are invalid
	 */
	Method.fromJSON = function fromJSON(name, json) {
	    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
	};

	/**
	 * Converts this method to a method descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IMethod} Method descriptor
	 */
	Method.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
	        "requestType"    , this.requestType,
	        "requestStream"  , this.requestStream,
	        "responseType"   , this.responseType,
	        "responseStream" , this.responseStream,
	        "options"        , this.options,
	        "comment"        , keepComments ? this.comment : undefined,
	        "parsedOptions"  , this.parsedOptions,
	    ]);
	};

	/**
	 * @override
	 */
	Method.prototype.resolve = function resolve() {

	    /* istanbul ignore if */
	    if (this.resolved)
	        return this;

	    this.resolvedRequestType = this.parent.lookupType(this.requestType);
	    this.resolvedResponseType = this.parent.lookupType(this.responseType);

	    return ReflectionObject.prototype.resolve.call(this);
	};
	return method;
}

var service;
var hasRequiredService;

function requireService () {
	if (hasRequiredService) return service;
	hasRequiredService = 1;
	service = Service;

	// extends Namespace
	var Namespace = requireNamespace();
	((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

	var Method = requireMethod(),
	    util   = requireUtil$1(),
	    rpc    = requireRpc();

	/**
	 * Constructs a new service instance.
	 * @classdesc Reflected service.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Service name
	 * @param {Object.<string,*>} [options] Service options
	 * @throws {TypeError} If arguments are invalid
	 */
	function Service(name, options) {
	    Namespace.call(this, name, options);

	    /**
	     * Service methods.
	     * @type {Object.<string,Method>}
	     */
	    this.methods = {}; // toJSON, marker

	    /**
	     * Cached methods as an array.
	     * @type {Method[]|null}
	     * @private
	     */
	    this._methodsArray = null;
	}

	/**
	 * Service descriptor.
	 * @interface IService
	 * @extends INamespace
	 * @property {Object.<string,IMethod>} methods Method descriptors
	 */

	/**
	 * Constructs a service from a service descriptor.
	 * @param {string} name Service name
	 * @param {IService} json Service descriptor
	 * @returns {Service} Created service
	 * @throws {TypeError} If arguments are invalid
	 */
	Service.fromJSON = function fromJSON(name, json) {
	    var service = new Service(name, json.options);
	    /* istanbul ignore else */
	    if (json.methods)
	        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
	            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
	    if (json.nested)
	        service.addJSON(json.nested);
	    service.comment = json.comment;
	    return service;
	};

	/**
	 * Converts this service to a service descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IService} Service descriptor
	 */
	Service.prototype.toJSON = function toJSON(toJSONOptions) {
	    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options" , inherited && inherited.options || undefined,
	        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
	        "nested"  , inherited && inherited.nested || undefined,
	        "comment" , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * Methods of this service as an array for iteration.
	 * @name Service#methodsArray
	 * @type {Method[]}
	 * @readonly
	 */
	Object.defineProperty(Service.prototype, "methodsArray", {
	    get: function() {
	        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
	    }
	});

	function clearCache(service) {
	    service._methodsArray = null;
	    return service;
	}

	/**
	 * @override
	 */
	Service.prototype.get = function get(name) {
	    return this.methods[name]
	        || Namespace.prototype.get.call(this, name);
	};

	/**
	 * @override
	 */
	Service.prototype.resolveAll = function resolveAll() {
	    var methods = this.methodsArray;
	    for (var i = 0; i < methods.length; ++i)
	        methods[i].resolve();
	    return Namespace.prototype.resolve.call(this);
	};

	/**
	 * @override
	 */
	Service.prototype.add = function add(object) {

	    /* istanbul ignore if */
	    if (this.get(object.name))
	        throw Error("duplicate name '" + object.name + "' in " + this);

	    if (object instanceof Method) {
	        this.methods[object.name] = object;
	        object.parent = this;
	        return clearCache(this);
	    }
	    return Namespace.prototype.add.call(this, object);
	};

	/**
	 * @override
	 */
	Service.prototype.remove = function remove(object) {
	    if (object instanceof Method) {

	        /* istanbul ignore if */
	        if (this.methods[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.methods[object.name];
	        object.parent = null;
	        return clearCache(this);
	    }
	    return Namespace.prototype.remove.call(this, object);
	};

	/**
	 * Creates a runtime service using the specified rpc implementation.
	 * @param {RPCImpl} rpcImpl RPC implementation
	 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
	 */
	Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
	    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
	    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
	        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
	        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
	            m: method,
	            q: method.resolvedRequestType.ctor,
	            s: method.resolvedResponseType.ctor
	        });
	    }
	    return rpcService;
	};
	return service;
}

var message;
var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return message;
	hasRequiredMessage = 1;
	message = Message;

	var util = requireMinimal$1();

	/**
	 * Constructs a new message instance.
	 * @classdesc Abstract runtime message.
	 * @constructor
	 * @param {Properties<T>} [properties] Properties to set
	 * @template T extends object = object
	 */
	function Message(properties) {
	    // not used internally
	    if (properties)
	        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	            this[keys[i]] = properties[keys[i]];
	}

	/**
	 * Reference to the reflected type.
	 * @name Message.$type
	 * @type {Type}
	 * @readonly
	 */

	/**
	 * Reference to the reflected type.
	 * @name Message#$type
	 * @type {Type}
	 * @readonly
	 */

	/*eslint-disable valid-jsdoc*/

	/**
	 * Creates a new message of this type using the specified properties.
	 * @param {Object.<string,*>} [properties] Properties to set
	 * @returns {Message<T>} Message instance
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.create = function create(properties) {
	    return this.$type.create(properties);
	};

	/**
	 * Encodes a message of this type.
	 * @param {T|Object.<string,*>} message Message to encode
	 * @param {Writer} [writer] Writer to use
	 * @returns {Writer} Writer
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.encode = function encode(message, writer) {
	    return this.$type.encode(message, writer);
	};

	/**
	 * Encodes a message of this type preceeded by its length as a varint.
	 * @param {T|Object.<string,*>} message Message to encode
	 * @param {Writer} [writer] Writer to use
	 * @returns {Writer} Writer
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.encodeDelimited = function encodeDelimited(message, writer) {
	    return this.$type.encodeDelimited(message, writer);
	};

	/**
	 * Decodes a message of this type.
	 * @name Message.decode
	 * @function
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode
	 * @returns {T} Decoded message
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.decode = function decode(reader) {
	    return this.$type.decode(reader);
	};

	/**
	 * Decodes a message of this type preceeded by its length as a varint.
	 * @name Message.decodeDelimited
	 * @function
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode
	 * @returns {T} Decoded message
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.decodeDelimited = function decodeDelimited(reader) {
	    return this.$type.decodeDelimited(reader);
	};

	/**
	 * Verifies a message of this type.
	 * @name Message.verify
	 * @function
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {string|null} `null` if valid, otherwise the reason why it is not
	 */
	Message.verify = function verify(message) {
	    return this.$type.verify(message);
	};

	/**
	 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
	 * @param {Object.<string,*>} object Plain object
	 * @returns {T} Message instance
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.fromObject = function fromObject(object) {
	    return this.$type.fromObject(object);
	};

	/**
	 * Creates a plain object from a message of this type. Also converts values to other types if specified.
	 * @param {T} message Message instance
	 * @param {IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 * @template T extends Message<T>
	 * @this Constructor<T>
	 */
	Message.toObject = function toObject(message, options) {
	    return this.$type.toObject(message, options);
	};

	/**
	 * Converts this message to JSON.
	 * @returns {Object.<string,*>} JSON object
	 */
	Message.prototype.toJSON = function toJSON() {
	    return this.$type.toObject(this, util.toJSONOptions);
	};

	/*eslint-enable valid-jsdoc*/
	return message;
}

var decoder_1;
var hasRequiredDecoder;

function requireDecoder () {
	if (hasRequiredDecoder) return decoder_1;
	hasRequiredDecoder = 1;
	decoder_1 = decoder;

	var Enum    = require_enum(),
	    types   = requireTypes(),
	    util    = requireUtil$1();

	function missing(field) {
	    return "missing required '" + field.name + "'";
	}

	/**
	 * Generates a decoder specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function decoder(mtype) {
	    /* eslint-disable no-unexpected-multiline */
	    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
	    ("if(!(r instanceof Reader))")
	        ("r=Reader.create(r)")
	    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
	    ("while(r.pos<c){")
	        ("var t=r.uint32()");
	    if (mtype.group) gen
	        ("if((t&7)===4)")
	            ("break");
	    gen
	        ("switch(t>>>3){");

	    var i = 0;
	    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
	        var field = mtype._fieldsArray[i].resolve(),
	            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
	            ref   = "m" + util.safeProp(field.name); gen
	            ("case %i: {", field.id);

	        // Map fields
	        if (field.map) { gen
	                ("if(%s===util.emptyObject)", ref)
	                    ("%s={}", ref)
	                ("var c2 = r.uint32()+r.pos");

	            if (types.defaults[field.keyType] !== undefined) gen
	                ("k=%j", types.defaults[field.keyType]);
	            else gen
	                ("k=null");

	            if (types.defaults[type] !== undefined) gen
	                ("value=%j", types.defaults[type]);
	            else gen
	                ("value=null");

	            gen
	                ("while(r.pos<c2){")
	                    ("var tag2=r.uint32()")
	                    ("switch(tag2>>>3){")
	                        ("case 1: k=r.%s(); break", field.keyType)
	                        ("case 2:");

	            if (types.basic[type] === undefined) gen
	                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
	            else gen
	                            ("value=r.%s()", type);

	            gen
	                            ("break")
	                        ("default:")
	                            ("r.skipType(tag2&7)")
	                            ("break")
	                    ("}")
	                ("}");

	            if (types.long[field.keyType] !== undefined) gen
	                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
	            else gen
	                ("%s[k]=value", ref);

	        // Repeated fields
	        } else if (field.repeated) { gen

	                ("if(!(%s&&%s.length))", ref, ref)
	                    ("%s=[]", ref);

	            // Packable (always check for forward and backward compatiblity)
	            if (types.packed[type] !== undefined) gen
	                ("if((t&7)===2){")
	                    ("var c2=r.uint32()+r.pos")
	                    ("while(r.pos<c2)")
	                        ("%s.push(r.%s())", ref, type)
	                ("}else");

	            // Non-packed
	            if (types.basic[type] === undefined) gen(field.resolvedType.group
	                    ? "%s.push(types[%i].decode(r))"
	                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
	            else gen
	                    ("%s.push(r.%s())", ref, type);

	        // Non-repeated
	        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
	                ? "%s=types[%i].decode(r)"
	                : "%s=types[%i].decode(r,r.uint32())", ref, i);
	        else gen
	                ("%s=r.%s()", ref, type);
	        gen
	                ("break")
	            ("}");
	        // Unknown fields
	    } gen
	            ("default:")
	                ("r.skipType(t&7)")
	                ("break")

	        ("}")
	    ("}");

	    // Field presence
	    for (i = 0; i < mtype._fieldsArray.length; ++i) {
	        var rfield = mtype._fieldsArray[i];
	        if (rfield.required) gen
	    ("if(!m.hasOwnProperty(%j))", rfield.name)
	        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
	    }

	    return gen
	    ("return m");
	    /* eslint-enable no-unexpected-multiline */
	}
	return decoder_1;
}

var verifier_1;
var hasRequiredVerifier;

function requireVerifier () {
	if (hasRequiredVerifier) return verifier_1;
	hasRequiredVerifier = 1;
	verifier_1 = verifier;

	var Enum      = require_enum(),
	    util      = requireUtil$1();

	function invalid(field, expected) {
	    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
	}

	/**
	 * Generates a partial value verifier.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {number} fieldIndex Field index
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genVerifyValue(gen, field, fieldIndex, ref) {
	    /* eslint-disable no-unexpected-multiline */
	    if (field.resolvedType) {
	        if (field.resolvedType instanceof Enum) { gen
	            ("switch(%s){", ref)
	                ("default:")
	                    ("return%j", invalid(field, "enum value"));
	            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
	                ("case %i:", field.resolvedType.values[keys[j]]);
	            gen
	                    ("break")
	            ("}");
	        } else {
	            gen
	            ("{")
	                ("var e=types[%i].verify(%s);", fieldIndex, ref)
	                ("if(e)")
	                    ("return%j+e", field.name + ".")
	            ("}");
	        }
	    } else {
	        switch (field.type) {
	            case "int32":
	            case "uint32":
	            case "sint32":
	            case "fixed32":
	            case "sfixed32": gen
	                ("if(!util.isInteger(%s))", ref)
	                    ("return%j", invalid(field, "integer"));
	                break;
	            case "int64":
	            case "uint64":
	            case "sint64":
	            case "fixed64":
	            case "sfixed64": gen
	                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
	                    ("return%j", invalid(field, "integer|Long"));
	                break;
	            case "float":
	            case "double": gen
	                ("if(typeof %s!==\"number\")", ref)
	                    ("return%j", invalid(field, "number"));
	                break;
	            case "bool": gen
	                ("if(typeof %s!==\"boolean\")", ref)
	                    ("return%j", invalid(field, "boolean"));
	                break;
	            case "string": gen
	                ("if(!util.isString(%s))", ref)
	                    ("return%j", invalid(field, "string"));
	                break;
	            case "bytes": gen
	                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
	                    ("return%j", invalid(field, "buffer"));
	                break;
	        }
	    }
	    return gen;
	    /* eslint-enable no-unexpected-multiline */
	}

	/**
	 * Generates a partial key verifier.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genVerifyKey(gen, field, ref) {
	    /* eslint-disable no-unexpected-multiline */
	    switch (field.keyType) {
	        case "int32":
	        case "uint32":
	        case "sint32":
	        case "fixed32":
	        case "sfixed32": gen
	            ("if(!util.key32Re.test(%s))", ref)
	                ("return%j", invalid(field, "integer key"));
	            break;
	        case "int64":
	        case "uint64":
	        case "sint64":
	        case "fixed64":
	        case "sfixed64": gen
	            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
	                ("return%j", invalid(field, "integer|Long key"));
	            break;
	        case "bool": gen
	            ("if(!util.key2Re.test(%s))", ref)
	                ("return%j", invalid(field, "boolean key"));
	            break;
	    }
	    return gen;
	    /* eslint-enable no-unexpected-multiline */
	}

	/**
	 * Generates a verifier specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function verifier(mtype) {
	    /* eslint-disable no-unexpected-multiline */

	    var gen = util.codegen(["m"], mtype.name + "$verify")
	    ("if(typeof m!==\"object\"||m===null)")
	        ("return%j", "object expected");
	    var oneofs = mtype.oneofsArray,
	        seenFirstField = {};
	    if (oneofs.length) gen
	    ("var p={}");

	    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
	        var field = mtype._fieldsArray[i].resolve(),
	            ref   = "m" + util.safeProp(field.name);

	        if (field.optional) gen
	        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

	        // map fields
	        if (field.map) { gen
	            ("if(!util.isObject(%s))", ref)
	                ("return%j", invalid(field, "object"))
	            ("var k=Object.keys(%s)", ref)
	            ("for(var i=0;i<k.length;++i){");
	                genVerifyKey(gen, field, "k[i]");
	                genVerifyValue(gen, field, i, ref + "[k[i]]")
	            ("}");

	        // repeated fields
	        } else if (field.repeated) { gen
	            ("if(!Array.isArray(%s))", ref)
	                ("return%j", invalid(field, "array"))
	            ("for(var i=0;i<%s.length;++i){", ref);
	                genVerifyValue(gen, field, i, ref + "[i]")
	            ("}");

	        // required or present fields
	        } else {
	            if (field.partOf) {
	                var oneofProp = util.safeProp(field.partOf.name);
	                if (seenFirstField[field.partOf.name] === 1) gen
	            ("if(p%s===1)", oneofProp)
	                ("return%j", field.partOf.name + ": multiple values");
	                seenFirstField[field.partOf.name] = 1;
	                gen
	            ("p%s=1", oneofProp);
	            }
	            genVerifyValue(gen, field, i, ref);
	        }
	        if (field.optional) gen
	        ("}");
	    }
	    return gen
	    ("return null");
	    /* eslint-enable no-unexpected-multiline */
	}
	return verifier_1;
}

var converter = {};

var hasRequiredConverter;

function requireConverter () {
	if (hasRequiredConverter) return converter;
	hasRequiredConverter = 1;
	(function (exports) {
		/**
		 * Runtime message from/to plain object converters.
		 * @namespace
		 */
		var converter = exports;

		var Enum = require_enum(),
		    util = requireUtil$1();

		/**
		 * Generates a partial value fromObject conveter.
		 * @param {Codegen} gen Codegen instance
		 * @param {Field} field Reflected field
		 * @param {number} fieldIndex Field index
		 * @param {string} prop Property reference
		 * @returns {Codegen} Codegen instance
		 * @ignore
		 */
		function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
		    var defaultAlreadyEmitted = false;
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    if (field.resolvedType) {
		        if (field.resolvedType instanceof Enum) { gen
		            ("switch(d%s){", prop);
		            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
		                // enum unknown values passthrough
		                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) { gen
		                    ("default:")
		                        ("if(typeof(d%s)===\"number\"){m%s=d%s;break}", prop, prop, prop);
		                    if (!field.repeated) gen // fallback to default value only for
		                                             // arrays, to avoid leaving holes.
		                        ("break");           // for non-repeated fields, just ignore
		                    defaultAlreadyEmitted = true;
		                }
		                gen
		                ("case%j:", keys[i])
		                ("case %i:", values[keys[i]])
		                    ("m%s=%j", prop, values[keys[i]])
		                    ("break");
		            } gen
		            ("}");
		        } else gen
		            ("if(typeof d%s!==\"object\")", prop)
		                ("throw TypeError(%j)", field.fullName + ": object expected")
		            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
		    } else {
		        var isUnsigned = false;
		        switch (field.type) {
		            case "double":
		            case "float": gen
		                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
		                break;
		            case "uint32":
		            case "fixed32": gen
		                ("m%s=d%s>>>0", prop, prop);
		                break;
		            case "int32":
		            case "sint32":
		            case "sfixed32": gen
		                ("m%s=d%s|0", prop, prop);
		                break;
		            case "uint64":
		                isUnsigned = true;
		                // eslint-disable-next-line no-fallthrough
		            case "int64":
		            case "sint64":
		            case "fixed64":
		            case "sfixed64": gen
		                ("if(util.Long)")
		                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
		                ("else if(typeof d%s===\"string\")", prop)
		                    ("m%s=parseInt(d%s,10)", prop, prop)
		                ("else if(typeof d%s===\"number\")", prop)
		                    ("m%s=d%s", prop, prop)
		                ("else if(typeof d%s===\"object\")", prop)
		                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
		                break;
		            case "bytes": gen
		                ("if(typeof d%s===\"string\")", prop)
		                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
		                ("else if(d%s.length >= 0)", prop)
		                    ("m%s=d%s", prop, prop);
		                break;
		            case "string": gen
		                ("m%s=String(d%s)", prop, prop);
		                break;
		            case "bool": gen
		                ("m%s=Boolean(d%s)", prop, prop);
		                break;
		            /* default: gen
		                ("m%s=d%s", prop, prop);
		                break; */
		        }
		    }
		    return gen;
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}

		/**
		 * Generates a plain object to runtime message converter specific to the specified message type.
		 * @param {Type} mtype Message type
		 * @returns {Codegen} Codegen instance
		 */
		converter.fromObject = function fromObject(mtype) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    var fields = mtype.fieldsArray;
		    var gen = util.codegen(["d"], mtype.name + "$fromObject")
		    ("if(d instanceof this.ctor)")
		        ("return d");
		    if (!fields.length) return gen
		    ("return new this.ctor");
		    gen
		    ("var m=new this.ctor");
		    for (var i = 0; i < fields.length; ++i) {
		        var field  = fields[i].resolve(),
		            prop   = util.safeProp(field.name);

		        // Map fields
		        if (field.map) { gen
		    ("if(d%s){", prop)
		        ("if(typeof d%s!==\"object\")", prop)
		            ("throw TypeError(%j)", field.fullName + ": object expected")
		        ("m%s={}", prop)
		        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
		            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
		        ("}")
		    ("}");

		        // Repeated fields
		        } else if (field.repeated) { gen
		    ("if(d%s){", prop)
		        ("if(!Array.isArray(d%s))", prop)
		            ("throw TypeError(%j)", field.fullName + ": array expected")
		        ("m%s=[]", prop)
		        ("for(var i=0;i<d%s.length;++i){", prop);
		            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
		        ("}")
		    ("}");

		        // Non-repeated fields
		        } else {
		            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
		    ("if(d%s!=null){", prop); // !== undefined && !== null
		        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
		            if (!(field.resolvedType instanceof Enum)) gen
		    ("}");
		        }
		    } return gen
		    ("return m");
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		};

		/**
		 * Generates a partial value toObject converter.
		 * @param {Codegen} gen Codegen instance
		 * @param {Field} field Reflected field
		 * @param {number} fieldIndex Field index
		 * @param {string} prop Property reference
		 * @returns {Codegen} Codegen instance
		 * @ignore
		 */
		function genValuePartial_toObject(gen, field, fieldIndex, prop) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    if (field.resolvedType) {
		        if (field.resolvedType instanceof Enum) gen
		            ("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
		        else gen
		            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
		    } else {
		        var isUnsigned = false;
		        switch (field.type) {
		            case "double":
		            case "float": gen
		            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
		                break;
		            case "uint64":
		                isUnsigned = true;
		                // eslint-disable-next-line no-fallthrough
		            case "int64":
		            case "sint64":
		            case "fixed64":
		            case "sfixed64": gen
		            ("if(typeof m%s===\"number\")", prop)
		                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
		            ("else") // Long-like
		                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
		                break;
		            case "bytes": gen
		            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
		                break;
		            default: gen
		            ("d%s=m%s", prop, prop);
		                break;
		        }
		    }
		    return gen;
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}

		/**
		 * Generates a runtime message to plain object converter specific to the specified message type.
		 * @param {Type} mtype Message type
		 * @returns {Codegen} Codegen instance
		 */
		converter.toObject = function toObject(mtype) {
		    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
		    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
		    if (!fields.length)
		        return util.codegen()("return {}");
		    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
		    ("if(!o)")
		        ("o={}")
		    ("var d={}");

		    var repeatedFields = [],
		        mapFields = [],
		        normalFields = [],
		        i = 0;
		    for (; i < fields.length; ++i)
		        if (!fields[i].partOf)
		            ( fields[i].resolve().repeated ? repeatedFields
		            : fields[i].map ? mapFields
		            : normalFields).push(fields[i]);

		    if (repeatedFields.length) { gen
		    ("if(o.arrays||o.defaults){");
		        for (i = 0; i < repeatedFields.length; ++i) gen
		        ("d%s=[]", util.safeProp(repeatedFields[i].name));
		        gen
		    ("}");
		    }

		    if (mapFields.length) { gen
		    ("if(o.objects||o.defaults){");
		        for (i = 0; i < mapFields.length; ++i) gen
		        ("d%s={}", util.safeProp(mapFields[i].name));
		        gen
		    ("}");
		    }

		    if (normalFields.length) { gen
		    ("if(o.defaults){");
		        for (i = 0; i < normalFields.length; ++i) {
		            var field = normalFields[i],
		                prop  = util.safeProp(field.name);
		            if (field.resolvedType instanceof Enum) gen
		        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
		            else if (field.long) gen
		        ("if(util.Long){")
		            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
		            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
		        ("}else")
		            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
		            else if (field.bytes) {
		                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
		                gen
		        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
		        ("else{")
		            ("d%s=%s", prop, arrayDefault)
		            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
		        ("}");
		            } else gen
		        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
		        } gen
		    ("}");
		    }
		    var hasKs2 = false;
		    for (i = 0; i < fields.length; ++i) {
		        var field = fields[i],
		            index = mtype._fieldsArray.indexOf(field),
		            prop  = util.safeProp(field.name);
		        if (field.map) {
		            if (!hasKs2) { hasKs2 = true; gen
		    ("var ks2");
		            } gen
		    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
		        ("d%s={}", prop)
		        ("for(var j=0;j<ks2.length;++j){");
		            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
		        ("}");
		        } else if (field.repeated) { gen
		    ("if(m%s&&m%s.length){", prop, prop)
		        ("d%s=[]", prop)
		        ("for(var j=0;j<m%s.length;++j){", prop);
		            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
		        ("}");
		        } else { gen
		    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
		        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
		        if (field.partOf) gen
		        ("if(o.oneofs)")
		            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
		        }
		        gen
		    ("}");
		    }
		    return gen
		    ("return d");
		    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
		}; 
	} (converter));
	return converter;
}

var wrappers = {};

var hasRequiredWrappers;

function requireWrappers () {
	if (hasRequiredWrappers) return wrappers;
	hasRequiredWrappers = 1;
	(function (exports) {

		/**
		 * Wrappers for common types.
		 * @type {Object.<string,IWrapper>}
		 * @const
		 */
		var wrappers = exports;

		var Message = requireMessage();

		/**
		 * From object converter part of an {@link IWrapper}.
		 * @typedef WrapperFromObjectConverter
		 * @type {function}
		 * @param {Object.<string,*>} object Plain object
		 * @returns {Message<{}>} Message instance
		 * @this Type
		 */

		/**
		 * To object converter part of an {@link IWrapper}.
		 * @typedef WrapperToObjectConverter
		 * @type {function}
		 * @param {Message<{}>} message Message instance
		 * @param {IConversionOptions} [options] Conversion options
		 * @returns {Object.<string,*>} Plain object
		 * @this Type
		 */

		/**
		 * Common type wrapper part of {@link wrappers}.
		 * @interface IWrapper
		 * @property {WrapperFromObjectConverter} [fromObject] From object converter
		 * @property {WrapperToObjectConverter} [toObject] To object converter
		 */

		// Custom wrapper for Any
		wrappers[".google.protobuf.Any"] = {

		    fromObject: function(object) {

		        // unwrap value type if mapped
		        if (object && object["@type"]) {
		             // Only use fully qualified type name after the last '/'
		            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
		            var type = this.lookup(name);
		            /* istanbul ignore else */
		            if (type) {
		                // type_url does not accept leading "."
		                var type_url = object["@type"].charAt(0) === "." ?
		                    object["@type"].slice(1) : object["@type"];
		                // type_url prefix is optional, but path seperator is required
		                if (type_url.indexOf("/") === -1) {
		                    type_url = "/" + type_url;
		                }
		                return this.create({
		                    type_url: type_url,
		                    value: type.encode(type.fromObject(object)).finish()
		                });
		            }
		        }

		        return this.fromObject(object);
		    },

		    toObject: function(message, options) {

		        // Default prefix
		        var googleApi = "type.googleapis.com/";
		        var prefix = "";
		        var name = "";

		        // decode value if requested and unmapped
		        if (options && options.json && message.type_url && message.value) {
		            // Only use fully qualified type name after the last '/'
		            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
		            // Separate the prefix used
		            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
		            var type = this.lookup(name);
		            /* istanbul ignore else */
		            if (type)
		                message = type.decode(message.value);
		        }

		        // wrap value if unmapped
		        if (!(message instanceof this.ctor) && message instanceof Message) {
		            var object = message.$type.toObject(message, options);
		            var messageName = message.$type.fullName[0] === "." ?
		                message.$type.fullName.slice(1) : message.$type.fullName;
		            // Default to type.googleapis.com prefix if no prefix is used
		            if (prefix === "") {
		                prefix = googleApi;
		            }
		            name = prefix + messageName;
		            object["@type"] = name;
		            return object;
		        }

		        return this.toObject(message, options);
		    }
		}; 
	} (wrappers));
	return wrappers;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;
	type = Type;

	// extends Namespace
	var Namespace = requireNamespace();
	((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

	var Enum      = require_enum(),
	    OneOf     = requireOneof(),
	    Field     = requireField(),
	    MapField  = requireMapfield(),
	    Service   = requireService(),
	    Message   = requireMessage(),
	    Reader    = requireReader(),
	    Writer    = requireWriter(),
	    util      = requireUtil$1(),
	    encoder   = requireEncoder(),
	    decoder   = requireDecoder(),
	    verifier  = requireVerifier(),
	    converter = requireConverter(),
	    wrappers  = requireWrappers();

	/**
	 * Constructs a new reflected message type instance.
	 * @classdesc Reflected message type.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {string} name Message name
	 * @param {Object.<string,*>} [options] Declared options
	 */
	function Type(name, options) {
	    Namespace.call(this, name, options);

	    /**
	     * Message fields.
	     * @type {Object.<string,Field>}
	     */
	    this.fields = {};  // toJSON, marker

	    /**
	     * Oneofs declared within this namespace, if any.
	     * @type {Object.<string,OneOf>}
	     */
	    this.oneofs = undefined; // toJSON

	    /**
	     * Extension ranges, if any.
	     * @type {number[][]}
	     */
	    this.extensions = undefined; // toJSON

	    /**
	     * Reserved ranges, if any.
	     * @type {Array.<number[]|string>}
	     */
	    this.reserved = undefined; // toJSON

	    /*?
	     * Whether this type is a legacy group.
	     * @type {boolean|undefined}
	     */
	    this.group = undefined; // toJSON

	    /**
	     * Cached fields by id.
	     * @type {Object.<number,Field>|null}
	     * @private
	     */
	    this._fieldsById = null;

	    /**
	     * Cached fields as an array.
	     * @type {Field[]|null}
	     * @private
	     */
	    this._fieldsArray = null;

	    /**
	     * Cached oneofs as an array.
	     * @type {OneOf[]|null}
	     * @private
	     */
	    this._oneofsArray = null;

	    /**
	     * Cached constructor.
	     * @type {Constructor<{}>}
	     * @private
	     */
	    this._ctor = null;
	}

	Object.defineProperties(Type.prototype, {

	    /**
	     * Message fields by id.
	     * @name Type#fieldsById
	     * @type {Object.<number,Field>}
	     * @readonly
	     */
	    fieldsById: {
	        get: function() {

	            /* istanbul ignore if */
	            if (this._fieldsById)
	                return this._fieldsById;

	            this._fieldsById = {};
	            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
	                var field = this.fields[names[i]],
	                    id = field.id;

	                /* istanbul ignore if */
	                if (this._fieldsById[id])
	                    throw Error("duplicate id " + id + " in " + this);

	                this._fieldsById[id] = field;
	            }
	            return this._fieldsById;
	        }
	    },

	    /**
	     * Fields of this message as an array for iteration.
	     * @name Type#fieldsArray
	     * @type {Field[]}
	     * @readonly
	     */
	    fieldsArray: {
	        get: function() {
	            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
	        }
	    },

	    /**
	     * Oneofs of this message as an array for iteration.
	     * @name Type#oneofsArray
	     * @type {OneOf[]}
	     * @readonly
	     */
	    oneofsArray: {
	        get: function() {
	            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
	        }
	    },

	    /**
	     * The registered constructor, if any registered, otherwise a generic constructor.
	     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
	     * @name Type#ctor
	     * @type {Constructor<{}>}
	     */
	    ctor: {
	        get: function() {
	            return this._ctor || (this.ctor = Type.generateConstructor(this)());
	        },
	        set: function(ctor) {

	            // Ensure proper prototype
	            var prototype = ctor.prototype;
	            if (!(prototype instanceof Message)) {
	                (ctor.prototype = new Message()).constructor = ctor;
	                util.merge(ctor.prototype, prototype);
	            }

	            // Classes and messages reference their reflected type
	            ctor.$type = ctor.prototype.$type = this;

	            // Mix in static methods
	            util.merge(ctor, Message, true);

	            this._ctor = ctor;

	            // Messages have non-enumerable default values on their prototype
	            var i = 0;
	            for (; i < /* initializes */ this.fieldsArray.length; ++i)
	                this._fieldsArray[i].resolve(); // ensures a proper value

	            // Messages have non-enumerable getters and setters for each virtual oneof field
	            var ctorProperties = {};
	            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
	                ctorProperties[this._oneofsArray[i].resolve().name] = {
	                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
	                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
	                };
	            if (i)
	                Object.defineProperties(ctor.prototype, ctorProperties);
	        }
	    }
	});

	/**
	 * Generates a constructor function for the specified type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	Type.generateConstructor = function generateConstructor(mtype) {
	    /* eslint-disable no-unexpected-multiline */
	    var gen = util.codegen(["p"], mtype.name);
	    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
	    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
	        if ((field = mtype._fieldsArray[i]).map) gen
	            ("this%s={}", util.safeProp(field.name));
	        else if (field.repeated) gen
	            ("this%s=[]", util.safeProp(field.name));
	    return gen
	    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
	        ("this[ks[i]]=p[ks[i]]");
	    /* eslint-enable no-unexpected-multiline */
	};

	function clearCache(type) {
	    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
	    delete type.encode;
	    delete type.decode;
	    delete type.verify;
	    return type;
	}

	/**
	 * Message type descriptor.
	 * @interface IType
	 * @extends INamespace
	 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
	 * @property {Object.<string,IField>} fields Field descriptors
	 * @property {number[][]} [extensions] Extension ranges
	 * @property {Array.<number[]|string>} [reserved] Reserved ranges
	 * @property {boolean} [group=false] Whether a legacy group or not
	 */

	/**
	 * Creates a message type from a message type descriptor.
	 * @param {string} name Message name
	 * @param {IType} json Message type descriptor
	 * @returns {Type} Created message type
	 */
	Type.fromJSON = function fromJSON(name, json) {
	    var type = new Type(name, json.options);
	    type.extensions = json.extensions;
	    type.reserved = json.reserved;
	    var names = Object.keys(json.fields),
	        i = 0;
	    for (; i < names.length; ++i)
	        type.add(
	            ( typeof json.fields[names[i]].keyType !== "undefined"
	            ? MapField.fromJSON
	            : Field.fromJSON )(names[i], json.fields[names[i]])
	        );
	    if (json.oneofs)
	        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
	            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
	    if (json.nested)
	        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
	            var nested = json.nested[names[i]];
	            type.add( // most to least likely
	                ( nested.id !== undefined
	                ? Field.fromJSON
	                : nested.fields !== undefined
	                ? Type.fromJSON
	                : nested.values !== undefined
	                ? Enum.fromJSON
	                : nested.methods !== undefined
	                ? Service.fromJSON
	                : Namespace.fromJSON )(names[i], nested)
	            );
	        }
	    if (json.extensions && json.extensions.length)
	        type.extensions = json.extensions;
	    if (json.reserved && json.reserved.length)
	        type.reserved = json.reserved;
	    if (json.group)
	        type.group = true;
	    if (json.comment)
	        type.comment = json.comment;
	    return type;
	};

	/**
	 * Converts this message type to a message type descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IType} Message type descriptor
	 */
	Type.prototype.toJSON = function toJSON(toJSONOptions) {
	    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options"    , inherited && inherited.options || undefined,
	        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
	        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
	        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
	        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
	        "group"      , this.group || undefined,
	        "nested"     , inherited && inherited.nested || undefined,
	        "comment"    , keepComments ? this.comment : undefined
	    ]);
	};

	/**
	 * @override
	 */
	Type.prototype.resolveAll = function resolveAll() {
	    var fields = this.fieldsArray, i = 0;
	    while (i < fields.length)
	        fields[i++].resolve();
	    var oneofs = this.oneofsArray; i = 0;
	    while (i < oneofs.length)
	        oneofs[i++].resolve();
	    return Namespace.prototype.resolveAll.call(this);
	};

	/**
	 * @override
	 */
	Type.prototype.get = function get(name) {
	    return this.fields[name]
	        || this.oneofs && this.oneofs[name]
	        || this.nested && this.nested[name]
	        || null;
	};

	/**
	 * Adds a nested object to this type.
	 * @param {ReflectionObject} object Nested object to add
	 * @returns {Type} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
	 */
	Type.prototype.add = function add(object) {

	    if (this.get(object.name))
	        throw Error("duplicate name '" + object.name + "' in " + this);

	    if (object instanceof Field && object.extend === undefined) {
	        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
	        // The root object takes care of adding distinct sister-fields to the respective extended
	        // type instead.

	        // avoids calling the getter if not absolutely necessary because it's called quite frequently
	        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
	            throw Error("duplicate id " + object.id + " in " + this);
	        if (this.isReservedId(object.id))
	            throw Error("id " + object.id + " is reserved in " + this);
	        if (this.isReservedName(object.name))
	            throw Error("name '" + object.name + "' is reserved in " + this);

	        if (object.parent)
	            object.parent.remove(object);
	        this.fields[object.name] = object;
	        object.message = this;
	        object.onAdd(this);
	        return clearCache(this);
	    }
	    if (object instanceof OneOf) {
	        if (!this.oneofs)
	            this.oneofs = {};
	        this.oneofs[object.name] = object;
	        object.onAdd(this);
	        return clearCache(this);
	    }
	    return Namespace.prototype.add.call(this, object);
	};

	/**
	 * Removes a nested object from this type.
	 * @param {ReflectionObject} object Nested object to remove
	 * @returns {Type} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `object` is not a member of this type
	 */
	Type.prototype.remove = function remove(object) {
	    if (object instanceof Field && object.extend === undefined) {
	        // See Type#add for the reason why extension fields are excluded here.

	        /* istanbul ignore if */
	        if (!this.fields || this.fields[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.fields[object.name];
	        object.parent = null;
	        object.onRemove(this);
	        return clearCache(this);
	    }
	    if (object instanceof OneOf) {

	        /* istanbul ignore if */
	        if (!this.oneofs || this.oneofs[object.name] !== object)
	            throw Error(object + " is not a member of " + this);

	        delete this.oneofs[object.name];
	        object.parent = null;
	        object.onRemove(this);
	        return clearCache(this);
	    }
	    return Namespace.prototype.remove.call(this, object);
	};

	/**
	 * Tests if the specified id is reserved.
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Type.prototype.isReservedId = function isReservedId(id) {
	    return Namespace.isReservedId(this.reserved, id);
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Type.prototype.isReservedName = function isReservedName(name) {
	    return Namespace.isReservedName(this.reserved, name);
	};

	/**
	 * Creates a new message of this type using the specified properties.
	 * @param {Object.<string,*>} [properties] Properties to set
	 * @returns {Message<{}>} Message instance
	 */
	Type.prototype.create = function create(properties) {
	    return new this.ctor(properties);
	};

	/**
	 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
	 * @returns {Type} `this`
	 */
	Type.prototype.setup = function setup() {
	    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
	    // multiple times (V8, soft-deopt prototype-check).

	    var fullName = this.fullName,
	        types    = [];
	    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
	        types.push(this._fieldsArray[i].resolve().resolvedType);

	    // Replace setup methods with type-specific generated functions
	    this.encode = encoder(this)({
	        Writer : Writer,
	        types  : types,
	        util   : util
	    });
	    this.decode = decoder(this)({
	        Reader : Reader,
	        types  : types,
	        util   : util
	    });
	    this.verify = verifier(this)({
	        types : types,
	        util  : util
	    });
	    this.fromObject = converter.fromObject(this)({
	        types : types,
	        util  : util
	    });
	    this.toObject = converter.toObject(this)({
	        types : types,
	        util  : util
	    });

	    // Inject custom wrappers for common types
	    var wrapper = wrappers[fullName];
	    if (wrapper) {
	        var originalThis = Object.create(this);
	        // if (wrapper.fromObject) {
	            originalThis.fromObject = this.fromObject;
	            this.fromObject = wrapper.fromObject.bind(originalThis);
	        // }
	        // if (wrapper.toObject) {
	            originalThis.toObject = this.toObject;
	            this.toObject = wrapper.toObject.bind(originalThis);
	        // }
	    }

	    return this;
	};

	/**
	 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
	 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
	 * @param {Writer} [writer] Writer to encode to
	 * @returns {Writer} writer
	 */
	Type.prototype.encode = function encode_setup(message, writer) {
	    return this.setup().encode(message, writer); // overrides this method
	};

	/**
	 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
	 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
	 * @param {Writer} [writer] Writer to encode to
	 * @returns {Writer} writer
	 */
	Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
	    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
	};

	/**
	 * Decodes a message of this type.
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
	 * @param {number} [length] Length of the message, if known beforehand
	 * @returns {Message<{}>} Decoded message
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {util.ProtocolError<{}>} If required fields are missing
	 */
	Type.prototype.decode = function decode_setup(reader, length) {
	    return this.setup().decode(reader, length); // overrides this method
	};

	/**
	 * Decodes a message of this type preceeded by its byte length as a varint.
	 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
	 * @returns {Message<{}>} Decoded message
	 * @throws {Error} If the payload is not a reader or valid buffer
	 * @throws {util.ProtocolError} If required fields are missing
	 */
	Type.prototype.decodeDelimited = function decodeDelimited(reader) {
	    if (!(reader instanceof Reader))
	        reader = Reader.create(reader);
	    return this.decode(reader, reader.uint32());
	};

	/**
	 * Verifies that field values are valid and that required fields are present.
	 * @param {Object.<string,*>} message Plain object to verify
	 * @returns {null|string} `null` if valid, otherwise the reason why it is not
	 */
	Type.prototype.verify = function verify_setup(message) {
	    return this.setup().verify(message); // overrides this method
	};

	/**
	 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
	 * @param {Object.<string,*>} object Plain object to convert
	 * @returns {Message<{}>} Message instance
	 */
	Type.prototype.fromObject = function fromObject(object) {
	    return this.setup().fromObject(object);
	};

	/**
	 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
	 * @interface IConversionOptions
	 * @property {Function} [longs] Long conversion type.
	 * Valid values are `String` and `Number` (the global types).
	 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
	 * @property {Function} [enums] Enum value conversion type.
	 * Only valid value is `String` (the global type).
	 * Defaults to copy the present value, which is the numeric id.
	 * @property {Function} [bytes] Bytes value conversion type.
	 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
	 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
	 * @property {boolean} [defaults=false] Also sets default values on the resulting object
	 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
	 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
	 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
	 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
	 */

	/**
	 * Creates a plain object from a message of this type. Also converts values to other types if specified.
	 * @param {Message<{}>} message Message instance
	 * @param {IConversionOptions} [options] Conversion options
	 * @returns {Object.<string,*>} Plain object
	 */
	Type.prototype.toObject = function toObject(message, options) {
	    return this.setup().toObject(message, options);
	};

	/**
	 * Decorator function as returned by {@link Type.d} (TypeScript).
	 * @typedef TypeDecorator
	 * @type {function}
	 * @param {Constructor<T>} target Target constructor
	 * @returns {undefined}
	 * @template T extends Message<T>
	 */

	/**
	 * Type decorator (TypeScript).
	 * @param {string} [typeName] Type name, defaults to the constructor's name
	 * @returns {TypeDecorator<T>} Decorator function
	 * @template T extends Message<T>
	 */
	Type.d = function decorateType(typeName) {
	    return function typeDecorator(target) {
	        util.decorateType(target, typeName);
	    };
	};
	return type;
}

var root$1;
var hasRequiredRoot$1;

function requireRoot$1 () {
	if (hasRequiredRoot$1) return root$1;
	hasRequiredRoot$1 = 1;
	root$1 = Root;

	// extends Namespace
	var Namespace = requireNamespace();
	((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

	var Field   = requireField(),
	    Enum    = require_enum(),
	    OneOf   = requireOneof(),
	    util    = requireUtil$1();

	var Type,   // cyclic
	    parse,  // might be excluded
	    common; // "

	/**
	 * Constructs a new root namespace instance.
	 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
	 * @extends NamespaceBase
	 * @constructor
	 * @param {Object.<string,*>} [options] Top level options
	 */
	function Root(options) {
	    Namespace.call(this, "", options);

	    /**
	     * Deferred extension fields.
	     * @type {Field[]}
	     */
	    this.deferred = [];

	    /**
	     * Resolved file names of loaded files.
	     * @type {string[]}
	     */
	    this.files = [];
	}

	/**
	 * Loads a namespace descriptor into a root namespace.
	 * @param {INamespace} json Nameespace descriptor
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
	 * @returns {Root} Root namespace
	 */
	Root.fromJSON = function fromJSON(json, root) {
	    if (!root)
	        root = new Root();
	    if (json.options)
	        root.setOptions(json.options);
	    return root.addJSON(json.nested);
	};

	/**
	 * Resolves the path of an imported file, relative to the importing origin.
	 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
	 * @function
	 * @param {string} origin The file name of the importing file
	 * @param {string} target The file name being imported
	 * @returns {string|null} Resolved path to `target` or `null` to skip the file
	 */
	Root.prototype.resolvePath = util.path.resolve;

	/**
	 * Fetch content from file path or url
	 * This method exists so you can override it with your own logic.
	 * @function
	 * @param {string} path File path or url
	 * @param {FetchCallback} callback Callback function
	 * @returns {undefined}
	 */
	Root.prototype.fetch = util.fetch;

	// A symbol-like function to safely signal synchronous loading
	/* istanbul ignore next */
	function SYNC() {} // eslint-disable-line no-empty-function

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} options Parse options
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 */
	Root.prototype.load = function load(filename, options, callback) {
	    if (typeof options === "function") {
	        callback = options;
	        options = undefined;
	    }
	    var self = this;
	    if (!callback)
	        return util.asPromise(load, self, filename, options);

	    var sync = callback === SYNC; // undocumented

	    // Finishes loading by calling the callback (exactly once)
	    function finish(err, root) {
	        /* istanbul ignore if */
	        if (!callback)
	            return;
	        if (sync)
	            throw err;
	        var cb = callback;
	        callback = null;
	        cb(err, root);
	    }

	    // Bundled definition existence checking
	    function getBundledFileName(filename) {
	        var idx = filename.lastIndexOf("google/protobuf/");
	        if (idx > -1) {
	            var altname = filename.substring(idx);
	            if (altname in common) return altname;
	        }
	        return null;
	    }

	    // Processes a single file
	    function process(filename, source) {
	        try {
	            if (util.isString(source) && source.charAt(0) === "{")
	                source = JSON.parse(source);
	            if (!util.isString(source))
	                self.setOptions(source.options).addJSON(source.nested);
	            else {
	                parse.filename = filename;
	                var parsed = parse(source, self, options),
	                    resolved,
	                    i = 0;
	                if (parsed.imports)
	                    for (; i < parsed.imports.length; ++i)
	                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
	                            fetch(resolved);
	                if (parsed.weakImports)
	                    for (i = 0; i < parsed.weakImports.length; ++i)
	                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
	                            fetch(resolved, true);
	            }
	        } catch (err) {
	            finish(err);
	        }
	        if (!sync && !queued)
	            finish(null, self); // only once anyway
	    }

	    // Fetches a single file
	    function fetch(filename, weak) {
	        filename = getBundledFileName(filename) || filename;

	        // Skip if already loaded / attempted
	        if (self.files.indexOf(filename) > -1)
	            return;
	        self.files.push(filename);

	        // Shortcut bundled definitions
	        if (filename in common) {
	            if (sync)
	                process(filename, common[filename]);
	            else {
	                ++queued;
	                setTimeout(function() {
	                    --queued;
	                    process(filename, common[filename]);
	                });
	            }
	            return;
	        }

	        // Otherwise fetch from disk or network
	        if (sync) {
	            var source;
	            try {
	                source = util.fs.readFileSync(filename).toString("utf8");
	            } catch (err) {
	                if (!weak)
	                    finish(err);
	                return;
	            }
	            process(filename, source);
	        } else {
	            ++queued;
	            self.fetch(filename, function(err, source) {
	                --queued;
	                /* istanbul ignore if */
	                if (!callback)
	                    return; // terminated meanwhile
	                if (err) {
	                    /* istanbul ignore else */
	                    if (!weak)
	                        finish(err);
	                    else if (!queued) // can't be covered reliably
	                        finish(null, self);
	                    return;
	                }
	                process(filename, source);
	            });
	        }
	    }
	    var queued = 0;

	    // Assembling the root namespace doesn't require working type
	    // references anymore, so we can load everything in parallel
	    if (util.isString(filename))
	        filename = [ filename ];
	    for (var i = 0, resolved; i < filename.length; ++i)
	        if (resolved = self.resolvePath("", filename[i]))
	            fetch(resolved);

	    if (sync)
	        return self;
	    if (!queued)
	        finish(null, self);
	    return undefined;
	};
	// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
	 * @function Root#load
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @variation 2
	 */
	// function load(filename:string, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
	 * @function Root#load
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {Promise<Root>} Promise
	 * @variation 3
	 */
	// function load(filename:string, [options:IParseOptions]):Promise<Root>

	/**
	 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
	 * @function Root#loadSync
	 * @param {string|string[]} filename Names of one or multiple files to load
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {Root} Root namespace
	 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
	 */
	Root.prototype.loadSync = function loadSync(filename, options) {
	    if (!util.isNode)
	        throw Error("not supported");
	    return this.load(filename, options, SYNC);
	};

	/**
	 * @override
	 */
	Root.prototype.resolveAll = function resolveAll() {
	    if (this.deferred.length)
	        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
	            return "'extend " + field.extend + "' in " + field.parent.fullName;
	        }).join(", "));
	    return Namespace.prototype.resolveAll.call(this);
	};

	// only uppercased (and thus conflict-free) children are exposed, see below
	var exposeRe = /^[A-Z]/;

	/**
	 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
	 * @param {Root} root Root instance
	 * @param {Field} field Declaring extension field witin the declaring type
	 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
	 * @inner
	 * @ignore
	 */
	function tryHandleExtension(root, field) {
	    var extendedType = field.parent.lookup(field.extend);
	    if (extendedType) {
	        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
	        //do not allow to extend same field twice to prevent the error
	        if (extendedType.get(sisterField.name)) {
	            return true;
	        }
	        sisterField.declaringField = field;
	        field.extensionField = sisterField;
	        extendedType.add(sisterField);
	        return true;
	    }
	    return false;
	}

	/**
	 * Called when any object is added to this root or its sub-namespaces.
	 * @param {ReflectionObject} object Object added
	 * @returns {undefined}
	 * @private
	 */
	Root.prototype._handleAdd = function _handleAdd(object) {
	    if (object instanceof Field) {

	        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
	            if (!tryHandleExtension(this, object))
	                this.deferred.push(object);

	    } else if (object instanceof Enum) {

	        if (exposeRe.test(object.name))
	            object.parent[object.name] = object.values; // expose enum values as property of its parent

	    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

	        if (object instanceof Type) // Try to handle any deferred extensions
	            for (var i = 0; i < this.deferred.length;)
	                if (tryHandleExtension(this, this.deferred[i]))
	                    this.deferred.splice(i, 1);
	                else
	                    ++i;
	        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
	            this._handleAdd(object._nestedArray[j]);
	        if (exposeRe.test(object.name))
	            object.parent[object.name] = object; // expose namespace as property of its parent
	    }

	    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
	    // properties of namespaces just like static code does. This allows using a .d.ts generated for
	    // a static module with reflection-based solutions where the condition is met.
	};

	/**
	 * Called when any object is removed from this root or its sub-namespaces.
	 * @param {ReflectionObject} object Object removed
	 * @returns {undefined}
	 * @private
	 */
	Root.prototype._handleRemove = function _handleRemove(object) {
	    if (object instanceof Field) {

	        if (/* an extension field */ object.extend !== undefined) {
	            if (/* already handled */ object.extensionField) { // remove its sister field
	                object.extensionField.parent.remove(object.extensionField);
	                object.extensionField = null;
	            } else { // cancel the extension
	                var index = this.deferred.indexOf(object);
	                /* istanbul ignore else */
	                if (index > -1)
	                    this.deferred.splice(index, 1);
	            }
	        }

	    } else if (object instanceof Enum) {

	        if (exposeRe.test(object.name))
	            delete object.parent[object.name]; // unexpose enum values

	    } else if (object instanceof Namespace) {

	        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
	            this._handleRemove(object._nestedArray[i]);

	        if (exposeRe.test(object.name))
	            delete object.parent[object.name]; // unexpose namespaces

	    }
	};

	// Sets up cyclic dependencies (called in index-light)
	Root._configure = function(Type_, parse_, common_) {
	    Type   = Type_;
	    parse  = parse_;
	    common = common_;
	};
	return root$1;
}

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1.exports;
	hasRequiredUtil$1 = 1;

	/**
	 * Various utility functions.
	 * @namespace
	 */
	var util = util$1.exports = requireMinimal$1();

	var roots = requireRoots();

	var Type, // cyclic
	    Enum;

	util.codegen = requireCodegen();
	util.fetch   = requireFetch();
	util.path    = requirePath();

	/**
	 * Node's fs module if available.
	 * @type {Object.<string,*>}
	 */
	util.fs = util.inquire("fs");

	/**
	 * Converts an object's values to an array.
	 * @param {Object.<string,*>} object Object to convert
	 * @returns {Array.<*>} Converted array
	 */
	util.toArray = function toArray(object) {
	    if (object) {
	        var keys  = Object.keys(object),
	            array = new Array(keys.length),
	            index = 0;
	        while (index < keys.length)
	            array[index] = object[keys[index++]];
	        return array;
	    }
	    return [];
	};

	/**
	 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
	 * @param {Array.<*>} array Array to convert
	 * @returns {Object.<string,*>} Converted object
	 */
	util.toObject = function toObject(array) {
	    var object = {},
	        index  = 0;
	    while (index < array.length) {
	        var key = array[index++],
	            val = array[index++];
	        if (val !== undefined)
	            object[key] = val;
	    }
	    return object;
	};

	var safePropBackslashRe = /\\/g,
	    safePropQuoteRe     = /"/g;

	/**
	 * Tests whether the specified name is a reserved word in JS.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	util.isReserved = function isReserved(name) {
	    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
	};

	/**
	 * Returns a safe property accessor for the specified property name.
	 * @param {string} prop Property name
	 * @returns {string} Safe accessor
	 */
	util.safeProp = function safeProp(prop) {
	    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
	        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
	    return "." + prop;
	};

	/**
	 * Converts the first character of a string to upper case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.ucFirst = function ucFirst(str) {
	    return str.charAt(0).toUpperCase() + str.substring(1);
	};

	var camelCaseRe = /_([a-z])/g;

	/**
	 * Converts a string to camel case.
	 * @param {string} str String to convert
	 * @returns {string} Converted string
	 */
	util.camelCase = function camelCase(str) {
	    return str.substring(0, 1)
	         + str.substring(1)
	               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
	};

	/**
	 * Compares reflected fields by id.
	 * @param {Field} a First field
	 * @param {Field} b Second field
	 * @returns {number} Comparison value
	 */
	util.compareFieldsById = function compareFieldsById(a, b) {
	    return a.id - b.id;
	};

	/**
	 * Decorator helper for types (TypeScript).
	 * @param {Constructor<T>} ctor Constructor function
	 * @param {string} [typeName] Type name, defaults to the constructor's name
	 * @returns {Type} Reflected type
	 * @template T extends Message<T>
	 * @property {Root} root Decorators root
	 */
	util.decorateType = function decorateType(ctor, typeName) {

	    /* istanbul ignore if */
	    if (ctor.$type) {
	        if (typeName && ctor.$type.name !== typeName) {
	            util.decorateRoot.remove(ctor.$type);
	            ctor.$type.name = typeName;
	            util.decorateRoot.add(ctor.$type);
	        }
	        return ctor.$type;
	    }

	    /* istanbul ignore next */
	    if (!Type)
	        Type = requireType();

	    var type = new Type(typeName || ctor.name);
	    util.decorateRoot.add(type);
	    type.ctor = ctor; // sets up .encode, .decode etc.
	    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
	    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
	    return type;
	};

	var decorateEnumIndex = 0;

	/**
	 * Decorator helper for enums (TypeScript).
	 * @param {Object} object Enum object
	 * @returns {Enum} Reflected enum
	 */
	util.decorateEnum = function decorateEnum(object) {

	    /* istanbul ignore if */
	    if (object.$type)
	        return object.$type;

	    /* istanbul ignore next */
	    if (!Enum)
	        Enum = require_enum();

	    var enm = new Enum("Enum" + decorateEnumIndex++, object);
	    util.decorateRoot.add(enm);
	    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
	    return enm;
	};


	/**
	 * Sets the value of a property by property path. If a value already exists, it is turned to an array
	 * @param {Object.<string,*>} dst Destination object
	 * @param {string} path dot '.' delimited path of the property to set
	 * @param {Object} value the value to set
	 * @returns {Object.<string,*>} Destination object
	 */
	util.setProperty = function setProperty(dst, path, value) {
	    function setProp(dst, path, value) {
	        var part = path.shift();
	        if (part === "__proto__" || part === "prototype") {
	          return dst;
	        }
	        if (path.length > 0) {
	            dst[part] = setProp(dst[part] || {}, path, value);
	        } else {
	            var prevValue = dst[part];
	            if (prevValue)
	                value = [].concat(prevValue).concat(value);
	            dst[part] = value;
	        }
	        return dst;
	    }

	    if (typeof dst !== "object")
	        throw TypeError("dst must be an object");
	    if (!path)
	        throw TypeError("path must be specified");

	    path = path.split(".");
	    return setProp(dst, path, value);
	};

	/**
	 * Decorator root (TypeScript).
	 * @name util.decorateRoot
	 * @type {Root}
	 * @readonly
	 */
	Object.defineProperty(util, "decorateRoot", {
	    get: function() {
	        return roots["decorated"] || (roots["decorated"] = new (requireRoot$1())());
	    }
	});
	return util$1.exports;
}

var object;
var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	object = ReflectionObject;

	ReflectionObject.className = "ReflectionObject";

	var util = requireUtil$1();

	var Root; // cyclic

	/**
	 * Constructs a new reflection object instance.
	 * @classdesc Base class of all reflection objects.
	 * @constructor
	 * @param {string} name Object name
	 * @param {Object.<string,*>} [options] Declared options
	 * @abstract
	 */
	function ReflectionObject(name, options) {

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    if (options && !util.isObject(options))
	        throw TypeError("options must be an object");

	    /**
	     * Options.
	     * @type {Object.<string,*>|undefined}
	     */
	    this.options = options; // toJSON

	    /**
	     * Parsed Options.
	     * @type {Array.<Object.<string,*>>|undefined}
	     */
	    this.parsedOptions = null;

	    /**
	     * Unique name within its namespace.
	     * @type {string}
	     */
	    this.name = name;

	    /**
	     * Parent namespace.
	     * @type {Namespace|null}
	     */
	    this.parent = null;

	    /**
	     * Whether already resolved or not.
	     * @type {boolean}
	     */
	    this.resolved = false;

	    /**
	     * Comment text, if any.
	     * @type {string|null}
	     */
	    this.comment = null;

	    /**
	     * Defining file name.
	     * @type {string|null}
	     */
	    this.filename = null;
	}

	Object.defineProperties(ReflectionObject.prototype, {

	    /**
	     * Reference to the root namespace.
	     * @name ReflectionObject#root
	     * @type {Root}
	     * @readonly
	     */
	    root: {
	        get: function() {
	            var ptr = this;
	            while (ptr.parent !== null)
	                ptr = ptr.parent;
	            return ptr;
	        }
	    },

	    /**
	     * Full name including leading dot.
	     * @name ReflectionObject#fullName
	     * @type {string}
	     * @readonly
	     */
	    fullName: {
	        get: function() {
	            var path = [ this.name ],
	                ptr = this.parent;
	            while (ptr) {
	                path.unshift(ptr.name);
	                ptr = ptr.parent;
	            }
	            return path.join(".");
	        }
	    }
	});

	/**
	 * Converts this reflection object to its descriptor representation.
	 * @returns {Object.<string,*>} Descriptor
	 * @abstract
	 */
	ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
	    throw Error(); // not implemented, shouldn't happen
	};

	/**
	 * Called when this object is added to a parent.
	 * @param {ReflectionObject} parent Parent added to
	 * @returns {undefined}
	 */
	ReflectionObject.prototype.onAdd = function onAdd(parent) {
	    if (this.parent && this.parent !== parent)
	        this.parent.remove(this);
	    this.parent = parent;
	    this.resolved = false;
	    var root = parent.root;
	    if (root instanceof Root)
	        root._handleAdd(this);
	};

	/**
	 * Called when this object is removed from a parent.
	 * @param {ReflectionObject} parent Parent removed from
	 * @returns {undefined}
	 */
	ReflectionObject.prototype.onRemove = function onRemove(parent) {
	    var root = parent.root;
	    if (root instanceof Root)
	        root._handleRemove(this);
	    this.parent = null;
	    this.resolved = false;
	};

	/**
	 * Resolves this objects type references.
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.resolve = function resolve() {
	    if (this.resolved)
	        return this;
	    if (this.root instanceof Root)
	        this.resolved = true; // only if part of a root
	    return this;
	};

	/**
	 * Gets an option value.
	 * @param {string} name Option name
	 * @returns {*} Option value or `undefined` if not set
	 */
	ReflectionObject.prototype.getOption = function getOption(name) {
	    if (this.options)
	        return this.options[name];
	    return undefined;
	};

	/**
	 * Sets an option.
	 * @param {string} name Option name
	 * @param {*} value Option value
	 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
	    if (!ifNotSet || !this.options || this.options[name] === undefined)
	        (this.options || (this.options = {}))[name] = value;
	    return this;
	};

	/**
	 * Sets a parsed option.
	 * @param {string} name parsed Option name
	 * @param {*} value Option value
	 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
	    if (!this.parsedOptions) {
	        this.parsedOptions = [];
	    }
	    var parsedOptions = this.parsedOptions;
	    if (propName) {
	        // If setting a sub property of an option then try to merge it
	        // with an existing option
	        var opt = parsedOptions.find(function (opt) {
	            return Object.prototype.hasOwnProperty.call(opt, name);
	        });
	        if (opt) {
	            // If we found an existing option - just merge the property value
	            var newValue = opt[name];
	            util.setProperty(newValue, propName, value);
	        } else {
	            // otherwise, create a new option, set it's property and add it to the list
	            opt = {};
	            opt[name] = util.setProperty({}, propName, value);
	            parsedOptions.push(opt);
	        }
	    } else {
	        // Always create a new option when setting the value of the option itself
	        var newOpt = {};
	        newOpt[name] = value;
	        parsedOptions.push(newOpt);
	    }
	    return this;
	};

	/**
	 * Sets multiple options.
	 * @param {Object.<string,*>} options Options to set
	 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
	 * @returns {ReflectionObject} `this`
	 */
	ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
	    if (options)
	        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
	            this.setOption(keys[i], options[keys[i]], ifNotSet);
	    return this;
	};

	/**
	 * Converts this instance to its string representation.
	 * @returns {string} Class name[, space, full name]
	 */
	ReflectionObject.prototype.toString = function toString() {
	    var className = this.constructor.className,
	        fullName  = this.fullName;
	    if (fullName.length)
	        return className + " " + fullName;
	    return className;
	};

	// Sets up cyclic dependencies (called in index-light)
	ReflectionObject._configure = function(Root_) {
	    Root = Root_;
	};
	return object;
}

var _enum;
var hasRequired_enum;

function require_enum () {
	if (hasRequired_enum) return _enum;
	hasRequired_enum = 1;
	_enum = Enum;

	// extends ReflectionObject
	var ReflectionObject = requireObject();
	((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

	var Namespace = requireNamespace(),
	    util = requireUtil$1();

	/**
	 * Constructs a new enum instance.
	 * @classdesc Reflected enum.
	 * @extends ReflectionObject
	 * @constructor
	 * @param {string} name Unique name within its namespace
	 * @param {Object.<string,number>} [values] Enum values as an object, by name
	 * @param {Object.<string,*>} [options] Declared options
	 * @param {string} [comment] The comment for this enum
	 * @param {Object.<string,string>} [comments] The value comments for this enum
	 * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum
	 */
	function Enum(name, values, options, comment, comments, valuesOptions) {
	    ReflectionObject.call(this, name, options);

	    if (values && typeof values !== "object")
	        throw TypeError("values must be an object");

	    /**
	     * Enum values by id.
	     * @type {Object.<number,string>}
	     */
	    this.valuesById = {};

	    /**
	     * Enum values by name.
	     * @type {Object.<string,number>}
	     */
	    this.values = Object.create(this.valuesById); // toJSON, marker

	    /**
	     * Enum comment text.
	     * @type {string|null}
	     */
	    this.comment = comment;

	    /**
	     * Value comment texts, if any.
	     * @type {Object.<string,string>}
	     */
	    this.comments = comments || {};

	    /**
	     * Values options, if any
	     * @type {Object<string, Object<string, *>>|undefined}
	     */
	    this.valuesOptions = valuesOptions;

	    /**
	     * Reserved ranges, if any.
	     * @type {Array.<number[]|string>}
	     */
	    this.reserved = undefined; // toJSON

	    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
	    // compatible enum. This is used by pbts to write actual enum definitions that work for
	    // static and reflection code alike instead of emitting generic object definitions.

	    if (values)
	        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
	            if (typeof values[keys[i]] === "number") // use forward entries only
	                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
	}

	/**
	 * Enum descriptor.
	 * @interface IEnum
	 * @property {Object.<string,number>} values Enum values
	 * @property {Object.<string,*>} [options] Enum options
	 */

	/**
	 * Constructs an enum from an enum descriptor.
	 * @param {string} name Enum name
	 * @param {IEnum} json Enum descriptor
	 * @returns {Enum} Created enum
	 * @throws {TypeError} If arguments are invalid
	 */
	Enum.fromJSON = function fromJSON(name, json) {
	    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
	    enm.reserved = json.reserved;
	    return enm;
	};

	/**
	 * Converts this enum to an enum descriptor.
	 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
	 * @returns {IEnum} Enum descriptor
	 */
	Enum.prototype.toJSON = function toJSON(toJSONOptions) {
	    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
	    return util.toObject([
	        "options"       , this.options,
	        "valuesOptions" , this.valuesOptions,
	        "values"        , this.values,
	        "reserved"      , this.reserved && this.reserved.length ? this.reserved : undefined,
	        "comment"       , keepComments ? this.comment : undefined,
	        "comments"      , keepComments ? this.comments : undefined
	    ]);
	};

	/**
	 * Adds a value to this enum.
	 * @param {string} name Value name
	 * @param {number} id Value id
	 * @param {string} [comment] Comment, if any
	 * @param {Object.<string, *>|undefined} [options] Options, if any
	 * @returns {Enum} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If there is already a value with this name or id
	 */
	Enum.prototype.add = function add(name, id, comment, options) {
	    // utilized by the parser but not by .fromJSON

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    if (!util.isInteger(id))
	        throw TypeError("id must be an integer");

	    if (this.values[name] !== undefined)
	        throw Error("duplicate name '" + name + "' in " + this);

	    if (this.isReservedId(id))
	        throw Error("id " + id + " is reserved in " + this);

	    if (this.isReservedName(name))
	        throw Error("name '" + name + "' is reserved in " + this);

	    if (this.valuesById[id] !== undefined) {
	        if (!(this.options && this.options.allow_alias))
	            throw Error("duplicate id " + id + " in " + this);
	        this.values[name] = id;
	    } else
	        this.valuesById[this.values[name] = id] = name;

	    if (options) {
	        if (this.valuesOptions === undefined)
	            this.valuesOptions = {};
	        this.valuesOptions[name] = options || null;
	    }

	    this.comments[name] = comment || null;
	    return this;
	};

	/**
	 * Removes a value from this enum
	 * @param {string} name Value name
	 * @returns {Enum} `this`
	 * @throws {TypeError} If arguments are invalid
	 * @throws {Error} If `name` is not a name of this enum
	 */
	Enum.prototype.remove = function remove(name) {

	    if (!util.isString(name))
	        throw TypeError("name must be a string");

	    var val = this.values[name];
	    if (val == null)
	        throw Error("name '" + name + "' does not exist in " + this);

	    delete this.valuesById[val];
	    delete this.values[name];
	    delete this.comments[name];
	    if (this.valuesOptions)
	        delete this.valuesOptions[name];

	    return this;
	};

	/**
	 * Tests if the specified id is reserved.
	 * @param {number} id Id to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Enum.prototype.isReservedId = function isReservedId(id) {
	    return Namespace.isReservedId(this.reserved, id);
	};

	/**
	 * Tests if the specified name is reserved.
	 * @param {string} name Name to test
	 * @returns {boolean} `true` if reserved, otherwise `false`
	 */
	Enum.prototype.isReservedName = function isReservedName(name) {
	    return Namespace.isReservedName(this.reserved, name);
	};
	return _enum;
}

var encoder_1;
var hasRequiredEncoder;

function requireEncoder () {
	if (hasRequiredEncoder) return encoder_1;
	hasRequiredEncoder = 1;
	encoder_1 = encoder;

	var Enum     = require_enum(),
	    types    = requireTypes(),
	    util     = requireUtil$1();

	/**
	 * Generates a partial message type encoder.
	 * @param {Codegen} gen Codegen instance
	 * @param {Field} field Reflected field
	 * @param {number} fieldIndex Field index
	 * @param {string} ref Variable reference
	 * @returns {Codegen} Codegen instance
	 * @ignore
	 */
	function genTypePartial(gen, field, fieldIndex, ref) {
	    return field.resolvedType.group
	        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
	        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
	}

	/**
	 * Generates an encoder specific to the specified message type.
	 * @param {Type} mtype Message type
	 * @returns {Codegen} Codegen instance
	 */
	function encoder(mtype) {
	    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
	    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
	    ("if(!w)")
	        ("w=Writer.create()");

	    var i, ref;

	    // "when a message is serialized its known fields should be written sequentially by field number"
	    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

	    for (var i = 0; i < fields.length; ++i) {
	        var field    = fields[i].resolve(),
	            index    = mtype._fieldsArray.indexOf(field),
	            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
	            wireType = types.basic[type];
	            ref      = "m" + util.safeProp(field.name);

	        // Map fields
	        if (field.map) {
	            gen
	    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
	        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
	            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
	            if (wireType === undefined) gen
	            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
	            else gen
	            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
	            gen
	        ("}")
	    ("}");

	            // Repeated fields
	        } else if (field.repeated) { gen
	    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

	            // Packed repeated
	            if (field.packed && types.packed[type] !== undefined) { gen

	        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
	        ("for(var i=0;i<%s.length;++i)", ref)
	            ("w.%s(%s[i])", type, ref)
	        ("w.ldelim()");

	            // Non-packed
	            } else { gen

	        ("for(var i=0;i<%s.length;++i)", ref);
	                if (wireType === undefined)
	            genTypePartial(gen, field, index, ref + "[i]");
	                else gen
	            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

	            } gen
	    ("}");

	        // Non-repeated
	        } else {
	            if (field.optional) gen
	    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

	            if (wireType === undefined)
	        genTypePartial(gen, field, index, ref);
	            else gen
	        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

	        }
	    }

	    return gen
	    ("return w");
	    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
	}
	return encoder_1;
}

var hasRequiredIndexLight;

function requireIndexLight () {
	if (hasRequiredIndexLight) return indexLight.exports;
	hasRequiredIndexLight = 1;
	var protobuf = indexLight.exports = requireIndexMinimal();

	protobuf.build = "light";

	/**
	 * A node-style callback as used by {@link load} and {@link Root#load}.
	 * @typedef LoadCallback
	 * @type {function}
	 * @param {Error|null} error Error, if any, otherwise `null`
	 * @param {Root} [root] Root, if there hasn't been an error
	 * @returns {undefined}
	 */

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} root Root namespace, defaults to create a new one if omitted.
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @see {@link Root#load}
	 */
	function load(filename, root, callback) {
	    if (typeof root === "function") {
	        callback = root;
	        root = new protobuf.Root();
	    } else if (!root)
	        root = new protobuf.Root();
	    return root.load(filename, callback);
	}

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
	 * @name load
	 * @function
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {LoadCallback} callback Callback function
	 * @returns {undefined}
	 * @see {@link Root#load}
	 * @variation 2
	 */
	// function load(filename:string, callback:LoadCallback):undefined

	/**
	 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
	 * @name load
	 * @function
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
	 * @returns {Promise<Root>} Promise
	 * @see {@link Root#load}
	 * @variation 3
	 */
	// function load(filename:string, [root:Root]):Promise<Root>

	protobuf.load = load;

	/**
	 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
	 * @param {string|string[]} filename One or multiple files to load
	 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
	 * @returns {Root} Root namespace
	 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
	 * @see {@link Root#loadSync}
	 */
	function loadSync(filename, root) {
	    if (!root)
	        root = new protobuf.Root();
	    return root.loadSync(filename);
	}

	protobuf.loadSync = loadSync;

	// Serialization
	protobuf.encoder          = requireEncoder();
	protobuf.decoder          = requireDecoder();
	protobuf.verifier         = requireVerifier();
	protobuf.converter        = requireConverter();

	// Reflection
	protobuf.ReflectionObject = requireObject();
	protobuf.Namespace        = requireNamespace();
	protobuf.Root             = requireRoot$1();
	protobuf.Enum             = require_enum();
	protobuf.Type             = requireType();
	protobuf.Field            = requireField();
	protobuf.OneOf            = requireOneof();
	protobuf.MapField         = requireMapfield();
	protobuf.Service          = requireService();
	protobuf.Method           = requireMethod();

	// Runtime
	protobuf.Message          = requireMessage();
	protobuf.wrappers         = requireWrappers();

	// Utility
	protobuf.types            = requireTypes();
	protobuf.util             = requireUtil$1();

	// Set up possibly cyclic reflection dependencies
	protobuf.ReflectionObject._configure(protobuf.Root);
	protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
	protobuf.Root._configure(protobuf.Type);
	protobuf.Field._configure(protobuf.Type);
	return indexLight.exports;
}

var tokenize_1;
var hasRequiredTokenize;

function requireTokenize () {
	if (hasRequiredTokenize) return tokenize_1;
	hasRequiredTokenize = 1;
	tokenize_1 = tokenize;

	var delimRe        = /[\s{}=;:[\],'"()<>]/g,
	    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
	    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

	var setCommentRe = /^ *[*/]+ */,
	    setCommentAltRe = /^\s*\*?\/*/,
	    setCommentSplitRe = /\n/g,
	    whitespaceRe = /\s/,
	    unescapeRe = /\\(.?)/g;

	var unescapeMap = {
	    "0": "\0",
	    "r": "\r",
	    "n": "\n",
	    "t": "\t"
	};

	/**
	 * Unescapes a string.
	 * @param {string} str String to unescape
	 * @returns {string} Unescaped string
	 * @property {Object.<string,string>} map Special characters map
	 * @memberof tokenize
	 */
	function unescape(str) {
	    return str.replace(unescapeRe, function($0, $1) {
	        switch ($1) {
	            case "\\":
	            case "":
	                return $1;
	            default:
	                return unescapeMap[$1] || "";
	        }
	    });
	}

	tokenize.unescape = unescape;

	/**
	 * Gets the next token and advances.
	 * @typedef TokenizerHandleNext
	 * @type {function}
	 * @returns {string|null} Next token or `null` on eof
	 */

	/**
	 * Peeks for the next token.
	 * @typedef TokenizerHandlePeek
	 * @type {function}
	 * @returns {string|null} Next token or `null` on eof
	 */

	/**
	 * Pushes a token back to the stack.
	 * @typedef TokenizerHandlePush
	 * @type {function}
	 * @param {string} token Token
	 * @returns {undefined}
	 */

	/**
	 * Skips the next token.
	 * @typedef TokenizerHandleSkip
	 * @type {function}
	 * @param {string} expected Expected token
	 * @param {boolean} [optional=false] If optional
	 * @returns {boolean} Whether the token matched
	 * @throws {Error} If the token didn't match and is not optional
	 */

	/**
	 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
	 * @typedef TokenizerHandleCmnt
	 * @type {function}
	 * @param {number} [line] Line number
	 * @returns {string|null} Comment text or `null` if none
	 */

	/**
	 * Handle object returned from {@link tokenize}.
	 * @interface ITokenizerHandle
	 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
	 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
	 * @property {TokenizerHandlePush} push Pushes a token back to the stack
	 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
	 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
	 * @property {number} line Current line number
	 */

	/**
	 * Tokenizes the given .proto source and returns an object with useful utility functions.
	 * @param {string} source Source contents
	 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
	 * @returns {ITokenizerHandle} Tokenizer handle
	 */
	function tokenize(source, alternateCommentMode) {
	    /* eslint-disable callback-return */
	    source = source.toString();

	    var offset = 0,
	        length = source.length,
	        line = 1,
	        lastCommentLine = 0,
	        comments = {};

	    var stack = [];

	    var stringDelim = null;

	    /* istanbul ignore next */
	    /**
	     * Creates an error for illegal syntax.
	     * @param {string} subject Subject
	     * @returns {Error} Error created
	     * @inner
	     */
	    function illegal(subject) {
	        return Error("illegal " + subject + " (line " + line + ")");
	    }

	    /**
	     * Reads a string till its end.
	     * @returns {string} String read
	     * @inner
	     */
	    function readString() {
	        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
	        re.lastIndex = offset - 1;
	        var match = re.exec(source);
	        if (!match)
	            throw illegal("string");
	        offset = re.lastIndex;
	        push(stringDelim);
	        stringDelim = null;
	        return unescape(match[1]);
	    }

	    /**
	     * Gets the character at `pos` within the source.
	     * @param {number} pos Position
	     * @returns {string} Character
	     * @inner
	     */
	    function charAt(pos) {
	        return source.charAt(pos);
	    }

	    /**
	     * Sets the current comment text.
	     * @param {number} start Start offset
	     * @param {number} end End offset
	     * @param {boolean} isLeading set if a leading comment
	     * @returns {undefined}
	     * @inner
	     */
	    function setComment(start, end, isLeading) {
	        var comment = {
	            type: source.charAt(start++),
	            lineEmpty: false,
	            leading: isLeading,
	        };
	        var lookback;
	        if (alternateCommentMode) {
	            lookback = 2;  // alternate comment parsing: "//" or "/*"
	        } else {
	            lookback = 3;  // "///" or "/**"
	        }
	        var commentOffset = start - lookback,
	            c;
	        do {
	            if (--commentOffset < 0 ||
	                    (c = source.charAt(commentOffset)) === "\n") {
	                comment.lineEmpty = true;
	                break;
	            }
	        } while (c === " " || c === "\t");
	        var lines = source
	            .substring(start, end)
	            .split(setCommentSplitRe);
	        for (var i = 0; i < lines.length; ++i)
	            lines[i] = lines[i]
	                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
	                .trim();
	        comment.text = lines
	            .join("\n")
	            .trim();

	        comments[line] = comment;
	        lastCommentLine = line;
	    }

	    function isDoubleSlashCommentLine(startOffset) {
	        var endOffset = findEndOfLine(startOffset);

	        // see if remaining line matches comment pattern
	        var lineText = source.substring(startOffset, endOffset);
	        var isComment = /^\s*\/\//.test(lineText);
	        return isComment;
	    }

	    function findEndOfLine(cursor) {
	        // find end of cursor's line
	        var endOffset = cursor;
	        while (endOffset < length && charAt(endOffset) !== "\n") {
	            endOffset++;
	        }
	        return endOffset;
	    }

	    /**
	     * Obtains the next token.
	     * @returns {string|null} Next token or `null` on eof
	     * @inner
	     */
	    function next() {
	        if (stack.length > 0)
	            return stack.shift();
	        if (stringDelim)
	            return readString();
	        var repeat,
	            prev,
	            curr,
	            start,
	            isDoc,
	            isLeadingComment = offset === 0;
	        do {
	            if (offset === length)
	                return null;
	            repeat = false;
	            while (whitespaceRe.test(curr = charAt(offset))) {
	                if (curr === "\n") {
	                    isLeadingComment = true;
	                    ++line;
	                }
	                if (++offset === length)
	                    return null;
	            }

	            if (charAt(offset) === "/") {
	                if (++offset === length) {
	                    throw illegal("comment");
	                }
	                if (charAt(offset) === "/") { // Line
	                    if (!alternateCommentMode) {
	                        // check for triple-slash comment
	                        isDoc = charAt(start = offset + 1) === "/";

	                        while (charAt(++offset) !== "\n") {
	                            if (offset === length) {
	                                return null;
	                            }
	                        }
	                        ++offset;
	                        if (isDoc) {
	                            setComment(start, offset - 1, isLeadingComment);
	                            // Trailing comment cannot not be multi-line,
	                            // so leading comment state should be reset to handle potential next comments
	                            isLeadingComment = true;
	                        }
	                        ++line;
	                        repeat = true;
	                    } else {
	                        // check for double-slash comments, consolidating consecutive lines
	                        start = offset;
	                        isDoc = false;
	                        if (isDoubleSlashCommentLine(offset - 1)) {
	                            isDoc = true;
	                            do {
	                                offset = findEndOfLine(offset);
	                                if (offset === length) {
	                                    break;
	                                }
	                                offset++;
	                                if (!isLeadingComment) {
	                                    // Trailing comment cannot not be multi-line
	                                    break;
	                                }
	                            } while (isDoubleSlashCommentLine(offset));
	                        } else {
	                            offset = Math.min(length, findEndOfLine(offset) + 1);
	                        }
	                        if (isDoc) {
	                            setComment(start, offset, isLeadingComment);
	                            isLeadingComment = true;
	                        }
	                        line++;
	                        repeat = true;
	                    }
	                } else if ((curr = charAt(offset)) === "*") { /* Block */
	                    // check for /** (regular comment mode) or /* (alternate comment mode)
	                    start = offset + 1;
	                    isDoc = alternateCommentMode || charAt(start) === "*";
	                    do {
	                        if (curr === "\n") {
	                            ++line;
	                        }
	                        if (++offset === length) {
	                            throw illegal("comment");
	                        }
	                        prev = curr;
	                        curr = charAt(offset);
	                    } while (prev !== "*" || curr !== "/");
	                    ++offset;
	                    if (isDoc) {
	                        setComment(start, offset - 2, isLeadingComment);
	                        isLeadingComment = true;
	                    }
	                    repeat = true;
	                } else {
	                    return "/";
	                }
	            }
	        } while (repeat);

	        // offset !== length if we got here

	        var end = offset;
	        delimRe.lastIndex = 0;
	        var delim = delimRe.test(charAt(end++));
	        if (!delim)
	            while (end < length && !delimRe.test(charAt(end)))
	                ++end;
	        var token = source.substring(offset, offset = end);
	        if (token === "\"" || token === "'")
	            stringDelim = token;
	        return token;
	    }

	    /**
	     * Pushes a token back to the stack.
	     * @param {string} token Token
	     * @returns {undefined}
	     * @inner
	     */
	    function push(token) {
	        stack.push(token);
	    }

	    /**
	     * Peeks for the next token.
	     * @returns {string|null} Token or `null` on eof
	     * @inner
	     */
	    function peek() {
	        if (!stack.length) {
	            var token = next();
	            if (token === null)
	                return null;
	            push(token);
	        }
	        return stack[0];
	    }

	    /**
	     * Skips a token.
	     * @param {string} expected Expected token
	     * @param {boolean} [optional=false] Whether the token is optional
	     * @returns {boolean} `true` when skipped, `false` if not
	     * @throws {Error} When a required token is not present
	     * @inner
	     */
	    function skip(expected, optional) {
	        var actual = peek(),
	            equals = actual === expected;
	        if (equals) {
	            next();
	            return true;
	        }
	        if (!optional)
	            throw illegal("token '" + actual + "', '" + expected + "' expected");
	        return false;
	    }

	    /**
	     * Gets a comment.
	     * @param {number} [trailingLine] Line number if looking for a trailing comment
	     * @returns {string|null} Comment text
	     * @inner
	     */
	    function cmnt(trailingLine) {
	        var ret = null;
	        var comment;
	        if (trailingLine === undefined) {
	            comment = comments[line - 1];
	            delete comments[line - 1];
	            if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
	                ret = comment.leading ? comment.text : null;
	            }
	        } else {
	            /* istanbul ignore else */
	            if (lastCommentLine < trailingLine) {
	                peek();
	            }
	            comment = comments[trailingLine];
	            delete comments[trailingLine];
	            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
	                ret = comment.leading ? null : comment.text;
	            }
	        }
	        return ret;
	    }

	    return Object.defineProperty({
	        next: next,
	        peek: peek,
	        push: push,
	        skip: skip,
	        cmnt: cmnt
	    }, "line", {
	        get: function() { return line; }
	    });
	    /* eslint-enable callback-return */
	}
	return tokenize_1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;
	parse_1 = parse;

	parse.filename = null;
	parse.defaults = { keepCase: false };

	var tokenize  = requireTokenize(),
	    Root      = requireRoot$1(),
	    Type      = requireType(),
	    Field     = requireField(),
	    MapField  = requireMapfield(),
	    OneOf     = requireOneof(),
	    Enum      = require_enum(),
	    Service   = requireService(),
	    Method    = requireMethod(),
	    types     = requireTypes(),
	    util      = requireUtil$1();

	var base10Re    = /^[1-9][0-9]*$/,
	    base10NegRe = /^-?[1-9][0-9]*$/,
	    base16Re    = /^0[x][0-9a-fA-F]+$/,
	    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
	    base8Re     = /^0[0-7]+$/,
	    base8NegRe  = /^-?0[0-7]+$/,
	    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
	    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
	    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
	    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

	/**
	 * Result object returned from {@link parse}.
	 * @interface IParserResult
	 * @property {string|undefined} package Package name, if declared
	 * @property {string[]|undefined} imports Imports, if any
	 * @property {string[]|undefined} weakImports Weak imports, if any
	 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
	 * @property {Root} root Populated root instance
	 */

	/**
	 * Options modifying the behavior of {@link parse}.
	 * @interface IParseOptions
	 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
	 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
	 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
	 */

	/**
	 * Options modifying the behavior of JSON serialization.
	 * @interface IToJSONOptions
	 * @property {boolean} [keepComments=false] Serializes comments.
	 */

	/**
	 * Parses the given .proto source and returns an object with the parsed contents.
	 * @param {string} source Source contents
	 * @param {Root} root Root to populate
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {IParserResult} Parser result
	 * @property {string} filename=null Currently processing file name for error reporting, if known
	 * @property {IParseOptions} defaults Default {@link IParseOptions}
	 */
	function parse(source, root, options) {
	    /* eslint-disable callback-return */
	    if (!(root instanceof Root)) {
	        options = root;
	        root = new Root();
	    }
	    if (!options)
	        options = parse.defaults;

	    var preferTrailingComment = options.preferTrailingComment || false;
	    var tn = tokenize(source, options.alternateCommentMode || false),
	        next = tn.next,
	        push = tn.push,
	        peek = tn.peek,
	        skip = tn.skip,
	        cmnt = tn.cmnt;

	    var head = true,
	        pkg,
	        imports,
	        weakImports,
	        syntax,
	        isProto3 = false;

	    var ptr = root;

	    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

	    /* istanbul ignore next */
	    function illegal(token, name, insideTryCatch) {
	        var filename = parse.filename;
	        if (!insideTryCatch)
	            parse.filename = null;
	        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
	    }

	    function readString() {
	        var values = [],
	            token;
	        do {
	            /* istanbul ignore if */
	            if ((token = next()) !== "\"" && token !== "'")
	                throw illegal(token);

	            values.push(next());
	            skip(token);
	            token = peek();
	        } while (token === "\"" || token === "'");
	        return values.join("");
	    }

	    function readValue(acceptTypeRef) {
	        var token = next();
	        switch (token) {
	            case "'":
	            case "\"":
	                push(token);
	                return readString();
	            case "true": case "TRUE":
	                return true;
	            case "false": case "FALSE":
	                return false;
	        }
	        try {
	            return parseNumber(token, /* insideTryCatch */ true);
	        } catch (e) {

	            /* istanbul ignore else */
	            if (typeRefRe.test(token))
	                return token;

	            /* istanbul ignore next */
	            throw illegal(token, "value");
	        }
	    }

	    function readRanges(target, acceptStrings) {
	        var token, start;
	        do {
	            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
	                target.push(readString());
	            else
	                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
	        } while (skip(",", true));
	        var dummy = {options: undefined};
	        dummy.setOption = function(name, value) {
	          if (this.options === undefined) this.options = {};
	          this.options[name] = value;
	        };
	        ifBlock(
	            dummy,
	            function parseRange_block(token) {
	              /* istanbul ignore else */
	              if (token === "option") {
	                parseOption(dummy, token);  // skip
	                skip(";");
	              } else
	                throw illegal(token);
	            },
	            function parseRange_line() {
	              parseInlineOptions(dummy);  // skip
	            });
	    }

	    function parseNumber(token, insideTryCatch) {
	        var sign = 1;
	        if (token.charAt(0) === "-") {
	            sign = -1;
	            token = token.substring(1);
	        }
	        switch (token) {
	            case "inf": case "INF": case "Inf":
	                return sign * Infinity;
	            case "nan": case "NAN": case "Nan": case "NaN":
	                return NaN;
	            case "0":
	                return 0;
	        }
	        if (base10Re.test(token))
	            return sign * parseInt(token, 10);
	        if (base16Re.test(token))
	            return sign * parseInt(token, 16);
	        if (base8Re.test(token))
	            return sign * parseInt(token, 8);

	        /* istanbul ignore else */
	        if (numberRe.test(token))
	            return sign * parseFloat(token);

	        /* istanbul ignore next */
	        throw illegal(token, "number", insideTryCatch);
	    }

	    function parseId(token, acceptNegative) {
	        switch (token) {
	            case "max": case "MAX": case "Max":
	                return 536870911;
	            case "0":
	                return 0;
	        }

	        /* istanbul ignore if */
	        if (!acceptNegative && token.charAt(0) === "-")
	            throw illegal(token, "id");

	        if (base10NegRe.test(token))
	            return parseInt(token, 10);
	        if (base16NegRe.test(token))
	            return parseInt(token, 16);

	        /* istanbul ignore else */
	        if (base8NegRe.test(token))
	            return parseInt(token, 8);

	        /* istanbul ignore next */
	        throw illegal(token, "id");
	    }

	    function parsePackage() {

	        /* istanbul ignore if */
	        if (pkg !== undefined)
	            throw illegal("package");

	        pkg = next();

	        /* istanbul ignore if */
	        if (!typeRefRe.test(pkg))
	            throw illegal(pkg, "name");

	        ptr = ptr.define(pkg);
	        skip(";");
	    }

	    function parseImport() {
	        var token = peek();
	        var whichImports;
	        switch (token) {
	            case "weak":
	                whichImports = weakImports || (weakImports = []);
	                next();
	                break;
	            case "public":
	                next();
	                // eslint-disable-next-line no-fallthrough
	            default:
	                whichImports = imports || (imports = []);
	                break;
	        }
	        token = readString();
	        skip(";");
	        whichImports.push(token);
	    }

	    function parseSyntax() {
	        skip("=");
	        syntax = readString();
	        isProto3 = syntax === "proto3";

	        /* istanbul ignore if */
	        if (!isProto3 && syntax !== "proto2")
	            throw illegal(syntax, "syntax");

	        // Syntax is needed to understand the meaning of the optional field rule
	        // Otherwise the meaning is ambiguous between proto2 and proto3
	        root.setOption("syntax", syntax);

	        skip(";");
	    }

	    function parseCommon(parent, token) {
	        switch (token) {

	            case "option":
	                parseOption(parent, token);
	                skip(";");
	                return true;

	            case "message":
	                parseType(parent, token);
	                return true;

	            case "enum":
	                parseEnum(parent, token);
	                return true;

	            case "service":
	                parseService(parent, token);
	                return true;

	            case "extend":
	                parseExtension(parent, token);
	                return true;
	        }
	        return false;
	    }

	    function ifBlock(obj, fnIf, fnElse) {
	        var trailingLine = tn.line;
	        if (obj) {
	            if(typeof obj.comment !== "string") {
	              obj.comment = cmnt(); // try block-type comment
	            }
	            obj.filename = parse.filename;
	        }
	        if (skip("{", true)) {
	            var token;
	            while ((token = next()) !== "}")
	                fnIf(token);
	            skip(";", true);
	        } else {
	            if (fnElse)
	                fnElse();
	            skip(";");
	            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
	                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
	        }
	    }

	    function parseType(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "type name");

	        var type = new Type(token);
	        ifBlock(type, function parseType_block(token) {
	            if (parseCommon(type, token))
	                return;

	            switch (token) {

	                case "map":
	                    parseMapField(type);
	                    break;

	                case "required":
	                case "repeated":
	                    parseField(type, token);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(type, "proto3_optional");
	                    } else {
	                        parseField(type, "optional");
	                    }
	                    break;

	                case "oneof":
	                    parseOneOf(type, token);
	                    break;

	                case "extensions":
	                    readRanges(type.extensions || (type.extensions = []));
	                    break;

	                case "reserved":
	                    readRanges(type.reserved || (type.reserved = []), true);
	                    break;

	                default:
	                    /* istanbul ignore if */
	                    if (!isProto3 || !typeRefRe.test(token))
	                        throw illegal(token);

	                    push(token);
	                    parseField(type, "optional");
	                    break;
	            }
	        });
	        parent.add(type);
	    }

	    function parseField(parent, rule, extend) {
	        var type = next();
	        if (type === "group") {
	            parseGroup(parent, rule);
	            return;
	        }
	        // Type names can consume multiple tokens, in multiple variants:
	        //    package.subpackage   field       tokens: "package.subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package . subpackage field       tokens: "package" "." "subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package.  subpackage field       tokens: "package." "subpackage" [TYPE NAME ENDS HERE] "field"
	        //    package  .subpackage field       tokens: "package" ".subpackage" [TYPE NAME ENDS HERE] "field"
	        // Keep reading tokens until we get a type name with no period at the end,
	        // and the next token does not start with a period.
	        while (type.endsWith(".") || peek().startsWith(".")) {
	            type += next();
	        }

	        /* istanbul ignore if */
	        if (!typeRefRe.test(type))
	            throw illegal(type, "type");

	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        name = applyCase(name);
	        skip("=");

	        var field = new Field(name, parseId(next()), type, rule, extend);
	        ifBlock(field, function parseField_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(field, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseField_line() {
	            parseInlineOptions(field);
	        });

	        if (rule === "proto3_optional") {
	            // for proto3 optional fields, we create a single-member Oneof to mimic "optional" behavior
	            var oneof = new OneOf("_" + name);
	            field.setOption("proto3_optional", true);
	            oneof.add(field);
	            parent.add(oneof);
	        } else {
	            parent.add(field);
	        }

	        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
	        // parsing proto2 descriptors without the option, where applicable. This must be done for
	        // all known packable types and anything that could be an enum (= is not a basic type).
	        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
	            field.setOption("packed", false, /* ifNotSet */ true);
	    }

	    function parseGroup(parent, rule) {
	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        var fieldName = util.lcFirst(name);
	        if (name === fieldName)
	            name = util.ucFirst(name);
	        skip("=");
	        var id = parseId(next());
	        var type = new Type(name);
	        type.group = true;
	        var field = new Field(fieldName, id, name, rule);
	        field.filename = parse.filename;
	        ifBlock(type, function parseGroup_block(token) {
	            switch (token) {

	                case "option":
	                    parseOption(type, token);
	                    skip(";");
	                    break;

	                case "required":
	                case "repeated":
	                    parseField(type, token);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(type, "proto3_optional");
	                    } else {
	                        parseField(type, "optional");
	                    }
	                    break;

	                case "message":
	                    parseType(type, token);
	                    break;

	                case "enum":
	                    parseEnum(type, token);
	                    break;

	                /* istanbul ignore next */
	                default:
	                    throw illegal(token); // there are no groups with proto3 semantics
	            }
	        });
	        parent.add(type)
	              .add(field);
	    }

	    function parseMapField(parent) {
	        skip("<");
	        var keyType = next();

	        /* istanbul ignore if */
	        if (types.mapKey[keyType] === undefined)
	            throw illegal(keyType, "type");

	        skip(",");
	        var valueType = next();

	        /* istanbul ignore if */
	        if (!typeRefRe.test(valueType))
	            throw illegal(valueType, "type");

	        skip(">");
	        var name = next();

	        /* istanbul ignore if */
	        if (!nameRe.test(name))
	            throw illegal(name, "name");

	        skip("=");
	        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
	        ifBlock(field, function parseMapField_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(field, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseMapField_line() {
	            parseInlineOptions(field);
	        });
	        parent.add(field);
	    }

	    function parseOneOf(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var oneof = new OneOf(applyCase(token));
	        ifBlock(oneof, function parseOneOf_block(token) {
	            if (token === "option") {
	                parseOption(oneof, token);
	                skip(";");
	            } else {
	                push(token);
	                parseField(oneof, "optional");
	            }
	        });
	        parent.add(oneof);
	    }

	    function parseEnum(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var enm = new Enum(token);
	        ifBlock(enm, function parseEnum_block(token) {
	          switch(token) {
	            case "option":
	              parseOption(enm, token);
	              skip(";");
	              break;

	            case "reserved":
	              readRanges(enm.reserved || (enm.reserved = []), true);
	              break;

	            default:
	              parseEnumValue(enm, token);
	          }
	        });
	        parent.add(enm);
	    }

	    function parseEnumValue(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token))
	            throw illegal(token, "name");

	        skip("=");
	        var value = parseId(next(), true),
	            dummy = {
	                options: undefined
	            };
	        dummy.setOption = function(name, value) {
	            if (this.options === undefined)
	                this.options = {};
	            this.options[name] = value;
	        };
	        ifBlock(dummy, function parseEnumValue_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(dummy, token); // skip
	                skip(";");
	            } else
	                throw illegal(token);

	        }, function parseEnumValue_line() {
	            parseInlineOptions(dummy); // skip
	        });
	        parent.add(token, value, dummy.comment, dummy.options);
	    }

	    function parseOption(parent, token) {
	        var isCustom = skip("(", true);

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token, "name");

	        var name = token;
	        var option = name;
	        var propName;

	        if (isCustom) {
	            skip(")");
	            name = "(" + name + ")";
	            option = name;
	            token = peek();
	            if (fqTypeRefRe.test(token)) {
	                propName = token.slice(1); //remove '.' before property name
	                name += token;
	                next();
	            }
	        }
	        skip("=");
	        var optionValue = parseOptionValue(parent, name);
	        setParsedOption(parent, option, optionValue, propName);
	    }

	    function parseOptionValue(parent, name) {
	        // { a: "foo" b { c: "bar" } }
	        if (skip("{", true)) {
	            var objectResult = {};

	            while (!skip("}", true)) {
	                /* istanbul ignore if */
	                if (!nameRe.test(token = next())) {
	                    throw illegal(token, "name");
	                }
	                if (token === null) {
	                  throw illegal(token, "end of input");
	                }

	                var value;
	                var propName = token;

	                skip(":", true);

	                if (peek() === "{")
	                    value = parseOptionValue(parent, name + "." + token);
	                else if (peek() === "[") {
	                    // option (my_option) = {
	                    //     repeated_value: [ "foo", "bar" ]
	                    // };
	                    value = [];
	                    var lastValue;
	                    if (skip("[", true)) {
	                        do {
	                            lastValue = readValue();
	                            value.push(lastValue);
	                        } while (skip(",", true));
	                        skip("]");
	                        if (typeof lastValue !== "undefined") {
	                            setOption(parent, name + "." + token, lastValue);
	                        }
	                    }
	                } else {
	                    value = readValue();
	                    setOption(parent, name + "." + token, value);
	                }

	                var prevValue = objectResult[propName];

	                if (prevValue)
	                    value = [].concat(prevValue).concat(value);

	                objectResult[propName] = value;

	                // Semicolons and commas can be optional
	                skip(",", true);
	                skip(";", true);
	            }

	            return objectResult;
	        }

	        var simpleValue = readValue();
	        setOption(parent, name, simpleValue);
	        return simpleValue;
	        // Does not enforce a delimiter to be universal
	    }

	    function setOption(parent, name, value) {
	        if (parent.setOption)
	            parent.setOption(name, value);
	    }

	    function setParsedOption(parent, name, value, propName) {
	        if (parent.setParsedOption)
	            parent.setParsedOption(name, value, propName);
	    }

	    function parseInlineOptions(parent) {
	        if (skip("[", true)) {
	            do {
	                parseOption(parent, "option");
	            } while (skip(",", true));
	            skip("]");
	        }
	        return parent;
	    }

	    function parseService(parent, token) {

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "service name");

	        var service = new Service(token);
	        ifBlock(service, function parseService_block(token) {
	            if (parseCommon(service, token))
	                return;

	            /* istanbul ignore else */
	            if (token === "rpc")
	                parseMethod(service, token);
	            else
	                throw illegal(token);
	        });
	        parent.add(service);
	    }

	    function parseMethod(parent, token) {
	        // Get the comment of the preceding line now (if one exists) in case the
	        // method is defined across multiple lines.
	        var commentText = cmnt();

	        var type = token;

	        /* istanbul ignore if */
	        if (!nameRe.test(token = next()))
	            throw illegal(token, "name");

	        var name = token,
	            requestType, requestStream,
	            responseType, responseStream;

	        skip("(");
	        if (skip("stream", true))
	            requestStream = true;

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token);

	        requestType = token;
	        skip(")"); skip("returns"); skip("(");
	        if (skip("stream", true))
	            responseStream = true;

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token);

	        responseType = token;
	        skip(")");

	        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
	        method.comment = commentText;
	        ifBlock(method, function parseMethod_block(token) {

	            /* istanbul ignore else */
	            if (token === "option") {
	                parseOption(method, token);
	                skip(";");
	            } else
	                throw illegal(token);

	        });
	        parent.add(method);
	    }

	    function parseExtension(parent, token) {

	        /* istanbul ignore if */
	        if (!typeRefRe.test(token = next()))
	            throw illegal(token, "reference");

	        var reference = token;
	        ifBlock(null, function parseExtension_block(token) {
	            switch (token) {

	                case "required":
	                case "repeated":
	                    parseField(parent, token, reference);
	                    break;

	                case "optional":
	                    /* istanbul ignore if */
	                    if (isProto3) {
	                        parseField(parent, "proto3_optional", reference);
	                    } else {
	                        parseField(parent, "optional", reference);
	                    }
	                    break;

	                default:
	                    /* istanbul ignore if */
	                    if (!isProto3 || !typeRefRe.test(token))
	                        throw illegal(token);
	                    push(token);
	                    parseField(parent, "optional", reference);
	                    break;
	            }
	        });
	    }

	    var token;
	    while ((token = next()) !== null) {
	        switch (token) {

	            case "package":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parsePackage();
	                break;

	            case "import":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parseImport();
	                break;

	            case "syntax":

	                /* istanbul ignore if */
	                if (!head)
	                    throw illegal(token);

	                parseSyntax();
	                break;

	            case "option":

	                parseOption(ptr, token);
	                skip(";");
	                break;

	            default:

	                /* istanbul ignore else */
	                if (parseCommon(ptr, token)) {
	                    head = false;
	                    continue;
	                }

	                /* istanbul ignore next */
	                throw illegal(token);
	        }
	    }

	    parse.filename = null;
	    return {
	        "package"     : pkg,
	        "imports"     : imports,
	         weakImports  : weakImports,
	         syntax       : syntax,
	         root         : root
	    };
	}

	/**
	 * Parses the given .proto source and returns an object with the parsed contents.
	 * @name parse
	 * @function
	 * @param {string} source Source contents
	 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
	 * @returns {IParserResult} Parser result
	 * @property {string} filename=null Currently processing file name for error reporting, if known
	 * @property {IParseOptions} defaults Default {@link IParseOptions}
	 * @variation 2
	 */
	return parse_1;
}

var common_1;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common_1;
	hasRequiredCommon = 1;
	common_1 = common;

	var commonRe = /\/|\./;

	/**
	 * Provides common type definitions.
	 * Can also be used to provide additional google types or your own custom types.
	 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
	 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
	 * @returns {undefined}
	 * @property {INamespace} google/protobuf/any.proto Any
	 * @property {INamespace} google/protobuf/duration.proto Duration
	 * @property {INamespace} google/protobuf/empty.proto Empty
	 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
	 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
	 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
	 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
	 * @example
	 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
	 * protobuf.common("descriptor", descriptorJson);
	 *
	 * // manually provides a custom definition (uses my.foo namespace)
	 * protobuf.common("my/foo/bar.proto", myFooBarJson);
	 */
	function common(name, json) {
	    if (!commonRe.test(name)) {
	        name = "google/protobuf/" + name + ".proto";
	        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
	    }
	    common[name] = json;
	}

	// Not provided because of limited use (feel free to discuss or to provide yourself):
	//
	// google/protobuf/descriptor.proto
	// google/protobuf/source_context.proto
	// google/protobuf/type.proto
	//
	// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
	// the repository or package within the google/protobuf directory.

	common("any", {

	    /**
	     * Properties of a google.protobuf.Any message.
	     * @interface IAny
	     * @type {Object}
	     * @property {string} [typeUrl]
	     * @property {Uint8Array} [bytes]
	     * @memberof common
	     */
	    Any: {
	        fields: {
	            type_url: {
	                type: "string",
	                id: 1
	            },
	            value: {
	                type: "bytes",
	                id: 2
	            }
	        }
	    }
	});

	var timeType;

	common("duration", {

	    /**
	     * Properties of a google.protobuf.Duration message.
	     * @interface IDuration
	     * @type {Object}
	     * @property {number|Long} [seconds]
	     * @property {number} [nanos]
	     * @memberof common
	     */
	    Duration: timeType = {
	        fields: {
	            seconds: {
	                type: "int64",
	                id: 1
	            },
	            nanos: {
	                type: "int32",
	                id: 2
	            }
	        }
	    }
	});

	common("timestamp", {

	    /**
	     * Properties of a google.protobuf.Timestamp message.
	     * @interface ITimestamp
	     * @type {Object}
	     * @property {number|Long} [seconds]
	     * @property {number} [nanos]
	     * @memberof common
	     */
	    Timestamp: timeType
	});

	common("empty", {

	    /**
	     * Properties of a google.protobuf.Empty message.
	     * @interface IEmpty
	     * @memberof common
	     */
	    Empty: {
	        fields: {}
	    }
	});

	common("struct", {

	    /**
	     * Properties of a google.protobuf.Struct message.
	     * @interface IStruct
	     * @type {Object}
	     * @property {Object.<string,IValue>} [fields]
	     * @memberof common
	     */
	    Struct: {
	        fields: {
	            fields: {
	                keyType: "string",
	                type: "Value",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Value message.
	     * @interface IValue
	     * @type {Object}
	     * @property {string} [kind]
	     * @property {0} [nullValue]
	     * @property {number} [numberValue]
	     * @property {string} [stringValue]
	     * @property {boolean} [boolValue]
	     * @property {IStruct} [structValue]
	     * @property {IListValue} [listValue]
	     * @memberof common
	     */
	    Value: {
	        oneofs: {
	            kind: {
	                oneof: [
	                    "nullValue",
	                    "numberValue",
	                    "stringValue",
	                    "boolValue",
	                    "structValue",
	                    "listValue"
	                ]
	            }
	        },
	        fields: {
	            nullValue: {
	                type: "NullValue",
	                id: 1
	            },
	            numberValue: {
	                type: "double",
	                id: 2
	            },
	            stringValue: {
	                type: "string",
	                id: 3
	            },
	            boolValue: {
	                type: "bool",
	                id: 4
	            },
	            structValue: {
	                type: "Struct",
	                id: 5
	            },
	            listValue: {
	                type: "ListValue",
	                id: 6
	            }
	        }
	    },

	    NullValue: {
	        values: {
	            NULL_VALUE: 0
	        }
	    },

	    /**
	     * Properties of a google.protobuf.ListValue message.
	     * @interface IListValue
	     * @type {Object}
	     * @property {Array.<IValue>} [values]
	     * @memberof common
	     */
	    ListValue: {
	        fields: {
	            values: {
	                rule: "repeated",
	                type: "Value",
	                id: 1
	            }
	        }
	    }
	});

	common("wrappers", {

	    /**
	     * Properties of a google.protobuf.DoubleValue message.
	     * @interface IDoubleValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    DoubleValue: {
	        fields: {
	            value: {
	                type: "double",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.FloatValue message.
	     * @interface IFloatValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    FloatValue: {
	        fields: {
	            value: {
	                type: "float",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Int64Value message.
	     * @interface IInt64Value
	     * @type {Object}
	     * @property {number|Long} [value]
	     * @memberof common
	     */
	    Int64Value: {
	        fields: {
	            value: {
	                type: "int64",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.UInt64Value message.
	     * @interface IUInt64Value
	     * @type {Object}
	     * @property {number|Long} [value]
	     * @memberof common
	     */
	    UInt64Value: {
	        fields: {
	            value: {
	                type: "uint64",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.Int32Value message.
	     * @interface IInt32Value
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    Int32Value: {
	        fields: {
	            value: {
	                type: "int32",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.UInt32Value message.
	     * @interface IUInt32Value
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    UInt32Value: {
	        fields: {
	            value: {
	                type: "uint32",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.BoolValue message.
	     * @interface IBoolValue
	     * @type {Object}
	     * @property {boolean} [value]
	     * @memberof common
	     */
	    BoolValue: {
	        fields: {
	            value: {
	                type: "bool",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.StringValue message.
	     * @interface IStringValue
	     * @type {Object}
	     * @property {string} [value]
	     * @memberof common
	     */
	    StringValue: {
	        fields: {
	            value: {
	                type: "string",
	                id: 1
	            }
	        }
	    },

	    /**
	     * Properties of a google.protobuf.BytesValue message.
	     * @interface IBytesValue
	     * @type {Object}
	     * @property {Uint8Array} [value]
	     * @memberof common
	     */
	    BytesValue: {
	        fields: {
	            value: {
	                type: "bytes",
	                id: 1
	            }
	        }
	    }
	});

	common("field_mask", {

	    /**
	     * Properties of a google.protobuf.FieldMask message.
	     * @interface IDoubleValue
	     * @type {Object}
	     * @property {number} [value]
	     * @memberof common
	     */
	    FieldMask: {
	        fields: {
	            paths: {
	                rule: "repeated",
	                type: "string",
	                id: 1
	            }
	        }
	    }
	});

	/**
	 * Gets the root definition of the specified common proto file.
	 *
	 * Bundled definitions are:
	 * - google/protobuf/any.proto
	 * - google/protobuf/duration.proto
	 * - google/protobuf/empty.proto
	 * - google/protobuf/field_mask.proto
	 * - google/protobuf/struct.proto
	 * - google/protobuf/timestamp.proto
	 * - google/protobuf/wrappers.proto
	 *
	 * @param {string} file Proto file name
	 * @returns {INamespace|null} Root definition or `null` if not defined
	 */
	common.get = function get(file) {
	    return common[file] || null;
	};
	return common_1;
}

var hasRequiredSrc$5;

function requireSrc$5 () {
	if (hasRequiredSrc$5) return src$3.exports;
	hasRequiredSrc$5 = 1;
	var protobuf = src$3.exports = requireIndexLight();

	protobuf.build = "full";

	// Parser
	protobuf.tokenize         = requireTokenize();
	protobuf.parse            = requireParse();
	protobuf.common           = requireCommon();

	// Configure parser
	protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
	return src$3.exports;
}

var protobufjs;
var hasRequiredProtobufjs;

function requireProtobufjs () {
	if (hasRequiredProtobufjs) return protobufjs;
	hasRequiredProtobufjs = 1;
	protobufjs = requireSrc$5();
	return protobufjs;
}

var descriptor = {exports: {}};

var nested$3 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					FileDescriptorSet: {
						fields: {
							file: {
								rule: "repeated",
								type: "FileDescriptorProto",
								id: 1
							}
						}
					},
					FileDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							"package": {
								type: "string",
								id: 2
							},
							dependency: {
								rule: "repeated",
								type: "string",
								id: 3
							},
							publicDependency: {
								rule: "repeated",
								type: "int32",
								id: 10,
								options: {
									packed: false
								}
							},
							weakDependency: {
								rule: "repeated",
								type: "int32",
								id: 11,
								options: {
									packed: false
								}
							},
							messageType: {
								rule: "repeated",
								type: "DescriptorProto",
								id: 4
							},
							enumType: {
								rule: "repeated",
								type: "EnumDescriptorProto",
								id: 5
							},
							service: {
								rule: "repeated",
								type: "ServiceDescriptorProto",
								id: 6
							},
							extension: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 7
							},
							options: {
								type: "FileOptions",
								id: 8
							},
							sourceCodeInfo: {
								type: "SourceCodeInfo",
								id: 9
							},
							syntax: {
								type: "string",
								id: 12
							}
						}
					},
					DescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							field: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 2
							},
							extension: {
								rule: "repeated",
								type: "FieldDescriptorProto",
								id: 6
							},
							nestedType: {
								rule: "repeated",
								type: "DescriptorProto",
								id: 3
							},
							enumType: {
								rule: "repeated",
								type: "EnumDescriptorProto",
								id: 4
							},
							extensionRange: {
								rule: "repeated",
								type: "ExtensionRange",
								id: 5
							},
							oneofDecl: {
								rule: "repeated",
								type: "OneofDescriptorProto",
								id: 8
							},
							options: {
								type: "MessageOptions",
								id: 7
							},
							reservedRange: {
								rule: "repeated",
								type: "ReservedRange",
								id: 9
							},
							reservedName: {
								rule: "repeated",
								type: "string",
								id: 10
							}
						},
						nested: {
							ExtensionRange: {
								fields: {
									start: {
										type: "int32",
										id: 1
									},
									end: {
										type: "int32",
										id: 2
									}
								}
							},
							ReservedRange: {
								fields: {
									start: {
										type: "int32",
										id: 1
									},
									end: {
										type: "int32",
										id: 2
									}
								}
							}
						}
					},
					FieldDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 3
							},
							label: {
								type: "Label",
								id: 4
							},
							type: {
								type: "Type",
								id: 5
							},
							typeName: {
								type: "string",
								id: 6
							},
							extendee: {
								type: "string",
								id: 2
							},
							defaultValue: {
								type: "string",
								id: 7
							},
							oneofIndex: {
								type: "int32",
								id: 9
							},
							jsonName: {
								type: "string",
								id: 10
							},
							options: {
								type: "FieldOptions",
								id: 8
							}
						},
						nested: {
							Type: {
								values: {
									TYPE_DOUBLE: 1,
									TYPE_FLOAT: 2,
									TYPE_INT64: 3,
									TYPE_UINT64: 4,
									TYPE_INT32: 5,
									TYPE_FIXED64: 6,
									TYPE_FIXED32: 7,
									TYPE_BOOL: 8,
									TYPE_STRING: 9,
									TYPE_GROUP: 10,
									TYPE_MESSAGE: 11,
									TYPE_BYTES: 12,
									TYPE_UINT32: 13,
									TYPE_ENUM: 14,
									TYPE_SFIXED32: 15,
									TYPE_SFIXED64: 16,
									TYPE_SINT32: 17,
									TYPE_SINT64: 18
								}
							},
							Label: {
								values: {
									LABEL_OPTIONAL: 1,
									LABEL_REQUIRED: 2,
									LABEL_REPEATED: 3
								}
							}
						}
					},
					OneofDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							options: {
								type: "OneofOptions",
								id: 2
							}
						}
					},
					EnumDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								rule: "repeated",
								type: "EnumValueDescriptorProto",
								id: 2
							},
							options: {
								type: "EnumOptions",
								id: 3
							}
						}
					},
					EnumValueDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 2
							},
							options: {
								type: "EnumValueOptions",
								id: 3
							}
						}
					},
					ServiceDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							method: {
								rule: "repeated",
								type: "MethodDescriptorProto",
								id: 2
							},
							options: {
								type: "ServiceOptions",
								id: 3
							}
						}
					},
					MethodDescriptorProto: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							inputType: {
								type: "string",
								id: 2
							},
							outputType: {
								type: "string",
								id: 3
							},
							options: {
								type: "MethodOptions",
								id: 4
							},
							clientStreaming: {
								type: "bool",
								id: 5
							},
							serverStreaming: {
								type: "bool",
								id: 6
							}
						}
					},
					FileOptions: {
						fields: {
							javaPackage: {
								type: "string",
								id: 1
							},
							javaOuterClassname: {
								type: "string",
								id: 8
							},
							javaMultipleFiles: {
								type: "bool",
								id: 10
							},
							javaGenerateEqualsAndHash: {
								type: "bool",
								id: 20,
								options: {
									deprecated: true
								}
							},
							javaStringCheckUtf8: {
								type: "bool",
								id: 27
							},
							optimizeFor: {
								type: "OptimizeMode",
								id: 9,
								options: {
									"default": "SPEED"
								}
							},
							goPackage: {
								type: "string",
								id: 11
							},
							ccGenericServices: {
								type: "bool",
								id: 16
							},
							javaGenericServices: {
								type: "bool",
								id: 17
							},
							pyGenericServices: {
								type: "bool",
								id: 18
							},
							deprecated: {
								type: "bool",
								id: 23
							},
							ccEnableArenas: {
								type: "bool",
								id: 31
							},
							objcClassPrefix: {
								type: "string",
								id: 36
							},
							csharpNamespace: {
								type: "string",
								id: 37
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								38,
								38
							]
						],
						nested: {
							OptimizeMode: {
								values: {
									SPEED: 1,
									CODE_SIZE: 2,
									LITE_RUNTIME: 3
								}
							}
						}
					},
					MessageOptions: {
						fields: {
							messageSetWireFormat: {
								type: "bool",
								id: 1
							},
							noStandardDescriptorAccessor: {
								type: "bool",
								id: 2
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							mapEntry: {
								type: "bool",
								id: 7
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								8,
								8
							]
						]
					},
					FieldOptions: {
						fields: {
							ctype: {
								type: "CType",
								id: 1,
								options: {
									"default": "STRING"
								}
							},
							packed: {
								type: "bool",
								id: 2
							},
							jstype: {
								type: "JSType",
								id: 6,
								options: {
									"default": "JS_NORMAL"
								}
							},
							lazy: {
								type: "bool",
								id: 5
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							weak: {
								type: "bool",
								id: 10
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						],
						reserved: [
							[
								4,
								4
							]
						],
						nested: {
							CType: {
								values: {
									STRING: 0,
									CORD: 1,
									STRING_PIECE: 2
								}
							},
							JSType: {
								values: {
									JS_NORMAL: 0,
									JS_STRING: 1,
									JS_NUMBER: 2
								}
							}
						}
					},
					OneofOptions: {
						fields: {
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					EnumOptions: {
						fields: {
							allowAlias: {
								type: "bool",
								id: 2
							},
							deprecated: {
								type: "bool",
								id: 3
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					EnumValueOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 1
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					ServiceOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 33
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					MethodOptions: {
						fields: {
							deprecated: {
								type: "bool",
								id: 33
							},
							uninterpretedOption: {
								rule: "repeated",
								type: "UninterpretedOption",
								id: 999
							}
						},
						extensions: [
							[
								1000,
								536870911
							]
						]
					},
					UninterpretedOption: {
						fields: {
							name: {
								rule: "repeated",
								type: "NamePart",
								id: 2
							},
							identifierValue: {
								type: "string",
								id: 3
							},
							positiveIntValue: {
								type: "uint64",
								id: 4
							},
							negativeIntValue: {
								type: "int64",
								id: 5
							},
							doubleValue: {
								type: "double",
								id: 6
							},
							stringValue: {
								type: "bytes",
								id: 7
							},
							aggregateValue: {
								type: "string",
								id: 8
							}
						},
						nested: {
							NamePart: {
								fields: {
									namePart: {
										rule: "required",
										type: "string",
										id: 1
									},
									isExtension: {
										rule: "required",
										type: "bool",
										id: 2
									}
								}
							}
						}
					},
					SourceCodeInfo: {
						fields: {
							location: {
								rule: "repeated",
								type: "Location",
								id: 1
							}
						},
						nested: {
							Location: {
								fields: {
									path: {
										rule: "repeated",
										type: "int32",
										id: 1
									},
									span: {
										rule: "repeated",
										type: "int32",
										id: 2
									},
									leadingComments: {
										type: "string",
										id: 3
									},
									trailingComments: {
										type: "string",
										id: 4
									},
									leadingDetachedComments: {
										rule: "repeated",
										type: "string",
										id: 6
									}
								}
							}
						}
					},
					GeneratedCodeInfo: {
						fields: {
							annotation: {
								rule: "repeated",
								type: "Annotation",
								id: 1
							}
						},
						nested: {
							Annotation: {
								fields: {
									path: {
										rule: "repeated",
										type: "int32",
										id: 1
									},
									sourceFile: {
										type: "string",
										id: 2
									},
									begin: {
										type: "int32",
										id: 3
									},
									end: {
										type: "int32",
										id: 4
									}
								}
							}
						}
					}
				}
			}
		}
	}
};
var require$$4 = {
	nested: nested$3
};

var hasRequiredDescriptor;

function requireDescriptor () {
	if (hasRequiredDescriptor) return descriptor.exports;
	hasRequiredDescriptor = 1;
	(function (module, exports) {
		var $protobuf = requireProtobufjs();
		module.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require$$4).lookup(".google.protobuf");

		var Namespace = $protobuf.Namespace,
		    Root      = $protobuf.Root,
		    Enum      = $protobuf.Enum,
		    Type      = $protobuf.Type,
		    Field     = $protobuf.Field,
		    MapField  = $protobuf.MapField,
		    OneOf     = $protobuf.OneOf,
		    Service   = $protobuf.Service,
		    Method    = $protobuf.Method;

		// --- Root ---

		/**
		 * Properties of a FileDescriptorSet message.
		 * @interface IFileDescriptorSet
		 * @property {IFileDescriptorProto[]} file Files
		 */

		/**
		 * Properties of a FileDescriptorProto message.
		 * @interface IFileDescriptorProto
		 * @property {string} [name] File name
		 * @property {string} [package] Package
		 * @property {*} [dependency] Not supported
		 * @property {*} [publicDependency] Not supported
		 * @property {*} [weakDependency] Not supported
		 * @property {IDescriptorProto[]} [messageType] Nested message types
		 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
		 * @property {IServiceDescriptorProto[]} [service] Nested services
		 * @property {IFieldDescriptorProto[]} [extension] Nested extension fields
		 * @property {IFileOptions} [options] Options
		 * @property {*} [sourceCodeInfo] Not supported
		 * @property {string} [syntax="proto2"] Syntax
		 */

		/**
		 * Properties of a FileOptions message.
		 * @interface IFileOptions
		 * @property {string} [javaPackage]
		 * @property {string} [javaOuterClassname]
		 * @property {boolean} [javaMultipleFiles]
		 * @property {boolean} [javaGenerateEqualsAndHash]
		 * @property {boolean} [javaStringCheckUtf8]
		 * @property {IFileOptionsOptimizeMode} [optimizeFor=1]
		 * @property {string} [goPackage]
		 * @property {boolean} [ccGenericServices]
		 * @property {boolean} [javaGenericServices]
		 * @property {boolean} [pyGenericServices]
		 * @property {boolean} [deprecated]
		 * @property {boolean} [ccEnableArenas]
		 * @property {string} [objcClassPrefix]
		 * @property {string} [csharpNamespace]
		 */

		/**
		 * Values of he FileOptions.OptimizeMode enum.
		 * @typedef IFileOptionsOptimizeMode
		 * @type {number}
		 * @property {number} SPEED=1
		 * @property {number} CODE_SIZE=2
		 * @property {number} LITE_RUNTIME=3
		 */

		/**
		 * Creates a root from a descriptor set.
		 * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Root} Root instance
		 */
		Root.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.FileDescriptorSet.decode(descriptor);

		    var root = new Root();

		    if (descriptor.file) {
		        var fileDescriptor,
		            filePackage;
		        for (var j = 0, i; j < descriptor.file.length; ++j) {
		            filePackage = root;
		            if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
		                filePackage = root.define(fileDescriptor["package"]);
		            if (fileDescriptor.name && fileDescriptor.name.length)
		                root.files.push(filePackage.filename = fileDescriptor.name);
		            if (fileDescriptor.messageType)
		                for (i = 0; i < fileDescriptor.messageType.length; ++i)
		                    filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
		            if (fileDescriptor.enumType)
		                for (i = 0; i < fileDescriptor.enumType.length; ++i)
		                    filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
		            if (fileDescriptor.extension)
		                for (i = 0; i < fileDescriptor.extension.length; ++i)
		                    filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
		            if (fileDescriptor.service)
		                for (i = 0; i < fileDescriptor.service.length; ++i)
		                    filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
		            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);
		            if (opts) {
		                var ks = Object.keys(opts);
		                for (i = 0; i < ks.length; ++i)
		                    filePackage.setOption(ks[i], opts[ks[i]]);
		            }
		        }
		    }

		    return root;
		};

		/**
		 * Converts a root to a descriptor set.
		 * @returns {Message<IFileDescriptorSet>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Root.prototype.toDescriptor = function toDescriptor(syntax) {
		    var set = exports.FileDescriptorSet.create();
		    Root_toDescriptorRecursive(this, set.file, syntax);
		    return set;
		};

		// Traverses a namespace and assembles the descriptor set
		function Root_toDescriptorRecursive(ns, files, syntax) {

		    // Create a new file
		    var file = exports.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
		    if (syntax)
		        file.syntax = syntax;
		    if (!(ns instanceof Root))
		        file["package"] = ns.fullName.substring(1);

		    // Add nested types
		    for (var i = 0, nested; i < ns.nestedArray.length; ++i)
		        if ((nested = ns._nestedArray[i]) instanceof Type)
		            file.messageType.push(nested.toDescriptor(syntax));
		        else if (nested instanceof Enum)
		            file.enumType.push(nested.toDescriptor());
		        else if (nested instanceof Field)
		            file.extension.push(nested.toDescriptor(syntax));
		        else if (nested instanceof Service)
		            file.service.push(nested.toDescriptor());
		        else if (nested instanceof /* plain */ Namespace)
		            Root_toDescriptorRecursive(nested, files, syntax); // requires new file

		    // Keep package-level options
		    file.options = toDescriptorOptions(ns.options, exports.FileOptions);

		    // And keep the file only if there is at least one nested object
		    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
		        files.push(file);
		}

		// --- Type ---

		/**
		 * Properties of a DescriptorProto message.
		 * @interface IDescriptorProto
		 * @property {string} [name] Message type name
		 * @property {IFieldDescriptorProto[]} [field] Fields
		 * @property {IFieldDescriptorProto[]} [extension] Extension fields
		 * @property {IDescriptorProto[]} [nestedType] Nested message types
		 * @property {IEnumDescriptorProto[]} [enumType] Nested enums
		 * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges
		 * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs
		 * @property {IMessageOptions} [options] Not supported
		 * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges
		 * @property {string[]} [reservedName] Reserved names
		 */

		/**
		 * Properties of a MessageOptions message.
		 * @interface IMessageOptions
		 * @property {boolean} [mapEntry=false] Whether this message is a map entry
		 */

		/**
		 * Properties of an ExtensionRange message.
		 * @interface IDescriptorProtoExtensionRange
		 * @property {number} [start] Start field id
		 * @property {number} [end] End field id
		 */

		/**
		 * Properties of a ReservedRange message.
		 * @interface IDescriptorProtoReservedRange
		 * @property {number} [start] Start field id
		 * @property {number} [end] End field id
		 */

		var unnamedMessageIndex = 0;

		/**
		 * Creates a type from a descriptor.
		 * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 * @returns {Type} Type instance
		 */
		Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.DescriptorProto.decode(descriptor);

		    // Create the message type
		    var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),
		        i;

		    /* Oneofs */ if (descriptor.oneofDecl)
		        for (i = 0; i < descriptor.oneofDecl.length; ++i)
		            type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
		    /* Fields */ if (descriptor.field)
		        for (i = 0; i < descriptor.field.length; ++i) {
		            var field = Field.fromDescriptor(descriptor.field[i], syntax);
		            type.add(field);
		            if (descriptor.field[i].hasOwnProperty("oneofIndex")) // eslint-disable-line no-prototype-builtins
		                type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
		        }
		    /* Extension fields */ if (descriptor.extension)
		        for (i = 0; i < descriptor.extension.length; ++i)
		            type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
		    /* Nested types */ if (descriptor.nestedType)
		        for (i = 0; i < descriptor.nestedType.length; ++i) {
		            type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
		            if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
		                type.setOption("map_entry", true);
		        }
		    /* Nested enums */ if (descriptor.enumType)
		        for (i = 0; i < descriptor.enumType.length; ++i)
		            type.add(Enum.fromDescriptor(descriptor.enumType[i]));
		    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {
		        type.extensions = [];
		        for (i = 0; i < descriptor.extensionRange.length; ++i)
		            type.extensions.push([ descriptor.extensionRange[i].start, descriptor.extensionRange[i].end ]);
		    }
		    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
		        type.reserved = [];
		        /* Ranges */ if (descriptor.reservedRange)
		            for (i = 0; i < descriptor.reservedRange.length; ++i)
		                type.reserved.push([ descriptor.reservedRange[i].start, descriptor.reservedRange[i].end ]);
		        /* Names */ if (descriptor.reservedName)
		            for (i = 0; i < descriptor.reservedName.length; ++i)
		                type.reserved.push(descriptor.reservedName[i]);
		    }

		    return type;
		};

		/**
		 * Converts a type to a descriptor.
		 * @returns {Message<IDescriptorProto>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Type.prototype.toDescriptor = function toDescriptor(syntax) {
		    var descriptor = exports.DescriptorProto.create({ name: this.name }),
		        i;

		    /* Fields */ for (i = 0; i < this.fieldsArray.length; ++i) {
		        var fieldDescriptor;
		        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
		        if (this._fieldsArray[i] instanceof MapField) { // map fields are repeated FieldNameEntry
		            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),
		                valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),
		                valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14
		                    ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type
		                    : undefined;
		            descriptor.nestedType.push(exports.DescriptorProto.create({
		                name: fieldDescriptor.typeName,
		                field: [
		                    exports.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }), // can't reference a type or enum
		                    exports.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
		                ],
		                options: exports.MessageOptions.create({ mapEntry: true })
		            }));
		        }
		    }
		    /* Oneofs */ for (i = 0; i < this.oneofsArray.length; ++i)
		        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
		    /* Nested... */ for (i = 0; i < this.nestedArray.length; ++i) {
		        /* Extension fields */ if (this._nestedArray[i] instanceof Field)
		            descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
		        /* Types */ else if (this._nestedArray[i] instanceof Type)
		            descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
		        /* Enums */ else if (this._nestedArray[i] instanceof Enum)
		            descriptor.enumType.push(this._nestedArray[i].toDescriptor());
		        // plain nested namespaces become packages instead in Root#toDescriptor
		    }
		    /* Extension ranges */ if (this.extensions)
		        for (i = 0; i < this.extensions.length; ++i)
		            descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
		    /* Reserved... */ if (this.reserved)
		        for (i = 0; i < this.reserved.length; ++i)
		            /* Names */ if (typeof this.reserved[i] === "string")
		                descriptor.reservedName.push(this.reserved[i]);
		            /* Ranges */ else
		                descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));

		    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);

		    return descriptor;
		};

		// --- Field ---

		/**
		 * Properties of a FieldDescriptorProto message.
		 * @interface IFieldDescriptorProto
		 * @property {string} [name] Field name
		 * @property {number} [number] Field id
		 * @property {IFieldDescriptorProtoLabel} [label] Field rule
		 * @property {IFieldDescriptorProtoType} [type] Field basic type
		 * @property {string} [typeName] Field type name
		 * @property {string} [extendee] Extended type name
		 * @property {string} [defaultValue] Literal default value
		 * @property {number} [oneofIndex] Oneof index if part of a oneof
		 * @property {*} [jsonName] Not supported
		 * @property {IFieldOptions} [options] Field options
		 */

		/**
		 * Values of the FieldDescriptorProto.Label enum.
		 * @typedef IFieldDescriptorProtoLabel
		 * @type {number}
		 * @property {number} LABEL_OPTIONAL=1
		 * @property {number} LABEL_REQUIRED=2
		 * @property {number} LABEL_REPEATED=3
		 */

		/**
		 * Values of the FieldDescriptorProto.Type enum.
		 * @typedef IFieldDescriptorProtoType
		 * @type {number}
		 * @property {number} TYPE_DOUBLE=1
		 * @property {number} TYPE_FLOAT=2
		 * @property {number} TYPE_INT64=3
		 * @property {number} TYPE_UINT64=4
		 * @property {number} TYPE_INT32=5
		 * @property {number} TYPE_FIXED64=6
		 * @property {number} TYPE_FIXED32=7
		 * @property {number} TYPE_BOOL=8
		 * @property {number} TYPE_STRING=9
		 * @property {number} TYPE_GROUP=10
		 * @property {number} TYPE_MESSAGE=11
		 * @property {number} TYPE_BYTES=12
		 * @property {number} TYPE_UINT32=13
		 * @property {number} TYPE_ENUM=14
		 * @property {number} TYPE_SFIXED32=15
		 * @property {number} TYPE_SFIXED64=16
		 * @property {number} TYPE_SINT32=17
		 * @property {number} TYPE_SINT64=18
		 */

		/**
		 * Properties of a FieldOptions message.
		 * @interface IFieldOptions
		 * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)
		 * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)
		 */

		/**
		 * Values of the FieldOptions.JSType enum.
		 * @typedef IFieldOptionsJSType
		 * @type {number}
		 * @property {number} JS_NORMAL=0
		 * @property {number} JS_STRING=1
		 * @property {number} JS_NUMBER=2
		 */

		// copied here from parse.js
		var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;

		/**
		 * Creates a field from a descriptor.
		 * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 * @returns {Field} Field instance
		 */
		Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.DescriptorProto.decode(descriptor);

		    if (typeof descriptor.number !== "number")
		        throw Error("missing field id");

		    // Rewire field type
		    var fieldType;
		    if (descriptor.typeName && descriptor.typeName.length)
		        fieldType = descriptor.typeName;
		    else
		        fieldType = fromDescriptorType(descriptor.type);

		    // Rewire field rule
		    var fieldRule;
		    switch (descriptor.label) {
		        // 0 is reserved for errors
		        case 1: fieldRule = undefined; break;
		        case 2: fieldRule = "required"; break;
		        case 3: fieldRule = "repeated"; break;
		        default: throw Error("illegal label: " + descriptor.label);
		    }

			var extendee = descriptor.extendee;
			if (descriptor.extendee !== undefined) {
				extendee = extendee.length ? extendee : undefined;
			}
		    var field = new Field(
		        descriptor.name.length ? descriptor.name : "field" + descriptor.number,
		        descriptor.number,
		        fieldType,
		        fieldRule,
		        extendee
		    );

		    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);

		    if (descriptor.defaultValue && descriptor.defaultValue.length) {
		        var defaultValue = descriptor.defaultValue;
		        switch (defaultValue) {
		            case "true": case "TRUE":
		                defaultValue = true;
		                break;
		            case "false": case "FALSE":
		                defaultValue = false;
		                break;
		            default:
		                var match = numberRe.exec(defaultValue);
		                if (match)
		                    defaultValue = parseInt(defaultValue); // eslint-disable-line radix
		                break;
		        }
		        field.setOption("default", defaultValue);
		    }

		    if (packableDescriptorType(descriptor.type)) {
		        if (syntax === "proto3") { // defaults to packed=true (internal preset is packed=true)
		            if (descriptor.options && !descriptor.options.packed)
		                field.setOption("packed", false);
		        } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false
		            field.setOption("packed", false);
		    }

		    return field;
		};

		/**
		 * Converts a field to a descriptor.
		 * @returns {Message<IFieldDescriptorProto>} Descriptor
		 * @param {string} [syntax="proto2"] Syntax
		 */
		Field.prototype.toDescriptor = function toDescriptor(syntax) {
		    var descriptor = exports.FieldDescriptorProto.create({ name: this.name, number: this.id });

		    if (this.map) {

		        descriptor.type = 11; // message
		        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)
		        descriptor.label = 3; // repeated

		    } else {

		        // Rewire field type
		        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
		            case 10: // group
		            case 11: // type
		            case 14: // enum
		                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
		                break;
		        }

		        // Rewire field rule
		        switch (this.rule) {
		            case "repeated": descriptor.label = 3; break;
		            case "required": descriptor.label = 2; break;
		            default: descriptor.label = 1; break;
		        }

		    }

		    // Handle extension field
		    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;

		    // Handle part of oneof
		    if (this.partOf)
		        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
		            throw Error("missing oneof");

		    if (this.options) {
		        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);
		        if (this.options["default"] != null)
		            descriptor.defaultValue = String(this.options["default"]);
		    }

		    if (syntax === "proto3") { // defaults to packed=true
		        if (!this.packed)
		            (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;
		    } else if (this.packed) // defaults to packed=false
		        (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;

		    return descriptor;
		};

		// --- Enum ---

		/**
		 * Properties of an EnumDescriptorProto message.
		 * @interface IEnumDescriptorProto
		 * @property {string} [name] Enum name
		 * @property {IEnumValueDescriptorProto[]} [value] Enum values
		 * @property {IEnumOptions} [options] Enum options
		 */

		/**
		 * Properties of an EnumValueDescriptorProto message.
		 * @interface IEnumValueDescriptorProto
		 * @property {string} [name] Name
		 * @property {number} [number] Value
		 * @property {*} [options] Not supported
		 */

		/**
		 * Properties of an EnumOptions message.
		 * @interface IEnumOptions
		 * @property {boolean} [allowAlias] Whether aliases are allowed
		 * @property {boolean} [deprecated]
		 */

		var unnamedEnumIndex = 0;

		/**
		 * Creates an enum from a descriptor.
		 * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Enum} Enum instance
		 */
		Enum.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.EnumDescriptorProto.decode(descriptor);

		    // Construct values object
		    var values = {};
		    if (descriptor.value)
		        for (var i = 0; i < descriptor.value.length; ++i) {
		            var name  = descriptor.value[i].name,
		                value = descriptor.value[i].number || 0;
		            values[name && name.length ? name : "NAME" + value] = value;
		        }

		    return new Enum(
		        descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++,
		        values,
		        fromDescriptorOptions(descriptor.options, exports.EnumOptions)
		    );
		};

		/**
		 * Converts an enum to a descriptor.
		 * @returns {Message<IEnumDescriptorProto>} Descriptor
		 */
		Enum.prototype.toDescriptor = function toDescriptor() {

		    // Values
		    var values = [];
		    for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
		        values.push(exports.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));

		    return exports.EnumDescriptorProto.create({
		        name: this.name,
		        value: values,
		        options: toDescriptorOptions(this.options, exports.EnumOptions)
		    });
		};

		// --- OneOf ---

		/**
		 * Properties of a OneofDescriptorProto message.
		 * @interface IOneofDescriptorProto
		 * @property {string} [name] Oneof name
		 * @property {*} [options] Not supported
		 */

		var unnamedOneofIndex = 0;

		/**
		 * Creates a oneof from a descriptor.
		 * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {OneOf} OneOf instance
		 */
		OneOf.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.OneofDescriptorProto.decode(descriptor);

		    return new OneOf(
		        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here
		        descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++
		        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option
		    );
		};

		/**
		 * Converts a oneof to a descriptor.
		 * @returns {Message<IOneofDescriptorProto>} Descriptor
		 */
		OneOf.prototype.toDescriptor = function toDescriptor() {
		    return exports.OneofDescriptorProto.create({
		        name: this.name
		        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option
		    });
		};

		// --- Service ---

		/**
		 * Properties of a ServiceDescriptorProto message.
		 * @interface IServiceDescriptorProto
		 * @property {string} [name] Service name
		 * @property {IMethodDescriptorProto[]} [method] Methods
		 * @property {IServiceOptions} [options] Options
		 */

		/**
		 * Properties of a ServiceOptions message.
		 * @interface IServiceOptions
		 * @property {boolean} [deprecated]
		 */

		var unnamedServiceIndex = 0;

		/**
		 * Creates a service from a descriptor.
		 * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Service} Service instance
		 */
		Service.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.ServiceDescriptorProto.decode(descriptor);

		    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));
		    if (descriptor.method)
		        for (var i = 0; i < descriptor.method.length; ++i)
		            service.add(Method.fromDescriptor(descriptor.method[i]));

		    return service;
		};

		/**
		 * Converts a service to a descriptor.
		 * @returns {Message<IServiceDescriptorProto>} Descriptor
		 */
		Service.prototype.toDescriptor = function toDescriptor() {

		    // Methods
		    var methods = [];
		    for (var i = 0; i < this.methodsArray.length; ++i)
		        methods.push(this._methodsArray[i].toDescriptor());

		    return exports.ServiceDescriptorProto.create({
		        name: this.name,
		        method: methods,
		        options: toDescriptorOptions(this.options, exports.ServiceOptions)
		    });
		};

		// --- Method ---

		/**
		 * Properties of a MethodDescriptorProto message.
		 * @interface IMethodDescriptorProto
		 * @property {string} [name] Method name
		 * @property {string} [inputType] Request type name
		 * @property {string} [outputType] Response type name
		 * @property {IMethodOptions} [options] Not supported
		 * @property {boolean} [clientStreaming=false] Whether requests are streamed
		 * @property {boolean} [serverStreaming=false] Whether responses are streamed
		 */

		/**
		 * Properties of a MethodOptions message.
		 * @interface IMethodOptions
		 * @property {boolean} [deprecated]
		 */

		var unnamedMethodIndex = 0;

		/**
		 * Creates a method from a descriptor.
		 * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor
		 * @returns {Method} Reflected method instance
		 */
		Method.fromDescriptor = function fromDescriptor(descriptor) {

		    // Decode the descriptor message if specified as a buffer:
		    if (typeof descriptor.length === "number")
		        descriptor = exports.MethodDescriptorProto.decode(descriptor);

		    return new Method(
		        // unnamedMethodIndex is global, not per service, because we have no ref to a service here
		        descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++,
		        "rpc",
		        descriptor.inputType,
		        descriptor.outputType,
		        Boolean(descriptor.clientStreaming),
		        Boolean(descriptor.serverStreaming),
		        fromDescriptorOptions(descriptor.options, exports.MethodOptions)
		    );
		};

		/**
		 * Converts a method to a descriptor.
		 * @returns {Message<IMethodDescriptorProto>} Descriptor
		 */
		Method.prototype.toDescriptor = function toDescriptor() {
		    return exports.MethodDescriptorProto.create({
		        name: this.name,
		        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
		        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
		        clientStreaming: this.requestStream,
		        serverStreaming: this.responseStream,
		        options: toDescriptorOptions(this.options, exports.MethodOptions)
		    });
		};

		// --- utility ---

		// Converts a descriptor type to a protobuf.js basic type
		function fromDescriptorType(type) {
		    switch (type) {
		        // 0 is reserved for errors
		        case 1: return "double";
		        case 2: return "float";
		        case 3: return "int64";
		        case 4: return "uint64";
		        case 5: return "int32";
		        case 6: return "fixed64";
		        case 7: return "fixed32";
		        case 8: return "bool";
		        case 9: return "string";
		        case 12: return "bytes";
		        case 13: return "uint32";
		        case 15: return "sfixed32";
		        case 16: return "sfixed64";
		        case 17: return "sint32";
		        case 18: return "sint64";
		    }
		    throw Error("illegal type: " + type);
		}

		// Tests if a descriptor type is packable
		function packableDescriptorType(type) {
		    switch (type) {
		        case 1: // double
		        case 2: // float
		        case 3: // int64
		        case 4: // uint64
		        case 5: // int32
		        case 6: // fixed64
		        case 7: // fixed32
		        case 8: // bool
		        case 13: // uint32
		        case 14: // enum (!)
		        case 15: // sfixed32
		        case 16: // sfixed64
		        case 17: // sint32
		        case 18: // sint64
		            return true;
		    }
		    return false;
		}

		// Converts a protobuf.js basic type to a descriptor type
		function toDescriptorType(type, resolvedType) {
		    switch (type) {
		        // 0 is reserved for errors
		        case "double": return 1;
		        case "float": return 2;
		        case "int64": return 3;
		        case "uint64": return 4;
		        case "int32": return 5;
		        case "fixed64": return 6;
		        case "fixed32": return 7;
		        case "bool": return 8;
		        case "string": return 9;
		        case "bytes": return 12;
		        case "uint32": return 13;
		        case "sfixed32": return 15;
		        case "sfixed64": return 16;
		        case "sint32": return 17;
		        case "sint64": return 18;
		    }
		    if (resolvedType instanceof Enum)
		        return 14;
		    if (resolvedType instanceof Type)
		        return resolvedType.group ? 10 : 11;
		    throw Error("illegal type: " + type);
		}

		// Converts descriptor options to an options object
		function fromDescriptorOptions(options, type) {
		    if (!options)
		        return undefined;
		    var out = [];
		    for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
		        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption")
		            if (options.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins
		                val = options[key];
		                if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== undefined)
		                    val = field.resolvedType.valuesById[val];
		                out.push(underScore(key), val);
		            }
		    return out.length ? $protobuf.util.toObject(out) : undefined;
		}

		// Converts an options object to descriptor options
		function toDescriptorOptions(options, type) {
		    if (!options)
		        return undefined;
		    var out = [];
		    for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
		        val = options[key = ks[i]];
		        if (key === "default")
		            continue;
		        var field = type.fields[key];
		        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
		            continue;
		        out.push(key, val);
		    }
		    return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;
		}

		// Calculates the shortest relative path from `from` to `to`.
		function shortname(from, to) {
		    var fromPath = from.fullName.split("."),
		        toPath = to.fullName.split("."),
		        i = 0,
		        j = 0,
		        k = toPath.length - 1;
		    if (!(from instanceof Root) && to instanceof Namespace)
		        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
		            var other = to.lookup(fromPath[i++], true);
		            if (other !== null && other !== to)
		                break;
		            ++j;
		        }
		    else
		        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);
		    return toPath.slice(j).join(".");
		}

		// copied here from cli/targets/proto.js
		function underScore(str) {
		    return str.substring(0,1)
		         + str.substring(1)
		               .replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) { return "_" + $1.toLowerCase(); });
		}

		// --- exports ---

		/**
		 * Reflected file descriptor set.
		 * @name FileDescriptorSet
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected file descriptor proto.
		 * @name FileDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected descriptor proto.
		 * @name DescriptorProto
		 * @type {Type}
		 * @property {Type} ExtensionRange
		 * @property {Type} ReservedRange
		 * @const
		 * @tstype $protobuf.Type & {
		 *     ExtensionRange: $protobuf.Type,
		 *     ReservedRange: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected field descriptor proto.
		 * @name FieldDescriptorProto
		 * @type {Type}
		 * @property {Enum} Label
		 * @property {Enum} Type
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Label: $protobuf.Enum,
		 *     Type: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected oneof descriptor proto.
		 * @name OneofDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum descriptor proto.
		 * @name EnumDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected service descriptor proto.
		 * @name ServiceDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum value descriptor proto.
		 * @name EnumValueDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected method descriptor proto.
		 * @name MethodDescriptorProto
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected file options.
		 * @name FileOptions
		 * @type {Type}
		 * @property {Enum} OptimizeMode
		 * @const
		 * @tstype $protobuf.Type & {
		 *     OptimizeMode: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected message options.
		 * @name MessageOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected field options.
		 * @name FieldOptions
		 * @type {Type}
		 * @property {Enum} CType
		 * @property {Enum} JSType
		 * @const
		 * @tstype $protobuf.Type & {
		 *     CType: $protobuf.Enum,
		 *     JSType: $protobuf.Enum
		 * }
		 */

		/**
		 * Reflected oneof options.
		 * @name OneofOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum options.
		 * @name EnumOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected enum value options.
		 * @name EnumValueOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected service options.
		 * @name ServiceOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected method options.
		 * @name MethodOptions
		 * @type {Type}
		 * @const
		 * @tstype $protobuf.Type
		 */

		/**
		 * Reflected uninterpretet option.
		 * @name UninterpretedOption
		 * @type {Type}
		 * @property {Type} NamePart
		 * @const
		 * @tstype $protobuf.Type & {
		 *     NamePart: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected source code info.
		 * @name SourceCodeInfo
		 * @type {Type}
		 * @property {Type} Location
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Location: $protobuf.Type
		 * }
		 */

		/**
		 * Reflected generated code info.
		 * @name GeneratedCodeInfo
		 * @type {Type}
		 * @property {Type} Annotation
		 * @const
		 * @tstype $protobuf.Type & {
		 *     Annotation: $protobuf.Type
		 * }
		 */ 
	} (descriptor, descriptor.exports));
	return descriptor.exports;
}

var util = {};

var nested$2 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					Api: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							methods: {
								rule: "repeated",
								type: "Method",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							},
							version: {
								type: "string",
								id: 4
							},
							sourceContext: {
								type: "SourceContext",
								id: 5
							},
							mixins: {
								rule: "repeated",
								type: "Mixin",
								id: 6
							},
							syntax: {
								type: "Syntax",
								id: 7
							}
						}
					},
					Method: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							requestTypeUrl: {
								type: "string",
								id: 2
							},
							requestStreaming: {
								type: "bool",
								id: 3
							},
							responseTypeUrl: {
								type: "string",
								id: 4
							},
							responseStreaming: {
								type: "bool",
								id: 5
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 6
							},
							syntax: {
								type: "Syntax",
								id: 7
							}
						}
					},
					Mixin: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							root: {
								type: "string",
								id: 2
							}
						}
					},
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					},
					Option: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								type: "Any",
								id: 2
							}
						}
					},
					Syntax: {
						values: {
							SYNTAX_PROTO2: 0,
							SYNTAX_PROTO3: 1
						}
					}
				}
			}
		}
	}
};
var require$$3 = {
	nested: nested$2
};

var nested$1 = {
	google: {
		nested: {
			protobuf: {
				nested: {
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					}
				}
			}
		}
	}
};
var require$$5 = {
	nested: nested$1
};

var nested = {
	google: {
		nested: {
			protobuf: {
				nested: {
					Type: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							fields: {
								rule: "repeated",
								type: "Field",
								id: 2
							},
							oneofs: {
								rule: "repeated",
								type: "string",
								id: 3
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 4
							},
							sourceContext: {
								type: "SourceContext",
								id: 5
							},
							syntax: {
								type: "Syntax",
								id: 6
							}
						}
					},
					Field: {
						fields: {
							kind: {
								type: "Kind",
								id: 1
							},
							cardinality: {
								type: "Cardinality",
								id: 2
							},
							number: {
								type: "int32",
								id: 3
							},
							name: {
								type: "string",
								id: 4
							},
							typeUrl: {
								type: "string",
								id: 6
							},
							oneofIndex: {
								type: "int32",
								id: 7
							},
							packed: {
								type: "bool",
								id: 8
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 9
							},
							jsonName: {
								type: "string",
								id: 10
							},
							defaultValue: {
								type: "string",
								id: 11
							}
						},
						nested: {
							Kind: {
								values: {
									TYPE_UNKNOWN: 0,
									TYPE_DOUBLE: 1,
									TYPE_FLOAT: 2,
									TYPE_INT64: 3,
									TYPE_UINT64: 4,
									TYPE_INT32: 5,
									TYPE_FIXED64: 6,
									TYPE_FIXED32: 7,
									TYPE_BOOL: 8,
									TYPE_STRING: 9,
									TYPE_GROUP: 10,
									TYPE_MESSAGE: 11,
									TYPE_BYTES: 12,
									TYPE_UINT32: 13,
									TYPE_ENUM: 14,
									TYPE_SFIXED32: 15,
									TYPE_SFIXED64: 16,
									TYPE_SINT32: 17,
									TYPE_SINT64: 18
								}
							},
							Cardinality: {
								values: {
									CARDINALITY_UNKNOWN: 0,
									CARDINALITY_OPTIONAL: 1,
									CARDINALITY_REQUIRED: 2,
									CARDINALITY_REPEATED: 3
								}
							}
						}
					},
					Enum: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							enumvalue: {
								rule: "repeated",
								type: "EnumValue",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							},
							sourceContext: {
								type: "SourceContext",
								id: 4
							},
							syntax: {
								type: "Syntax",
								id: 5
							}
						}
					},
					EnumValue: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							number: {
								type: "int32",
								id: 2
							},
							options: {
								rule: "repeated",
								type: "Option",
								id: 3
							}
						}
					},
					Option: {
						fields: {
							name: {
								type: "string",
								id: 1
							},
							value: {
								type: "Any",
								id: 2
							}
						}
					},
					Syntax: {
						values: {
							SYNTAX_PROTO2: 0,
							SYNTAX_PROTO3: 1
						}
					},
					Any: {
						fields: {
							type_url: {
								type: "string",
								id: 1
							},
							value: {
								type: "bytes",
								id: 2
							}
						}
					},
					SourceContext: {
						fields: {
							fileName: {
								type: "string",
								id: 1
							}
						}
					}
				}
			}
		}
	}
};
var require$$6 = {
	nested: nested
};

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	/**
	 * @license
	 * Copyright 2018 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(util, "__esModule", { value: true });
	util.addCommonProtos = util.loadProtosWithOptionsSync = util.loadProtosWithOptions = undefined;
	const fs = require$$0$5;
	const path = require$$1$6;
	const Protobuf = requireProtobufjs();
	function addIncludePathResolver(root, includePaths) {
	    const originalResolvePath = root.resolvePath;
	    root.resolvePath = (origin, target) => {
	        if (path.isAbsolute(target)) {
	            return target;
	        }
	        for (const directory of includePaths) {
	            const fullPath = path.join(directory, target);
	            try {
	                fs.accessSync(fullPath, fs.constants.R_OK);
	                return fullPath;
	            }
	            catch (err) {
	                continue;
	            }
	        }
	        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
	        return originalResolvePath(origin, target);
	    };
	}
	async function loadProtosWithOptions(filename, options) {
	    const root = new Protobuf.Root();
	    options = options || {};
	    if (!!options.includeDirs) {
	        if (!Array.isArray(options.includeDirs)) {
	            return Promise.reject(new Error('The includeDirs option must be an array'));
	        }
	        addIncludePathResolver(root, options.includeDirs);
	    }
	    const loadedRoot = await root.load(filename, options);
	    loadedRoot.resolveAll();
	    return loadedRoot;
	}
	util.loadProtosWithOptions = loadProtosWithOptions;
	function loadProtosWithOptionsSync(filename, options) {
	    const root = new Protobuf.Root();
	    options = options || {};
	    if (!!options.includeDirs) {
	        if (!Array.isArray(options.includeDirs)) {
	            throw new Error('The includeDirs option must be an array');
	        }
	        addIncludePathResolver(root, options.includeDirs);
	    }
	    const loadedRoot = root.loadSync(filename, options);
	    loadedRoot.resolveAll();
	    return loadedRoot;
	}
	util.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
	/**
	 * Load Google's well-known proto files that aren't exposed by Protobuf.js.
	 */
	function addCommonProtos() {
	    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,
	    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.
	    // Using constant strings for compatibility with tools like Webpack
	    const apiDescriptor = require$$3;
	    const descriptorDescriptor = require$$4;
	    const sourceContextDescriptor = require$$5;
	    const typeDescriptor = require$$6;
	    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);
	    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);
	}
	util.addCommonProtos = addCommonProtos;
	
	return util;
}

var umd = {exports: {}};

var hasRequiredUmd;

function requireUmd () {
	if (hasRequiredUmd) return umd.exports;
	hasRequiredUmd = 1;
	(function (module, exports) {
		// GENERATED FILE. DO NOT EDIT.
		var Long = (function(exports) {
		  
		  Object.defineProperty(exports, "__esModule", {
		    value: true
		  });
		  exports.default = undefined;
		  
		  /**
		   * @license
		   * Copyright 2009 The Closure Library Authors
		   * Copyright 2020 Daniel Wirtz / The long.js Authors.
		   *
		   * Licensed under the Apache License, Version 2.0 (the "License");
		   * you may not use this file except in compliance with the License.
		   * You may obtain a copy of the License at
		   *
		   *     http://www.apache.org/licenses/LICENSE-2.0
		   *
		   * Unless required by applicable law or agreed to in writing, software
		   * distributed under the License is distributed on an "AS IS" BASIS,
		   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		   * See the License for the specific language governing permissions and
		   * limitations under the License.
		   *
		   * SPDX-License-Identifier: Apache-2.0
		   */
		  // WebAssembly optimizations to do native i64 multiplication and divide
		  var wasm = null;
		  
		  try {
		    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
		  } catch (e) {// no wasm support :(
		  }
		  /**
		   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
		   *  See the from* functions below for more convenient ways of constructing Longs.
		   * @exports Long
		   * @class A Long class for representing a 64 bit two's-complement integer value.
		   * @param {number} low The low (signed) 32 bits of the long
		   * @param {number} high The high (signed) 32 bits of the long
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @constructor
		   */
		  
		  
		  function Long(low, high, unsigned) {
		    /**
		     * The low 32 bits as a signed value.
		     * @type {number}
		     */
		    this.low = low | 0;
		    /**
		     * The high 32 bits as a signed value.
		     * @type {number}
		     */
		  
		    this.high = high | 0;
		    /**
		     * Whether unsigned or not.
		     * @type {boolean}
		     */
		  
		    this.unsigned = !!unsigned;
		  } // The internal representation of a long is the two given signed, 32-bit values.
		  // We use 32-bit pieces because these are the size of integers on which
		  // Javascript performs bit-operations.  For operations like addition and
		  // multiplication, we split each number into 16 bit pieces, which can easily be
		  // multiplied within Javascript's floating-point representation without overflow
		  // or change in sign.
		  //
		  // In the algorithms below, we frequently reduce the negative case to the
		  // positive case by negating the input(s) and then post-processing the result.
		  // Note that we must ALWAYS check specially whether those values are MIN_VALUE
		  // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
		  // a positive number, it overflows back into a negative).  Not handling this
		  // case would often result in infinite recursion.
		  //
		  // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
		  // methods on which they depend.
		  
		  /**
		   * An indicator used to reliably determine if an object is a Long or not.
		   * @type {boolean}
		   * @const
		   * @private
		   */
		  
		  
		  Long.prototype.__isLong__;
		  Object.defineProperty(Long.prototype, "__isLong__", {
		    value: true
		  });
		  /**
		   * @function
		   * @param {*} obj Object
		   * @returns {boolean}
		   * @inner
		   */
		  
		  function isLong(obj) {
		    return (obj && obj["__isLong__"]) === true;
		  }
		  /**
		   * @function
		   * @param {*} value number
		   * @returns {number}
		   * @inner
		   */
		  
		  
		  function ctz32(value) {
		    var c = Math.clz32(value & -value);
		    return value ? 31 - c : c;
		  }
		  /**
		   * Tests if the specified object is a Long.
		   * @function
		   * @param {*} obj Object
		   * @returns {boolean}
		   */
		  
		  
		  Long.isLong = isLong;
		  /**
		   * A cache of the Long representations of small integer values.
		   * @type {!Object}
		   * @inner
		   */
		  
		  var INT_CACHE = {};
		  /**
		   * A cache of the Long representations of small unsigned integer values.
		   * @type {!Object}
		   * @inner
		   */
		  
		  var UINT_CACHE = {};
		  /**
		   * @param {number} value
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromInt(value, unsigned) {
		    var obj, cachedObj, cache;
		  
		    if (unsigned) {
		      value >>>= 0;
		  
		      if (cache = 0 <= value && value < 256) {
		        cachedObj = UINT_CACHE[value];
		        if (cachedObj) return cachedObj;
		      }
		  
		      obj = fromBits(value, 0, true);
		      if (cache) UINT_CACHE[value] = obj;
		      return obj;
		    } else {
		      value |= 0;
		  
		      if (cache = -128 <= value && value < 128) {
		        cachedObj = INT_CACHE[value];
		        if (cachedObj) return cachedObj;
		      }
		  
		      obj = fromBits(value, value < 0 ? -1 : 0, false);
		      if (cache) INT_CACHE[value] = obj;
		      return obj;
		    }
		  }
		  /**
		   * Returns a Long representing the given 32 bit integer value.
		   * @function
		   * @param {number} value The 32 bit integer in question
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromInt = fromInt;
		  /**
		   * @param {number} value
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromNumber(value, unsigned) {
		    if (isNaN(value)) return unsigned ? UZERO : ZERO;
		  
		    if (unsigned) {
		      if (value < 0) return UZERO;
		      if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
		    } else {
		      if (value <= -9223372036854776e3) return MIN_VALUE;
		      if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
		    }
		  
		    if (value < 0) return fromNumber(-value, unsigned).neg();
		    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
		  }
		  /**
		   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
		   * @function
		   * @param {number} value The number in question
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromNumber = fromNumber;
		  /**
		   * @param {number} lowBits
		   * @param {number} highBits
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromBits(lowBits, highBits, unsigned) {
		    return new Long(lowBits, highBits, unsigned);
		  }
		  /**
		   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
		   *  assumed to use 32 bits.
		   * @function
		   * @param {number} lowBits The low 32 bits
		   * @param {number} highBits The high 32 bits
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBits = fromBits;
		  /**
		   * @function
		   * @param {number} base
		   * @param {number} exponent
		   * @returns {number}
		   * @inner
		   */
		  
		  var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)
		  
		  /**
		   * @param {string} str
		   * @param {(boolean|number)=} unsigned
		   * @param {number=} radix
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromString(str, unsigned, radix) {
		    if (str.length === 0) throw Error('empty string');
		  
		    if (typeof unsigned === 'number') {
		      // For goog.math.long compatibility
		      radix = unsigned;
		      unsigned = false;
		    } else {
		      unsigned = !!unsigned;
		    }
		  
		    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
		    radix = radix || 10;
		    if (radix < 2 || 36 < radix) throw RangeError('radix');
		    var p;
		    if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
		      return fromString(str.substring(1), unsigned, radix).neg();
		    } // Do several (8) digits each time through the loop, so as to
		    // minimize the calls to the very expensive emulated div.
		  
		    var radixToPower = fromNumber(pow_dbl(radix, 8));
		    var result = ZERO;
		  
		    for (var i = 0; i < str.length; i += 8) {
		      var size = Math.min(8, str.length - i),
		          value = parseInt(str.substring(i, i + size), radix);
		  
		      if (size < 8) {
		        var power = fromNumber(pow_dbl(radix, size));
		        result = result.mul(power).add(fromNumber(value));
		      } else {
		        result = result.mul(radixToPower);
		        result = result.add(fromNumber(value));
		      }
		    }
		  
		    result.unsigned = unsigned;
		    return result;
		  }
		  /**
		   * Returns a Long representation of the given string, written using the specified radix.
		   * @function
		   * @param {string} str The textual representation of the Long
		   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
		   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
		   * @returns {!Long} The corresponding Long value
		   */
		  
		  
		  Long.fromString = fromString;
		  /**
		   * @function
		   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
		   * @param {boolean=} unsigned
		   * @returns {!Long}
		   * @inner
		   */
		  
		  function fromValue(val, unsigned) {
		    if (typeof val === 'number') return fromNumber(val, unsigned);
		    if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:
		  
		    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
		  }
		  /**
		   * Converts the specified value to a Long using the appropriate from* function for its type.
		   * @function
		   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {!Long}
		   */
		  
		  
		  Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
		  // no runtime penalty for these.
		  
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_16_DBL = 1 << 16;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_24_DBL = 1 << 24;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
		  /**
		   * @type {number}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
		  /**
		   * @type {!Long}
		   * @const
		   * @inner
		   */
		  
		  var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var ZERO = fromInt(0);
		  /**
		   * Signed zero.
		   * @type {!Long}
		   */
		  
		  Long.ZERO = ZERO;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var UZERO = fromInt(0, true);
		  /**
		   * Unsigned zero.
		   * @type {!Long}
		   */
		  
		  Long.UZERO = UZERO;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var ONE = fromInt(1);
		  /**
		   * Signed one.
		   * @type {!Long}
		   */
		  
		  Long.ONE = ONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var UONE = fromInt(1, true);
		  /**
		   * Unsigned one.
		   * @type {!Long}
		   */
		  
		  Long.UONE = UONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var NEG_ONE = fromInt(-1);
		  /**
		   * Signed negative one.
		   * @type {!Long}
		   */
		  
		  Long.NEG_ONE = NEG_ONE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
		  /**
		   * Maximum signed value.
		   * @type {!Long}
		   */
		  
		  Long.MAX_VALUE = MAX_VALUE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
		  /**
		   * Maximum unsigned value.
		   * @type {!Long}
		   */
		  
		  Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
		  /**
		   * @type {!Long}
		   * @inner
		   */
		  
		  var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
		  /**
		   * Minimum signed value.
		   * @type {!Long}
		   */
		  
		  Long.MIN_VALUE = MIN_VALUE;
		  /**
		   * @alias Long.prototype
		   * @inner
		   */
		  
		  var LongPrototype = Long.prototype;
		  /**
		   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  LongPrototype.toInt = function toInt() {
		    return this.unsigned ? this.low >>> 0 : this.low;
		  };
		  /**
		   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  
		  LongPrototype.toNumber = function toNumber() {
		    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
		    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
		  };
		  /**
		   * Converts the Long to a string written in the specified radix.
		   * @this {!Long}
		   * @param {number=} radix Radix (2-36), defaults to 10
		   * @returns {string}
		   * @override
		   * @throws {RangeError} If `radix` is out of range
		   */
		  
		  
		  LongPrototype.toString = function toString(radix) {
		    radix = radix || 10;
		    if (radix < 2 || 36 < radix) throw RangeError('radix');
		    if (this.isZero()) return '0';
		  
		    if (this.isNegative()) {
		      // Unsigned Longs are never negative
		      if (this.eq(MIN_VALUE)) {
		        // We need to change the Long value before it can be negated, so we remove
		        // the bottom-most digit in this base and then recurse to do the rest.
		        var radixLong = fromNumber(radix),
		            div = this.div(radixLong),
		            rem1 = div.mul(radixLong).sub(this);
		        return div.toString(radix) + rem1.toInt().toString(radix);
		      } else return '-' + this.neg().toString(radix);
		    } // Do several (6) digits each time through the loop, so as to
		    // minimize the calls to the very expensive emulated div.
		  
		  
		    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
		        rem = this;
		    var result = '';
		  
		    while (true) {
		      var remDiv = rem.div(radixToPower),
		          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
		          digits = intval.toString(radix);
		      rem = remDiv;
		      if (rem.isZero()) return digits + result;else {
		        while (digits.length < 6) digits = '0' + digits;
		  
		        result = '' + digits + result;
		      }
		    }
		  };
		  /**
		   * Gets the high 32 bits as a signed integer.
		   * @this {!Long}
		   * @returns {number} Signed high bits
		   */
		  
		  
		  LongPrototype.getHighBits = function getHighBits() {
		    return this.high;
		  };
		  /**
		   * Gets the high 32 bits as an unsigned integer.
		   * @this {!Long}
		   * @returns {number} Unsigned high bits
		   */
		  
		  
		  LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
		    return this.high >>> 0;
		  };
		  /**
		   * Gets the low 32 bits as a signed integer.
		   * @this {!Long}
		   * @returns {number} Signed low bits
		   */
		  
		  
		  LongPrototype.getLowBits = function getLowBits() {
		    return this.low;
		  };
		  /**
		   * Gets the low 32 bits as an unsigned integer.
		   * @this {!Long}
		   * @returns {number} Unsigned low bits
		   */
		  
		  
		  LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
		    return this.low >>> 0;
		  };
		  /**
		   * Gets the number of bits needed to represent the absolute value of this Long.
		   * @this {!Long}
		   * @returns {number}
		   */
		  
		  
		  LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
		    if (this.isNegative()) // Unsigned Longs are never negative
		      return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
		    var val = this.high != 0 ? this.high : this.low;
		  
		    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
		  
		    return this.high != 0 ? bit + 33 : bit + 1;
		  };
		  /**
		   * Tests if this Long's value equals zero.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isZero = function isZero() {
		    return this.high === 0 && this.low === 0;
		  };
		  /**
		   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.eqz = LongPrototype.isZero;
		  /**
		   * Tests if this Long's value is negative.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  LongPrototype.isNegative = function isNegative() {
		    return !this.unsigned && this.high < 0;
		  };
		  /**
		   * Tests if this Long's value is positive or zero.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isPositive = function isPositive() {
		    return this.unsigned || this.high >= 0;
		  };
		  /**
		   * Tests if this Long's value is odd.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isOdd = function isOdd() {
		    return (this.low & 1) === 1;
		  };
		  /**
		   * Tests if this Long's value is even.
		   * @this {!Long}
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.isEven = function isEven() {
		    return (this.low & 1) === 0;
		  };
		  /**
		   * Tests if this Long's value equals the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.equals = function equals(other) {
		    if (!isLong(other)) other = fromValue(other);
		    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
		    return this.high === other.high && this.low === other.low;
		  };
		  /**
		   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.eq = LongPrototype.equals;
		  /**
		   * Tests if this Long's value differs from the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.notEquals = function notEquals(other) {
		    return !this.eq(
		    /* validates */
		    other);
		  };
		  /**
		   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.neq = LongPrototype.notEquals;
		  /**
		   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.ne = LongPrototype.notEquals;
		  /**
		   * Tests if this Long's value is less than the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.lessThan = function lessThan(other) {
		    return this.comp(
		    /* validates */
		    other) < 0;
		  };
		  /**
		   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.lt = LongPrototype.lessThan;
		  /**
		   * Tests if this Long's value is less than or equal the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
		    return this.comp(
		    /* validates */
		    other) <= 0;
		  };
		  /**
		   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.lte = LongPrototype.lessThanOrEqual;
		  /**
		   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.le = LongPrototype.lessThanOrEqual;
		  /**
		   * Tests if this Long's value is greater than the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.greaterThan = function greaterThan(other) {
		    return this.comp(
		    /* validates */
		    other) > 0;
		  };
		  /**
		   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.gt = LongPrototype.greaterThan;
		  /**
		   * Tests if this Long's value is greater than or equal the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
		    return this.comp(
		    /* validates */
		    other) >= 0;
		  };
		  /**
		   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  
		  LongPrototype.gte = LongPrototype.greaterThanOrEqual;
		  /**
		   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {boolean}
		   */
		  
		  LongPrototype.ge = LongPrototype.greaterThanOrEqual;
		  /**
		   * Compares this Long's value with the specified's.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other value
		   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
		   *  if the given one is greater
		   */
		  
		  LongPrototype.compare = function compare(other) {
		    if (!isLong(other)) other = fromValue(other);
		    if (this.eq(other)) return 0;
		    var thisNeg = this.isNegative(),
		        otherNeg = other.isNegative();
		    if (thisNeg && !otherNeg) return -1;
		    if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same
		  
		    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned
		  
		    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
		  };
		  /**
		   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
		   * @function
		   * @param {!Long|number|string} other Other value
		   * @returns {number} 0 if they are the same, 1 if the this is greater and -1
		   *  if the given one is greater
		   */
		  
		  
		  LongPrototype.comp = LongPrototype.compare;
		  /**
		   * Negates this Long's value.
		   * @this {!Long}
		   * @returns {!Long} Negated Long
		   */
		  
		  LongPrototype.negate = function negate() {
		    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
		    return this.not().add(ONE);
		  };
		  /**
		   * Negates this Long's value. This is an alias of {@link Long#negate}.
		   * @function
		   * @returns {!Long} Negated Long
		   */
		  
		  
		  LongPrototype.neg = LongPrototype.negate;
		  /**
		   * Returns the sum of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} addend Addend
		   * @returns {!Long} Sum
		   */
		  
		  LongPrototype.add = function add(addend) {
		    if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.
		  
		    var a48 = this.high >>> 16;
		    var a32 = this.high & 0xFFFF;
		    var a16 = this.low >>> 16;
		    var a00 = this.low & 0xFFFF;
		    var b48 = addend.high >>> 16;
		    var b32 = addend.high & 0xFFFF;
		    var b16 = addend.low >>> 16;
		    var b00 = addend.low & 0xFFFF;
		    var c48 = 0,
		        c32 = 0,
		        c16 = 0,
		        c00 = 0;
		    c00 += a00 + b00;
		    c16 += c00 >>> 16;
		    c00 &= 0xFFFF;
		    c16 += a16 + b16;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c32 += a32 + b32;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c48 += a48 + b48;
		    c48 &= 0xFFFF;
		    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		  };
		  /**
		   * Returns the difference of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} subtrahend Subtrahend
		   * @returns {!Long} Difference
		   */
		  
		  
		  LongPrototype.subtract = function subtract(subtrahend) {
		    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
		    return this.add(subtrahend.neg());
		  };
		  /**
		   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
		   * @function
		   * @param {!Long|number|string} subtrahend Subtrahend
		   * @returns {!Long} Difference
		   */
		  
		  
		  LongPrototype.sub = LongPrototype.subtract;
		  /**
		   * Returns the product of this and the specified Long.
		   * @this {!Long}
		   * @param {!Long|number|string} multiplier Multiplier
		   * @returns {!Long} Product
		   */
		  
		  LongPrototype.multiply = function multiply(multiplier) {
		    if (this.isZero()) return this;
		    if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present
		  
		    if (wasm) {
		      var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
		    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
		    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
		  
		    if (this.isNegative()) {
		      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
		    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication
		  
		  
		    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
		    // We can skip products that would overflow.
		  
		    var a48 = this.high >>> 16;
		    var a32 = this.high & 0xFFFF;
		    var a16 = this.low >>> 16;
		    var a00 = this.low & 0xFFFF;
		    var b48 = multiplier.high >>> 16;
		    var b32 = multiplier.high & 0xFFFF;
		    var b16 = multiplier.low >>> 16;
		    var b00 = multiplier.low & 0xFFFF;
		    var c48 = 0,
		        c32 = 0,
		        c16 = 0,
		        c00 = 0;
		    c00 += a00 * b00;
		    c16 += c00 >>> 16;
		    c00 &= 0xFFFF;
		    c16 += a16 * b00;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c16 += a00 * b16;
		    c32 += c16 >>> 16;
		    c16 &= 0xFFFF;
		    c32 += a32 * b00;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c32 += a16 * b16;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c32 += a00 * b32;
		    c48 += c32 >>> 16;
		    c32 &= 0xFFFF;
		    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
		    c48 &= 0xFFFF;
		    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
		  };
		  /**
		   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
		   * @function
		   * @param {!Long|number|string} multiplier Multiplier
		   * @returns {!Long} Product
		   */
		  
		  
		  LongPrototype.mul = LongPrototype.multiply;
		  /**
		   * Returns this Long divided by the specified. The result is signed if this Long is signed or
		   *  unsigned if this Long is unsigned.
		   * @this {!Long}
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Quotient
		   */
		  
		  LongPrototype.divide = function divide(divisor) {
		    if (!isLong(divisor)) divisor = fromValue(divisor);
		    if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present
		  
		    if (wasm) {
		      // guard against signed division overflow: the largest
		      // negative number / -1 would be 1 larger than the largest
		      // positive number, due to two's complement.
		      if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
		        // be consistent with non-wasm code path
		        return this;
		      }
		  
		      var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
		    var approx, rem, res;
		  
		    if (!this.unsigned) {
		      // This section is only relevant for signed longs and is derived from the
		      // closure library as a whole.
		      if (this.eq(MIN_VALUE)) {
		        if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
		        else if (divisor.eq(MIN_VALUE)) return ONE;else {
		          // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
		          var halfThis = this.shr(1);
		          approx = halfThis.div(divisor).shl(1);
		  
		          if (approx.eq(ZERO)) {
		            return divisor.isNegative() ? ONE : NEG_ONE;
		          } else {
		            rem = this.sub(divisor.mul(approx));
		            res = approx.add(rem.div(divisor));
		            return res;
		          }
		        }
		      } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
		  
		      if (this.isNegative()) {
		        if (divisor.isNegative()) return this.neg().div(divisor.neg());
		        return this.neg().div(divisor).neg();
		      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
		  
		      res = ZERO;
		    } else {
		      // The algorithm below has not been made for unsigned longs. It's therefore
		      // required to take special care of the MSB prior to running it.
		      if (!divisor.unsigned) divisor = divisor.toUnsigned();
		      if (divisor.gt(this)) return UZERO;
		      if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
		        return UONE;
		      res = UZERO;
		    } // Repeat the following until the remainder is less than other:  find a
		    // floating-point that approximates remainder / other *from below*, add this
		    // into the result, and subtract it from the remainder.  It is critical that
		    // the approximate value is less than or equal to the real value so that the
		    // remainder never becomes negative.
		  
		  
		    rem = this;
		  
		    while (rem.gte(divisor)) {
		      // Approximate the result of division. This may be a little greater or
		      // smaller than the actual value.
		      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
		      // the smallest non-fractional digit, whichever is larger.
		  
		      var log2 = Math.ceil(Math.log(approx) / Math.LN2),
		          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
		          // Decrease the approximation until it is smaller than the remainder.  Note
		      // that if it is too large, the product overflows and is negative.
		      approxRes = fromNumber(approx),
		          approxRem = approxRes.mul(divisor);
		  
		      while (approxRem.isNegative() || approxRem.gt(rem)) {
		        approx -= delta;
		        approxRes = fromNumber(approx, this.unsigned);
		        approxRem = approxRes.mul(divisor);
		      } // We know the answer can't be zero... and actually, zero would cause
		      // infinite recursion since we would make no progress.
		  
		  
		      if (approxRes.isZero()) approxRes = ONE;
		      res = res.add(approxRes);
		      rem = rem.sub(approxRem);
		    }
		  
		    return res;
		  };
		  /**
		   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Quotient
		   */
		  
		  
		  LongPrototype.div = LongPrototype.divide;
		  /**
		   * Returns this Long modulo the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  LongPrototype.modulo = function modulo(divisor) {
		    if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present
		  
		    if (wasm) {
		      var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
		      return fromBits(low, wasm["get_high"](), this.unsigned);
		    }
		  
		    return this.sub(this.div(divisor).mul(divisor));
		  };
		  /**
		   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  
		  LongPrototype.mod = LongPrototype.modulo;
		  /**
		   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
		   * @function
		   * @param {!Long|number|string} divisor Divisor
		   * @returns {!Long} Remainder
		   */
		  
		  LongPrototype.rem = LongPrototype.modulo;
		  /**
		   * Returns the bitwise NOT of this Long.
		   * @this {!Long}
		   * @returns {!Long}
		   */
		  
		  LongPrototype.not = function not() {
		    return fromBits(~this.low, ~this.high, this.unsigned);
		  };
		  /**
		   * Returns count leading zeros of this Long.
		   * @this {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.countLeadingZeros = function countLeadingZeros() {
		    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
		  };
		  /**
		   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
		   * @function
		   * @param {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.clz = LongPrototype.countLeadingZeros;
		  /**
		   * Returns count trailing zeros of this Long.
		   * @this {!Long}
		   * @returns {!number}
		   */
		  
		  LongPrototype.countTrailingZeros = function countTrailingZeros() {
		    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
		  };
		  /**
		   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
		   * @function
		   * @param {!Long}
		   * @returns {!number}
		   */
		  
		  
		  LongPrototype.ctz = LongPrototype.countTrailingZeros;
		  /**
		   * Returns the bitwise AND of this Long and the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  LongPrototype.and = function and(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
		  };
		  /**
		   * Returns the bitwise OR of this Long and the specified.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  
		  LongPrototype.or = function or(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
		  };
		  /**
		   * Returns the bitwise XOR of this Long and the given one.
		   * @this {!Long}
		   * @param {!Long|number|string} other Other Long
		   * @returns {!Long}
		   */
		  
		  
		  LongPrototype.xor = function xor(other) {
		    if (!isLong(other)) other = fromValue(other);
		    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits shifted to the left by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shiftLeft = function shiftLeft(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shl = LongPrototype.shiftLeft;
		  /**
		   * Returns this Long with bits arithmetically shifted to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shiftRight = function shiftRight(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shr = LongPrototype.shiftRight;
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
		    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
		    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  
		  LongPrototype.shru = LongPrototype.shiftRightUnsigned;
		  /**
		   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Shifted Long
		   */
		  
		  LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
		  /**
		   * Returns this Long with bits rotated to the left by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  LongPrototype.rotateLeft = function rotateLeft(numBits) {
		    var b;
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
		  
		    if (numBits < 32) {
		      b = 32 - numBits;
		      return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
		    }
		  
		    numBits -= 32;
		    b = 32 - numBits;
		    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  
		  LongPrototype.rotl = LongPrototype.rotateLeft;
		  /**
		   * Returns this Long with bits rotated to the right by the given amount.
		   * @this {!Long}
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  LongPrototype.rotateRight = function rotateRight(numBits) {
		    var b;
		    if (isLong(numBits)) numBits = numBits.toInt();
		    if ((numBits &= 63) === 0) return this;
		    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
		  
		    if (numBits < 32) {
		      b = 32 - numBits;
		      return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
		    }
		  
		    numBits -= 32;
		    b = 32 - numBits;
		    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
		  };
		  /**
		   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
		   * @function
		   * @param {number|!Long} numBits Number of bits
		   * @returns {!Long} Rotated Long
		   */
		  
		  
		  LongPrototype.rotr = LongPrototype.rotateRight;
		  /**
		   * Converts this Long to signed.
		   * @this {!Long}
		   * @returns {!Long} Signed long
		   */
		  
		  LongPrototype.toSigned = function toSigned() {
		    if (!this.unsigned) return this;
		    return fromBits(this.low, this.high, false);
		  };
		  /**
		   * Converts this Long to unsigned.
		   * @this {!Long}
		   * @returns {!Long} Unsigned long
		   */
		  
		  
		  LongPrototype.toUnsigned = function toUnsigned() {
		    if (this.unsigned) return this;
		    return fromBits(this.low, this.high, true);
		  };
		  /**
		   * Converts this Long to its byte representation.
		   * @param {boolean=} le Whether little or big endian, defaults to big endian
		   * @this {!Long}
		   * @returns {!Array.<number>} Byte representation
		   */
		  
		  
		  LongPrototype.toBytes = function toBytes(le) {
		    return le ? this.toBytesLE() : this.toBytesBE();
		  };
		  /**
		   * Converts this Long to its little endian byte representation.
		   * @this {!Long}
		   * @returns {!Array.<number>} Little endian byte representation
		   */
		  
		  
		  LongPrototype.toBytesLE = function toBytesLE() {
		    var hi = this.high,
		        lo = this.low;
		    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
		  };
		  /**
		   * Converts this Long to its big endian byte representation.
		   * @this {!Long}
		   * @returns {!Array.<number>} Big endian byte representation
		   */
		  
		  
		  LongPrototype.toBytesBE = function toBytesBE() {
		    var hi = this.high,
		        lo = this.low;
		    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
		  };
		  /**
		   * Creates a Long from its byte representation.
		   * @param {!Array.<number>} bytes Byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @param {boolean=} le Whether little or big endian, defaults to big endian
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytes = function fromBytes(bytes, unsigned, le) {
		    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
		  };
		  /**
		   * Creates a Long from its little endian byte representation.
		   * @param {!Array.<number>} bytes Little endian byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
		    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
		  };
		  /**
		   * Creates a Long from its big endian byte representation.
		   * @param {!Array.<number>} bytes Big endian byte representation
		   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
		   * @returns {Long} The corresponding Long value
		   */
		  
		  
		  Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
		    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
		  };
		  
		  var _default = Long;
		  exports.default = _default;
		  return "default" in exports ? exports.default : exports;
		})({});
		module.exports = Long; 
	} (umd));
	return umd.exports;
}

var hasRequiredSrc$4;

function requireSrc$4 () {
	if (hasRequiredSrc$4) return src$4;
	hasRequiredSrc$4 = 1;
	(function (exports) {
		/**
		 * @license
		 * Copyright 2018 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = undefined;
		const camelCase = requireLodash_camelcase();
		const Protobuf = requireProtobufjs();
		const descriptor = requireDescriptor();
		const util_1 = requireUtil();
		const Long = requireUmd();
		exports.Long = Long;
		function isAnyExtension(obj) {
		    return ('@type' in obj) && (typeof obj['@type'] === 'string');
		}
		exports.isAnyExtension = isAnyExtension;
		var IdempotencyLevel;
		(function (IdempotencyLevel) {
		    IdempotencyLevel["IDEMPOTENCY_UNKNOWN"] = "IDEMPOTENCY_UNKNOWN";
		    IdempotencyLevel["NO_SIDE_EFFECTS"] = "NO_SIDE_EFFECTS";
		    IdempotencyLevel["IDEMPOTENT"] = "IDEMPOTENT";
		})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));
		const descriptorOptions = {
		    longs: String,
		    enums: String,
		    bytes: String,
		    defaults: true,
		    oneofs: true,
		    json: true,
		};
		function joinName(baseName, name) {
		    if (baseName === '') {
		        return name;
		    }
		    else {
		        return baseName + '.' + name;
		    }
		}
		function isHandledReflectionObject(obj) {
		    return (obj instanceof Protobuf.Service ||
		        obj instanceof Protobuf.Type ||
		        obj instanceof Protobuf.Enum);
		}
		function isNamespaceBase(obj) {
		    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
		}
		function getAllHandledReflectionObjects(obj, parentName) {
		    const objName = joinName(parentName, obj.name);
		    if (isHandledReflectionObject(obj)) {
		        return [[objName, obj]];
		    }
		    else {
		        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {
		            return Object.keys(obj.nested)
		                .map(name => {
		                return getAllHandledReflectionObjects(obj.nested[name], objName);
		            })
		                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
		        }
		    }
		    return [];
		}
		function createDeserializer(cls, options) {
		    return function deserialize(argBuf) {
		        return cls.toObject(cls.decode(argBuf), options);
		    };
		}
		function createSerializer(cls) {
		    return function serialize(arg) {
		        if (Array.isArray(arg)) {
		            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
		        }
		        const message = cls.fromObject(arg);
		        return cls.encode(message).finish();
		    };
		}
		function mapMethodOptions(options) {
		    return (options || []).reduce((obj, item) => {
		        for (const [key, value] of Object.entries(item)) {
		            switch (key) {
		                case 'uninterpreted_option':
		                    obj.uninterpreted_option.push(item.uninterpreted_option);
		                    break;
		                default:
		                    obj[key] = value;
		            }
		        }
		        return obj;
		    }, {
		        deprecated: false,
		        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
		        uninterpreted_option: [],
		    });
		}
		function createMethodDefinition(method, serviceName, options, fileDescriptors) {
		    /* This is only ever called after the corresponding root.resolveAll(), so we
		     * can assume that the resolved request and response types are non-null */
		    const requestType = method.resolvedRequestType;
		    const responseType = method.resolvedResponseType;
		    return {
		        path: '/' + serviceName + '/' + method.name,
		        requestStream: !!method.requestStream,
		        responseStream: !!method.responseStream,
		        requestSerialize: createSerializer(requestType),
		        requestDeserialize: createDeserializer(requestType, options),
		        responseSerialize: createSerializer(responseType),
		        responseDeserialize: createDeserializer(responseType, options),
		        // TODO(murgatroid99): Find a better way to handle this
		        originalName: camelCase(method.name),
		        requestType: createMessageDefinition(requestType, fileDescriptors),
		        responseType: createMessageDefinition(responseType, fileDescriptors),
		        options: mapMethodOptions(method.parsedOptions),
		    };
		}
		function createServiceDefinition(service, name, options, fileDescriptors) {
		    const def = {};
		    for (const method of service.methodsArray) {
		        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
		    }
		    return def;
		}
		function createMessageDefinition(message, fileDescriptors) {
		    const messageDescriptor = message.toDescriptor('proto3');
		    return {
		        format: 'Protocol Buffer 3 DescriptorProto',
		        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
		        fileDescriptorProtos: fileDescriptors,
		    };
		}
		function createEnumDefinition(enumType, fileDescriptors) {
		    const enumDescriptor = enumType.toDescriptor('proto3');
		    return {
		        format: 'Protocol Buffer 3 EnumDescriptorProto',
		        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
		        fileDescriptorProtos: fileDescriptors,
		    };
		}
		/**
		 * function createDefinition(obj: Protobuf.Service, name: string, options:
		 * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,
		 * name: string, options: Options): MessageTypeDefinition; function
		 * createDefinition(obj: Protobuf.Enum, name: string, options: Options):
		 * EnumTypeDefinition;
		 */
		function createDefinition(obj, name, options, fileDescriptors) {
		    if (obj instanceof Protobuf.Service) {
		        return createServiceDefinition(obj, name, options, fileDescriptors);
		    }
		    else if (obj instanceof Protobuf.Type) {
		        return createMessageDefinition(obj, fileDescriptors);
		    }
		    else if (obj instanceof Protobuf.Enum) {
		        return createEnumDefinition(obj, fileDescriptors);
		    }
		    else {
		        throw new Error('Type mismatch in reflection object handling');
		    }
		}
		function createPackageDefinition(root, options) {
		    const def = {};
		    root.resolveAll();
		    const descriptorList = root.toDescriptor('proto3').file;
		    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
		    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {
		        def[name] = createDefinition(obj, name, options, bufferList);
		    }
		    return def;
		}
		function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
		    options = options || {};
		    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
		    root.resolveAll();
		    return createPackageDefinition(root, options);
		}
		/**
		 * Load a .proto file with the specified options.
		 * @param filename One or multiple file paths to load. Can be an absolute path
		 *     or relative to an include path.
		 * @param options.keepCase Preserve field names. The default is to change them
		 *     to camel case.
		 * @param options.longs The type that should be used to represent `long` values.
		 *     Valid options are `Number` and `String`. Defaults to a `Long` object type
		 *     from a library.
		 * @param options.enums The type that should be used to represent `enum` values.
		 *     The only valid option is `String`. Defaults to the numeric value.
		 * @param options.bytes The type that should be used to represent `bytes`
		 *     values. Valid options are `Array` and `String`. The default is to use
		 *     `Buffer`.
		 * @param options.defaults Set default values on output objects. Defaults to
		 *     `false`.
		 * @param options.arrays Set empty arrays for missing array values even if
		 *     `defaults` is `false`. Defaults to `false`.
		 * @param options.objects Set empty objects for missing object values even if
		 *     `defaults` is `false`. Defaults to `false`.
		 * @param options.oneofs Set virtual oneof properties to the present field's
		 *     name
		 * @param options.json Represent Infinity and NaN as strings in float fields,
		 *     and automatically decode google.protobuf.Any values.
		 * @param options.includeDirs Paths to search for imported `.proto` files.
		 */
		function load(filename, options) {
		    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {
		        return createPackageDefinition(loadedRoot, options);
		    });
		}
		exports.load = load;
		function loadSync(filename, options) {
		    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
		    return createPackageDefinition(loadedRoot, options);
		}
		exports.loadSync = loadSync;
		function fromJSON(json, options) {
		    options = options || {};
		    const loadedRoot = Protobuf.Root.fromJSON(json);
		    loadedRoot.resolveAll();
		    return createPackageDefinition(loadedRoot, options);
		}
		exports.fromJSON = fromJSON;
		function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
		    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
		    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
		}
		exports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
		function loadFileDescriptorSetFromObject(descriptorSet, options) {
		    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
		    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
		}
		exports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
		(0, util_1.addCommonProtos)();
		
	} (src$4));
	return src$4;
}

var hasRequiredChannelz;

function requireChannelz () {
	if (hasRequiredChannelz) return channelz;
	hasRequiredChannelz = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channelz, "__esModule", { value: true });
	channelz.setup = channelz.getChannelzServiceDefinition = channelz.getChannelzHandlers = channelz.unregisterChannelzRef = channelz.registerChannelzSocket = channelz.registerChannelzServer = channelz.registerChannelzSubchannel = channelz.registerChannelzChannel = channelz.ChannelzCallTrackerStub = channelz.ChannelzCallTracker = channelz.ChannelzChildrenTrackerStub = channelz.ChannelzChildrenTracker = channelz.ChannelzTrace = channelz.ChannelzTraceStub = undefined;
	const net_1 = require$$0$a;
	const ordered_map_1 = require$$1$1;
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const subchannel_address_1 = requireSubchannelAddress();
	const admin_1 = requireAdmin();
	const make_client_1 = requireMakeClient();
	function channelRefToMessage(ref) {
	    return {
	        channel_id: ref.id,
	        name: ref.name,
	    };
	}
	function subchannelRefToMessage(ref) {
	    return {
	        subchannel_id: ref.id,
	        name: ref.name,
	    };
	}
	function serverRefToMessage(ref) {
	    return {
	        server_id: ref.id,
	    };
	}
	function socketRefToMessage(ref) {
	    return {
	        socket_id: ref.id,
	        name: ref.name,
	    };
	}
	/**
	 * The loose upper bound on the number of events that should be retained in a
	 * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a
	 * number that should be large enough to contain the recent relevant
	 * information, but small enough to not use excessive memory.
	 */
	const TARGET_RETAINED_TRACES = 32;
	/**
	 * Default number of sockets/servers/channels/subchannels to return
	 */
	const DEFAULT_MAX_RESULTS = 100;
	class ChannelzTraceStub {
	    constructor() {
	        this.events = [];
	        this.creationTimestamp = new Date();
	        this.eventsLogged = 0;
	    }
	    addTrace() { }
	    getTraceMessage() {
	        return {
	            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
	            num_events_logged: this.eventsLogged,
	            events: [],
	        };
	    }
	}
	channelz.ChannelzTraceStub = ChannelzTraceStub;
	class ChannelzTrace {
	    constructor() {
	        this.events = [];
	        this.eventsLogged = 0;
	        this.creationTimestamp = new Date();
	    }
	    addTrace(severity, description, child) {
	        const timestamp = new Date();
	        this.events.push({
	            description: description,
	            severity: severity,
	            timestamp: timestamp,
	            childChannel: (child === null || child === undefined ? undefined : child.kind) === 'channel' ? child : undefined,
	            childSubchannel: (child === null || child === undefined ? undefined : child.kind) === 'subchannel' ? child : undefined,
	        });
	        // Whenever the trace array gets too large, discard the first half
	        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
	            this.events = this.events.slice(TARGET_RETAINED_TRACES);
	        }
	        this.eventsLogged += 1;
	    }
	    getTraceMessage() {
	        return {
	            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
	            num_events_logged: this.eventsLogged,
	            events: this.events.map(event => {
	                return {
	                    description: event.description,
	                    severity: event.severity,
	                    timestamp: dateToProtoTimestamp(event.timestamp),
	                    channel_ref: event.childChannel
	                        ? channelRefToMessage(event.childChannel)
	                        : null,
	                    subchannel_ref: event.childSubchannel
	                        ? subchannelRefToMessage(event.childSubchannel)
	                        : null,
	                };
	            }),
	        };
	    }
	}
	channelz.ChannelzTrace = ChannelzTrace;
	class ChannelzChildrenTracker {
	    constructor() {
	        this.channelChildren = new ordered_map_1.OrderedMap();
	        this.subchannelChildren = new ordered_map_1.OrderedMap();
	        this.socketChildren = new ordered_map_1.OrderedMap();
	        this.trackerMap = {
	            ["channel" /* EntityTypes.channel */]: this.channelChildren,
	            ["subchannel" /* EntityTypes.subchannel */]: this.subchannelChildren,
	            ["socket" /* EntityTypes.socket */]: this.socketChildren,
	        };
	    }
	    refChild(child) {
	        const tracker = this.trackerMap[child.kind];
	        const trackedChild = tracker.find(child.id);
	        if (trackedChild.equals(tracker.end())) {
	            tracker.setElement(child.id, {
	                ref: child,
	                count: 1,
	            }, trackedChild);
	        }
	        else {
	            trackedChild.pointer[1].count += 1;
	        }
	    }
	    unrefChild(child) {
	        const tracker = this.trackerMap[child.kind];
	        const trackedChild = tracker.getElementByKey(child.id);
	        if (trackedChild !== undefined) {
	            trackedChild.count -= 1;
	            if (trackedChild.count === 0) {
	                tracker.eraseElementByKey(child.id);
	            }
	        }
	    }
	    getChildLists() {
	        return {
	            channels: this.channelChildren,
	            subchannels: this.subchannelChildren,
	            sockets: this.socketChildren,
	        };
	    }
	}
	channelz.ChannelzChildrenTracker = ChannelzChildrenTracker;
	class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
	    refChild() { }
	    unrefChild() { }
	}
	channelz.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;
	class ChannelzCallTracker {
	    constructor() {
	        this.callsStarted = 0;
	        this.callsSucceeded = 0;
	        this.callsFailed = 0;
	        this.lastCallStartedTimestamp = null;
	    }
	    addCallStarted() {
	        this.callsStarted += 1;
	        this.lastCallStartedTimestamp = new Date();
	    }
	    addCallSucceeded() {
	        this.callsSucceeded += 1;
	    }
	    addCallFailed() {
	        this.callsFailed += 1;
	    }
	}
	channelz.ChannelzCallTracker = ChannelzCallTracker;
	class ChannelzCallTrackerStub extends ChannelzCallTracker {
	    addCallStarted() { }
	    addCallSucceeded() { }
	    addCallFailed() { }
	}
	channelz.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
	const entityMaps = {
	    ["channel" /* EntityTypes.channel */]: new ordered_map_1.OrderedMap(),
	    ["subchannel" /* EntityTypes.subchannel */]: new ordered_map_1.OrderedMap(),
	    ["server" /* EntityTypes.server */]: new ordered_map_1.OrderedMap(),
	    ["socket" /* EntityTypes.socket */]: new ordered_map_1.OrderedMap(),
	};
	const generateRegisterFn = (kind) => {
	    let nextId = 1;
	    function getNextId() {
	        return nextId++;
	    }
	    const entityMap = entityMaps[kind];
	    return (name, getInfo, channelzEnabled) => {
	        const id = getNextId();
	        const ref = { id, name, kind };
	        if (channelzEnabled) {
	            entityMap.setElement(id, { ref, getInfo });
	        }
	        return ref;
	    };
	};
	channelz.registerChannelzChannel = generateRegisterFn("channel" /* EntityTypes.channel */);
	channelz.registerChannelzSubchannel = generateRegisterFn("subchannel" /* EntityTypes.subchannel */);
	channelz.registerChannelzServer = generateRegisterFn("server" /* EntityTypes.server */);
	channelz.registerChannelzSocket = generateRegisterFn("socket" /* EntityTypes.socket */);
	function unregisterChannelzRef(ref) {
	    entityMaps[ref.kind].eraseElementByKey(ref.id);
	}
	channelz.unregisterChannelzRef = unregisterChannelzRef;
	/**
	 * Parse a single section of an IPv6 address as two bytes
	 * @param addressSection A hexadecimal string of length up to 4
	 * @returns The pair of bytes representing this address section
	 */
	function parseIPv6Section(addressSection) {
	    const numberValue = Number.parseInt(addressSection, 16);
	    return [(numberValue / 256) | 0, numberValue % 256];
	}
	/**
	 * Parse a chunk of an IPv6 address string to some number of bytes
	 * @param addressChunk Some number of segments of up to 4 hexadecimal
	 *   characters each, joined by colons.
	 * @returns The list of bytes representing this address chunk
	 */
	function parseIPv6Chunk(addressChunk) {
	    if (addressChunk === '') {
	        return [];
	    }
	    const bytePairs = addressChunk
	        .split(':')
	        .map(section => parseIPv6Section(section));
	    const result = [];
	    return result.concat(...bytePairs);
	}
	/**
	 * Converts an IPv4 or IPv6 address from string representation to binary
	 * representation
	 * @param ipAddress an IP address in standard IPv4 or IPv6 text format
	 * @returns
	 */
	function ipAddressStringToBuffer(ipAddress) {
	    if ((0, net_1.isIPv4)(ipAddress)) {
	        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));
	    }
	    else if ((0, net_1.isIPv6)(ipAddress)) {
	        let leftSection;
	        let rightSection;
	        const doubleColonIndex = ipAddress.indexOf('::');
	        if (doubleColonIndex === -1) {
	            leftSection = ipAddress;
	            rightSection = '';
	        }
	        else {
	            leftSection = ipAddress.substring(0, doubleColonIndex);
	            rightSection = ipAddress.substring(doubleColonIndex + 2);
	        }
	        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
	        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
	        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
	        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
	    }
	    else {
	        return null;
	    }
	}
	function connectivityStateToMessage(state) {
	    switch (state) {
	        case connectivity_state_1.ConnectivityState.CONNECTING:
	            return {
	                state: 'CONNECTING',
	            };
	        case connectivity_state_1.ConnectivityState.IDLE:
	            return {
	                state: 'IDLE',
	            };
	        case connectivity_state_1.ConnectivityState.READY:
	            return {
	                state: 'READY',
	            };
	        case connectivity_state_1.ConnectivityState.SHUTDOWN:
	            return {
	                state: 'SHUTDOWN',
	            };
	        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
	            return {
	                state: 'TRANSIENT_FAILURE',
	            };
	        default:
	            return {
	                state: 'UNKNOWN',
	            };
	    }
	}
	function dateToProtoTimestamp(date) {
	    if (!date) {
	        return null;
	    }
	    const millisSinceEpoch = date.getTime();
	    return {
	        seconds: (millisSinceEpoch / 1000) | 0,
	        nanos: (millisSinceEpoch % 1000) * 1000000,
	    };
	}
	function getChannelMessage(channelEntry) {
	    const resolvedInfo = channelEntry.getInfo();
	    const channelRef = [];
	    const subchannelRef = [];
	    resolvedInfo.children.channels.forEach(el => {
	        channelRef.push(channelRefToMessage(el[1].ref));
	    });
	    resolvedInfo.children.subchannels.forEach(el => {
	        subchannelRef.push(subchannelRefToMessage(el[1].ref));
	    });
	    return {
	        ref: channelRefToMessage(channelEntry.ref),
	        data: {
	            target: resolvedInfo.target,
	            state: connectivityStateToMessage(resolvedInfo.state),
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        channel_ref: channelRef,
	        subchannel_ref: subchannelRef,
	    };
	}
	function GetChannel(call, callback) {
	    const channelId = parseInt(call.request.channel_id, 10);
	    const channelEntry = entityMaps["channel" /* EntityTypes.channel */].getElementByKey(channelId);
	    if (channelEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No channel data found for id ' + channelId,
	        });
	        return;
	    }
	    callback(null, { channel: getChannelMessage(channelEntry) });
	}
	function GetTopChannels(call, callback) {
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const resultList = [];
	    const startId = parseInt(call.request.start_channel_id, 10);
	    const channelEntries = entityMaps["channel" /* EntityTypes.channel */];
	    let i;
	    for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(getChannelMessage(i.pointer[1]));
	    }
	    callback(null, {
	        channel: resultList,
	        end: i.equals(channelEntries.end()),
	    });
	}
	function getServerMessage(serverEntry) {
	    const resolvedInfo = serverEntry.getInfo();
	    const listenSocket = [];
	    resolvedInfo.listenerChildren.sockets.forEach(el => {
	        listenSocket.push(socketRefToMessage(el[1].ref));
	    });
	    return {
	        ref: serverRefToMessage(serverEntry.ref),
	        data: {
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        listen_socket: listenSocket,
	    };
	}
	function GetServer(call, callback) {
	    const serverId = parseInt(call.request.server_id, 10);
	    const serverEntries = entityMaps["server" /* EntityTypes.server */];
	    const serverEntry = serverEntries.getElementByKey(serverId);
	    if (serverEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No server data found for id ' + serverId,
	        });
	        return;
	    }
	    callback(null, { server: getServerMessage(serverEntry) });
	}
	function GetServers(call, callback) {
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const startId = parseInt(call.request.start_server_id, 10);
	    const serverEntries = entityMaps["server" /* EntityTypes.server */];
	    const resultList = [];
	    let i;
	    for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(getServerMessage(i.pointer[1]));
	    }
	    callback(null, {
	        server: resultList,
	        end: i.equals(serverEntries.end()),
	    });
	}
	function GetSubchannel(call, callback) {
	    const subchannelId = parseInt(call.request.subchannel_id, 10);
	    const subchannelEntry = entityMaps["subchannel" /* EntityTypes.subchannel */].getElementByKey(subchannelId);
	    if (subchannelEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No subchannel data found for id ' + subchannelId,
	        });
	        return;
	    }
	    const resolvedInfo = subchannelEntry.getInfo();
	    const listenSocket = [];
	    resolvedInfo.children.sockets.forEach(el => {
	        listenSocket.push(socketRefToMessage(el[1].ref));
	    });
	    const subchannelMessage = {
	        ref: subchannelRefToMessage(subchannelEntry.ref),
	        data: {
	            target: resolvedInfo.target,
	            state: connectivityStateToMessage(resolvedInfo.state),
	            calls_started: resolvedInfo.callTracker.callsStarted,
	            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
	            calls_failed: resolvedInfo.callTracker.callsFailed,
	            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
	            trace: resolvedInfo.trace.getTraceMessage(),
	        },
	        socket_ref: listenSocket,
	    };
	    callback(null, { subchannel: subchannelMessage });
	}
	function subchannelAddressToAddressMessage(subchannelAddress) {
	    var _a;
	    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
	        return {
	            address: 'tcpip_address',
	            tcpip_address: {
	                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== undefined ? _a : undefined,
	                port: subchannelAddress.port,
	            },
	        };
	    }
	    else {
	        return {
	            address: 'uds_address',
	            uds_address: {
	                filename: subchannelAddress.path,
	            },
	        };
	    }
	}
	function GetSocket(call, callback) {
	    var _a, _b, _c, _d, _e;
	    const socketId = parseInt(call.request.socket_id, 10);
	    const socketEntry = entityMaps["socket" /* EntityTypes.socket */].getElementByKey(socketId);
	    if (socketEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No socket data found for id ' + socketId,
	        });
	        return;
	    }
	    const resolvedInfo = socketEntry.getInfo();
	    const securityMessage = resolvedInfo.security
	        ? {
	            model: 'tls',
	            tls: {
	                cipher_suite: resolvedInfo.security.cipherSuiteStandardName
	                    ? 'standard_name'
	                    : 'other_name',
	                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== undefined ? _a : undefined,
	                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== undefined ? _b : undefined,
	                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== undefined ? _c : undefined,
	                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== undefined ? _d : undefined,
	            },
	        }
	        : null;
	    const socketMessage = {
	        ref: socketRefToMessage(socketEntry.ref),
	        local: resolvedInfo.localAddress
	            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)
	            : null,
	        remote: resolvedInfo.remoteAddress
	            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)
	            : null,
	        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== undefined ? _e : undefined,
	        security: securityMessage,
	        data: {
	            keep_alives_sent: resolvedInfo.keepAlivesSent,
	            streams_started: resolvedInfo.streamsStarted,
	            streams_succeeded: resolvedInfo.streamsSucceeded,
	            streams_failed: resolvedInfo.streamsFailed,
	            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
	            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
	            messages_received: resolvedInfo.messagesReceived,
	            messages_sent: resolvedInfo.messagesSent,
	            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
	            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
	            local_flow_control_window: resolvedInfo.localFlowControlWindow
	                ? { value: resolvedInfo.localFlowControlWindow }
	                : null,
	            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow
	                ? { value: resolvedInfo.remoteFlowControlWindow }
	                : null,
	        },
	    };
	    callback(null, { socket: socketMessage });
	}
	function GetServerSockets(call, callback) {
	    const serverId = parseInt(call.request.server_id, 10);
	    const serverEntry = entityMaps["server" /* EntityTypes.server */].getElementByKey(serverId);
	    if (serverEntry === undefined) {
	        callback({
	            code: constants_1.Status.NOT_FOUND,
	            details: 'No server data found for id ' + serverId,
	        });
	        return;
	    }
	    const startId = parseInt(call.request.start_socket_id, 10);
	    const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
	    const resolvedInfo = serverEntry.getInfo();
	    // If we wanted to include listener sockets in the result, this line would
	    // instead say
	    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);
	    const allSockets = resolvedInfo.sessionChildren.sockets;
	    const resultList = [];
	    let i;
	    for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {
	        resultList.push(socketRefToMessage(i.pointer[1].ref));
	    }
	    callback(null, {
	        socket_ref: resultList,
	        end: i.equals(allSockets.end()),
	    });
	}
	function getChannelzHandlers() {
	    return {
	        GetChannel,
	        GetTopChannels,
	        GetServer,
	        GetServers,
	        GetSubchannel,
	        GetSocket,
	        GetServerSockets,
	    };
	}
	channelz.getChannelzHandlers = getChannelzHandlers;
	let loadedChannelzDefinition = null;
	function getChannelzServiceDefinition() {
	    if (loadedChannelzDefinition) {
	        return loadedChannelzDefinition;
	    }
	    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at
	     * runtime for users who will not use/enable channelz. */
	    const loaderLoadSync = requireSrc$4()
	        .loadSync;
	    const loadedProto = loaderLoadSync('channelz.proto', {
	        keepCase: true,
	        longs: String,
	        enums: String,
	        defaults: true,
	        oneofs: true,
	        includeDirs: [`${__dirname}/../../proto`],
	    });
	    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
	    loadedChannelzDefinition =
	        channelzGrpcObject.grpc.channelz.v1.Channelz.service;
	    return loadedChannelzDefinition;
	}
	channelz.getChannelzServiceDefinition = getChannelzServiceDefinition;
	function setup() {
	    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
	}
	channelz.setup = setup;
	
	return channelz;
}

var hasRequiredSubchannel;

function requireSubchannel () {
	if (hasRequiredSubchannel) return subchannel;
	hasRequiredSubchannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannel, "__esModule", { value: true });
	subchannel.Subchannel = undefined;
	const connectivity_state_1 = requireConnectivityState();
	const backoff_timeout_1 = requireBackoffTimeout();
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const uri_parser_1 = requireUriParser();
	const subchannel_address_1 = requireSubchannelAddress();
	const channelz_1 = requireChannelz();
	const TRACER_NAME = 'subchannel';
	/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't
	 * have a constant for the max signed 32 bit integer, so this is a simple way
	 * to calculate it */
	const KEEPALIVE_MAX_TIME_MS = 2147483647;
	class Subchannel {
	    /**
	     * A class representing a connection to a single backend.
	     * @param channelTarget The target string for the channel as a whole
	     * @param subchannelAddress The address for the backend that this subchannel
	     *     will connect to
	     * @param options The channel options, plus any specific subchannel options
	     *     for this subchannel
	     * @param credentials The channel credentials used to establish this
	     *     connection
	     */
	    constructor(channelTarget, subchannelAddress, options, credentials, connector) {
	        var _a;
	        this.channelTarget = channelTarget;
	        this.subchannelAddress = subchannelAddress;
	        this.options = options;
	        this.credentials = credentials;
	        this.connector = connector;
	        /**
	         * The subchannel's current connectivity state. Invariant: `session` === `null`
	         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.
	         */
	        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The underlying http2 session used to make requests.
	         */
	        this.transport = null;
	        /**
	         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to
	         * CONNECTING instead of IDLE when the backoff timeout ends.
	         */
	        this.continueConnecting = false;
	        /**
	         * A list of listener functions that will be called whenever the connectivity
	         * state changes. Will be modified by `addConnectivityStateListener` and
	         * `removeConnectivityStateListener`
	         */
	        this.stateListeners = new Set();
	        /**
	         * Tracks channels and subchannel pools with references to this subchannel
	         */
	        this.refcount = 0;
	        // Channelz info
	        this.channelzEnabled = true;
	        const backoffOptions = {
	            initialDelay: options['grpc.initial_reconnect_backoff_ms'],
	            maxDelay: options['grpc.max_reconnect_backoff_ms'],
	        };
	        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
	            this.handleBackoffTimer();
	        }, backoffOptions);
	        this.backoffTimeout.unref();
	        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
	        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== undefined ? _a : -1;
	        if (options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	            this.channelzTrace = new channelz_1.ChannelzTraceStub();
	            this.callTracker = new channelz_1.ChannelzCallTrackerStub();
	            this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
	        }
	        else {
	            this.channelzTrace = new channelz_1.ChannelzTrace();
	            this.callTracker = new channelz_1.ChannelzCallTracker();
	            this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
	            this.streamTracker = new channelz_1.ChannelzCallTracker();
	        }
	        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
	        this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');
	        this.trace('Subchannel constructed with options ' +
	            JSON.stringify(options, undefined, 2));
	        credentials._ref();
	    }
	    getChannelzInfo() {
	        return {
	            state: this.connectivityState,
	            trace: this.channelzTrace,
	            callTracker: this.callTracker,
	            children: this.childrenTracker.getChildLists(),
	            target: this.subchannelAddressString,
	        };
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    refTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    handleBackoffTimer() {
	        if (this.continueConnecting) {
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
	        }
	        else {
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
	        }
	    }
	    /**
	     * Start a backoff timer with the current nextBackoff timeout
	     */
	    startBackoff() {
	        this.backoffTimeout.runOnce();
	    }
	    stopBackoff() {
	        this.backoffTimeout.stop();
	        this.backoffTimeout.reset();
	    }
	    startConnectingInternal() {
	        let options = this.options;
	        if (options['grpc.keepalive_time_ms']) {
	            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
	            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });
	        }
	        this.connector
	            .connect(this.subchannelAddress, this.credentials, options)
	            .then(transport => {
	            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
	                this.transport = transport;
	                if (this.channelzEnabled) {
	                    this.childrenTracker.refChild(transport.getChannelzRef());
	                }
	                transport.addDisconnectListener(tooManyPings => {
	                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
	                    if (tooManyPings && this.keepaliveTime > 0) {
	                        this.keepaliveTime *= 2;
	                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
	                    }
	                });
	            }
	            else {
	                /* If we can't transition from CONNECTING to READY here, we will
	                 * not be using this transport, so release its resources. */
	                transport.shutdown();
	            }
	        }, error => {
	            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
	        });
	    }
	    /**
	     * Initiate a state transition from any element of oldStates to the new
	     * state. If the current connectivityState is not in oldStates, do nothing.
	     * @param oldStates The set of states to transition from
	     * @param newState The state to transition to
	     * @returns True if the state changed, false otherwise
	     */
	    transitionToState(oldStates, newState, errorMessage) {
	        var _a, _b;
	        if (oldStates.indexOf(this.connectivityState) === -1) {
	            return false;
	        }
	        if (errorMessage) {
	            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
	                ' -> ' +
	                connectivity_state_1.ConnectivityState[newState] +
	                ' with error "' + errorMessage + '"');
	        }
	        else {
	            this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +
	                ' -> ' +
	                connectivity_state_1.ConnectivityState[newState]);
	        }
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
	        }
	        const previousState = this.connectivityState;
	        this.connectivityState = newState;
	        switch (newState) {
	            case connectivity_state_1.ConnectivityState.READY:
	                this.stopBackoff();
	                break;
	            case connectivity_state_1.ConnectivityState.CONNECTING:
	                this.startBackoff();
	                this.startConnectingInternal();
	                this.continueConnecting = false;
	                break;
	            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
	                if (this.channelzEnabled && this.transport) {
	                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
	                }
	                (_a = this.transport) === null || _a === undefined ? undefined : _a.shutdown();
	                this.transport = null;
	                /* If the backoff timer has already ended by the time we get to the
	                 * TRANSIENT_FAILURE state, we want to immediately transition out of
	                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */
	                if (!this.backoffTimeout.isRunning()) {
	                    process.nextTick(() => {
	                        this.handleBackoffTimer();
	                    });
	                }
	                break;
	            case connectivity_state_1.ConnectivityState.IDLE:
	                if (this.channelzEnabled && this.transport) {
	                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());
	                }
	                (_b = this.transport) === null || _b === undefined ? undefined : _b.shutdown();
	                this.transport = null;
	                break;
	            default:
	                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
	        }
	        for (const listener of this.stateListeners) {
	            listener(this, previousState, newState, this.keepaliveTime, errorMessage);
	        }
	        return true;
	    }
	    ref() {
	        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));
	        this.refcount += 1;
	    }
	    unref() {
	        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));
	        this.refcount -= 1;
	        if (this.refcount === 0) {
	            this.channelzTrace.addTrace('CT_INFO', 'Shutting down');
	            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	            this.credentials._unref();
	            process.nextTick(() => {
	                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
	            });
	        }
	    }
	    unrefIfOneRef() {
	        if (this.refcount === 1) {
	            this.unref();
	            return true;
	        }
	        return false;
	    }
	    createCall(metadata, host, method, listener) {
	        if (!this.transport) {
	            throw new Error('Cannot create call, subchannel not READY');
	        }
	        let statsTracker;
	        if (this.channelzEnabled) {
	            this.callTracker.addCallStarted();
	            this.streamTracker.addCallStarted();
	            statsTracker = {
	                onCallEnd: status => {
	                    if (status.code === constants_1.Status.OK) {
	                        this.callTracker.addCallSucceeded();
	                    }
	                    else {
	                        this.callTracker.addCallFailed();
	                    }
	                },
	            };
	        }
	        else {
	            statsTracker = {};
	        }
	        return this.transport.createCall(metadata, host, method, listener, statsTracker);
	    }
	    /**
	     * If the subchannel is currently IDLE, start connecting and switch to the
	     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
	     * the next time it would transition to IDLE, start connecting again instead.
	     * Otherwise, do nothing.
	     */
	    startConnecting() {
	        process.nextTick(() => {
	            /* First, try to transition from IDLE to connecting. If that doesn't happen
	             * because the state is not currently IDLE, check if it is
	             * TRANSIENT_FAILURE, and if so indicate that it should go back to
	             * connecting after the backoff timer ends. Otherwise do nothing */
	            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
	                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                    this.continueConnecting = true;
	                }
	            }
	        });
	    }
	    /**
	     * Get the subchannel's current connectivity state.
	     */
	    getConnectivityState() {
	        return this.connectivityState;
	    }
	    /**
	     * Add a listener function to be called whenever the subchannel's
	     * connectivity state changes.
	     * @param listener
	     */
	    addConnectivityStateListener(listener) {
	        this.stateListeners.add(listener);
	    }
	    /**
	     * Remove a listener previously added with `addConnectivityStateListener`
	     * @param listener A reference to a function previously passed to
	     *     `addConnectivityStateListener`
	     */
	    removeConnectivityStateListener(listener) {
	        this.stateListeners.delete(listener);
	    }
	    /**
	     * Reset the backoff timeout, and immediately start connecting if in backoff.
	     */
	    resetBackoff() {
	        process.nextTick(() => {
	            this.backoffTimeout.reset();
	            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
	        });
	    }
	    getAddress() {
	        return this.subchannelAddressString;
	    }
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    isHealthy() {
	        return true;
	    }
	    addHealthStateWatcher(listener) {
	        // Do nothing with the listener
	    }
	    removeHealthStateWatcher(listener) {
	        // Do nothing with the listener
	    }
	    getRealSubchannel() {
	        return this;
	    }
	    realSubchannelEquals(other) {
	        return other.getRealSubchannel() === this;
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        if (newKeepaliveTime > this.keepaliveTime) {
	            this.keepaliveTime = newKeepaliveTime;
	        }
	    }
	}
	subchannel.Subchannel = Subchannel;
	
	return subchannel;
}

var transport = {};

var http_proxy = {};

var resolverDns = {};

var environment = {};

var hasRequiredEnvironment;

function requireEnvironment () {
	if (hasRequiredEnvironment) return environment;
	hasRequiredEnvironment = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var _a;
	Object.defineProperty(environment, "__esModule", { value: true });
	environment.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = undefined;
	environment.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a !== undefined ? _a : 'false') === 'true';
	
	return environment;
}

var hasRequiredResolverDns;

function requireResolverDns () {
	if (hasRequiredResolverDns) return resolverDns;
	hasRequiredResolverDns = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.setup = exports.DEFAULT_PORT = undefined;
		const resolver_1 = requireResolver();
		const dns_1 = require$$1$8;
		const service_config_1 = requireServiceConfig();
		const constants_1 = requireConstants();
		const metadata_1 = requireMetadata();
		const logging = requireLogging();
		const constants_2 = requireConstants();
		const uri_parser_1 = requireUriParser();
		const net_1 = require$$0$a;
		const backoff_timeout_1 = requireBackoffTimeout();
		const environment_1 = requireEnvironment();
		const TRACER_NAME = 'dns_resolver';
		function trace(text) {
		    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
		}
		/**
		 * The default TCP port to connect to if not explicitly specified in the target.
		 */
		exports.DEFAULT_PORT = 443;
		const DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;
		/**
		 * Resolver implementation that handles DNS names and IP addresses.
		 */
		class DnsResolver {
		    constructor(target, listener, channelOptions) {
		        var _a, _b, _c;
		        this.target = target;
		        this.listener = listener;
		        this.pendingLookupPromise = null;
		        this.pendingTxtPromise = null;
		        this.latestLookupResult = null;
		        this.latestServiceConfig = null;
		        this.latestServiceConfigError = null;
		        this.continueResolving = false;
		        this.isNextResolutionTimerRunning = false;
		        this.isServiceConfigEnabled = true;
		        this.returnedIpResult = false;
		        this.alternativeResolver = new dns_1.promises.Resolver();
		        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
		        if (target.authority) {
		            this.alternativeResolver.setServers([target.authority]);
		        }
		        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
		        if (hostPort === null) {
		            this.ipResult = null;
		            this.dnsHostname = null;
		            this.port = null;
		        }
		        else {
		            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
		                this.ipResult = [
		                    {
		                        addresses: [
		                            {
		                                host: hostPort.host,
		                                port: (_a = hostPort.port) !== null && _a !== undefined ? _a : exports.DEFAULT_PORT,
		                            },
		                        ],
		                    },
		                ];
		                this.dnsHostname = null;
		                this.port = null;
		            }
		            else {
		                this.ipResult = null;
		                this.dnsHostname = hostPort.host;
		                this.port = (_b = hostPort.port) !== null && _b !== undefined ? _b : exports.DEFAULT_PORT;
		            }
		        }
		        this.percentage = Math.random() * 100;
		        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {
		            this.isServiceConfigEnabled = false;
		        }
		        this.defaultResolutionError = {
		            code: constants_1.Status.UNAVAILABLE,
		            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
		            metadata: new metadata_1.Metadata(),
		        };
		        const backoffOptions = {
		            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],
		            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],
		        };
		        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
		            if (this.continueResolving) {
		                this.startResolutionWithBackoff();
		            }
		        }, backoffOptions);
		        this.backoff.unref();
		        this.minTimeBetweenResolutionsMs =
		            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== undefined ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
		        this.nextResolutionTimer = setTimeout(() => { }, 0);
		        clearTimeout(this.nextResolutionTimer);
		    }
		    /**
		     * If the target is an IP address, just provide that address as a result.
		     * Otherwise, initiate A, AAAA, and TXT lookups
		     */
		    startResolution() {
		        if (this.ipResult !== null) {
		            if (!this.returnedIpResult) {
		                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));
		                setImmediate(() => {
		                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
		                });
		                this.returnedIpResult = true;
		            }
		            this.backoff.stop();
		            this.backoff.reset();
		            this.stopNextResolutionTimer();
		            return;
		        }
		        if (this.dnsHostname === null) {
		            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));
		            setImmediate(() => {
		                this.listener.onError({
		                    code: constants_1.Status.UNAVAILABLE,
		                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
		                    metadata: new metadata_1.Metadata(),
		                });
		            });
		            this.stopNextResolutionTimer();
		        }
		        else {
		            if (this.pendingLookupPromise !== null) {
		                return;
		            }
		            trace('Looking up DNS hostname ' + this.dnsHostname);
		            /* We clear out latestLookupResult here to ensure that it contains the
		             * latest result since the last time we started resolving. That way, the
		             * TXT resolution handler can use it, but only if it finishes second. We
		             * don't clear out any previous service config results because it's
		             * better to use a service config that's slightly out of date than to
		             * revert to an effectively blank one. */
		            this.latestLookupResult = null;
		            const hostname = this.dnsHostname;
		            this.pendingLookupPromise = this.lookup(hostname);
		            this.pendingLookupPromise.then(addressList => {
		                if (this.pendingLookupPromise === null) {
		                    return;
		                }
		                this.pendingLookupPromise = null;
		                this.backoff.reset();
		                this.backoff.stop();
		                this.latestLookupResult = addressList.map(address => ({
		                    addresses: [address],
		                }));
		                const allAddressesString = '[' +
		                    addressList.map(addr => addr.host + ':' + addr.port).join(',') +
		                    ']';
		                trace('Resolved addresses for target ' +
		                    (0, uri_parser_1.uriToString)(this.target) +
		                    ': ' +
		                    allAddressesString);
		                if (this.latestLookupResult.length === 0) {
		                    this.listener.onError(this.defaultResolutionError);
		                    return;
		                }
		                /* If the TXT lookup has not yet finished, both of the last two
		                 * arguments will be null, which is the equivalent of getting an
		                 * empty TXT response. When the TXT lookup does finish, its handler
		                 * can update the service config by using the same address list */
		                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
		            }, err => {
		                if (this.pendingLookupPromise === null) {
		                    return;
		                }
		                trace('Resolution error for target ' +
		                    (0, uri_parser_1.uriToString)(this.target) +
		                    ': ' +
		                    err.message);
		                this.pendingLookupPromise = null;
		                this.stopNextResolutionTimer();
		                this.listener.onError(this.defaultResolutionError);
		            });
		            /* If there already is a still-pending TXT resolution, we can just use
		             * that result when it comes in */
		            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
		                /* We handle the TXT query promise differently than the others because
		                 * the name resolution attempt as a whole is a success even if the TXT
		                 * lookup fails */
		                this.pendingTxtPromise = this.resolveTxt(hostname);
		                this.pendingTxtPromise.then(txtRecord => {
		                    if (this.pendingTxtPromise === null) {
		                        return;
		                    }
		                    this.pendingTxtPromise = null;
		                    try {
		                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
		                    }
		                    catch (err) {
		                        this.latestServiceConfigError = {
		                            code: constants_1.Status.UNAVAILABLE,
		                            details: `Parsing service config failed with error ${err.message}`,
		                            metadata: new metadata_1.Metadata(),
		                        };
		                    }
		                    if (this.latestLookupResult !== null) {
		                        /* We rely here on the assumption that calling this function with
		                         * identical parameters will be essentialy idempotent, and calling
		                         * it with the same address list and a different service config
		                         * should result in a fast and seamless switchover. */
		                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
		                    }
		                }, err => {
		                    /* If TXT lookup fails we should do nothing, which means that we
		                     * continue to use the result of the most recent successful lookup,
		                     * or the default null config object if there has never been a
		                     * successful lookup. We do not set the latestServiceConfigError
		                     * here because that is specifically used for response validation
		                     * errors. We still need to handle this error so that it does not
		                     * bubble up as an unhandled promise rejection. */
		                });
		            }
		        }
		    }
		    async lookup(hostname) {
		        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
		            trace('Using alternative DNS resolver.');
		            const records = await Promise.allSettled([
		                this.alternativeResolver.resolve4(hostname),
		                this.alternativeResolver.resolve6(hostname),
		            ]);
		            if (records.every(result => result.status === 'rejected')) {
		                throw new Error(records[0].reason);
		            }
		            return records
		                .reduce((acc, result) => {
		                return result.status === 'fulfilled'
		                    ? [...acc, ...result.value]
		                    : acc;
		            }, [])
		                .map(addr => ({
		                host: addr,
		                port: +this.port,
		            }));
		        }
		        /* We lookup both address families here and then split them up later
		         * because when looking up a single family, dns.lookup outputs an error
		         * if the name exists but there are no records for that family, and that
		         * error is indistinguishable from other kinds of errors */
		        const addressList = await dns_1.promises.lookup(hostname, { all: true });
		        return addressList.map(addr => ({ host: addr.address, port: +this.port }));
		    }
		    async resolveTxt(hostname) {
		        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
		            trace('Using alternative DNS resolver.');
		            return this.alternativeResolver.resolveTxt(hostname);
		        }
		        return dns_1.promises.resolveTxt(hostname);
		    }
		    startNextResolutionTimer() {
		        var _a, _b;
		        clearTimeout(this.nextResolutionTimer);
		        this.nextResolutionTimer = setTimeout(() => {
		            this.stopNextResolutionTimer();
		            if (this.continueResolving) {
		                this.startResolutionWithBackoff();
		            }
		        }, this.minTimeBetweenResolutionsMs);
		        (_b = (_a = this.nextResolutionTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
		        this.isNextResolutionTimerRunning = true;
		    }
		    stopNextResolutionTimer() {
		        clearTimeout(this.nextResolutionTimer);
		        this.isNextResolutionTimerRunning = false;
		    }
		    startResolutionWithBackoff() {
		        if (this.pendingLookupPromise === null) {
		            this.continueResolving = false;
		            this.backoff.runOnce();
		            this.startNextResolutionTimer();
		            this.startResolution();
		        }
		    }
		    updateResolution() {
		        /* If there is a pending lookup, just let it finish. Otherwise, if the
		         * nextResolutionTimer or backoff timer is running, set the
		         * continueResolving flag to resolve when whichever of those timers
		         * fires. Otherwise, start resolving immediately. */
		        if (this.pendingLookupPromise === null) {
		            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
		                if (this.isNextResolutionTimerRunning) {
		                    trace('resolution update delayed by "min time between resolutions" rate limit');
		                }
		                else {
		                    trace('resolution update delayed by backoff timer until ' +
		                        this.backoff.getEndTime().toISOString());
		                }
		                this.continueResolving = true;
		            }
		            else {
		                this.startResolutionWithBackoff();
		            }
		        }
		    }
		    /**
		     * Reset the resolver to the same state it had when it was created. In-flight
		     * DNS requests cannot be cancelled, but they are discarded and their results
		     * will be ignored.
		     */
		    destroy() {
		        this.continueResolving = false;
		        this.backoff.reset();
		        this.backoff.stop();
		        this.stopNextResolutionTimer();
		        this.pendingLookupPromise = null;
		        this.pendingTxtPromise = null;
		        this.latestLookupResult = null;
		        this.latestServiceConfig = null;
		        this.latestServiceConfigError = null;
		        this.returnedIpResult = false;
		    }
		    /**
		     * Get the default authority for the given target. For IP targets, that is
		     * the IP address. For DNS targets, it is the hostname.
		     * @param target
		     */
		    static getDefaultAuthority(target) {
		        return target.path;
		    }
		}
		/**
		 * Set up the DNS resolver class by registering it as the handler for the
		 * "dns:" prefix and as the default resolver.
		 */
		function setup() {
		    (0, resolver_1.registerResolver)('dns', DnsResolver);
		    (0, resolver_1.registerDefaultScheme)('dns');
		}
		exports.setup = setup;
		
	} (resolverDns));
	return resolverDns;
}

var hasRequiredHttp_proxy;

function requireHttp_proxy () {
	if (hasRequiredHttp_proxy) return http_proxy;
	hasRequiredHttp_proxy = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(http_proxy, "__esModule", { value: true });
	http_proxy.getProxiedConnection = http_proxy.mapProxyName = undefined;
	const logging_1 = requireLogging();
	const constants_1 = requireConstants();
	const resolver_1 = requireResolver();
	const http = require$$2__default;
	const tls = require$$4$2;
	const logging = requireLogging();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const url_1 = require$$1$5;
	const resolver_dns_1 = requireResolverDns();
	const TRACER_NAME = 'proxy';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	function getProxyInfo() {
	    let proxyEnv = '';
	    let envVar = '';
	    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.
	     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The
	     * fallback behavior can be removed if there's a demand for it.
	     */
	    if (process.env.grpc_proxy) {
	        envVar = 'grpc_proxy';
	        proxyEnv = process.env.grpc_proxy;
	    }
	    else if (process.env.https_proxy) {
	        envVar = 'https_proxy';
	        proxyEnv = process.env.https_proxy;
	    }
	    else if (process.env.http_proxy) {
	        envVar = 'http_proxy';
	        proxyEnv = process.env.http_proxy;
	    }
	    else {
	        return {};
	    }
	    let proxyUrl;
	    try {
	        proxyUrl = new url_1.URL(proxyEnv);
	    }
	    catch (e) {
	        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
	        return {};
	    }
	    if (proxyUrl.protocol !== 'http:') {
	        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
	        return {};
	    }
	    let userCred = null;
	    if (proxyUrl.username) {
	        if (proxyUrl.password) {
	            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');
	            userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
	        }
	        else {
	            userCred = proxyUrl.username;
	        }
	    }
	    const hostname = proxyUrl.hostname;
	    let port = proxyUrl.port;
	    /* The proxy URL uses the scheme "http:", which has a default port number of
	     * 80. We need to set that explicitly here if it is omitted because otherwise
	     * it will use gRPC's default port 443. */
	    if (port === '') {
	        port = '80';
	    }
	    const result = {
	        address: `${hostname}:${port}`,
	    };
	    if (userCred) {
	        result.creds = userCred;
	    }
	    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);
	    return result;
	}
	function getNoProxyHostList() {
	    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */
	    let noProxyStr = process.env.no_grpc_proxy;
	    let envVar = 'no_grpc_proxy';
	    if (!noProxyStr) {
	        noProxyStr = process.env.no_proxy;
	        envVar = 'no_proxy';
	    }
	    if (noProxyStr) {
	        trace('No proxy server list set by environment variable ' + envVar);
	        return noProxyStr.split(',');
	    }
	    else {
	        return [];
	    }
	}
	function mapProxyName(target, options) {
	    var _a;
	    const noProxyResult = {
	        target: target,
	        extraOptions: {},
	    };
	    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== undefined ? _a : 1) === 0) {
	        return noProxyResult;
	    }
	    if (target.scheme === 'unix') {
	        return noProxyResult;
	    }
	    const proxyInfo = getProxyInfo();
	    if (!proxyInfo.address) {
	        return noProxyResult;
	    }
	    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
	    if (!hostPort) {
	        return noProxyResult;
	    }
	    const serverHost = hostPort.host;
	    for (const host of getNoProxyHostList()) {
	        if (host === serverHost) {
	            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));
	            return noProxyResult;
	        }
	    }
	    const extraOptions = {
	        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),
	    };
	    if (proxyInfo.creds) {
	        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;
	    }
	    return {
	        target: {
	            scheme: 'dns',
	            path: proxyInfo.address,
	        },
	        extraOptions: extraOptions,
	    };
	}
	http_proxy.mapProxyName = mapProxyName;
	function getProxiedConnection(address, channelOptions, connectionOptions) {
	    var _a;
	    if (!('grpc.http_connect_target' in channelOptions)) {
	        return Promise.resolve({});
	    }
	    const realTarget = channelOptions['grpc.http_connect_target'];
	    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
	    if (parsedTarget === null) {
	        return Promise.resolve({});
	    }
	    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);
	    if (splitHostPost === null) {
	        return Promise.resolve({});
	    }
	    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== undefined ? _a : resolver_dns_1.DEFAULT_PORT}`;
	    const options = {
	        method: 'CONNECT',
	        path: hostPort,
	    };
	    const headers = {
	        Host: hostPort,
	    };
	    // Connect to the subchannel address as a proxy
	    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
	        options.host = address.host;
	        options.port = address.port;
	    }
	    else {
	        options.socketPath = address.path;
	    }
	    if ('grpc.http_connect_creds' in channelOptions) {
	        headers['Proxy-Authorization'] =
	            'Basic ' +
	                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');
	    }
	    options.headers = headers;
	    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
	    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);
	    return new Promise((resolve, reject) => {
	        const request = http.request(options);
	        request.once('connect', (res, socket, head) => {
	            var _a;
	            request.removeAllListeners();
	            socket.removeAllListeners();
	            if (res.statusCode === 200) {
	                trace('Successfully connected to ' +
	                    options.path +
	                    ' through proxy ' +
	                    proxyAddressString);
	                // The HTTP client may have already read a few bytes of the proxied
	                // connection. If that's the case, put them back into the socket.
	                // See https://github.com/grpc/grpc-node/issues/2744.
	                if (head.length > 0) {
	                    socket.unshift(head);
	                }
	                if ('secureContext' in connectionOptions) {
	                    /* The proxy is connecting to a TLS server, so upgrade this socket
	                     * connection to a TLS connection.
	                     * This is a workaround for https://github.com/nodejs/node/issues/32922
	                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
	                    const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);
	                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
	                    const remoteHost = (_a = hostPort === null || hostPort === undefined ? undefined : hostPort.host) !== null && _a !== undefined ? _a : targetPath;
	                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {
	                        trace('Successfully established a TLS connection to ' +
	                            options.path +
	                            ' through proxy ' +
	                            proxyAddressString);
	                        resolve({ socket: cts, realTarget: parsedTarget });
	                    });
	                    cts.on('error', (error) => {
	                        trace('Failed to establish a TLS connection to ' +
	                            options.path +
	                            ' through proxy ' +
	                            proxyAddressString +
	                            ' with error ' +
	                            error.message);
	                        reject();
	                    });
	                }
	                else {
	                    trace('Successfully established a plaintext connection to ' +
	                        options.path +
	                        ' through proxy ' +
	                        proxyAddressString);
	                    resolve({
	                        socket,
	                        realTarget: parsedTarget,
	                    });
	                }
	            }
	            else {
	                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +
	                    options.path +
	                    ' through proxy ' +
	                    proxyAddressString +
	                    ' with status ' +
	                    res.statusCode);
	                reject();
	            }
	        });
	        request.once('error', err => {
	            request.removeAllListeners();
	            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +
	                proxyAddressString +
	                ' with error ' +
	                err.message);
	            reject();
	        });
	        request.end();
	    });
	}
	http_proxy.getProxiedConnection = getProxiedConnection;
	
	return http_proxy;
}

var subchannelCall = {};

var streamDecoder = {};

var hasRequiredStreamDecoder;

function requireStreamDecoder () {
	if (hasRequiredStreamDecoder) return streamDecoder;
	hasRequiredStreamDecoder = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(streamDecoder, "__esModule", { value: true });
	streamDecoder.StreamDecoder = undefined;
	var ReadState;
	(function (ReadState) {
	    ReadState[ReadState["NO_DATA"] = 0] = "NO_DATA";
	    ReadState[ReadState["READING_SIZE"] = 1] = "READING_SIZE";
	    ReadState[ReadState["READING_MESSAGE"] = 2] = "READING_MESSAGE";
	})(ReadState || (ReadState = {}));
	class StreamDecoder {
	    constructor(maxReadMessageLength) {
	        this.maxReadMessageLength = maxReadMessageLength;
	        this.readState = ReadState.NO_DATA;
	        this.readCompressFlag = Buffer.alloc(1);
	        this.readPartialSize = Buffer.alloc(4);
	        this.readSizeRemaining = 4;
	        this.readMessageSize = 0;
	        this.readPartialMessage = [];
	        this.readMessageRemaining = 0;
	    }
	    write(data) {
	        let readHead = 0;
	        let toRead;
	        const result = [];
	        while (readHead < data.length) {
	            switch (this.readState) {
	                case ReadState.NO_DATA:
	                    this.readCompressFlag = data.slice(readHead, readHead + 1);
	                    readHead += 1;
	                    this.readState = ReadState.READING_SIZE;
	                    this.readPartialSize.fill(0);
	                    this.readSizeRemaining = 4;
	                    this.readMessageSize = 0;
	                    this.readMessageRemaining = 0;
	                    this.readPartialMessage = [];
	                    break;
	                case ReadState.READING_SIZE:
	                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);
	                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
	                    this.readSizeRemaining -= toRead;
	                    readHead += toRead;
	                    // readSizeRemaining >=0 here
	                    if (this.readSizeRemaining === 0) {
	                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);
	                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
	                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
	                        }
	                        this.readMessageRemaining = this.readMessageSize;
	                        if (this.readMessageRemaining > 0) {
	                            this.readState = ReadState.READING_MESSAGE;
	                        }
	                        else {
	                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
	                            this.readState = ReadState.NO_DATA;
	                            result.push(message);
	                        }
	                    }
	                    break;
	                case ReadState.READING_MESSAGE:
	                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);
	                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
	                    this.readMessageRemaining -= toRead;
	                    readHead += toRead;
	                    // readMessageRemaining >=0 here
	                    if (this.readMessageRemaining === 0) {
	                        // At this point, we have read a full message
	                        const framedMessageBuffers = [
	                            this.readCompressFlag,
	                            this.readPartialSize,
	                        ].concat(this.readPartialMessage);
	                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
	                        this.readState = ReadState.NO_DATA;
	                        result.push(framedMessage);
	                    }
	                    break;
	                default:
	                    throw new Error('Unexpected read state');
	            }
	        }
	        return result;
	    }
	}
	streamDecoder.StreamDecoder = StreamDecoder;
	
	return streamDecoder;
}

var hasRequiredSubchannelCall;

function requireSubchannelCall () {
	if (hasRequiredSubchannelCall) return subchannelCall;
	hasRequiredSubchannelCall = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelCall, "__esModule", { value: true });
	subchannelCall.Http2SubchannelCall = undefined;
	const http2 = require$$0$f;
	const os = require$$0$3;
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const stream_decoder_1 = requireStreamDecoder();
	const logging = requireLogging();
	const constants_2 = requireConstants();
	const TRACER_NAME = 'subchannel_call';
	/**
	 * Should do approximately the same thing as util.getSystemErrorName but the
	 * TypeScript types don't have that function for some reason so I just made my
	 * own.
	 * @param errno
	 */
	function getSystemErrorName(errno) {
	    for (const [name, num] of Object.entries(os.constants.errno)) {
	        if (num === errno) {
	            return name;
	        }
	    }
	    return 'Unknown system error ' + errno;
	}
	function mapHttpStatusCode(code) {
	    const details = `Received HTTP status code ${code}`;
	    let mappedStatusCode;
	    switch (code) {
	        // TODO(murgatroid99): handle 100 and 101
	        case 400:
	            mappedStatusCode = constants_1.Status.INTERNAL;
	            break;
	        case 401:
	            mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
	            break;
	        case 403:
	            mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
	            break;
	        case 404:
	            mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
	            break;
	        case 429:
	        case 502:
	        case 503:
	        case 504:
	            mappedStatusCode = constants_1.Status.UNAVAILABLE;
	            break;
	        default:
	            mappedStatusCode = constants_1.Status.UNKNOWN;
	    }
	    return {
	        code: mappedStatusCode,
	        details: details,
	        metadata: new metadata_1.Metadata()
	    };
	}
	class Http2SubchannelCall {
	    constructor(http2Stream, callEventTracker, listener, transport, callId) {
	        var _a;
	        this.http2Stream = http2Stream;
	        this.callEventTracker = callEventTracker;
	        this.listener = listener;
	        this.transport = transport;
	        this.callId = callId;
	        this.isReadFilterPending = false;
	        this.isPushPending = false;
	        this.canPush = false;
	        /**
	         * Indicates that an 'end' event has come from the http2 stream, so there
	         * will be no more data events.
	         */
	        this.readsClosed = false;
	        this.statusOutput = false;
	        this.unpushedReadMessages = [];
	        // This is populated (non-null) if and only if the call has ended
	        this.finalStatus = null;
	        this.internalError = null;
	        this.serverEndedCall = false;
	        this.connectionDropped = false;
	        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== undefined ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);
	        http2Stream.on('response', (headers, flags) => {
	            let headersString = '';
	            for (const header of Object.keys(headers)) {
	                headersString += '\t\t' + header + ': ' + headers[header] + '\n';
	            }
	            this.trace('Received server headers:\n' + headersString);
	            this.httpStatusCode = headers[':status'];
	            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
	                this.handleTrailers(headers);
	            }
	            else {
	                let metadata;
	                try {
	                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	                }
	                catch (error) {
	                    this.endCall({
	                        code: constants_1.Status.UNKNOWN,
	                        details: error.message,
	                        metadata: new metadata_1.Metadata(),
	                    });
	                    return;
	                }
	                this.listener.onReceiveMetadata(metadata);
	            }
	        });
	        http2Stream.on('trailers', (headers) => {
	            this.handleTrailers(headers);
	        });
	        http2Stream.on('data', (data) => {
	            /* If the status has already been output, allow the http2 stream to
	             * drain without processing the data. */
	            if (this.statusOutput) {
	                return;
	            }
	            this.trace('receive HTTP/2 data frame of length ' + data.length);
	            let messages;
	            try {
	                messages = this.decoder.write(data);
	            }
	            catch (e) {
	                /* Some servers send HTML error pages along with HTTP status codes.
	                 * When the client attempts to parse this as a length-delimited
	                 * message, the parsed message size is greater than the default limit,
	                 * resulting in a message decoding error. In that situation, the HTTP
	                 * error code information is more useful to the user than the
	                 * RESOURCE_EXHAUSTED error is, so we report that instead. Normally,
	                 * we delay processing the HTTP status until after the stream ends, to
	                 * prioritize reporting the gRPC status from trailers if it is present,
	                 * but when there is a message parsing error we end the stream early
	                 * before processing trailers. */
	                if (this.httpStatusCode !== undefined && this.httpStatusCode !== 200) {
	                    const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
	                    this.cancelWithStatus(mappedStatus.code, mappedStatus.details);
	                }
	                else {
	                    this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);
	                }
	                return;
	            }
	            for (const message of messages) {
	                this.trace('parsed message of length ' + message.length);
	                this.callEventTracker.addMessageReceived();
	                this.tryPush(message);
	            }
	        });
	        http2Stream.on('end', () => {
	            this.readsClosed = true;
	            this.maybeOutputStatus();
	        });
	        http2Stream.on('close', () => {
	            this.serverEndedCall = true;
	            /* Use process.next tick to ensure that this code happens after any
	             * "error" event that may be emitted at about the same time, so that
	             * we can bubble up the error message from that event. */
	            process.nextTick(() => {
	                var _a;
	                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);
	                /* If we have a final status with an OK status code, that means that
	                 * we have received all of the messages and we have processed the
	                 * trailers and the call completed successfully, so it doesn't matter
	                 * how the stream ends after that */
	                if (((_a = this.finalStatus) === null || _a === undefined ? undefined : _a.code) === constants_1.Status.OK) {
	                    return;
	                }
	                let code;
	                let details = '';
	                switch (http2Stream.rstCode) {
	                    case http2.constants.NGHTTP2_NO_ERROR:
	                        /* If we get a NO_ERROR code and we already have a status, the
	                         * stream completed properly and we just haven't fully processed
	                         * it yet */
	                        if (this.finalStatus !== null) {
	                            return;
	                        }
	                        if (this.httpStatusCode && this.httpStatusCode !== 200) {
	                            const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
	                            code = mappedStatus.code;
	                            details = mappedStatus.details;
	                        }
	                        else {
	                            code = constants_1.Status.INTERNAL;
	                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
	                        }
	                        break;
	                    case http2.constants.NGHTTP2_REFUSED_STREAM:
	                        code = constants_1.Status.UNAVAILABLE;
	                        details = 'Stream refused by server';
	                        break;
	                    case http2.constants.NGHTTP2_CANCEL:
	                        /* Bug reports indicate that Node synthesizes a NGHTTP2_CANCEL
	                         * code from connection drops. We want to prioritize reporting
	                         * an unavailable status when that happens. */
	                        if (this.connectionDropped) {
	                            code = constants_1.Status.UNAVAILABLE;
	                            details = 'Connection dropped';
	                        }
	                        else {
	                            code = constants_1.Status.CANCELLED;
	                            details = 'Call cancelled';
	                        }
	                        break;
	                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
	                        code = constants_1.Status.RESOURCE_EXHAUSTED;
	                        details = 'Bandwidth exhausted or memory limit exceeded';
	                        break;
	                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
	                        code = constants_1.Status.PERMISSION_DENIED;
	                        details = 'Protocol not secure enough';
	                        break;
	                    case http2.constants.NGHTTP2_INTERNAL_ERROR:
	                        code = constants_1.Status.INTERNAL;
	                        if (this.internalError === null) {
	                            /* This error code was previously handled in the default case, and
	                             * there are several instances of it online, so I wanted to
	                             * preserve the original error message so that people find existing
	                             * information in searches, but also include the more recognizable
	                             * "Internal server error" message. */
	                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
	                        }
	                        else {
	                            if (this.internalError.code === 'ECONNRESET' ||
	                                this.internalError.code === 'ETIMEDOUT') {
	                                code = constants_1.Status.UNAVAILABLE;
	                                details = this.internalError.message;
	                            }
	                            else {
	                                /* The "Received RST_STREAM with code ..." error is preserved
	                                 * here for continuity with errors reported online, but the
	                                 * error message at the end will probably be more relevant in
	                                 * most cases. */
	                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
	                            }
	                        }
	                        break;
	                    default:
	                        code = constants_1.Status.INTERNAL;
	                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
	                }
	                // This is a no-op if trailers were received at all.
	                // This is OK, because status codes emitted here correspond to more
	                // catastrophic issues that prevent us from receiving trailers in the
	                // first place.
	                this.endCall({
	                    code,
	                    details,
	                    metadata: new metadata_1.Metadata(),
	                    rstCode: http2Stream.rstCode,
	                });
	            });
	        });
	        http2Stream.on('error', (err) => {
	            /* We need an error handler here to stop "Uncaught Error" exceptions
	             * from bubbling up. However, errors here should all correspond to
	             * "close" events, where we will handle the error more granularly */
	            /* Specifically looking for stream errors that were *not* constructed
	             * from a RST_STREAM response here:
	             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267
	             */
	            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {
	                this.trace('Node error event: message=' +
	                    err.message +
	                    ' code=' +
	                    err.code +
	                    ' errno=' +
	                    getSystemErrorName(err.errno) +
	                    ' syscall=' +
	                    err.syscall);
	                this.internalError = err;
	            }
	            this.callEventTracker.onStreamEnd(false);
	        });
	    }
	    getDeadlineInfo() {
	        return [`remote_addr=${this.getPeer()}`];
	    }
	    onDisconnect() {
	        this.connectionDropped = true;
	        /* Give the call an event loop cycle to finish naturally before reporting
	         * the disconnection as an error. */
	        setImmediate(() => {
	            this.endCall({
	                code: constants_1.Status.UNAVAILABLE,
	                details: 'Connection dropped',
	                metadata: new metadata_1.Metadata(),
	            });
	        });
	    }
	    outputStatus() {
	        /* Precondition: this.finalStatus !== null */
	        if (!this.statusOutput) {
	            this.statusOutput = true;
	            this.trace('ended with status: code=' +
	                this.finalStatus.code +
	                ' details="' +
	                this.finalStatus.details +
	                '"');
	            this.callEventTracker.onCallEnd(this.finalStatus);
	            /* We delay the actual action of bubbling up the status to insulate the
	             * cleanup code in this class from any errors that may be thrown in the
	             * upper layers as a result of bubbling up the status. In particular,
	             * if the status is not OK, the "error" event may be emitted
	             * synchronously at the top level, which will result in a thrown error if
	             * the user does not handle that event. */
	            process.nextTick(() => {
	                this.listener.onReceiveStatus(this.finalStatus);
	            });
	            /* Leave the http2 stream in flowing state to drain incoming messages, to
	             * ensure that the stream closure completes. The call stream already does
	             * not push more messages after the status is output, so the messages go
	             * nowhere either way. */
	            this.http2Stream.resume();
	        }
	    }
	    trace(text) {
	        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);
	    }
	    /**
	     * On first call, emits a 'status' event with the given StatusObject.
	     * Subsequent calls are no-ops.
	     * @param status The status of the call.
	     */
	    endCall(status) {
	        /* If the status is OK and a new status comes in (e.g. from a
	         * deserialization failure), that new status takes priority */
	        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
	            this.finalStatus = status;
	            this.maybeOutputStatus();
	        }
	        this.destroyHttp2Stream();
	    }
	    maybeOutputStatus() {
	        if (this.finalStatus !== null) {
	            /* The combination check of readsClosed and that the two message buffer
	             * arrays are empty checks that there all incoming data has been fully
	             * processed */
	            if (this.finalStatus.code !== constants_1.Status.OK ||
	                (this.readsClosed &&
	                    this.unpushedReadMessages.length === 0 &&
	                    !this.isReadFilterPending &&
	                    !this.isPushPending)) {
	                this.outputStatus();
	            }
	        }
	    }
	    push(message) {
	        this.trace('pushing to reader message of length ' +
	            (message instanceof Buffer ? message.length : null));
	        this.canPush = false;
	        this.isPushPending = true;
	        process.nextTick(() => {
	            this.isPushPending = false;
	            /* If we have already output the status any later messages should be
	             * ignored, and can cause out-of-order operation errors higher up in the
	             * stack. Checking as late as possible here to avoid any race conditions.
	             */
	            if (this.statusOutput) {
	                return;
	            }
	            this.listener.onReceiveMessage(message);
	            this.maybeOutputStatus();
	        });
	    }
	    tryPush(messageBytes) {
	        if (this.canPush) {
	            this.http2Stream.pause();
	            this.push(messageBytes);
	        }
	        else {
	            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);
	            this.unpushedReadMessages.push(messageBytes);
	        }
	    }
	    handleTrailers(headers) {
	        this.serverEndedCall = true;
	        this.callEventTracker.onStreamEnd(true);
	        let headersString = '';
	        for (const header of Object.keys(headers)) {
	            headersString += '\t\t' + header + ': ' + headers[header] + '\n';
	        }
	        this.trace('Received server trailers:\n' + headersString);
	        let metadata;
	        try {
	            metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	        }
	        catch (e) {
	            metadata = new metadata_1.Metadata();
	        }
	        const metadataMap = metadata.getMap();
	        let status;
	        if (typeof metadataMap['grpc-status'] === 'string') {
	            const receivedStatus = Number(metadataMap['grpc-status']);
	            this.trace('received status code ' + receivedStatus + ' from server');
	            metadata.remove('grpc-status');
	            let details = '';
	            if (typeof metadataMap['grpc-message'] === 'string') {
	                try {
	                    details = decodeURI(metadataMap['grpc-message']);
	                }
	                catch (e) {
	                    details = metadataMap['grpc-message'];
	                }
	                metadata.remove('grpc-message');
	                this.trace('received status details string "' + details + '" from server');
	            }
	            status = {
	                code: receivedStatus,
	                details: details,
	                metadata: metadata
	            };
	        }
	        else if (this.httpStatusCode) {
	            status = mapHttpStatusCode(this.httpStatusCode);
	            status.metadata = metadata;
	        }
	        else {
	            status = {
	                code: constants_1.Status.UNKNOWN,
	                details: 'No status information received',
	                metadata: metadata
	            };
	        }
	        // This is a no-op if the call was already ended when handling headers.
	        this.endCall(status);
	    }
	    destroyHttp2Stream() {
	        var _a;
	        // The http2 stream could already have been destroyed if cancelWithStatus
	        // is called in response to an internal http2 error.
	        if (this.http2Stream.destroyed) {
	            return;
	        }
	        /* If the server ended the call, sending an RST_STREAM is redundant, so we
	         * just half close on the client side instead to finish closing the stream.
	         */
	        if (this.serverEndedCall) {
	            this.http2Stream.end();
	        }
	        else {
	            /* If the call has ended with an OK status, communicate that when closing
	             * the stream, partly to avoid a situation in which we detect an error
	             * RST_STREAM as a result after we have the status */
	            let code;
	            if (((_a = this.finalStatus) === null || _a === undefined ? undefined : _a.code) === constants_1.Status.OK) {
	                code = http2.constants.NGHTTP2_NO_ERROR;
	            }
	            else {
	                code = http2.constants.NGHTTP2_CANCEL;
	            }
	            this.trace('close http2 stream with code ' + code);
	            this.http2Stream.close(code);
	        }
	    }
	    cancelWithStatus(status, details) {
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
	    }
	    getStatus() {
	        return this.finalStatus;
	    }
	    getPeer() {
	        return this.transport.getPeerName();
	    }
	    getCallNumber() {
	        return this.callId;
	    }
	    startRead() {
	        /* If the stream has ended with an error, we should not emit any more
	         * messages and we should communicate that the stream has ended */
	        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
	            this.readsClosed = true;
	            this.maybeOutputStatus();
	            return;
	        }
	        this.canPush = true;
	        if (this.unpushedReadMessages.length > 0) {
	            const nextMessage = this.unpushedReadMessages.shift();
	            this.push(nextMessage);
	            return;
	        }
	        /* Only resume reading from the http2Stream if we don't have any pending
	         * messages to emit */
	        this.http2Stream.resume();
	    }
	    sendMessageWithContext(context, message) {
	        this.trace('write() called with message of length ' + message.length);
	        const cb = (error) => {
	            /* nextTick here ensures that no stream action can be taken in the call
	             * stack of the write callback, in order to hopefully work around
	             * https://github.com/nodejs/node/issues/49147 */
	            process.nextTick(() => {
	                var _a;
	                let code = constants_1.Status.UNAVAILABLE;
	                if ((error === null || error === undefined ? undefined : error.code) ===
	                    'ERR_STREAM_WRITE_AFTER_END') {
	                    code = constants_1.Status.INTERNAL;
	                }
	                if (error) {
	                    this.cancelWithStatus(code, `Write error: ${error.message}`);
	                }
	                (_a = context.callback) === null || _a === undefined ? undefined : _a.call(context);
	            });
	        };
	        this.trace('sending data chunk of length ' + message.length);
	        this.callEventTracker.addMessageSent();
	        try {
	            this.http2Stream.write(message, cb);
	        }
	        catch (error) {
	            this.endCall({
	                code: constants_1.Status.UNAVAILABLE,
	                details: `Write failed with error ${error.message}`,
	                metadata: new metadata_1.Metadata(),
	            });
	        }
	    }
	    halfClose() {
	        this.trace('end() called');
	        this.trace('calling end() on HTTP/2 stream');
	        this.http2Stream.end();
	    }
	}
	subchannelCall.Http2SubchannelCall = Http2SubchannelCall;
	
	return subchannelCall;
}

var callNumber = {};

var hasRequiredCallNumber;

function requireCallNumber () {
	if (hasRequiredCallNumber) return callNumber;
	hasRequiredCallNumber = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(callNumber, "__esModule", { value: true });
	callNumber.getNextCallNumber = undefined;
	let nextCallNumber = 0;
	function getNextCallNumber() {
	    return nextCallNumber++;
	}
	callNumber.getNextCallNumber = getNextCallNumber;
	
	return callNumber;
}

var hasRequiredTransport;

function requireTransport () {
	if (hasRequiredTransport) return transport;
	hasRequiredTransport = 1;
	/*
	 * Copyright 2023 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(transport, "__esModule", { value: true });
	transport.Http2SubchannelConnector = undefined;
	const http2 = require$$0$f;
	const tls_1 = require$$4$2;
	const channelz_1 = requireChannelz();
	const constants_1 = requireConstants();
	const http_proxy_1 = requireHttp_proxy();
	const logging = requireLogging();
	const resolver_1 = requireResolver();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const net = require$$0$a;
	const subchannel_call_1 = requireSubchannelCall();
	const call_number_1 = requireCallNumber();
	const TRACER_NAME = 'transport';
	const FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';
	const clientVersion = require$$12.version;
	const { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;
	const KEEPALIVE_TIMEOUT_MS = 20000;
	const tooManyPingsData = Buffer.from('too_many_pings', 'ascii');
	class Http2Transport {
	    constructor(session, subchannelAddress, options, 
	    /**
	     * Name of the remote server, if it is not the same as the subchannel
	     * address, i.e. if connecting through an HTTP CONNECT proxy.
	     */
	    remoteName) {
	        this.session = session;
	        this.options = options;
	        this.remoteName = remoteName;
	        /**
	         * Timer reference indicating when to send the next ping or when the most recent ping will be considered lost.
	         */
	        this.keepaliveTimer = null;
	        /**
	         * Indicates that the keepalive timer ran out while there were no active
	         * calls, and a ping should be sent the next time a call starts.
	         */
	        this.pendingSendKeepalivePing = false;
	        this.activeCalls = new Set();
	        this.disconnectListeners = [];
	        this.disconnectHandled = false;
	        this.channelzEnabled = true;
	        this.keepalivesSent = 0;
	        this.messagesSent = 0;
	        this.messagesReceived = 0;
	        this.lastMessageSentTimestamp = null;
	        this.lastMessageReceivedTimestamp = null;
	        /* Populate subchannelAddressString and channelzRef before doing anything
	         * else, because they are used in the trace methods. */
	        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
	        if (options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	            this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
	        }
	        else {
	            this.streamTracker = new channelz_1.ChannelzCallTracker();
	        }
	        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
	        // Build user-agent string.
	        this.userAgent = [
	            options['grpc.primary_user_agent'],
	            `grpc-node-js/${clientVersion}`,
	            options['grpc.secondary_user_agent'],
	        ]
	            .filter(e => e)
	            .join(' '); // remove falsey values first
	        if ('grpc.keepalive_time_ms' in options) {
	            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];
	        }
	        else {
	            this.keepaliveTimeMs = -1;
	        }
	        if ('grpc.keepalive_timeout_ms' in options) {
	            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];
	        }
	        else {
	            this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
	        }
	        if ('grpc.keepalive_permit_without_calls' in options) {
	            this.keepaliveWithoutCalls =
	                options['grpc.keepalive_permit_without_calls'] === 1;
	        }
	        else {
	            this.keepaliveWithoutCalls = false;
	        }
	        session.once('close', () => {
	            this.trace('session closed');
	            this.handleDisconnect();
	        });
	        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {
	            let tooManyPings = false;
	            /* See the last paragraph of
	             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */
	            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&
	                opaqueData &&
	                opaqueData.equals(tooManyPingsData)) {
	                tooManyPings = true;
	            }
	            this.trace('connection closed by GOAWAY with code ' +
	                errorCode +
	                ' and data ' +
	                (opaqueData === null || opaqueData === undefined ? undefined : opaqueData.toString()));
	            this.reportDisconnectToOwner(tooManyPings);
	        });
	        session.once('error', error => {
	            this.trace('connection closed with error ' + error.message);
	            this.handleDisconnect();
	        });
	        session.socket.once('close', () => {
	            this.trace('connection closed');
	            this.handleDisconnect();
	        });
	        if (logging.isTracerEnabled(TRACER_NAME)) {
	            session.on('remoteSettings', (settings) => {
	                this.trace('new settings received' +
	                    (this.session !== session ? ' on the old connection' : '') +
	                    ': ' +
	                    JSON.stringify(settings));
	            });
	            session.on('localSettings', (settings) => {
	                this.trace('local settings acknowledged by remote' +
	                    (this.session !== session ? ' on the old connection' : '') +
	                    ': ' +
	                    JSON.stringify(settings));
	            });
	        }
	        /* Start the keepalive timer last, because this can trigger trace logs,
	         * which should only happen after everything else is set up. */
	        if (this.keepaliveWithoutCalls) {
	            this.maybeStartKeepalivePingTimer();
	        }
	    }
	    getChannelzInfo() {
	        var _a, _b, _c;
	        const sessionSocket = this.session.socket;
	        const remoteAddress = sessionSocket.remoteAddress
	            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
	            : null;
	        const localAddress = sessionSocket.localAddress
	            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
	            : null;
	        let tlsInfo;
	        if (this.session.encrypted) {
	            const tlsSocket = sessionSocket;
	            const cipherInfo = tlsSocket.getCipher();
	            const certificate = tlsSocket.getCertificate();
	            const peerCertificate = tlsSocket.getPeerCertificate();
	            tlsInfo = {
	                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== undefined ? _a : null,
	                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
	                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
	                remoteCertificate: peerCertificate && 'raw' in peerCertificate
	                    ? peerCertificate.raw
	                    : null,
	            };
	        }
	        else {
	            tlsInfo = null;
	        }
	        const socketInfo = {
	            remoteAddress: remoteAddress,
	            localAddress: localAddress,
	            security: tlsInfo,
	            remoteName: this.remoteName,
	            streamsStarted: this.streamTracker.callsStarted,
	            streamsSucceeded: this.streamTracker.callsSucceeded,
	            streamsFailed: this.streamTracker.callsFailed,
	            messagesSent: this.messagesSent,
	            messagesReceived: this.messagesReceived,
	            keepAlivesSent: this.keepalivesSent,
	            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
	            lastRemoteStreamCreatedTimestamp: null,
	            lastMessageSentTimestamp: this.lastMessageSentTimestamp,
	            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
	            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== undefined ? _b : null,
	            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== undefined ? _c : null,
	        };
	        return socketInfo;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    keepaliveTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    flowControlTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    internalsTrace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +
	            this.channelzRef.id +
	            ') ' +
	            this.subchannelAddressString +
	            ' ' +
	            text);
	    }
	    /**
	     * Indicate to the owner of this object that this transport should no longer
	     * be used. That happens if the connection drops, or if the server sends a
	     * GOAWAY.
	     * @param tooManyPings If true, this was triggered by a GOAWAY with data
	     * indicating that the session was closed becaues the client sent too many
	     * pings.
	     * @returns
	     */
	    reportDisconnectToOwner(tooManyPings) {
	        if (this.disconnectHandled) {
	            return;
	        }
	        this.disconnectHandled = true;
	        this.disconnectListeners.forEach(listener => listener(tooManyPings));
	    }
	    /**
	     * Handle connection drops, but not GOAWAYs.
	     */
	    handleDisconnect() {
	        this.clearKeepaliveTimeout();
	        this.reportDisconnectToOwner(false);
	        for (const call of this.activeCalls) {
	            call.onDisconnect();
	        }
	        // Wait an event loop cycle before destroying the connection
	        setImmediate(() => {
	            this.session.destroy();
	        });
	    }
	    addDisconnectListener(listener) {
	        this.disconnectListeners.push(listener);
	    }
	    canSendPing() {
	        return (!this.session.destroyed &&
	            this.keepaliveTimeMs > 0 &&
	            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));
	    }
	    maybeSendPing() {
	        var _a, _b;
	        if (!this.canSendPing()) {
	            this.pendingSendKeepalivePing = true;
	            return;
	        }
	        if (this.keepaliveTimer) {
	            console.error('keepaliveTimeout is not null');
	            return;
	        }
	        if (this.channelzEnabled) {
	            this.keepalivesSent += 1;
	        }
	        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	        this.keepaliveTimer = setTimeout(() => {
	            this.keepaliveTimer = null;
	            this.keepaliveTrace('Ping timeout passed without response');
	            this.handleDisconnect();
	        }, this.keepaliveTimeoutMs);
	        (_b = (_a = this.keepaliveTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        let pingSendError = '';
	        try {
	            const pingSentSuccessfully = this.session.ping((err, duration, payload) => {
	                this.clearKeepaliveTimeout();
	                if (err) {
	                    this.keepaliveTrace('Ping failed with error ' + err.message);
	                    this.handleDisconnect();
	                }
	                else {
	                    this.keepaliveTrace('Received ping response');
	                    this.maybeStartKeepalivePingTimer();
	                }
	            });
	            if (!pingSentSuccessfully) {
	                pingSendError = 'Ping returned false';
	            }
	        }
	        catch (e) {
	            // grpc/grpc-node#2139
	            pingSendError = (e instanceof Error ? e.message : '') || 'Unknown error';
	        }
	        if (pingSendError) {
	            this.keepaliveTrace('Ping send failed: ' + pingSendError);
	            this.handleDisconnect();
	        }
	    }
	    /**
	     * Starts the keepalive ping timer if appropriate. If the timer already ran
	     * out while there were no active requests, instead send a ping immediately.
	     * If the ping timer is already running or a ping is currently in flight,
	     * instead do nothing and wait for them to resolve.
	     */
	    maybeStartKeepalivePingTimer() {
	        var _a, _b;
	        if (!this.canSendPing()) {
	            return;
	        }
	        if (this.pendingSendKeepalivePing) {
	            this.pendingSendKeepalivePing = false;
	            this.maybeSendPing();
	        }
	        else if (!this.keepaliveTimer) {
	            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	            this.keepaliveTimer = setTimeout(() => {
	                this.keepaliveTimer = null;
	                this.maybeSendPing();
	            }, this.keepaliveTimeMs);
	            (_b = (_a = this.keepaliveTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	        /* Otherwise, there is already either a keepalive timer or a ping pending,
	         * wait for those to resolve. */
	    }
	    /**
	     * Clears whichever keepalive timeout is currently active, if any.
	     */
	    clearKeepaliveTimeout() {
	        if (this.keepaliveTimer) {
	            clearTimeout(this.keepaliveTimer);
	            this.keepaliveTimer = null;
	        }
	    }
	    removeActiveCall(call) {
	        this.activeCalls.delete(call);
	        if (this.activeCalls.size === 0) {
	            this.session.unref();
	        }
	    }
	    addActiveCall(call) {
	        this.activeCalls.add(call);
	        if (this.activeCalls.size === 1) {
	            this.session.ref();
	            if (!this.keepaliveWithoutCalls) {
	                this.maybeStartKeepalivePingTimer();
	            }
	        }
	    }
	    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
	        const headers = metadata.toHttp2Headers();
	        headers[HTTP2_HEADER_AUTHORITY] = host;
	        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
	        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';
	        headers[HTTP2_HEADER_METHOD] = 'POST';
	        headers[HTTP2_HEADER_PATH] = method;
	        headers[HTTP2_HEADER_TE] = 'trailers';
	        let http2Stream;
	        /* In theory, if an error is thrown by session.request because session has
	         * become unusable (e.g. because it has received a goaway), this subchannel
	         * should soon see the corresponding close or goaway event anyway and leave
	         * READY. But we have seen reports that this does not happen
	         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)
	         * so for defense in depth, we just discard the session when we see an
	         * error here.
	         */
	        try {
	            http2Stream = this.session.request(headers);
	        }
	        catch (e) {
	            this.handleDisconnect();
	            throw e;
	        }
	        this.flowControlTrace('local window size: ' +
	            this.session.state.localWindowSize +
	            ' remote window size: ' +
	            this.session.state.remoteWindowSize);
	        this.internalsTrace('session.closed=' +
	            this.session.closed +
	            ' session.destroyed=' +
	            this.session.destroyed +
	            ' session.socket.destroyed=' +
	            this.session.socket.destroyed);
	        let eventTracker;
	        // eslint-disable-next-line prefer-const
	        let call;
	        if (this.channelzEnabled) {
	            this.streamTracker.addCallStarted();
	            eventTracker = {
	                addMessageSent: () => {
	                    var _a;
	                    this.messagesSent += 1;
	                    this.lastMessageSentTimestamp = new Date();
	                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                addMessageReceived: () => {
	                    var _a;
	                    this.messagesReceived += 1;
	                    this.lastMessageReceivedTimestamp = new Date();
	                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                onCallEnd: status => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, status);
	                    this.removeActiveCall(call);
	                },
	                onStreamEnd: success => {
	                    var _a;
	                    if (success) {
	                        this.streamTracker.addCallSucceeded();
	                    }
	                    else {
	                        this.streamTracker.addCallFailed();
	                    }
	                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, success);
	                },
	            };
	        }
	        else {
	            eventTracker = {
	                addMessageSent: () => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                addMessageReceived: () => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker);
	                },
	                onCallEnd: status => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, status);
	                    this.removeActiveCall(call);
	                },
	                onStreamEnd: success => {
	                    var _a;
	                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === undefined ? undefined : _a.call(subchannelCallStatsTracker, success);
	                },
	            };
	        }
	        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
	        this.addActiveCall(call);
	        return call;
	    }
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    getPeerName() {
	        return this.subchannelAddressString;
	    }
	    getOptions() {
	        return this.options;
	    }
	    shutdown() {
	        this.session.close();
	        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	    }
	}
	class Http2SubchannelConnector {
	    constructor(channelTarget) {
	        this.channelTarget = channelTarget;
	        this.session = null;
	        this.isShutdown = false;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);
	    }
	    createSession(address, credentials, options, proxyConnectionResult) {
	        if (this.isShutdown) {
	            return Promise.reject();
	        }
	        return new Promise((resolve, reject) => {
	            var _a, _b, _c, _d;
	            let remoteName;
	            if (proxyConnectionResult.realTarget) {
	                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
	                this.trace('creating HTTP/2 session through proxy to ' +
	                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
	            }
	            else {
	                remoteName = null;
	                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));
	            }
	            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== undefined ? _a : this.channelTarget);
	            let connectionOptions = credentials._getConnectionOptions();
	            if (!connectionOptions) {
	                reject('Credentials not loaded');
	                return;
	            }
	            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
	            if ('grpc-node.max_session_memory' in options) {
	                connectionOptions.maxSessionMemory =
	                    options['grpc-node.max_session_memory'];
	            }
	            else {
	                /* By default, set a very large max session memory limit, to effectively
	                 * disable enforcement of the limit. Some testing indicates that Node's
	                 * behavior degrades badly when this limit is reached, so we solve that
	                 * by disabling the check entirely. */
	                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
	            }
	            let addressScheme = 'http://';
	            if ('secureContext' in connectionOptions) {
	                addressScheme = 'https://';
	                // If provided, the value of grpc.ssl_target_name_override should be used
	                // to override the target hostname when checking server identity.
	                // This option is used for testing only.
	                if (options['grpc.ssl_target_name_override']) {
	                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
	                    const originalCheckServerIdentity = (_b = connectionOptions.checkServerIdentity) !== null && _b !== undefined ? _b : tls_1.checkServerIdentity;
	                    connectionOptions.checkServerIdentity = (host, cert) => {
	                        return originalCheckServerIdentity(sslTargetNameOverride, cert);
	                    };
	                    connectionOptions.servername = sslTargetNameOverride;
	                }
	                else {
	                    const authorityHostname = (_d = (_c = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c === undefined ? undefined : _c.host) !== null && _d !== undefined ? _d : 'localhost';
	                    // We want to always set servername to support SNI
	                    connectionOptions.servername = authorityHostname;
	                }
	                if (proxyConnectionResult.socket) {
	                    /* This is part of the workaround for
	                     * https://github.com/nodejs/node/issues/32922. Without that bug,
	                     * proxyConnectionResult.socket would always be a plaintext socket and
	                     * this would say
	                     * connectionOptions.socket = proxyConnectionResult.socket; */
	                    connectionOptions.createConnection = (authority, option) => {
	                        return proxyConnectionResult.socket;
	                    };
	                }
	            }
	            else {
	                /* In all but the most recent versions of Node, http2.connect does not use
	                 * the options when establishing plaintext connections, so we need to
	                 * establish that connection explicitly. */
	                connectionOptions.createConnection = (authority, option) => {
	                    if (proxyConnectionResult.socket) {
	                        return proxyConnectionResult.socket;
	                    }
	                    else {
	                        /* net.NetConnectOpts is declared in a way that is more restrictive
	                         * than what net.connect will actually accept, so we use the type
	                         * assertion to work around that. */
	                        return net.connect(address);
	                    }
	                };
	            }
	            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });
	            /* http2.connect uses the options here:
	             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036
	             * The spread operator overides earlier values with later ones, so any port
	             * or host values in the options will be used rather than any values extracted
	             * from the first argument. In addition, the path overrides the host and port,
	             * as documented for plaintext connections here:
	             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener
	             * and for TLS connections here:
	             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In
	             * earlier versions of Node, http2.connect passes these options to
	             * tls.connect but not net.connect, so in the insecure case we still need
	             * to set the createConnection option above to create the connection
	             * explicitly. We cannot do that in the TLS case because http2.connect
	             * passes necessary additional options to tls.connect.
	             * The first argument just needs to be parseable as a URL and the scheme
	             * determines whether the connection will be established over TLS or not.
	             */
	            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
	            this.session = session;
	            let errorMessage = 'Failed to connect';
	            let reportedError = false;
	            session.unref();
	            session.once('connect', () => {
	                session.removeAllListeners();
	                resolve(new Http2Transport(session, address, options, remoteName));
	                this.session = null;
	            });
	            session.once('close', () => {
	                this.session = null;
	                // Leave time for error event to happen before rejecting
	                setImmediate(() => {
	                    if (!reportedError) {
	                        reportedError = true;
	                        reject(`${errorMessage} (${new Date().toISOString()})`);
	                    }
	                });
	            });
	            session.once('error', error => {
	                errorMessage = error.message;
	                this.trace('connection failed with error ' + errorMessage);
	                if (!reportedError) {
	                    reportedError = true;
	                    reject(`${errorMessage} (${new Date().toISOString()})`);
	                }
	            });
	        });
	    }
	    connect(address, credentials, options) {
	        var _a, _b, _c;
	        if (this.isShutdown) {
	            return Promise.reject();
	        }
	        /* Pass connection options through to the proxy so that it's able to
	         * upgrade it's connection to support tls if needed.
	         * This is a workaround for https://github.com/nodejs/node/issues/32922
	         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */
	        const connectionOptions = credentials._getConnectionOptions();
	        if (!connectionOptions) {
	            return Promise.reject('Credentials not loaded');
	        }
	        if ('secureContext' in connectionOptions) {
	            connectionOptions.ALPNProtocols = ['h2'];
	            // If provided, the value of grpc.ssl_target_name_override should be used
	            // to override the target hostname when checking server identity.
	            // This option is used for testing only.
	            if (options['grpc.ssl_target_name_override']) {
	                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];
	                const originalCheckServerIdentity = (_a = connectionOptions.checkServerIdentity) !== null && _a !== undefined ? _a : tls_1.checkServerIdentity;
	                connectionOptions.checkServerIdentity = (host, cert) => {
	                    return originalCheckServerIdentity(sslTargetNameOverride, cert);
	                };
	                connectionOptions.servername = sslTargetNameOverride;
	            }
	            else {
	                if ('grpc.http_connect_target' in options) {
	                    /* This is more or less how servername will be set in createSession
	                     * if a connection is successfully established through the proxy.
	                     * If the proxy is not used, these connectionOptions are discarded
	                     * anyway */
	                    const targetPath = (0, resolver_1.getDefaultAuthority)((_b = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _b !== undefined ? _b : {
	                        path: 'localhost',
	                    });
	                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
	                    connectionOptions.servername = (_c = hostPort === null || hostPort === undefined ? undefined : hostPort.host) !== null && _c !== undefined ? _c : targetPath;
	                }
	            }
	            if (options['grpc-node.tls_enable_trace']) {
	                connectionOptions.enableTrace = true;
	            }
	        }
	        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));
	    }
	    shutdown() {
	        var _a;
	        this.isShutdown = true;
	        (_a = this.session) === null || _a === undefined ? undefined : _a.close();
	        this.session = null;
	    }
	}
	transport.Http2SubchannelConnector = Http2SubchannelConnector;
	
	return transport;
}

var hasRequiredSubchannelPool;

function requireSubchannelPool () {
	if (hasRequiredSubchannelPool) return subchannelPool;
	hasRequiredSubchannelPool = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelPool, "__esModule", { value: true });
	subchannelPool.getSubchannelPool = subchannelPool.SubchannelPool = undefined;
	const channel_options_1 = requireChannelOptions();
	const subchannel_1 = requireSubchannel();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const transport_1 = requireTransport();
	// 10 seconds in milliseconds. This value is arbitrary.
	/**
	 * The amount of time in between checks for dropping subchannels that have no
	 * other references
	 */
	const REF_CHECK_INTERVAL = 10000;
	class SubchannelPool {
	    /**
	     * A pool of subchannels use for making connections. Subchannels with the
	     * exact same parameters will be reused.
	     */
	    constructor() {
	        this.pool = Object.create(null);
	        /**
	         * A timer of a task performing a periodic subchannel cleanup.
	         */
	        this.cleanupTimer = null;
	    }
	    /**
	     * Unrefs all unused subchannels and cancels the cleanup task if all
	     * subchannels have been unrefed.
	     */
	    unrefUnusedSubchannels() {
	        let allSubchannelsUnrefed = true;
	        /* These objects are created with Object.create(null), so they do not
	         * have a prototype, which means that for (... in ...) loops over them
	         * do not need to be filtered */
	        // eslint-disable-disable-next-line:forin
	        for (const channelTarget in this.pool) {
	            const subchannelObjArray = this.pool[channelTarget];
	            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());
	            if (refedSubchannels.length > 0) {
	                allSubchannelsUnrefed = false;
	            }
	            /* For each subchannel in the pool, try to unref it if it has
	             * exactly one ref (which is the ref from the pool itself). If that
	             * does happen, remove the subchannel from the pool */
	            this.pool[channelTarget] = refedSubchannels;
	        }
	        /* Currently we do not delete keys with empty values. If that results
	         * in significant memory usage we should change it. */
	        // Cancel the cleanup task if all subchannels have been unrefed.
	        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
	            clearInterval(this.cleanupTimer);
	            this.cleanupTimer = null;
	        }
	    }
	    /**
	     * Ensures that the cleanup task is spawned.
	     */
	    ensureCleanupTask() {
	        var _a, _b;
	        if (this.cleanupTimer === null) {
	            this.cleanupTimer = setInterval(() => {
	                this.unrefUnusedSubchannels();
	            }, REF_CHECK_INTERVAL);
	            // Unref because this timer should not keep the event loop running.
	            // Call unref only if it exists to address electron/electron#21162
	            (_b = (_a = this.cleanupTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	    }
	    /**
	     * Get a subchannel if one already exists with exactly matching parameters.
	     * Otherwise, create and save a subchannel with those parameters.
	     * @param channelTarget
	     * @param subchannelTarget
	     * @param channelArguments
	     * @param channelCredentials
	     */
	    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
	        this.ensureCleanupTask();
	        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
	        if (channelTarget in this.pool) {
	            const subchannelObjArray = this.pool[channelTarget];
	            for (const subchannelObj of subchannelObjArray) {
	                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&
	                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&
	                    channelCredentials._equals(subchannelObj.channelCredentials)) {
	                    return subchannelObj.subchannel;
	                }
	            }
	        }
	        // If we get here, no matching subchannel was found
	        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
	        if (!(channelTarget in this.pool)) {
	            this.pool[channelTarget] = [];
	        }
	        this.pool[channelTarget].push({
	            subchannelAddress: subchannelTarget,
	            channelArguments,
	            channelCredentials,
	            subchannel,
	        });
	        subchannel.ref();
	        return subchannel;
	    }
	}
	subchannelPool.SubchannelPool = SubchannelPool;
	const globalSubchannelPool = new SubchannelPool();
	/**
	 * Get either the global subchannel pool, or a new subchannel pool.
	 * @param global
	 */
	function getSubchannelPool(global) {
	    if (global) {
	        return globalSubchannelPool;
	    }
	    else {
	        return new SubchannelPool();
	    }
	}
	subchannelPool.getSubchannelPool = getSubchannelPool;
	
	return subchannelPool;
}

var filterStack = {};

var hasRequiredFilterStack;

function requireFilterStack () {
	if (hasRequiredFilterStack) return filterStack;
	hasRequiredFilterStack = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(filterStack, "__esModule", { value: true });
	filterStack.FilterStackFactory = filterStack.FilterStack = undefined;
	class FilterStack {
	    constructor(filters) {
	        this.filters = filters;
	    }
	    sendMetadata(metadata) {
	        let result = metadata;
	        for (let i = 0; i < this.filters.length; i++) {
	            result = this.filters[i].sendMetadata(result);
	        }
	        return result;
	    }
	    receiveMetadata(metadata) {
	        let result = metadata;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveMetadata(result);
	        }
	        return result;
	    }
	    sendMessage(message) {
	        let result = message;
	        for (let i = 0; i < this.filters.length; i++) {
	            result = this.filters[i].sendMessage(result);
	        }
	        return result;
	    }
	    receiveMessage(message) {
	        let result = message;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveMessage(result);
	        }
	        return result;
	    }
	    receiveTrailers(status) {
	        let result = status;
	        for (let i = this.filters.length - 1; i >= 0; i--) {
	            result = this.filters[i].receiveTrailers(result);
	        }
	        return result;
	    }
	    push(filters) {
	        this.filters.unshift(...filters);
	    }
	    getFilters() {
	        return this.filters;
	    }
	}
	filterStack.FilterStack = FilterStack;
	class FilterStackFactory {
	    constructor(factories) {
	        this.factories = factories;
	    }
	    push(filterFactories) {
	        this.factories.unshift(...filterFactories);
	    }
	    clone() {
	        return new FilterStackFactory([...this.factories]);
	    }
	    createFilter() {
	        return new FilterStack(this.factories.map(factory => factory.createFilter()));
	    }
	}
	filterStack.FilterStackFactory = FilterStackFactory;
	
	return filterStack;
}

var compressionFilter = {};

var compressionAlgorithms = {};

var hasRequiredCompressionAlgorithms;

function requireCompressionAlgorithms () {
	if (hasRequiredCompressionAlgorithms) return compressionAlgorithms;
	hasRequiredCompressionAlgorithms = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(compressionAlgorithms, "__esModule", { value: true });
	compressionAlgorithms.CompressionAlgorithms = undefined;
	var CompressionAlgorithms;
	(function (CompressionAlgorithms) {
	    CompressionAlgorithms[CompressionAlgorithms["identity"] = 0] = "identity";
	    CompressionAlgorithms[CompressionAlgorithms["deflate"] = 1] = "deflate";
	    CompressionAlgorithms[CompressionAlgorithms["gzip"] = 2] = "gzip";
	})(CompressionAlgorithms || (compressionAlgorithms.CompressionAlgorithms = CompressionAlgorithms = {}));
	
	return compressionAlgorithms;
}

var filter = {};

var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter;
	hasRequiredFilter = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(filter, "__esModule", { value: true });
	filter.BaseFilter = undefined;
	class BaseFilter {
	    async sendMetadata(metadata) {
	        return metadata;
	    }
	    receiveMetadata(metadata) {
	        return metadata;
	    }
	    async sendMessage(message) {
	        return message;
	    }
	    async receiveMessage(message) {
	        return message;
	    }
	    receiveTrailers(status) {
	        return status;
	    }
	}
	filter.BaseFilter = BaseFilter;
	
	return filter;
}

var hasRequiredCompressionFilter;

function requireCompressionFilter () {
	if (hasRequiredCompressionFilter) return compressionFilter;
	hasRequiredCompressionFilter = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(compressionFilter, "__esModule", { value: true });
	compressionFilter.CompressionFilterFactory = compressionFilter.CompressionFilter = undefined;
	const zlib = require$$3__default;
	const compression_algorithms_1 = requireCompressionAlgorithms();
	const constants_1 = requireConstants();
	const filter_1 = requireFilter();
	const logging = requireLogging();
	const isCompressionAlgorithmKey = (key) => {
	    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');
	};
	class CompressionHandler {
	    /**
	     * @param message Raw uncompressed message bytes
	     * @param compress Indicates whether the message should be compressed
	     * @return Framed message, compressed if applicable
	     */
	    async writeMessage(message, compress) {
	        let messageBuffer = message;
	        if (compress) {
	            messageBuffer = await this.compressMessage(messageBuffer);
	        }
	        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
	        output.writeUInt8(compress ? 1 : 0, 0);
	        output.writeUInt32BE(messageBuffer.length, 1);
	        messageBuffer.copy(output, 5);
	        return output;
	    }
	    /**
	     * @param data Framed message, possibly compressed
	     * @return Uncompressed message
	     */
	    async readMessage(data) {
	        const compressed = data.readUInt8(0) === 1;
	        let messageBuffer = data.slice(5);
	        if (compressed) {
	            messageBuffer = await this.decompressMessage(messageBuffer);
	        }
	        return messageBuffer;
	    }
	}
	class IdentityHandler extends CompressionHandler {
	    async compressMessage(message) {
	        return message;
	    }
	    async writeMessage(message, compress) {
	        const output = Buffer.allocUnsafe(message.length + 5);
	        /* With "identity" compression, messages should always be marked as
	         * uncompressed */
	        output.writeUInt8(0, 0);
	        output.writeUInt32BE(message.length, 1);
	        message.copy(output, 5);
	        return output;
	    }
	    decompressMessage(message) {
	        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
	    }
	}
	class DeflateHandler extends CompressionHandler {
	    constructor(maxRecvMessageLength) {
	        super();
	        this.maxRecvMessageLength = maxRecvMessageLength;
	    }
	    compressMessage(message) {
	        return new Promise((resolve, reject) => {
	            zlib.deflate(message, (err, output) => {
	                if (err) {
	                    reject(err);
	                }
	                else {
	                    resolve(output);
	                }
	            });
	        });
	    }
	    decompressMessage(message) {
	        return new Promise((resolve, reject) => {
	            let totalLength = 0;
	            const messageParts = [];
	            const decompresser = zlib.createInflate();
	            decompresser.on('data', (chunk) => {
	                messageParts.push(chunk);
	                totalLength += chunk.byteLength;
	                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
	                    decompresser.destroy();
	                    reject({
	                        code: constants_1.Status.RESOURCE_EXHAUSTED,
	                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
	                    });
	                }
	            });
	            decompresser.on('end', () => {
	                resolve(Buffer.concat(messageParts));
	            });
	            decompresser.write(message);
	            decompresser.end();
	        });
	    }
	}
	class GzipHandler extends CompressionHandler {
	    constructor(maxRecvMessageLength) {
	        super();
	        this.maxRecvMessageLength = maxRecvMessageLength;
	    }
	    compressMessage(message) {
	        return new Promise((resolve, reject) => {
	            zlib.gzip(message, (err, output) => {
	                if (err) {
	                    reject(err);
	                }
	                else {
	                    resolve(output);
	                }
	            });
	        });
	    }
	    decompressMessage(message) {
	        return new Promise((resolve, reject) => {
	            let totalLength = 0;
	            const messageParts = [];
	            const decompresser = zlib.createGunzip();
	            decompresser.on('data', (chunk) => {
	                messageParts.push(chunk);
	                totalLength += chunk.byteLength;
	                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {
	                    decompresser.destroy();
	                    reject({
	                        code: constants_1.Status.RESOURCE_EXHAUSTED,
	                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
	                    });
	                }
	            });
	            decompresser.on('end', () => {
	                resolve(Buffer.concat(messageParts));
	            });
	            decompresser.write(message);
	            decompresser.end();
	        });
	    }
	}
	class UnknownHandler extends CompressionHandler {
	    constructor(compressionName) {
	        super();
	        this.compressionName = compressionName;
	    }
	    compressMessage(message) {
	        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
	    }
	    decompressMessage(message) {
	        // This should be unreachable
	        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
	    }
	}
	function getCompressionHandler(compressionName, maxReceiveMessageSize) {
	    switch (compressionName) {
	        case 'identity':
	            return new IdentityHandler();
	        case 'deflate':
	            return new DeflateHandler(maxReceiveMessageSize);
	        case 'gzip':
	            return new GzipHandler(maxReceiveMessageSize);
	        default:
	            return new UnknownHandler(compressionName);
	    }
	}
	class CompressionFilter extends filter_1.BaseFilter {
	    constructor(channelOptions, sharedFilterConfig) {
	        var _a, _b, _c;
	        super();
	        this.sharedFilterConfig = sharedFilterConfig;
	        this.sendCompression = new IdentityHandler();
	        this.receiveCompression = new IdentityHandler();
	        this.currentCompressionAlgorithm = 'identity';
	        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];
	        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== undefined ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.maxSendMessageLength = (_b = channelOptions['grpc.max_send_message_length']) !== null && _b !== undefined ? _b : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
	        if (compressionAlgorithmKey !== undefined) {
	            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
	                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
	                const serverSupportedEncodings = (_c = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c === undefined ? undefined : _c.split(',');
	                /**
	                 * There are two possible situations here:
	                 * 1) We don't have any info yet from the server about what compression it supports
	                 *    In that case we should just use what the client tells us to use
	                 * 2) We've previously received a response from the server including a grpc-accept-encoding header
	                 *    In that case we only want to use the encoding chosen by the client if the server supports it
	                 */
	                if (!serverSupportedEncodings ||
	                    serverSupportedEncodings.includes(clientSelectedEncoding)) {
	                    this.currentCompressionAlgorithm = clientSelectedEncoding;
	                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);
	                }
	            }
	            else {
	                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
	            }
	        }
	    }
	    async sendMetadata(metadata) {
	        const headers = await metadata;
	        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');
	        headers.set('accept-encoding', 'identity');
	        // No need to send the header if it's "identity" -  behavior is identical; save the bandwidth
	        if (this.currentCompressionAlgorithm === 'identity') {
	            headers.remove('grpc-encoding');
	        }
	        else {
	            headers.set('grpc-encoding', this.currentCompressionAlgorithm);
	        }
	        return headers;
	    }
	    receiveMetadata(metadata) {
	        const receiveEncoding = metadata.get('grpc-encoding');
	        if (receiveEncoding.length > 0) {
	            const encoding = receiveEncoding[0];
	            if (typeof encoding === 'string') {
	                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
	            }
	        }
	        metadata.remove('grpc-encoding');
	        /* Check to see if the compression we're using to send messages is supported by the server
	         * If not, reset the sendCompression filter and have it use the default IdentityHandler */
	        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];
	        if (serverSupportedEncodingsHeader) {
	            this.sharedFilterConfig.serverSupportedEncodingHeader =
	                serverSupportedEncodingsHeader;
	            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');
	            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
	                this.sendCompression = new IdentityHandler();
	                this.currentCompressionAlgorithm = 'identity';
	            }
	        }
	        metadata.remove('grpc-accept-encoding');
	        return metadata;
	    }
	    async sendMessage(message) {
	        var _a;
	        /* This filter is special. The input message is the bare message bytes,
	         * and the output is a framed and possibly compressed message. For this
	         * reason, this filter should be at the bottom of the filter stack */
	        const resolvedMessage = await message;
	        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
	            throw {
	                code: constants_1.Status.RESOURCE_EXHAUSTED,
	                details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
	            };
	        }
	        let compress;
	        if (this.sendCompression instanceof IdentityHandler) {
	            compress = false;
	        }
	        else {
	            compress = (((_a = resolvedMessage.flags) !== null && _a !== undefined ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;
	        }
	        return {
	            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
	            flags: resolvedMessage.flags,
	        };
	    }
	    async receiveMessage(message) {
	        /* This filter is also special. The input message is framed and possibly
	         * compressed, and the output message is deframed and uncompressed. So
	         * this is another reason that this filter should be at the bottom of the
	         * filter stack. */
	        return this.receiveCompression.readMessage(await message);
	    }
	}
	compressionFilter.CompressionFilter = CompressionFilter;
	class CompressionFilterFactory {
	    constructor(channel, options) {
	        this.options = options;
	        this.sharedFilterConfig = {};
	    }
	    createFilter() {
	        return new CompressionFilter(this.options, this.sharedFilterConfig);
	    }
	}
	compressionFilter.CompressionFilterFactory = CompressionFilterFactory;
	
	return compressionFilter;
}

var loadBalancingCall = {};

var deadline = {};

var hasRequiredDeadline;

function requireDeadline () {
	if (hasRequiredDeadline) return deadline;
	hasRequiredDeadline = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(deadline, "__esModule", { value: true });
	deadline.formatDateDifference = deadline.deadlineToString = deadline.getRelativeTimeout = deadline.getDeadlineTimeoutString = deadline.minDeadline = undefined;
	function minDeadline(...deadlineList) {
	    let minValue = Infinity;
	    for (const deadline of deadlineList) {
	        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
	        if (deadlineMsecs < minValue) {
	            minValue = deadlineMsecs;
	        }
	    }
	    return minValue;
	}
	deadline.minDeadline = minDeadline;
	const units = [
	    ['m', 1],
	    ['S', 1000],
	    ['M', 60 * 1000],
	    ['H', 60 * 60 * 1000],
	];
	function getDeadlineTimeoutString(deadline) {
	    const now = new Date().getTime();
	    if (deadline instanceof Date) {
	        deadline = deadline.getTime();
	    }
	    const timeoutMs = Math.max(deadline - now, 0);
	    for (const [unit, factor] of units) {
	        const amount = timeoutMs / factor;
	        if (amount < 1e8) {
	            return String(Math.ceil(amount)) + unit;
	        }
	    }
	    throw new Error('Deadline is too far in the future');
	}
	deadline.getDeadlineTimeoutString = getDeadlineTimeoutString;
	/**
	 * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args
	 * In particular, "When delay is larger than 2147483647 or less than 1, the
	 * delay will be set to 1. Non-integer delays are truncated to an integer."
	 * This number of milliseconds is almost 25 days.
	 */
	const MAX_TIMEOUT_TIME = 2147483647;
	/**
	 * Get the timeout value that should be passed to setTimeout now for the timer
	 * to end at the deadline. For any deadline before now, the timer should end
	 * immediately, represented by a value of 0. For any deadline more than
	 * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will
	 * end at that time, so it is treated as infinitely far in the future.
	 * @param deadline
	 * @returns
	 */
	function getRelativeTimeout(deadline) {
	    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
	    const now = new Date().getTime();
	    const timeout = deadlineMs - now;
	    if (timeout < 0) {
	        return 0;
	    }
	    else if (timeout > MAX_TIMEOUT_TIME) {
	        return Infinity;
	    }
	    else {
	        return timeout;
	    }
	}
	deadline.getRelativeTimeout = getRelativeTimeout;
	function deadlineToString(deadline) {
	    if (deadline instanceof Date) {
	        return deadline.toISOString();
	    }
	    else {
	        const dateDeadline = new Date(deadline);
	        if (Number.isNaN(dateDeadline.getTime())) {
	            return '' + deadline;
	        }
	        else {
	            return dateDeadline.toISOString();
	        }
	    }
	}
	deadline.deadlineToString = deadlineToString;
	/**
	 * Calculate the difference between two dates as a number of seconds and format
	 * it as a string.
	 * @param startDate
	 * @param endDate
	 * @returns
	 */
	function formatDateDifference(startDate, endDate) {
	    return ((endDate.getTime() - startDate.getTime()) / 1000).toFixed(3) + 's';
	}
	deadline.formatDateDifference = formatDateDifference;
	
	return deadline;
}

var controlPlaneStatus = {};

var hasRequiredControlPlaneStatus;

function requireControlPlaneStatus () {
	if (hasRequiredControlPlaneStatus) return controlPlaneStatus;
	hasRequiredControlPlaneStatus = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(controlPlaneStatus, "__esModule", { value: true });
	controlPlaneStatus.restrictControlPlaneStatusCode = undefined;
	const constants_1 = requireConstants();
	const INAPPROPRIATE_CONTROL_PLANE_CODES = [
	    constants_1.Status.OK,
	    constants_1.Status.INVALID_ARGUMENT,
	    constants_1.Status.NOT_FOUND,
	    constants_1.Status.ALREADY_EXISTS,
	    constants_1.Status.FAILED_PRECONDITION,
	    constants_1.Status.ABORTED,
	    constants_1.Status.OUT_OF_RANGE,
	    constants_1.Status.DATA_LOSS,
	];
	function restrictControlPlaneStatusCode(code, details) {
	    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
	        return {
	            code: constants_1.Status.INTERNAL,
	            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,
	        };
	    }
	    else {
	        return { code, details };
	    }
	}
	controlPlaneStatus.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
	
	return controlPlaneStatus;
}

var hasRequiredLoadBalancingCall;

function requireLoadBalancingCall () {
	if (hasRequiredLoadBalancingCall) return loadBalancingCall;
	hasRequiredLoadBalancingCall = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancingCall, "__esModule", { value: true });
	loadBalancingCall.LoadBalancingCall = undefined;
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const deadline_1 = requireDeadline();
	const metadata_1 = requireMetadata();
	const picker_1 = requirePicker();
	const uri_parser_1 = requireUriParser();
	const logging = requireLogging();
	const control_plane_status_1 = requireControlPlaneStatus();
	const http2 = require$$0$f;
	const TRACER_NAME = 'load_balancing_call';
	class LoadBalancingCall {
	    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
	        var _a, _b;
	        this.channel = channel;
	        this.callConfig = callConfig;
	        this.methodName = methodName;
	        this.host = host;
	        this.credentials = credentials;
	        this.deadline = deadline;
	        this.callNumber = callNumber;
	        this.child = null;
	        this.readPending = false;
	        this.pendingMessage = null;
	        this.pendingHalfClose = false;
	        this.ended = false;
	        this.metadata = null;
	        this.listener = null;
	        this.onCallEnded = null;
	        this.childStartTime = null;
	        const splitPath = this.methodName.split('/');
	        let serviceName = '';
	        /* The standard path format is "/{serviceName}/{methodName}", so if we split
	         * by '/', the first item should be empty and the second should be the
	         * service name */
	        if (splitPath.length >= 2) {
	            serviceName = splitPath[1];
	        }
	        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === undefined ? undefined : _a.host) !== null && _b !== undefined ? _b : 'localhost';
	        /* Currently, call credentials are only allowed on HTTPS connections, so we
	         * can assume that the scheme is "https" */
	        this.serviceUrl = `https://${hostname}/${serviceName}`;
	        this.startTime = new Date();
	    }
	    getDeadlineInfo() {
	        var _a, _b;
	        const deadlineInfo = [];
	        if (this.childStartTime) {
	            if (this.childStartTime > this.startTime) {
	                if ((_a = this.metadata) === null || _a === undefined ? undefined : _a.getOptions().waitForReady) {
	                    deadlineInfo.push('wait_for_ready');
	                }
	                deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);
	            }
	            deadlineInfo.push(...this.child.getDeadlineInfo());
	            return deadlineInfo;
	        }
	        else {
	            if ((_b = this.metadata) === null || _b === undefined ? undefined : _b.getOptions().waitForReady) {
	                deadlineInfo.push('wait_for_ready');
	            }
	            deadlineInfo.push('Waiting for LB pick');
	        }
	        return deadlineInfo;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
	    }
	    outputStatus(status, progress) {
	        var _a, _b;
	        if (!this.ended) {
	            this.ended = true;
	            this.trace('ended with status: code=' +
	                status.code +
	                ' details="' +
	                status.details +
	                '" start time=' +
	                this.startTime.toISOString());
	            const finalStatus = Object.assign(Object.assign({}, status), { progress });
	            (_a = this.listener) === null || _a === undefined ? undefined : _a.onReceiveStatus(finalStatus);
	            (_b = this.onCallEnded) === null || _b === undefined ? undefined : _b.call(this, finalStatus.code);
	        }
	    }
	    doPick() {
	        var _a, _b;
	        if (this.ended) {
	            return;
	        }
	        if (!this.metadata) {
	            throw new Error('doPick called before start');
	        }
	        this.trace('Pick called');
	        const finalMetadata = this.metadata.clone();
	        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
	        const subchannelString = pickResult.subchannel
	            ? '(' +
	                pickResult.subchannel.getChannelzRef().id +
	                ') ' +
	                pickResult.subchannel.getAddress()
	            : '' + pickResult.subchannel;
	        this.trace('Pick result: ' +
	            picker_1.PickResultType[pickResult.pickResultType] +
	            ' subchannel: ' +
	            subchannelString +
	            ' status: ' +
	            ((_a = pickResult.status) === null || _a === undefined ? undefined : _a.code) +
	            ' ' +
	            ((_b = pickResult.status) === null || _b === undefined ? undefined : _b.details));
	        switch (pickResult.pickResultType) {
	            case picker_1.PickResultType.COMPLETE:
	                this.credentials
	                    .generateMetadata({ method_name: this.methodName, service_url: this.serviceUrl })
	                    .then(credsMetadata => {
	                    var _a, _b, _c;
	                    /* If this call was cancelled (e.g. by the deadline) before
	                     * metadata generation finished, we shouldn't do anything with
	                     * it. */
	                    if (this.ended) {
	                        this.trace('Credentials metadata generation finished after call ended');
	                        return;
	                    }
	                    finalMetadata.merge(credsMetadata);
	                    if (finalMetadata.get('authorization').length > 1) {
	                        this.outputStatus({
	                            code: constants_1.Status.INTERNAL,
	                            details: '"authorization" metadata cannot have multiple values',
	                            metadata: new metadata_1.Metadata(),
	                        }, 'PROCESSED');
	                    }
	                    if (pickResult.subchannel.getConnectivityState() !==
	                        connectivity_state_1.ConnectivityState.READY) {
	                        this.trace('Picked subchannel ' +
	                            subchannelString +
	                            ' has state ' +
	                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +
	                            ' after getting credentials metadata. Retrying pick');
	                        this.doPick();
	                        return;
	                    }
	                    if (this.deadline !== Infinity) {
	                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
	                    }
	                    try {
	                        this.child = pickResult
	                            .subchannel.getRealSubchannel()
	                            .createCall(finalMetadata, this.host, this.methodName, {
	                            onReceiveMetadata: metadata => {
	                                this.trace('Received metadata');
	                                this.listener.onReceiveMetadata(metadata);
	                            },
	                            onReceiveMessage: message => {
	                                this.trace('Received message');
	                                this.listener.onReceiveMessage(message);
	                            },
	                            onReceiveStatus: status => {
	                                this.trace('Received status');
	                                if (status.rstCode ===
	                                    http2.constants.NGHTTP2_REFUSED_STREAM) {
	                                    this.outputStatus(status, 'REFUSED');
	                                }
	                                else {
	                                    this.outputStatus(status, 'PROCESSED');
	                                }
	                            },
	                        });
	                        this.childStartTime = new Date();
	                    }
	                    catch (error) {
	                        this.trace('Failed to start call on picked subchannel ' +
	                            subchannelString +
	                            ' with error ' +
	                            error.message);
	                        this.outputStatus({
	                            code: constants_1.Status.INTERNAL,
	                            details: 'Failed to start HTTP/2 stream with error ' +
	                                error.message,
	                            metadata: new metadata_1.Metadata(),
	                        }, 'NOT_STARTED');
	                        return;
	                    }
	                    (_b = (_a = this.callConfig).onCommitted) === null || _b === undefined ? undefined : _b.call(_a);
	                    (_c = pickResult.onCallStarted) === null || _c === undefined ? undefined : _c.call(pickResult);
	                    this.onCallEnded = pickResult.onCallEnded;
	                    this.trace('Created child call [' + this.child.getCallNumber() + ']');
	                    if (this.readPending) {
	                        this.child.startRead();
	                    }
	                    if (this.pendingMessage) {
	                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
	                    }
	                    if (this.pendingHalfClose) {
	                        this.child.halfClose();
	                    }
	                }, (error) => {
	                    // We assume the error code isn't 0 (Status.OK)
	                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
	                    this.outputStatus({
	                        code: code,
	                        details: details,
	                        metadata: new metadata_1.Metadata(),
	                    }, 'PROCESSED');
	                });
	                break;
	            case picker_1.PickResultType.DROP:
	                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
	                setImmediate(() => {
	                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');
	                });
	                break;
	            case picker_1.PickResultType.TRANSIENT_FAILURE:
	                if (this.metadata.getOptions().waitForReady) {
	                    this.channel.queueCallForPick(this);
	                }
	                else {
	                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
	                    setImmediate(() => {
	                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');
	                    });
	                }
	                break;
	            case picker_1.PickResultType.QUEUE:
	                this.channel.queueCallForPick(this);
	        }
	    }
	    cancelWithStatus(status, details) {
	        var _a;
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        (_a = this.child) === null || _a === undefined ? undefined : _a.cancelWithStatus(status, details);
	        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.child) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : this.channel.getTarget();
	    }
	    start(metadata, listener) {
	        this.trace('start called');
	        this.listener = listener;
	        this.metadata = metadata;
	        this.doPick();
	    }
	    sendMessageWithContext(context, message) {
	        this.trace('write() called with message of length ' + message.length);
	        if (this.child) {
	            this.child.sendMessageWithContext(context, message);
	        }
	        else {
	            this.pendingMessage = { context, message };
	        }
	    }
	    startRead() {
	        this.trace('startRead called');
	        if (this.child) {
	            this.child.startRead();
	        }
	        else {
	            this.readPending = true;
	        }
	    }
	    halfClose() {
	        this.trace('halfClose called');
	        if (this.child) {
	            this.child.halfClose();
	        }
	        else {
	            this.pendingHalfClose = true;
	        }
	    }
	    setCredentials(credentials) {
	        throw new Error('Method not implemented.');
	    }
	    getCallNumber() {
	        return this.callNumber;
	    }
	}
	loadBalancingCall.LoadBalancingCall = LoadBalancingCall;
	
	return loadBalancingCall;
}

var resolvingCall = {};

var hasRequiredResolvingCall;

function requireResolvingCall () {
	if (hasRequiredResolvingCall) return resolvingCall;
	hasRequiredResolvingCall = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(resolvingCall, "__esModule", { value: true });
	resolvingCall.ResolvingCall = undefined;
	const constants_1 = requireConstants();
	const deadline_1 = requireDeadline();
	const metadata_1 = requireMetadata();
	const logging = requireLogging();
	const control_plane_status_1 = requireControlPlaneStatus();
	const TRACER_NAME = 'resolving_call';
	class ResolvingCall {
	    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {
	        this.channel = channel;
	        this.method = method;
	        this.filterStackFactory = filterStackFactory;
	        this.credentials = credentials;
	        this.callNumber = callNumber;
	        this.child = null;
	        this.readPending = false;
	        this.pendingMessage = null;
	        this.pendingHalfClose = false;
	        this.ended = false;
	        this.readFilterPending = false;
	        this.writeFilterPending = false;
	        this.pendingChildStatus = null;
	        this.metadata = null;
	        this.listener = null;
	        this.statusWatchers = [];
	        this.deadlineTimer = setTimeout(() => { }, 0);
	        this.filterStack = null;
	        this.deadlineStartTime = null;
	        this.configReceivedTime = null;
	        this.childStartTime = null;
	        this.deadline = options.deadline;
	        this.host = options.host;
	        if (options.parentCall) {
	            if (options.flags & constants_1.Propagate.CANCELLATION) {
	                options.parentCall.on('cancelled', () => {
	                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');
	                });
	            }
	            if (options.flags & constants_1.Propagate.DEADLINE) {
	                this.trace('Propagating deadline from parent: ' +
	                    options.parentCall.getDeadline());
	                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
	            }
	        }
	        this.trace('Created');
	        this.runDeadlineTimer();
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
	    }
	    runDeadlineTimer() {
	        clearTimeout(this.deadlineTimer);
	        this.deadlineStartTime = new Date();
	        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));
	        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);
	        if (timeout !== Infinity) {
	            this.trace('Deadline will be reached in ' + timeout + 'ms');
	            const handleDeadline = () => {
	                if (!this.deadlineStartTime) {
	                    this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');
	                    return;
	                }
	                const deadlineInfo = [];
	                const deadlineEndTime = new Date();
	                deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
	                if (this.configReceivedTime) {
	                    if (this.configReceivedTime > this.deadlineStartTime) {
	                        deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
	                    }
	                    if (this.childStartTime) {
	                        if (this.childStartTime > this.configReceivedTime) {
	                            deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
	                        }
	                    }
	                    else {
	                        deadlineInfo.push('waiting for metadata filters');
	                    }
	                }
	                else {
	                    deadlineInfo.push('waiting for name resolution');
	                }
	                if (this.child) {
	                    deadlineInfo.push(...this.child.getDeadlineInfo());
	                }
	                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(','));
	            };
	            if (timeout <= 0) {
	                process.nextTick(handleDeadline);
	            }
	            else {
	                this.deadlineTimer = setTimeout(handleDeadline, timeout);
	            }
	        }
	    }
	    outputStatus(status) {
	        if (!this.ended) {
	            this.ended = true;
	            if (!this.filterStack) {
	                this.filterStack = this.filterStackFactory.createFilter();
	            }
	            clearTimeout(this.deadlineTimer);
	            const filteredStatus = this.filterStack.receiveTrailers(status);
	            this.trace('ended with status: code=' +
	                filteredStatus.code +
	                ' details="' +
	                filteredStatus.details +
	                '"');
	            this.statusWatchers.forEach(watcher => watcher(filteredStatus));
	            process.nextTick(() => {
	                var _a;
	                (_a = this.listener) === null || _a === undefined ? undefined : _a.onReceiveStatus(filteredStatus);
	            });
	        }
	    }
	    sendMessageOnChild(context, message) {
	        if (!this.child) {
	            throw new Error('sendMessageonChild called with child not populated');
	        }
	        const child = this.child;
	        this.writeFilterPending = true;
	        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {
	            this.writeFilterPending = false;
	            child.sendMessageWithContext(context, filteredMessage.message);
	            if (this.pendingHalfClose) {
	                child.halfClose();
	            }
	        }, (status) => {
	            this.cancelWithStatus(status.code, status.details);
	        });
	    }
	    getConfig() {
	        if (this.ended) {
	            return;
	        }
	        if (!this.metadata || !this.listener) {
	            throw new Error('getConfig called before start');
	        }
	        const configResult = this.channel.getConfig(this.method, this.metadata);
	        if (configResult.type === 'NONE') {
	            this.channel.queueCallForConfig(this);
	            return;
	        }
	        else if (configResult.type === 'ERROR') {
	            if (this.metadata.getOptions().waitForReady) {
	                this.channel.queueCallForConfig(this);
	            }
	            else {
	                this.outputStatus(configResult.error);
	            }
	            return;
	        }
	        // configResult.type === 'SUCCESS'
	        this.configReceivedTime = new Date();
	        const config = configResult.config;
	        if (config.status !== constants_1.Status.OK) {
	            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);
	            this.outputStatus({
	                code: code,
	                details: details,
	                metadata: new metadata_1.Metadata(),
	            });
	            return;
	        }
	        if (config.methodConfig.timeout) {
	            const configDeadline = new Date();
	            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
	            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +
	                config.methodConfig.timeout.nanos / 1000000);
	            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
	            this.runDeadlineTimer();
	        }
	        this.filterStackFactory.push(config.dynamicFilterFactories);
	        this.filterStack = this.filterStackFactory.createFilter();
	        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {
	            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
	            this.trace('Created child [' + this.child.getCallNumber() + ']');
	            this.childStartTime = new Date();
	            this.child.start(filteredMetadata, {
	                onReceiveMetadata: metadata => {
	                    this.trace('Received metadata');
	                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
	                },
	                onReceiveMessage: message => {
	                    this.trace('Received message');
	                    this.readFilterPending = true;
	                    this.filterStack.receiveMessage(message).then(filteredMesssage => {
	                        this.trace('Finished filtering received message');
	                        this.readFilterPending = false;
	                        this.listener.onReceiveMessage(filteredMesssage);
	                        if (this.pendingChildStatus) {
	                            this.outputStatus(this.pendingChildStatus);
	                        }
	                    }, (status) => {
	                        this.cancelWithStatus(status.code, status.details);
	                    });
	                },
	                onReceiveStatus: status => {
	                    this.trace('Received status');
	                    if (this.readFilterPending) {
	                        this.pendingChildStatus = status;
	                    }
	                    else {
	                        this.outputStatus(status);
	                    }
	                },
	            });
	            if (this.readPending) {
	                this.child.startRead();
	            }
	            if (this.pendingMessage) {
	                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
	            }
	            else if (this.pendingHalfClose) {
	                this.child.halfClose();
	            }
	        }, (status) => {
	            this.outputStatus(status);
	        });
	    }
	    reportResolverError(status) {
	        var _a;
	        if ((_a = this.metadata) === null || _a === undefined ? undefined : _a.getOptions().waitForReady) {
	            this.channel.queueCallForConfig(this);
	        }
	        else {
	            this.outputStatus(status);
	        }
	    }
	    cancelWithStatus(status, details) {
	        var _a;
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        (_a = this.child) === null || _a === undefined ? undefined : _a.cancelWithStatus(status, details);
	        this.outputStatus({
	            code: status,
	            details: details,
	            metadata: new metadata_1.Metadata(),
	        });
	    }
	    getPeer() {
	        var _a, _b;
	        return (_b = (_a = this.child) === null || _a === undefined ? undefined : _a.getPeer()) !== null && _b !== undefined ? _b : this.channel.getTarget();
	    }
	    start(metadata, listener) {
	        this.trace('start called');
	        this.metadata = metadata.clone();
	        this.listener = listener;
	        this.getConfig();
	    }
	    sendMessageWithContext(context, message) {
	        this.trace('write() called with message of length ' + message.length);
	        if (this.child) {
	            this.sendMessageOnChild(context, message);
	        }
	        else {
	            this.pendingMessage = { context, message };
	        }
	    }
	    startRead() {
	        this.trace('startRead called');
	        if (this.child) {
	            this.child.startRead();
	        }
	        else {
	            this.readPending = true;
	        }
	    }
	    halfClose() {
	        this.trace('halfClose called');
	        if (this.child && !this.writeFilterPending) {
	            this.child.halfClose();
	        }
	        else {
	            this.pendingHalfClose = true;
	        }
	    }
	    setCredentials(credentials) {
	        this.credentials = this.credentials.compose(credentials);
	    }
	    addStatusWatcher(watcher) {
	        this.statusWatchers.push(watcher);
	    }
	    getCallNumber() {
	        return this.callNumber;
	    }
	}
	resolvingCall.ResolvingCall = ResolvingCall;
	
	return resolvingCall;
}

var retryingCall = {};

var hasRequiredRetryingCall;

function requireRetryingCall () {
	if (hasRequiredRetryingCall) return retryingCall;
	hasRequiredRetryingCall = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(retryingCall, "__esModule", { value: true });
	retryingCall.RetryingCall = retryingCall.MessageBufferTracker = retryingCall.RetryThrottler = undefined;
	const constants_1 = requireConstants();
	const deadline_1 = requireDeadline();
	const metadata_1 = requireMetadata();
	const logging = requireLogging();
	const TRACER_NAME = 'retrying_call';
	class RetryThrottler {
	    constructor(maxTokens, tokenRatio, previousRetryThrottler) {
	        this.maxTokens = maxTokens;
	        this.tokenRatio = tokenRatio;
	        if (previousRetryThrottler) {
	            /* When carrying over tokens from a previous config, rescale them to the
	             * new max value */
	            this.tokens =
	                previousRetryThrottler.tokens *
	                    (maxTokens / previousRetryThrottler.maxTokens);
	        }
	        else {
	            this.tokens = maxTokens;
	        }
	    }
	    addCallSucceeded() {
	        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
	    }
	    addCallFailed() {
	        this.tokens = Math.min(this.tokens - 1, 0);
	    }
	    canRetryCall() {
	        return this.tokens > this.maxTokens / 2;
	    }
	}
	retryingCall.RetryThrottler = RetryThrottler;
	class MessageBufferTracker {
	    constructor(totalLimit, limitPerCall) {
	        this.totalLimit = totalLimit;
	        this.limitPerCall = limitPerCall;
	        this.totalAllocated = 0;
	        this.allocatedPerCall = new Map();
	    }
	    allocate(size, callId) {
	        var _a;
	        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
	        if (this.limitPerCall - currentPerCall < size ||
	            this.totalLimit - this.totalAllocated < size) {
	            return false;
	        }
	        this.allocatedPerCall.set(callId, currentPerCall + size);
	        this.totalAllocated += size;
	        return true;
	    }
	    free(size, callId) {
	        var _a;
	        if (this.totalAllocated < size) {
	            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
	        }
	        this.totalAllocated -= size;
	        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
	        if (currentPerCall < size) {
	            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
	        }
	        this.allocatedPerCall.set(callId, currentPerCall - size);
	    }
	    freeAll(callId) {
	        var _a;
	        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== undefined ? _a : 0;
	        if (this.totalAllocated < currentPerCall) {
	            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
	        }
	        this.totalAllocated -= currentPerCall;
	        this.allocatedPerCall.delete(callId);
	    }
	}
	retryingCall.MessageBufferTracker = MessageBufferTracker;
	const PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';
	const DEFAULT_MAX_ATTEMPTS_LIMIT = 5;
	class RetryingCall {
	    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
	        var _a;
	        this.channel = channel;
	        this.callConfig = callConfig;
	        this.methodName = methodName;
	        this.host = host;
	        this.credentials = credentials;
	        this.deadline = deadline;
	        this.callNumber = callNumber;
	        this.bufferTracker = bufferTracker;
	        this.retryThrottler = retryThrottler;
	        this.listener = null;
	        this.initialMetadata = null;
	        this.underlyingCalls = [];
	        this.writeBuffer = [];
	        /**
	         * The offset of message indices in the writeBuffer. For example, if
	         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15
	         * is in writeBuffer[5].
	         */
	        this.writeBufferOffset = 0;
	        /**
	         * Tracks whether a read has been started, so that we know whether to start
	         * reads on new child calls. This only matters for the first read, because
	         * once a message comes in the child call becomes committed and there will
	         * be no new child calls.
	         */
	        this.readStarted = false;
	        this.transparentRetryUsed = false;
	        /**
	         * Number of attempts so far
	         */
	        this.attempts = 0;
	        this.hedgingTimer = null;
	        this.committedCallIndex = null;
	        this.initialRetryBackoffSec = 0;
	        this.nextRetryBackoffSec = 0;
	        const maxAttemptsLimit = (_a = channel.getOptions()['grpc-node.retry_max_attempts_limit']) !== null && _a !== undefined ? _a : DEFAULT_MAX_ATTEMPTS_LIMIT;
	        if (callConfig.methodConfig.retryPolicy) {
	            this.state = 'RETRY';
	            const retryPolicy = callConfig.methodConfig.retryPolicy;
	            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
	            this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
	        }
	        else if (callConfig.methodConfig.hedgingPolicy) {
	            this.state = 'HEDGING';
	            this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
	        }
	        else {
	            this.state = 'TRANSPARENT_ONLY';
	            this.maxAttempts = 1;
	        }
	        this.startTime = new Date();
	    }
	    getDeadlineInfo() {
	        if (this.underlyingCalls.length === 0) {
	            return [];
	        }
	        const deadlineInfo = [];
	        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
	        if (this.underlyingCalls.length > 1) {
	            deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
	        }
	        if (latestCall.startTime > this.startTime) {
	            deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
	        }
	        deadlineInfo.push(...latestCall.call.getDeadlineInfo());
	        return deadlineInfo;
	    }
	    getCallNumber() {
	        return this.callNumber;
	    }
	    trace(text) {
	        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);
	    }
	    reportStatus(statusObject) {
	        this.trace('ended with status: code=' +
	            statusObject.code +
	            ' details="' +
	            statusObject.details +
	            '" start time=' +
	            this.startTime.toISOString());
	        this.bufferTracker.freeAll(this.callNumber);
	        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
	        this.writeBuffer = [];
	        process.nextTick(() => {
	            var _a;
	            // Explicitly construct status object to remove progress field
	            (_a = this.listener) === null || _a === undefined ? undefined : _a.onReceiveStatus({
	                code: statusObject.code,
	                details: statusObject.details,
	                metadata: statusObject.metadata,
	            });
	        });
	    }
	    cancelWithStatus(status, details) {
	        this.trace('cancelWithStatus code: ' + status + ' details: "' + details + '"');
	        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });
	        for (const { call } of this.underlyingCalls) {
	            call.cancelWithStatus(status, details);
	        }
	    }
	    getPeer() {
	        if (this.committedCallIndex !== null) {
	            return this.underlyingCalls[this.committedCallIndex].call.getPeer();
	        }
	        else {
	            return 'unknown';
	        }
	    }
	    getBufferEntry(messageIndex) {
	        var _a;
	        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== undefined ? _a : {
	            entryType: 'FREED',
	            allocated: false,
	        });
	    }
	    getNextBufferIndex() {
	        return this.writeBufferOffset + this.writeBuffer.length;
	    }
	    clearSentMessages() {
	        if (this.state !== 'COMMITTED') {
	            return;
	        }
	        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
	        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {
	            const bufferEntry = this.getBufferEntry(messageIndex);
	            if (bufferEntry.allocated) {
	                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
	            }
	        }
	        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
	        this.writeBufferOffset = earliestNeededMessageIndex;
	    }
	    commitCall(index) {
	        if (this.state === 'COMMITTED') {
	            return;
	        }
	        if (this.underlyingCalls[index].state === 'COMPLETED') {
	            return;
	        }
	        this.trace('Committing call [' +
	            this.underlyingCalls[index].call.getCallNumber() +
	            '] at index ' +
	            index);
	        this.state = 'COMMITTED';
	        this.committedCallIndex = index;
	        for (let i = 0; i < this.underlyingCalls.length; i++) {
	            if (i === index) {
	                continue;
	            }
	            if (this.underlyingCalls[i].state === 'COMPLETED') {
	                continue;
	            }
	            this.underlyingCalls[i].state = 'COMPLETED';
	            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');
	        }
	        this.clearSentMessages();
	    }
	    commitCallWithMostMessages() {
	        if (this.state === 'COMMITTED') {
	            return;
	        }
	        let mostMessages = -1;
	        let callWithMostMessages = -1;
	        for (const [index, childCall] of this.underlyingCalls.entries()) {
	            if (childCall.state === 'ACTIVE' &&
	                childCall.nextMessageToSend > mostMessages) {
	                mostMessages = childCall.nextMessageToSend;
	                callWithMostMessages = index;
	            }
	        }
	        if (callWithMostMessages === -1) {
	            /* There are no active calls, disable retries to force the next call that
	             * is started to be committed. */
	            this.state = 'TRANSPARENT_ONLY';
	        }
	        else {
	            this.commitCall(callWithMostMessages);
	        }
	    }
	    isStatusCodeInList(list, code) {
	        return list.some(value => {
	            var _a;
	            return value === code ||
	                value.toString().toLowerCase() === ((_a = constants_1.Status[code]) === null || _a === undefined ? undefined : _a.toLowerCase());
	        });
	    }
	    getNextRetryBackoffMs() {
	        var _a;
	        const retryPolicy = (_a = this.callConfig) === null || _a === undefined ? undefined : _a.methodConfig.retryPolicy;
	        if (!retryPolicy) {
	            return 0;
	        }
	        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;
	        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
	        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
	        return nextBackoffMs;
	    }
	    maybeRetryCall(pushback, callback) {
	        if (this.state !== 'RETRY') {
	            callback(false);
	            return;
	        }
	        if (this.attempts >= this.maxAttempts) {
	            callback(false);
	            return;
	        }
	        let retryDelayMs;
	        if (pushback === null) {
	            retryDelayMs = this.getNextRetryBackoffMs();
	        }
	        else if (pushback < 0) {
	            this.state = 'TRANSPARENT_ONLY';
	            callback(false);
	            return;
	        }
	        else {
	            retryDelayMs = pushback;
	            this.nextRetryBackoffSec = this.initialRetryBackoffSec;
	        }
	        setTimeout(() => {
	            var _a, _b;
	            if (this.state !== 'RETRY') {
	                callback(false);
	                return;
	            }
	            if ((_b = (_a = this.retryThrottler) === null || _a === undefined ? undefined : _a.canRetryCall()) !== null && _b !== undefined ? _b : true) {
	                callback(true);
	                this.attempts += 1;
	                this.startNewAttempt();
	            }
	        }, retryDelayMs);
	    }
	    countActiveCalls() {
	        let count = 0;
	        for (const call of this.underlyingCalls) {
	            if ((call === null || call === undefined ? undefined : call.state) === 'ACTIVE') {
	                count += 1;
	            }
	        }
	        return count;
	    }
	    handleProcessedStatus(status, callIndex, pushback) {
	        var _a, _b, _c;
	        switch (this.state) {
	            case 'COMMITTED':
	            case 'TRANSPARENT_ONLY':
	                this.commitCall(callIndex);
	                this.reportStatus(status);
	                break;
	            case 'HEDGING':
	                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== undefined ? _a : [], status.code)) {
	                    (_b = this.retryThrottler) === null || _b === undefined ? undefined : _b.addCallFailed();
	                    let delayMs;
	                    if (pushback === null) {
	                        delayMs = 0;
	                    }
	                    else if (pushback < 0) {
	                        this.state = 'TRANSPARENT_ONLY';
	                        this.commitCall(callIndex);
	                        this.reportStatus(status);
	                        return;
	                    }
	                    else {
	                        delayMs = pushback;
	                    }
	                    setTimeout(() => {
	                        this.maybeStartHedgingAttempt();
	                        // If after trying to start a call there are no active calls, this was the last one
	                        if (this.countActiveCalls() === 0) {
	                            this.commitCall(callIndex);
	                            this.reportStatus(status);
	                        }
	                    }, delayMs);
	                }
	                else {
	                    this.commitCall(callIndex);
	                    this.reportStatus(status);
	                }
	                break;
	            case 'RETRY':
	                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
	                    (_c = this.retryThrottler) === null || _c === undefined ? undefined : _c.addCallFailed();
	                    this.maybeRetryCall(pushback, retried => {
	                        if (!retried) {
	                            this.commitCall(callIndex);
	                            this.reportStatus(status);
	                        }
	                    });
	                }
	                else {
	                    this.commitCall(callIndex);
	                    this.reportStatus(status);
	                }
	                break;
	        }
	    }
	    getPushback(metadata) {
	        const mdValue = metadata.get('grpc-retry-pushback-ms');
	        if (mdValue.length === 0) {
	            return null;
	        }
	        try {
	            return parseInt(mdValue[0]);
	        }
	        catch (e) {
	            return -1;
	        }
	    }
	    handleChildStatus(status, callIndex) {
	        var _a;
	        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {
	            return;
	        }
	        this.trace('state=' +
	            this.state +
	            ' handling status with progress ' +
	            status.progress +
	            ' from child [' +
	            this.underlyingCalls[callIndex].call.getCallNumber() +
	            '] in state ' +
	            this.underlyingCalls[callIndex].state);
	        this.underlyingCalls[callIndex].state = 'COMPLETED';
	        if (status.code === constants_1.Status.OK) {
	            (_a = this.retryThrottler) === null || _a === undefined ? undefined : _a.addCallSucceeded();
	            this.commitCall(callIndex);
	            this.reportStatus(status);
	            return;
	        }
	        if (this.state === 'COMMITTED') {
	            this.reportStatus(status);
	            return;
	        }
	        const pushback = this.getPushback(status.metadata);
	        switch (status.progress) {
	            case 'NOT_STARTED':
	                // RPC never leaves the client, always safe to retry
	                this.startNewAttempt();
	                break;
	            case 'REFUSED':
	                // RPC reaches the server library, but not the server application logic
	                if (this.transparentRetryUsed) {
	                    this.handleProcessedStatus(status, callIndex, pushback);
	                }
	                else {
	                    this.transparentRetryUsed = true;
	                    this.startNewAttempt();
	                }
	                break;
	            case 'DROP':
	                this.commitCall(callIndex);
	                this.reportStatus(status);
	                break;
	            case 'PROCESSED':
	                this.handleProcessedStatus(status, callIndex, pushback);
	                break;
	        }
	    }
	    maybeStartHedgingAttempt() {
	        if (this.state !== 'HEDGING') {
	            return;
	        }
	        if (!this.callConfig.methodConfig.hedgingPolicy) {
	            return;
	        }
	        if (this.attempts >= this.maxAttempts) {
	            return;
	        }
	        this.attempts += 1;
	        this.startNewAttempt();
	        this.maybeStartHedgingTimer();
	    }
	    maybeStartHedgingTimer() {
	        var _a, _b, _c;
	        if (this.hedgingTimer) {
	            clearTimeout(this.hedgingTimer);
	        }
	        if (this.state !== 'HEDGING') {
	            return;
	        }
	        if (!this.callConfig.methodConfig.hedgingPolicy) {
	            return;
	        }
	        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
	        if (this.attempts >= this.maxAttempts) {
	            return;
	        }
	        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== undefined ? _a : '0s';
	        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
	        this.hedgingTimer = setTimeout(() => {
	            this.maybeStartHedgingAttempt();
	        }, hedgingDelaySec * 1000);
	        (_c = (_b = this.hedgingTimer).unref) === null || _c === undefined ? undefined : _c.call(_b);
	    }
	    startNewAttempt() {
	        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
	        this.trace('Created child call [' +
	            child.getCallNumber() +
	            '] for attempt ' +
	            this.attempts);
	        const index = this.underlyingCalls.length;
	        this.underlyingCalls.push({
	            state: 'ACTIVE',
	            call: child,
	            nextMessageToSend: 0,
	            startTime: new Date()
	        });
	        const previousAttempts = this.attempts - 1;
	        const initialMetadata = this.initialMetadata.clone();
	        if (previousAttempts > 0) {
	            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
	        }
	        let receivedMetadata = false;
	        child.start(initialMetadata, {
	            onReceiveMetadata: metadata => {
	                this.trace('Received metadata from child [' + child.getCallNumber() + ']');
	                this.commitCall(index);
	                receivedMetadata = true;
	                if (previousAttempts > 0) {
	                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
	                }
	                if (this.underlyingCalls[index].state === 'ACTIVE') {
	                    this.listener.onReceiveMetadata(metadata);
	                }
	            },
	            onReceiveMessage: message => {
	                this.trace('Received message from child [' + child.getCallNumber() + ']');
	                this.commitCall(index);
	                if (this.underlyingCalls[index].state === 'ACTIVE') {
	                    this.listener.onReceiveMessage(message);
	                }
	            },
	            onReceiveStatus: status => {
	                this.trace('Received status from child [' + child.getCallNumber() + ']');
	                if (!receivedMetadata && previousAttempts > 0) {
	                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
	                }
	                this.handleChildStatus(status, index);
	            },
	        });
	        this.sendNextChildMessage(index);
	        if (this.readStarted) {
	            child.startRead();
	        }
	    }
	    start(metadata, listener) {
	        this.trace('start called');
	        this.listener = listener;
	        this.initialMetadata = metadata;
	        this.attempts += 1;
	        this.startNewAttempt();
	        this.maybeStartHedgingTimer();
	    }
	    handleChildWriteCompleted(childIndex) {
	        var _a, _b;
	        const childCall = this.underlyingCalls[childIndex];
	        const messageIndex = childCall.nextMessageToSend;
	        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === undefined ? undefined : _b.call(_a);
	        this.clearSentMessages();
	        childCall.nextMessageToSend += 1;
	        this.sendNextChildMessage(childIndex);
	    }
	    sendNextChildMessage(childIndex) {
	        const childCall = this.underlyingCalls[childIndex];
	        if (childCall.state === 'COMPLETED') {
	            return;
	        }
	        if (this.getBufferEntry(childCall.nextMessageToSend)) {
	            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
	            switch (bufferEntry.entryType) {
	                case 'MESSAGE':
	                    childCall.call.sendMessageWithContext({
	                        callback: error => {
	                            // Ignore error
	                            this.handleChildWriteCompleted(childIndex);
	                        },
	                    }, bufferEntry.message.message);
	                    break;
	                case 'HALF_CLOSE':
	                    childCall.nextMessageToSend += 1;
	                    childCall.call.halfClose();
	                    break;
	            }
	        }
	    }
	    sendMessageWithContext(context, message) {
	        var _a;
	        this.trace('write() called with message of length ' + message.length);
	        const writeObj = {
	            message,
	            flags: context.flags,
	        };
	        const messageIndex = this.getNextBufferIndex();
	        const bufferEntry = {
	            entryType: 'MESSAGE',
	            message: writeObj,
	            allocated: this.bufferTracker.allocate(message.length, this.callNumber),
	        };
	        this.writeBuffer.push(bufferEntry);
	        if (bufferEntry.allocated) {
	            (_a = context.callback) === null || _a === undefined ? undefined : _a.call(context);
	            for (const [callIndex, call] of this.underlyingCalls.entries()) {
	                if (call.state === 'ACTIVE' &&
	                    call.nextMessageToSend === messageIndex) {
	                    call.call.sendMessageWithContext({
	                        callback: error => {
	                            // Ignore error
	                            this.handleChildWriteCompleted(callIndex);
	                        },
	                    }, message);
	                }
	            }
	        }
	        else {
	            this.commitCallWithMostMessages();
	            // commitCallWithMostMessages can fail if we are between ping attempts
	            if (this.committedCallIndex === null) {
	                return;
	            }
	            const call = this.underlyingCalls[this.committedCallIndex];
	            bufferEntry.callback = context.callback;
	            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {
	                call.call.sendMessageWithContext({
	                    callback: error => {
	                        // Ignore error
	                        this.handleChildWriteCompleted(this.committedCallIndex);
	                    },
	                }, message);
	            }
	        }
	    }
	    startRead() {
	        this.trace('startRead called');
	        this.readStarted = true;
	        for (const underlyingCall of this.underlyingCalls) {
	            if ((underlyingCall === null || underlyingCall === undefined ? undefined : underlyingCall.state) === 'ACTIVE') {
	                underlyingCall.call.startRead();
	            }
	        }
	    }
	    halfClose() {
	        this.trace('halfClose called');
	        const halfCloseIndex = this.getNextBufferIndex();
	        this.writeBuffer.push({
	            entryType: 'HALF_CLOSE',
	            allocated: false,
	        });
	        for (const call of this.underlyingCalls) {
	            if ((call === null || call === undefined ? undefined : call.state) === 'ACTIVE' &&
	                call.nextMessageToSend === halfCloseIndex) {
	                call.nextMessageToSend += 1;
	                call.call.halfClose();
	            }
	        }
	    }
	    setCredentials(newCredentials) {
	        throw new Error('Method not implemented.');
	    }
	    getMethod() {
	        return this.methodName;
	    }
	    getHost() {
	        return this.host;
	    }
	}
	retryingCall.RetryingCall = RetryingCall;
	
	return retryingCall;
}

var subchannelInterface = {};

var hasRequiredSubchannelInterface;

function requireSubchannelInterface () {
	if (hasRequiredSubchannelInterface) return subchannelInterface;
	hasRequiredSubchannelInterface = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(subchannelInterface, "__esModule", { value: true });
	subchannelInterface.BaseSubchannelWrapper = undefined;
	class BaseSubchannelWrapper {
	    constructor(child) {
	        this.child = child;
	        this.healthy = true;
	        this.healthListeners = new Set();
	        child.addHealthStateWatcher(childHealthy => {
	            /* A change to the child health state only affects this wrapper's overall
	             * health state if this wrapper is reporting healthy. */
	            if (this.healthy) {
	                this.updateHealthListeners();
	            }
	        });
	    }
	    updateHealthListeners() {
	        for (const listener of this.healthListeners) {
	            listener(this.isHealthy());
	        }
	    }
	    getConnectivityState() {
	        return this.child.getConnectivityState();
	    }
	    addConnectivityStateListener(listener) {
	        this.child.addConnectivityStateListener(listener);
	    }
	    removeConnectivityStateListener(listener) {
	        this.child.removeConnectivityStateListener(listener);
	    }
	    startConnecting() {
	        this.child.startConnecting();
	    }
	    getAddress() {
	        return this.child.getAddress();
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        this.child.throttleKeepalive(newKeepaliveTime);
	    }
	    ref() {
	        this.child.ref();
	    }
	    unref() {
	        this.child.unref();
	    }
	    getChannelzRef() {
	        return this.child.getChannelzRef();
	    }
	    isHealthy() {
	        return this.healthy && this.child.isHealthy();
	    }
	    addHealthStateWatcher(listener) {
	        this.healthListeners.add(listener);
	    }
	    removeHealthStateWatcher(listener) {
	        this.healthListeners.delete(listener);
	    }
	    setHealthy(healthy) {
	        if (healthy !== this.healthy) {
	            this.healthy = healthy;
	            /* A change to this wrapper's health state only affects the overall
	             * reported health state if the child is healthy. */
	            if (this.child.isHealthy()) {
	                this.updateHealthListeners();
	            }
	        }
	    }
	    getRealSubchannel() {
	        return this.child.getRealSubchannel();
	    }
	    realSubchannelEquals(other) {
	        return this.getRealSubchannel() === other.getRealSubchannel();
	    }
	}
	subchannelInterface.BaseSubchannelWrapper = BaseSubchannelWrapper;
	
	return subchannelInterface;
}

var hasRequiredInternalChannel;

function requireInternalChannel () {
	if (hasRequiredInternalChannel) return internalChannel;
	hasRequiredInternalChannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(internalChannel, "__esModule", { value: true });
	internalChannel.InternalChannel = undefined;
	const channel_credentials_1 = requireChannelCredentials();
	const resolving_load_balancer_1 = requireResolvingLoadBalancer();
	const subchannel_pool_1 = requireSubchannelPool();
	const picker_1 = requirePicker();
	const metadata_1 = requireMetadata();
	const constants_1 = requireConstants();
	const filter_stack_1 = requireFilterStack();
	const compression_filter_1 = requireCompressionFilter();
	const resolver_1 = requireResolver();
	const logging_1 = requireLogging();
	const http_proxy_1 = requireHttp_proxy();
	const uri_parser_1 = requireUriParser();
	const connectivity_state_1 = requireConnectivityState();
	const channelz_1 = requireChannelz();
	const load_balancing_call_1 = requireLoadBalancingCall();
	const deadline_1 = requireDeadline();
	const resolving_call_1 = requireResolvingCall();
	const call_number_1 = requireCallNumber();
	const control_plane_status_1 = requireControlPlaneStatus();
	const retrying_call_1 = requireRetryingCall();
	const subchannel_interface_1 = requireSubchannelInterface();
	/**
	 * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args
	 */
	const MAX_TIMEOUT_TIME = 2147483647;
	const MIN_IDLE_TIMEOUT_MS = 1000;
	// 30 minutes
	const DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;
	const RETRY_THROTTLER_MAP = new Map();
	const DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB
	const DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB
	class ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
	    constructor(childSubchannel, channel) {
	        super(childSubchannel);
	        this.channel = channel;
	        this.refCount = 0;
	        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
	            channel.throttleKeepalive(keepaliveTime);
	        };
	        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);
	    }
	    ref() {
	        this.child.ref();
	        this.refCount += 1;
	    }
	    unref() {
	        this.child.unref();
	        this.refCount -= 1;
	        if (this.refCount <= 0) {
	            this.child.removeConnectivityStateListener(this.subchannelStateListener);
	            this.channel.removeWrappedSubchannel(this);
	        }
	    }
	}
	class ShutdownPicker {
	    pick(pickArgs) {
	        return {
	            pickResultType: picker_1.PickResultType.DROP,
	            status: {
	                code: constants_1.Status.UNAVAILABLE,
	                details: 'Channel closed before call started',
	                metadata: new metadata_1.Metadata()
	            },
	            subchannel: null,
	            onCallStarted: null,
	            onCallEnded: null
	        };
	    }
	}
	class InternalChannel {
	    constructor(target, credentials, options) {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        this.credentials = credentials;
	        this.options = options;
	        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
	        this.currentPicker = new picker_1.UnavailablePicker();
	        /**
	         * Calls queued up to get a call config. Should only be populated before the
	         * first time the resolver returns a result, which includes the ConfigSelector.
	         */
	        this.configSelectionQueue = [];
	        this.pickQueue = [];
	        this.connectivityStateWatchers = [];
	        this.configSelector = null;
	        /**
	         * This is the error from the name resolver if it failed most recently. It
	         * is only used to end calls that start while there is no config selector
	         * and the name resolver is in backoff, so it should be nulled if
	         * configSelector becomes set or the channel state becomes anything other
	         * than TRANSIENT_FAILURE.
	         */
	        this.currentResolutionError = null;
	        this.wrappedSubchannels = new Set();
	        this.callCount = 0;
	        this.idleTimer = null;
	        // Channelz info
	        this.channelzEnabled = true;
	        this.callTracker = new channelz_1.ChannelzCallTracker();
	        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
	        /**
	         * Randomly generated ID to be passed to the config selector, for use by
	         * ring_hash in xDS. An integer distributed approximately uniformly between
	         * 0 and MAX_SAFE_INTEGER.
	         */
	        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
	        if (typeof target !== 'string') {
	            throw new TypeError('Channel target must be a string');
	        }
	        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
	            throw new TypeError('Channel credentials must be a ChannelCredentials object');
	        }
	        if (options) {
	            if (typeof options !== 'object') {
	                throw new TypeError('Channel options must be an object');
	            }
	        }
	        this.originalTarget = target;
	        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
	        if (originalTargetUri === null) {
	            throw new Error(`Could not parse target name "${target}"`);
	        }
	        /* This ensures that the target has a scheme that is registered with the
	         * resolver */
	        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
	        if (defaultSchemeMapResult === null) {
	            throw new Error(`Could not find a default scheme for target name "${target}"`);
	        }
	        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);
	        (_b = (_a = this.callRefTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        if (this.options['grpc.enable_channelz'] === 0) {
	            this.channelzEnabled = false;
	        }
	        this.channelzTrace = new channelz_1.ChannelzTrace();
	        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Channel created');
	        }
	        if (this.options['grpc.default_authority']) {
	            this.defaultAuthority = this.options['grpc.default_authority'];
	        }
	        else {
	            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
	        }
	        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
	        this.target = proxyMapResult.target;
	        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
	        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what
	         * the grpc.use_local_subchannel_pool channel option means. */
	        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== undefined ? _c : 0) === 0);
	        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== undefined ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== undefined ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
	        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== undefined ? _f : -1;
	        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== undefined ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
	        const channelControlHelper = {
	            createSubchannel: (subchannelAddress, subchannelArgs, credentialsOverride) => {
	                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), credentialsOverride !== null && credentialsOverride !== undefined ? credentialsOverride : this.credentials);
	                subchannel.throttleKeepalive(this.keepaliveTime);
	                if (this.channelzEnabled) {
	                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());
	                }
	                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
	                this.wrappedSubchannels.add(wrappedSubchannel);
	                return wrappedSubchannel;
	            },
	            updateState: (connectivityState, picker) => {
	                this.currentPicker = picker;
	                const queueCopy = this.pickQueue.slice();
	                this.pickQueue = [];
	                if (queueCopy.length > 0) {
	                    this.callRefTimerUnref();
	                }
	                for (const call of queueCopy) {
	                    call.doPick();
	                }
	                this.updateState(connectivityState);
	            },
	            requestReresolution: () => {
	                // This should never be called.
	                throw new Error('Resolving load balancer should never call requestReresolution');
	            },
	            addChannelzChild: (child) => {
	                if (this.channelzEnabled) {
	                    this.childrenTracker.refChild(child);
	                }
	            },
	            removeChannelzChild: (child) => {
	                if (this.channelzEnabled) {
	                    this.childrenTracker.unrefChild(child);
	                }
	            },
	        };
	        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, credentials, options, (serviceConfig, configSelector) => {
	            if (serviceConfig.retryThrottling) {
	                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
	            }
	            else {
	                RETRY_THROTTLER_MAP.delete(this.getTarget());
	            }
	            if (this.channelzEnabled) {
	                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');
	            }
	            this.configSelector = configSelector;
	            this.currentResolutionError = null;
	            /* We process the queue asynchronously to ensure that the corresponding
	             * load balancer update has completed. */
	            process.nextTick(() => {
	                const localQueue = this.configSelectionQueue;
	                this.configSelectionQueue = [];
	                if (localQueue.length > 0) {
	                    this.callRefTimerUnref();
	                }
	                for (const call of localQueue) {
	                    call.getConfig();
	                }
	            });
	        }, status => {
	            if (this.channelzEnabled) {
	                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +
	                    status.code +
	                    ' and details "' +
	                    status.details +
	                    '"');
	            }
	            if (this.configSelectionQueue.length > 0) {
	                this.trace('Name resolution failed with calls queued for config selection');
	            }
	            if (this.configSelector === null) {
	                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
	            }
	            const localQueue = this.configSelectionQueue;
	            this.configSelectionQueue = [];
	            if (localQueue.length > 0) {
	                this.callRefTimerUnref();
	            }
	            for (const call of localQueue) {
	                call.reportResolverError(status);
	            }
	        });
	        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
	            new compression_filter_1.CompressionFilterFactory(this, this.options),
	        ]);
	        this.trace('Channel constructed with options ' +
	            JSON.stringify(options, undefined, 2));
	        const error = new Error();
	        if ((0, logging_1.isTracerEnabled)('channel_stacktrace')) {
	            (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +
	                this.channelzRef.id +
	                ') ' +
	                'Channel constructed \n' +
	                ((_h = error.stack) === null || _h === undefined ? undefined : _h.substring(error.stack.indexOf('\n') + 1)));
	        }
	        this.lastActivityTimestamp = new Date();
	    }
	    getChannelzInfo() {
	        return {
	            target: this.originalTarget,
	            state: this.connectivityState,
	            trace: this.channelzTrace,
	            callTracker: this.callTracker,
	            children: this.childrenTracker.getChildLists(),
	        };
	    }
	    trace(text, verbosityOverride) {
	        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== undefined ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);
	    }
	    callRefTimerRef() {
	        var _a, _b, _c, _d;
	        // If the hasRef function does not exist, always run the code
	        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === undefined ? undefined : _b.call(_a))) {
	            this.trace('callRefTimer.ref | configSelectionQueue.length=' +
	                this.configSelectionQueue.length +
	                ' pickQueue.length=' +
	                this.pickQueue.length);
	            (_d = (_c = this.callRefTimer).ref) === null || _d === undefined ? undefined : _d.call(_c);
	        }
	    }
	    callRefTimerUnref() {
	        var _a, _b;
	        // If the hasRef function does not exist, always run the code
	        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
	            this.trace('callRefTimer.unref | configSelectionQueue.length=' +
	                this.configSelectionQueue.length +
	                ' pickQueue.length=' +
	                this.pickQueue.length);
	            (_b = (_a = this.callRefTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	        }
	    }
	    removeConnectivityStateWatcher(watcherObject) {
	        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);
	        if (watcherIndex >= 0) {
	            this.connectivityStateWatchers.splice(watcherIndex, 1);
	        }
	    }
	    updateState(newState) {
	        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +
	            this.channelzRef.id +
	            ') ' +
	            (0, uri_parser_1.uriToString)(this.target) +
	            ' ' +
	            connectivity_state_1.ConnectivityState[this.connectivityState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (this.channelzEnabled) {
	            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);
	        }
	        this.connectivityState = newState;
	        const watchersCopy = this.connectivityStateWatchers.slice();
	        for (const watcherObject of watchersCopy) {
	            if (newState !== watcherObject.currentState) {
	                if (watcherObject.timer) {
	                    clearTimeout(watcherObject.timer);
	                }
	                this.removeConnectivityStateWatcher(watcherObject);
	                watcherObject.callback();
	            }
	        }
	        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	            this.currentResolutionError = null;
	        }
	    }
	    throttleKeepalive(newKeepaliveTime) {
	        if (newKeepaliveTime > this.keepaliveTime) {
	            this.keepaliveTime = newKeepaliveTime;
	            for (const wrappedSubchannel of this.wrappedSubchannels) {
	                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
	            }
	        }
	    }
	    removeWrappedSubchannel(wrappedSubchannel) {
	        this.wrappedSubchannels.delete(wrappedSubchannel);
	    }
	    doPick(metadata, extraPickInfo) {
	        return this.currentPicker.pick({
	            metadata: metadata,
	            extraPickInfo: extraPickInfo,
	        });
	    }
	    queueCallForPick(call) {
	        this.pickQueue.push(call);
	        this.callRefTimerRef();
	    }
	    getConfig(method, metadata) {
	        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            this.resolvingLoadBalancer.exitIdle();
	        }
	        if (this.configSelector) {
	            return {
	                type: 'SUCCESS',
	                config: this.configSelector(method, metadata, this.randomChannelId),
	            };
	        }
	        else {
	            if (this.currentResolutionError) {
	                return {
	                    type: 'ERROR',
	                    error: this.currentResolutionError,
	                };
	            }
	            else {
	                return {
	                    type: 'NONE',
	                };
	            }
	        }
	    }
	    queueCallForConfig(call) {
	        this.configSelectionQueue.push(call);
	        this.callRefTimerRef();
	    }
	    enterIdle() {
	        this.resolvingLoadBalancer.destroy();
	        this.updateState(connectivity_state_1.ConnectivityState.IDLE);
	        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
	        if (this.idleTimer) {
	            clearTimeout(this.idleTimer);
	            this.idleTimer = null;
	        }
	    }
	    startIdleTimeout(timeoutMs) {
	        var _a, _b;
	        this.idleTimer = setTimeout(() => {
	            if (this.callCount > 0) {
	                /* If there is currently a call, the channel will not go idle for a
	                 * period of at least idleTimeoutMs, so check again after that time.
	                 */
	                this.startIdleTimeout(this.idleTimeoutMs);
	                return;
	            }
	            const now = new Date();
	            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
	            if (timeSinceLastActivity >= this.idleTimeoutMs) {
	                this.trace('Idle timer triggered after ' +
	                    this.idleTimeoutMs +
	                    'ms of inactivity');
	                this.enterIdle();
	            }
	            else {
	                /* Whenever the timer fires with the latest activity being too recent,
	                 * set the timer again for the time when the time since the last
	                 * activity is equal to the timeout. This should result in the timer
	                 * firing no more than once every idleTimeoutMs/2 on average. */
	                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
	            }
	        }, timeoutMs);
	        (_b = (_a = this.idleTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    maybeStartIdleTimer() {
	        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN &&
	            !this.idleTimer) {
	            this.startIdleTimeout(this.idleTimeoutMs);
	        }
	    }
	    onCallStart() {
	        if (this.channelzEnabled) {
	            this.callTracker.addCallStarted();
	        }
	        this.callCount += 1;
	    }
	    onCallEnd(status) {
	        if (this.channelzEnabled) {
	            if (status.code === constants_1.Status.OK) {
	                this.callTracker.addCallSucceeded();
	            }
	            else {
	                this.callTracker.addCallFailed();
	            }
	        }
	        this.callCount -= 1;
	        this.lastActivityTimestamp = new Date();
	        this.maybeStartIdleTimer();
	    }
	    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createLoadBalancingCall [' + callNumber + '] method="' + method + '"');
	        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
	    }
	    createRetryingCall(callConfig, method, host, credentials, deadline) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createRetryingCall [' + callNumber + '] method="' + method + '"');
	        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
	    }
	    createInnerCall(callConfig, method, host, credentials, deadline) {
	        // Create a RetryingCall if retries are enabled
	        if (this.options['grpc.enable_retries'] === 0) {
	            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
	        }
	        else {
	            return this.createRetryingCall(callConfig, method, host, credentials, deadline);
	        }
	    }
	    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
	        const callNumber = (0, call_number_1.getNextCallNumber)();
	        this.trace('createResolvingCall [' +
	            callNumber +
	            '] method="' +
	            method +
	            '", deadline=' +
	            (0, deadline_1.deadlineToString)(deadline));
	        const finalOptions = {
	            deadline: deadline,
	            flags: propagateFlags !== null && propagateFlags !== undefined ? propagateFlags : constants_1.Propagate.DEFAULTS,
	            host: host !== null && host !== undefined ? host : this.defaultAuthority,
	            parentCall: parentCall,
	        };
	        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
	        this.onCallStart();
	        call.addStatusWatcher(status => {
	            this.onCallEnd(status);
	        });
	        return call;
	    }
	    close() {
	        this.resolvingLoadBalancer.destroy();
	        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
	        this.currentPicker = new ShutdownPicker();
	        for (const call of this.configSelectionQueue) {
	            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');
	        }
	        this.configSelectionQueue = [];
	        for (const call of this.pickQueue) {
	            call.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Channel closed before call started');
	        }
	        this.pickQueue = [];
	        clearInterval(this.callRefTimer);
	        if (this.idleTimer) {
	            clearTimeout(this.idleTimer);
	        }
	        if (this.channelzEnabled) {
	            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	        }
	        this.subchannelPool.unrefUnusedSubchannels();
	    }
	    getTarget() {
	        return (0, uri_parser_1.uriToString)(this.target);
	    }
	    getConnectivityState(tryToConnect) {
	        const connectivityState = this.connectivityState;
	        if (tryToConnect) {
	            this.resolvingLoadBalancer.exitIdle();
	            this.lastActivityTimestamp = new Date();
	            this.maybeStartIdleTimer();
	        }
	        return connectivityState;
	    }
	    watchConnectivityState(currentState, deadline, callback) {
	        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            throw new Error('Channel has been shut down');
	        }
	        let timer = null;
	        if (deadline !== Infinity) {
	            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
	            const now = new Date();
	            if (deadline === -Infinity || deadlineDate <= now) {
	                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));
	                return;
	            }
	            timer = setTimeout(() => {
	                this.removeConnectivityStateWatcher(watcherObject);
	                callback(new Error('Deadline passed without connectivity state change'));
	            }, deadlineDate.getTime() - now.getTime());
	        }
	        const watcherObject = {
	            currentState,
	            callback,
	            timer,
	        };
	        this.connectivityStateWatchers.push(watcherObject);
	    }
	    /**
	     * Get the channelz reference object for this channel. The returned value is
	     * garbage if channelz is disabled for this channel.
	     * @returns
	     */
	    getChannelzRef() {
	        return this.channelzRef;
	    }
	    createCall(method, deadline, host, parentCall, propagateFlags) {
	        if (typeof method !== 'string') {
	            throw new TypeError('Channel#createCall: method must be a string');
	        }
	        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
	            throw new TypeError('Channel#createCall: deadline must be a number or Date');
	        }
	        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
	            throw new Error('Channel has been shut down');
	        }
	        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
	    }
	    getOptions() {
	        return this.options;
	    }
	}
	internalChannel.InternalChannel = InternalChannel;
	
	return internalChannel;
}

var hasRequiredChannel;

function requireChannel () {
	if (hasRequiredChannel) return channel;
	hasRequiredChannel = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(channel, "__esModule", { value: true });
	channel.ChannelImplementation = undefined;
	const channel_credentials_1 = requireChannelCredentials();
	const internal_channel_1 = requireInternalChannel();
	class ChannelImplementation {
	    constructor(target, credentials, options) {
	        if (typeof target !== 'string') {
	            throw new TypeError('Channel target must be a string');
	        }
	        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
	            throw new TypeError('Channel credentials must be a ChannelCredentials object');
	        }
	        if (options) {
	            if (typeof options !== 'object') {
	                throw new TypeError('Channel options must be an object');
	            }
	        }
	        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
	    }
	    close() {
	        this.internalChannel.close();
	    }
	    getTarget() {
	        return this.internalChannel.getTarget();
	    }
	    getConnectivityState(tryToConnect) {
	        return this.internalChannel.getConnectivityState(tryToConnect);
	    }
	    watchConnectivityState(currentState, deadline, callback) {
	        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
	    }
	    /**
	     * Get the channelz reference object for this channel. The returned value is
	     * garbage if channelz is disabled for this channel.
	     * @returns
	     */
	    getChannelzRef() {
	        return this.internalChannel.getChannelzRef();
	    }
	    createCall(method, deadline, host, parentCall, propagateFlags) {
	        if (typeof method !== 'string') {
	            throw new TypeError('Channel#createCall: method must be a string');
	        }
	        if (!(typeof deadline === 'number' || deadline instanceof Date)) {
	            throw new TypeError('Channel#createCall: deadline must be a number or Date');
	        }
	        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
	    }
	}
	channel.ChannelImplementation = ChannelImplementation;
	
	return channel;
}

var server = {};

var serverCall = {};

var hasRequiredServerCall;

function requireServerCall () {
	if (hasRequiredServerCall) return serverCall;
	hasRequiredServerCall = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverCall, "__esModule", { value: true });
	serverCall.ServerDuplexStreamImpl = serverCall.ServerWritableStreamImpl = serverCall.ServerReadableStreamImpl = serverCall.ServerUnaryCallImpl = serverCall.serverErrorToStatus = undefined;
	const events_1 = require$$0$6;
	const stream_1 = require$$0$9;
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	function serverErrorToStatus(error, overrideTrailers) {
	    var _a;
	    const status = {
	        code: constants_1.Status.UNKNOWN,
	        details: 'message' in error ? error.message : 'Unknown Error',
	        metadata: (_a = overrideTrailers !== null && overrideTrailers !== undefined ? overrideTrailers : error.metadata) !== null && _a !== undefined ? _a : null,
	    };
	    if ('code' in error &&
	        typeof error.code === 'number' &&
	        Number.isInteger(error.code)) {
	        status.code = error.code;
	        if ('details' in error && typeof error.details === 'string') {
	            status.details = error.details;
	        }
	    }
	    return status;
	}
	serverCall.serverErrorToStatus = serverErrorToStatus;
	class ServerUnaryCallImpl extends events_1.EventEmitter {
	    constructor(path, call, metadata, request) {
	        super();
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.request = request;
	        this.cancelled = false;
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	}
	serverCall.ServerUnaryCallImpl = ServerUnaryCallImpl;
	class ServerReadableStreamImpl extends stream_1.Readable {
	    constructor(path, call, metadata) {
	        super({ objectMode: true });
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.cancelled = false;
	    }
	    _read(size) {
	        this.call.startRead();
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	}
	serverCall.ServerReadableStreamImpl = ServerReadableStreamImpl;
	class ServerWritableStreamImpl extends stream_1.Writable {
	    constructor(path, call, metadata, request) {
	        super({ objectMode: true });
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.request = request;
	        this.pendingStatus = {
	            code: constants_1.Status.OK,
	            details: 'OK',
	        };
	        this.cancelled = false;
	        this.trailingMetadata = new metadata_1.Metadata();
	        this.on('error', err => {
	            this.pendingStatus = serverErrorToStatus(err);
	            this.end();
	        });
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	    _write(chunk, encoding, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    callback) {
	        this.call.sendMessage(chunk, callback);
	    }
	    _final(callback) {
	        var _a;
	        callback(null);
	        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== undefined ? _a : this.trailingMetadata }));
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    end(metadata) {
	        if (metadata) {
	            this.trailingMetadata = metadata;
	        }
	        return super.end();
	    }
	}
	serverCall.ServerWritableStreamImpl = ServerWritableStreamImpl;
	class ServerDuplexStreamImpl extends stream_1.Duplex {
	    constructor(path, call, metadata) {
	        super({ objectMode: true });
	        this.path = path;
	        this.call = call;
	        this.metadata = metadata;
	        this.pendingStatus = {
	            code: constants_1.Status.OK,
	            details: 'OK',
	        };
	        this.cancelled = false;
	        this.trailingMetadata = new metadata_1.Metadata();
	        this.on('error', err => {
	            this.pendingStatus = serverErrorToStatus(err);
	            this.end();
	        });
	    }
	    getPeer() {
	        return this.call.getPeer();
	    }
	    sendMetadata(responseMetadata) {
	        this.call.sendMetadata(responseMetadata);
	    }
	    getDeadline() {
	        return this.call.getDeadline();
	    }
	    getPath() {
	        return this.path;
	    }
	    getHost() {
	        return this.call.getHost();
	    }
	    _read(size) {
	        this.call.startRead();
	    }
	    _write(chunk, encoding, 
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    callback) {
	        this.call.sendMessage(chunk, callback);
	    }
	    _final(callback) {
	        var _a;
	        callback(null);
	        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), { metadata: (_a = this.pendingStatus.metadata) !== null && _a !== undefined ? _a : this.trailingMetadata }));
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    end(metadata) {
	        if (metadata) {
	            this.trailingMetadata = metadata;
	        }
	        return super.end();
	    }
	}
	serverCall.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
	
	return serverCall;
}

var serverCredentials = {};

var hasRequiredServerCredentials;

function requireServerCredentials () {
	if (hasRequiredServerCredentials) return serverCredentials;
	hasRequiredServerCredentials = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverCredentials, "__esModule", { value: true });
	serverCredentials.createServerCredentialsWithInterceptors = serverCredentials.createCertificateProviderServerCredentials = serverCredentials.ServerCredentials = undefined;
	const tls_helpers_1 = requireTlsHelpers();
	class ServerCredentials {
	    constructor() {
	        this.watchers = new Set();
	        this.latestContextOptions = null;
	    }
	    _addWatcher(watcher) {
	        this.watchers.add(watcher);
	    }
	    _removeWatcher(watcher) {
	        this.watchers.delete(watcher);
	    }
	    getWatcherCount() {
	        return this.watchers.size;
	    }
	    updateSecureContextOptions(options) {
	        this.latestContextOptions = options;
	        for (const watcher of this.watchers) {
	            watcher(this.latestContextOptions);
	        }
	    }
	    _getSettings() {
	        return this.latestContextOptions;
	    }
	    _getInterceptors() {
	        return [];
	    }
	    static createInsecure() {
	        return new InsecureServerCredentials();
	    }
	    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
	        var _a;
	        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
	            throw new TypeError('rootCerts must be null or a Buffer');
	        }
	        if (!Array.isArray(keyCertPairs)) {
	            throw new TypeError('keyCertPairs must be an array');
	        }
	        if (typeof checkClientCertificate !== 'boolean') {
	            throw new TypeError('checkClientCertificate must be a boolean');
	        }
	        const cert = [];
	        const key = [];
	        for (let i = 0; i < keyCertPairs.length; i++) {
	            const pair = keyCertPairs[i];
	            if (pair === null || typeof pair !== 'object') {
	                throw new TypeError(`keyCertPair[${i}] must be an object`);
	            }
	            if (!Buffer.isBuffer(pair.private_key)) {
	                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
	            }
	            if (!Buffer.isBuffer(pair.cert_chain)) {
	                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
	            }
	            cert.push(pair.cert_chain);
	            key.push(pair.private_key);
	        }
	        return new SecureServerCredentials({
	            ca: (_a = rootCerts !== null && rootCerts !== undefined ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== undefined ? _a : undefined,
	            cert,
	            key,
	            requestCert: checkClientCertificate,
	            ciphers: tls_helpers_1.CIPHER_SUITES,
	        });
	    }
	}
	serverCredentials.ServerCredentials = ServerCredentials;
	class InsecureServerCredentials extends ServerCredentials {
	    _isSecure() {
	        return false;
	    }
	    _getSettings() {
	        return null;
	    }
	    _equals(other) {
	        return other instanceof InsecureServerCredentials;
	    }
	}
	class SecureServerCredentials extends ServerCredentials {
	    constructor(options) {
	        super();
	        this.options = options;
	    }
	    _isSecure() {
	        return true;
	    }
	    _getSettings() {
	        return this.options;
	    }
	    /**
	     * Checks equality by checking the options that are actually set by
	     * createSsl.
	     * @param other
	     * @returns
	     */
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (!(other instanceof SecureServerCredentials)) {
	            return false;
	        }
	        // options.ca equality check
	        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
	            if (!this.options.ca.equals(other.options.ca)) {
	                return false;
	            }
	        }
	        else {
	            if (this.options.ca !== other.options.ca) {
	                return false;
	            }
	        }
	        // options.cert equality check
	        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
	            if (this.options.cert.length !== other.options.cert.length) {
	                return false;
	            }
	            for (let i = 0; i < this.options.cert.length; i++) {
	                const thisCert = this.options.cert[i];
	                const otherCert = other.options.cert[i];
	                if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
	                    if (!thisCert.equals(otherCert)) {
	                        return false;
	                    }
	                }
	                else {
	                    if (thisCert !== otherCert) {
	                        return false;
	                    }
	                }
	            }
	        }
	        else {
	            if (this.options.cert !== other.options.cert) {
	                return false;
	            }
	        }
	        // options.key equality check
	        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
	            if (this.options.key.length !== other.options.key.length) {
	                return false;
	            }
	            for (let i = 0; i < this.options.key.length; i++) {
	                const thisKey = this.options.key[i];
	                const otherKey = other.options.key[i];
	                if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
	                    if (!thisKey.equals(otherKey)) {
	                        return false;
	                    }
	                }
	                else {
	                    if (thisKey !== otherKey) {
	                        return false;
	                    }
	                }
	            }
	        }
	        else {
	            if (this.options.key !== other.options.key) {
	                return false;
	            }
	        }
	        // options.requestCert equality check
	        if (this.options.requestCert !== other.options.requestCert) {
	            return false;
	        }
	        /* ciphers is derived from a value that is constant for the process, so no
	         * equality check is needed. */
	        return true;
	    }
	}
	class CertificateProviderServerCredentials extends ServerCredentials {
	    constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {
	        super();
	        this.identityCertificateProvider = identityCertificateProvider;
	        this.caCertificateProvider = caCertificateProvider;
	        this.requireClientCertificate = requireClientCertificate;
	        this.latestCaUpdate = null;
	        this.latestIdentityUpdate = null;
	        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
	        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
	    }
	    _addWatcher(watcher) {
	        var _a;
	        if (this.getWatcherCount() === 0) {
	            (_a = this.caCertificateProvider) === null || _a === undefined ? undefined : _a.addCaCertificateListener(this.caCertificateUpdateListener);
	            this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	        super._addWatcher(watcher);
	    }
	    _removeWatcher(watcher) {
	        var _a;
	        super._removeWatcher(watcher);
	        if (this.getWatcherCount() === 0) {
	            (_a = this.caCertificateProvider) === null || _a === undefined ? undefined : _a.removeCaCertificateListener(this.caCertificateUpdateListener);
	            this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
	        }
	    }
	    _isSecure() {
	        return true;
	    }
	    _equals(other) {
	        if (this === other) {
	            return true;
	        }
	        if (!(other instanceof CertificateProviderServerCredentials)) {
	            return false;
	        }
	        return (this.caCertificateProvider === other.caCertificateProvider &&
	            this.identityCertificateProvider === other.identityCertificateProvider &&
	            this.requireClientCertificate === other.requireClientCertificate);
	    }
	    calculateSecureContextOptions() {
	        var _a;
	        if (this.latestIdentityUpdate === null) {
	            return null;
	        }
	        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {
	            return null;
	        }
	        return {
	            ca: (_a = this.latestCaUpdate) === null || _a === undefined ? undefined : _a.caCertificate,
	            cert: this.latestIdentityUpdate.certificate,
	            key: this.latestIdentityUpdate.privateKey,
	            requestCert: this.latestIdentityUpdate !== null,
	            rejectUnauthorized: this.requireClientCertificate
	        };
	    }
	    finalizeUpdate() {
	        this.updateSecureContextOptions(this.calculateSecureContextOptions());
	    }
	    handleCaCertificateUpdate(update) {
	        this.latestCaUpdate = update;
	        this.finalizeUpdate();
	    }
	    handleIdentityCertitificateUpdate(update) {
	        this.latestIdentityUpdate = update;
	        this.finalizeUpdate();
	    }
	}
	function createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {
	    return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);
	}
	serverCredentials.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;
	class InterceptorServerCredentials extends ServerCredentials {
	    constructor(childCredentials, interceptors) {
	        super();
	        this.childCredentials = childCredentials;
	        this.interceptors = interceptors;
	    }
	    _isSecure() {
	        return this.childCredentials._isSecure();
	    }
	    _equals(other) {
	        if (!(other instanceof InterceptorServerCredentials)) {
	            return false;
	        }
	        if (!(this.childCredentials._equals(other.childCredentials))) {
	            return false;
	        }
	        if (this.interceptors.length !== other.interceptors.length) {
	            return false;
	        }
	        for (let i = 0; i < this.interceptors.length; i++) {
	            if (this.interceptors[i] !== other.interceptors[i]) {
	                return false;
	            }
	        }
	        return true;
	    }
	    _getInterceptors() {
	        return this.interceptors;
	    }
	    _addWatcher(watcher) {
	        this.childCredentials._addWatcher(watcher);
	    }
	    _removeWatcher(watcher) {
	        this.childCredentials._removeWatcher(watcher);
	    }
	}
	function createServerCredentialsWithInterceptors(credentials, interceptors) {
	    return new InterceptorServerCredentials(credentials, interceptors);
	}
	serverCredentials.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;
	
	return serverCredentials;
}

var serverInterceptors = {};

var hasRequiredServerInterceptors;

function requireServerInterceptors () {
	if (hasRequiredServerInterceptors) return serverInterceptors;
	hasRequiredServerInterceptors = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(serverInterceptors, "__esModule", { value: true });
	serverInterceptors.getServerInterceptingCall = serverInterceptors.BaseServerInterceptingCall = serverInterceptors.ServerInterceptingCall = serverInterceptors.ResponderBuilder = serverInterceptors.isInterceptingServerListener = serverInterceptors.ServerListenerBuilder = undefined;
	const metadata_1 = requireMetadata();
	const constants_1 = requireConstants();
	const http2 = require$$0$f;
	const error_1 = requireError();
	const zlib = require$$3__default;
	const stream_decoder_1 = requireStreamDecoder();
	const logging = requireLogging();
	const TRACER_NAME = 'server_call';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	class ServerListenerBuilder {
	    constructor() {
	        this.metadata = undefined;
	        this.message = undefined;
	        this.halfClose = undefined;
	        this.cancel = undefined;
	    }
	    withOnReceiveMetadata(onReceiveMetadata) {
	        this.metadata = onReceiveMetadata;
	        return this;
	    }
	    withOnReceiveMessage(onReceiveMessage) {
	        this.message = onReceiveMessage;
	        return this;
	    }
	    withOnReceiveHalfClose(onReceiveHalfClose) {
	        this.halfClose = onReceiveHalfClose;
	        return this;
	    }
	    withOnCancel(onCancel) {
	        this.cancel = onCancel;
	        return this;
	    }
	    build() {
	        return {
	            onReceiveMetadata: this.metadata,
	            onReceiveMessage: this.message,
	            onReceiveHalfClose: this.halfClose,
	            onCancel: this.cancel,
	        };
	    }
	}
	serverInterceptors.ServerListenerBuilder = ServerListenerBuilder;
	function isInterceptingServerListener(listener) {
	    return (listener.onReceiveMetadata !== undefined &&
	        listener.onReceiveMetadata.length === 1);
	}
	serverInterceptors.isInterceptingServerListener = isInterceptingServerListener;
	class InterceptingServerListenerImpl {
	    constructor(listener, nextListener) {
	        this.listener = listener;
	        this.nextListener = nextListener;
	        /**
	         * Once the call is cancelled, ignore all other events.
	         */
	        this.cancelled = false;
	        this.processingMetadata = false;
	        this.hasPendingMessage = false;
	        this.pendingMessage = null;
	        this.processingMessage = false;
	        this.hasPendingHalfClose = false;
	    }
	    processPendingMessage() {
	        if (this.hasPendingMessage) {
	            this.nextListener.onReceiveMessage(this.pendingMessage);
	            this.pendingMessage = null;
	            this.hasPendingMessage = false;
	        }
	    }
	    processPendingHalfClose() {
	        if (this.hasPendingHalfClose) {
	            this.nextListener.onReceiveHalfClose();
	            this.hasPendingHalfClose = false;
	        }
	    }
	    onReceiveMetadata(metadata) {
	        if (this.cancelled) {
	            return;
	        }
	        this.processingMetadata = true;
	        this.listener.onReceiveMetadata(metadata, interceptedMetadata => {
	            this.processingMetadata = false;
	            if (this.cancelled) {
	                return;
	            }
	            this.nextListener.onReceiveMetadata(interceptedMetadata);
	            this.processPendingMessage();
	            this.processPendingHalfClose();
	        });
	    }
	    onReceiveMessage(message) {
	        if (this.cancelled) {
	            return;
	        }
	        this.processingMessage = true;
	        this.listener.onReceiveMessage(message, msg => {
	            this.processingMessage = false;
	            if (this.cancelled) {
	                return;
	            }
	            if (this.processingMetadata) {
	                this.pendingMessage = msg;
	                this.hasPendingMessage = true;
	            }
	            else {
	                this.nextListener.onReceiveMessage(msg);
	                this.processPendingHalfClose();
	            }
	        });
	    }
	    onReceiveHalfClose() {
	        if (this.cancelled) {
	            return;
	        }
	        this.listener.onReceiveHalfClose(() => {
	            if (this.cancelled) {
	                return;
	            }
	            if (this.processingMetadata || this.processingMessage) {
	                this.hasPendingHalfClose = true;
	            }
	            else {
	                this.nextListener.onReceiveHalfClose();
	            }
	        });
	    }
	    onCancel() {
	        this.cancelled = true;
	        this.listener.onCancel();
	        this.nextListener.onCancel();
	    }
	}
	class ResponderBuilder {
	    constructor() {
	        this.start = undefined;
	        this.metadata = undefined;
	        this.message = undefined;
	        this.status = undefined;
	    }
	    withStart(start) {
	        this.start = start;
	        return this;
	    }
	    withSendMetadata(sendMetadata) {
	        this.metadata = sendMetadata;
	        return this;
	    }
	    withSendMessage(sendMessage) {
	        this.message = sendMessage;
	        return this;
	    }
	    withSendStatus(sendStatus) {
	        this.status = sendStatus;
	        return this;
	    }
	    build() {
	        return {
	            start: this.start,
	            sendMetadata: this.metadata,
	            sendMessage: this.message,
	            sendStatus: this.status,
	        };
	    }
	}
	serverInterceptors.ResponderBuilder = ResponderBuilder;
	const defaultServerListener = {
	    onReceiveMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    onReceiveMessage: (message, next) => {
	        next(message);
	    },
	    onReceiveHalfClose: next => {
	        next();
	    },
	    onCancel: () => { },
	};
	const defaultResponder = {
	    start: next => {
	        next();
	    },
	    sendMetadata: (metadata, next) => {
	        next(metadata);
	    },
	    sendMessage: (message, next) => {
	        next(message);
	    },
	    sendStatus: (status, next) => {
	        next(status);
	    },
	};
	class ServerInterceptingCall {
	    constructor(nextCall, responder) {
	        var _a, _b, _c, _d;
	        this.nextCall = nextCall;
	        this.processingMetadata = false;
	        this.processingMessage = false;
	        this.pendingMessage = null;
	        this.pendingMessageCallback = null;
	        this.pendingStatus = null;
	        this.responder = {
	            start: (_a = responder === null || responder === undefined ? undefined : responder.start) !== null && _a !== undefined ? _a : defaultResponder.start,
	            sendMetadata: (_b = responder === null || responder === undefined ? undefined : responder.sendMetadata) !== null && _b !== undefined ? _b : defaultResponder.sendMetadata,
	            sendMessage: (_c = responder === null || responder === undefined ? undefined : responder.sendMessage) !== null && _c !== undefined ? _c : defaultResponder.sendMessage,
	            sendStatus: (_d = responder === null || responder === undefined ? undefined : responder.sendStatus) !== null && _d !== undefined ? _d : defaultResponder.sendStatus,
	        };
	    }
	    processPendingMessage() {
	        if (this.pendingMessageCallback) {
	            this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
	            this.pendingMessage = null;
	            this.pendingMessageCallback = null;
	        }
	    }
	    processPendingStatus() {
	        if (this.pendingStatus) {
	            this.nextCall.sendStatus(this.pendingStatus);
	            this.pendingStatus = null;
	        }
	    }
	    start(listener) {
	        this.responder.start(interceptedListener => {
	            var _a, _b, _c, _d;
	            const fullInterceptedListener = {
	                onReceiveMetadata: (_a = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveMetadata) !== null && _a !== undefined ? _a : defaultServerListener.onReceiveMetadata,
	                onReceiveMessage: (_b = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveMessage) !== null && _b !== undefined ? _b : defaultServerListener.onReceiveMessage,
	                onReceiveHalfClose: (_c = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onReceiveHalfClose) !== null && _c !== undefined ? _c : defaultServerListener.onReceiveHalfClose,
	                onCancel: (_d = interceptedListener === null || interceptedListener === undefined ? undefined : interceptedListener.onCancel) !== null && _d !== undefined ? _d : defaultServerListener.onCancel,
	            };
	            const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
	            this.nextCall.start(finalInterceptingListener);
	        });
	    }
	    sendMetadata(metadata) {
	        this.processingMetadata = true;
	        this.responder.sendMetadata(metadata, interceptedMetadata => {
	            this.processingMetadata = false;
	            this.nextCall.sendMetadata(interceptedMetadata);
	            this.processPendingMessage();
	            this.processPendingStatus();
	        });
	    }
	    sendMessage(message, callback) {
	        this.processingMessage = true;
	        this.responder.sendMessage(message, interceptedMessage => {
	            this.processingMessage = false;
	            if (this.processingMetadata) {
	                this.pendingMessage = interceptedMessage;
	                this.pendingMessageCallback = callback;
	            }
	            else {
	                this.nextCall.sendMessage(interceptedMessage, callback);
	            }
	        });
	    }
	    sendStatus(status) {
	        this.responder.sendStatus(status, interceptedStatus => {
	            if (this.processingMetadata || this.processingMessage) {
	                this.pendingStatus = interceptedStatus;
	            }
	            else {
	                this.nextCall.sendStatus(interceptedStatus);
	            }
	        });
	    }
	    startRead() {
	        this.nextCall.startRead();
	    }
	    getPeer() {
	        return this.nextCall.getPeer();
	    }
	    getDeadline() {
	        return this.nextCall.getDeadline();
	    }
	    getHost() {
	        return this.nextCall.getHost();
	    }
	}
	serverInterceptors.ServerInterceptingCall = ServerInterceptingCall;
	const GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';
	const GRPC_ENCODING_HEADER = 'grpc-encoding';
	const GRPC_MESSAGE_HEADER = 'grpc-message';
	const GRPC_STATUS_HEADER = 'grpc-status';
	const GRPC_TIMEOUT_HEADER = 'grpc-timeout';
	const DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
	const deadlineUnitsToMs = {
	    H: 3600000,
	    M: 60000,
	    S: 1000,
	    m: 1,
	    u: 0.001,
	    n: 0.000001,
	};
	const defaultCompressionHeaders = {
	    // TODO(cjihrig): Remove these encoding headers from the default response
	    // once compression is integrated.
	    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',
	    [GRPC_ENCODING_HEADER]: 'identity',
	};
	const defaultResponseHeaders = {
	    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
	    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',
	};
	const defaultResponseOptions = {
	    waitForTrailers: true,
	};
	class BaseServerInterceptingCall {
	    constructor(stream, headers, callEventTracker, handler, options) {
	        var _a;
	        this.stream = stream;
	        this.callEventTracker = callEventTracker;
	        this.handler = handler;
	        this.listener = null;
	        this.deadlineTimer = null;
	        this.deadline = Infinity;
	        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
	        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
	        this.cancelled = false;
	        this.metadataSent = false;
	        this.wantTrailers = false;
	        this.cancelNotified = false;
	        this.incomingEncoding = 'identity';
	        this.readQueue = [];
	        this.isReadPending = false;
	        this.receivedHalfClose = false;
	        this.streamEnded = false;
	        this.stream.once('error', (err) => {
	            /* We need an error handler to avoid uncaught error event exceptions, but
	             * there is nothing we can reasonably do here. Any error event should
	             * have a corresponding close event, which handles emitting the cancelled
	             * event. And the stream is now in a bad state, so we can't reasonably
	             * expect to be able to send an error over it. */
	        });
	        this.stream.once('close', () => {
	            var _a;
	            trace('Request to method ' +
	                ((_a = this.handler) === null || _a === undefined ? undefined : _a.path) +
	                ' stream closed with rstCode ' +
	                this.stream.rstCode);
	            if (this.callEventTracker && !this.streamEnded) {
	                this.streamEnded = true;
	                this.callEventTracker.onStreamEnd(false);
	                this.callEventTracker.onCallEnd({
	                    code: constants_1.Status.CANCELLED,
	                    details: 'Stream closed before sending status',
	                    metadata: null,
	                });
	            }
	            this.notifyOnCancel();
	        });
	        this.stream.on('data', (data) => {
	            this.handleDataFrame(data);
	        });
	        this.stream.pause();
	        this.stream.on('end', () => {
	            this.handleEndEvent();
	        });
	        if ('grpc.max_send_message_length' in options) {
	            this.maxSendMessageSize = options['grpc.max_send_message_length'];
	        }
	        if ('grpc.max_receive_message_length' in options) {
	            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];
	        }
	        this.host = (_a = headers[':authority']) !== null && _a !== undefined ? _a : headers.host;
	        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);
	        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
	        if (logging.isTracerEnabled(TRACER_NAME)) {
	            trace('Request to ' +
	                this.handler.path +
	                ' received headers ' +
	                JSON.stringify(metadata.toJSON()));
	        }
	        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
	        if (timeoutHeader.length > 0) {
	            this.handleTimeoutHeader(timeoutHeader[0]);
	        }
	        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
	        if (encodingHeader.length > 0) {
	            this.incomingEncoding = encodingHeader[0];
	        }
	        // Remove several headers that should not be propagated to the application
	        metadata.remove(GRPC_TIMEOUT_HEADER);
	        metadata.remove(GRPC_ENCODING_HEADER);
	        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
	        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
	        metadata.remove(http2.constants.HTTP2_HEADER_TE);
	        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
	        this.metadata = metadata;
	    }
	    handleTimeoutHeader(timeoutHeader) {
	        const match = timeoutHeader.toString().match(DEADLINE_REGEX);
	        if (match === null) {
	            const status = {
	                code: constants_1.Status.INTERNAL,
	                details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
	                metadata: null,
	            };
	            // Wait for the constructor to complete before sending the error.
	            process.nextTick(() => {
	                this.sendStatus(status);
	            });
	            return;
	        }
	        const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;
	        const now = new Date();
	        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
	        this.deadlineTimer = setTimeout(() => {
	            const status = {
	                code: constants_1.Status.DEADLINE_EXCEEDED,
	                details: 'Deadline exceeded',
	                metadata: null,
	            };
	            this.sendStatus(status);
	        }, timeout);
	    }
	    checkCancelled() {
	        /* In some cases the stream can become destroyed before the close event
	         * fires. That creates a race condition that this check works around */
	        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
	            this.notifyOnCancel();
	            this.cancelled = true;
	        }
	        return this.cancelled;
	    }
	    notifyOnCancel() {
	        if (this.cancelNotified) {
	            return;
	        }
	        this.cancelNotified = true;
	        this.cancelled = true;
	        process.nextTick(() => {
	            var _a;
	            (_a = this.listener) === null || _a === undefined ? undefined : _a.onCancel();
	        });
	        if (this.deadlineTimer) {
	            clearTimeout(this.deadlineTimer);
	        }
	        // Flush incoming data frames
	        this.stream.resume();
	    }
	    /**
	     * A server handler can start sending messages without explicitly sending
	     * metadata. In that case, we need to send headers before sending any
	     * messages. This function does that if necessary.
	     */
	    maybeSendMetadata() {
	        if (!this.metadataSent) {
	            this.sendMetadata(new metadata_1.Metadata());
	        }
	    }
	    /**
	     * Serialize a message to a length-delimited byte string.
	     * @param value
	     * @returns
	     */
	    serializeMessage(value) {
	        const messageBuffer = this.handler.serialize(value);
	        const byteLength = messageBuffer.byteLength;
	        const output = Buffer.allocUnsafe(byteLength + 5);
	        /* Note: response compression is currently not supported, so this
	         * compressed bit is always 0. */
	        output.writeUInt8(0, 0);
	        output.writeUInt32BE(byteLength, 1);
	        messageBuffer.copy(output, 5);
	        return output;
	    }
	    decompressMessage(message, encoding) {
	        const messageContents = message.subarray(5);
	        if (encoding === 'identity') {
	            return messageContents;
	        }
	        else if (encoding === 'deflate' || encoding === 'gzip') {
	            let decompresser;
	            if (encoding === 'deflate') {
	                decompresser = zlib.createInflate();
	            }
	            else {
	                decompresser = zlib.createGunzip();
	            }
	            return new Promise((resolve, reject) => {
	                let totalLength = 0;
	                const messageParts = [];
	                decompresser.on('data', (chunk) => {
	                    messageParts.push(chunk);
	                    totalLength += chunk.byteLength;
	                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {
	                        decompresser.destroy();
	                        reject({
	                            code: constants_1.Status.RESOURCE_EXHAUSTED,
	                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
	                        });
	                    }
	                });
	                decompresser.on('end', () => {
	                    resolve(Buffer.concat(messageParts));
	                });
	                decompresser.write(messageContents);
	                decompresser.end();
	            });
	        }
	        else {
	            return Promise.reject({
	                code: constants_1.Status.UNIMPLEMENTED,
	                details: `Received message compressed with unsupported encoding "${encoding}"`,
	            });
	        }
	    }
	    async decompressAndMaybePush(queueEntry) {
	        if (queueEntry.type !== 'COMPRESSED') {
	            throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
	        }
	        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
	        const compressedMessageEncoding = compressed
	            ? this.incomingEncoding
	            : 'identity';
	        let decompressedMessage;
	        try {
	            decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
	        }
	        catch (err) {
	            this.sendStatus(err);
	            return;
	        }
	        try {
	            queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
	        }
	        catch (err) {
	            this.sendStatus({
	                code: constants_1.Status.INTERNAL,
	                details: `Error deserializing request: ${err.message}`,
	            });
	            return;
	        }
	        queueEntry.type = 'READABLE';
	        this.maybePushNextMessage();
	    }
	    maybePushNextMessage() {
	        if (this.listener &&
	            this.isReadPending &&
	            this.readQueue.length > 0 &&
	            this.readQueue[0].type !== 'COMPRESSED') {
	            this.isReadPending = false;
	            const nextQueueEntry = this.readQueue.shift();
	            if (nextQueueEntry.type === 'READABLE') {
	                this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
	            }
	            else {
	                // nextQueueEntry.type === 'HALF_CLOSE'
	                this.listener.onReceiveHalfClose();
	            }
	        }
	    }
	    handleDataFrame(data) {
	        var _a;
	        if (this.checkCancelled()) {
	            return;
	        }
	        trace('Request to ' +
	            this.handler.path +
	            ' received data frame of size ' +
	            data.length);
	        let rawMessages;
	        try {
	            rawMessages = this.decoder.write(data);
	        }
	        catch (e) {
	            this.sendStatus({ code: constants_1.Status.RESOURCE_EXHAUSTED, details: e.message });
	            return;
	        }
	        for (const messageBytes of rawMessages) {
	            this.stream.pause();
	            const queueEntry = {
	                type: 'COMPRESSED',
	                compressedMessage: messageBytes,
	                parsedMessage: null,
	            };
	            this.readQueue.push(queueEntry);
	            this.decompressAndMaybePush(queueEntry);
	            (_a = this.callEventTracker) === null || _a === undefined ? undefined : _a.addMessageReceived();
	        }
	    }
	    handleEndEvent() {
	        this.readQueue.push({
	            type: 'HALF_CLOSE',
	            compressedMessage: null,
	            parsedMessage: null,
	        });
	        this.receivedHalfClose = true;
	        this.maybePushNextMessage();
	    }
	    start(listener) {
	        trace('Request to ' + this.handler.path + ' start called');
	        if (this.checkCancelled()) {
	            return;
	        }
	        this.listener = listener;
	        listener.onReceiveMetadata(this.metadata);
	    }
	    sendMetadata(metadata) {
	        if (this.checkCancelled()) {
	            return;
	        }
	        if (this.metadataSent) {
	            return;
	        }
	        this.metadataSent = true;
	        const custom = metadata ? metadata.toHttp2Headers() : null;
	        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
	        this.stream.respond(headers, defaultResponseOptions);
	    }
	    sendMessage(message, callback) {
	        if (this.checkCancelled()) {
	            return;
	        }
	        let response;
	        try {
	            response = this.serializeMessage(message);
	        }
	        catch (e) {
	            this.sendStatus({
	                code: constants_1.Status.INTERNAL,
	                details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,
	                metadata: null,
	            });
	            return;
	        }
	        if (this.maxSendMessageSize !== -1 &&
	            response.length - 5 > this.maxSendMessageSize) {
	            this.sendStatus({
	                code: constants_1.Status.RESOURCE_EXHAUSTED,
	                details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
	                metadata: null,
	            });
	            return;
	        }
	        this.maybeSendMetadata();
	        trace('Request to ' +
	            this.handler.path +
	            ' sent data frame of size ' +
	            response.length);
	        this.stream.write(response, error => {
	            var _a;
	            if (error) {
	                this.sendStatus({
	                    code: constants_1.Status.INTERNAL,
	                    details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
	                    metadata: null,
	                });
	                return;
	            }
	            (_a = this.callEventTracker) === null || _a === undefined ? undefined : _a.addMessageSent();
	            callback();
	        });
	    }
	    sendStatus(status) {
	        var _a, _b;
	        if (this.checkCancelled()) {
	            return;
	        }
	        trace('Request to method ' +
	            ((_a = this.handler) === null || _a === undefined ? undefined : _a.path) +
	            ' ended with status code: ' +
	            constants_1.Status[status.code] +
	            ' details: ' +
	            status.details);
	        if (this.metadataSent) {
	            if (!this.wantTrailers) {
	                this.wantTrailers = true;
	                this.stream.once('wantTrailers', () => {
	                    var _a;
	                    if (this.callEventTracker && !this.streamEnded) {
	                        this.streamEnded = true;
	                        this.callEventTracker.onStreamEnd(true);
	                        this.callEventTracker.onCallEnd(status);
	                    }
	                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, (_a = status.metadata) === null || _a === undefined ? undefined : _a.toHttp2Headers());
	                    this.stream.sendTrailers(trailersToSend);
	                    this.notifyOnCancel();
	                });
	                this.stream.end();
	            }
	            else {
	                this.notifyOnCancel();
	            }
	        }
	        else {
	            if (this.callEventTracker && !this.streamEnded) {
	                this.streamEnded = true;
	                this.callEventTracker.onStreamEnd(true);
	                this.callEventTracker.onCallEnd(status);
	            }
	            // Trailers-only response
	            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: status.code, [GRPC_MESSAGE_HEADER]: encodeURI(status.details) }, defaultResponseHeaders), (_b = status.metadata) === null || _b === undefined ? undefined : _b.toHttp2Headers());
	            this.stream.respond(trailersToSend, { endStream: true });
	            this.notifyOnCancel();
	        }
	    }
	    startRead() {
	        trace('Request to ' + this.handler.path + ' startRead called');
	        if (this.checkCancelled()) {
	            return;
	        }
	        this.isReadPending = true;
	        if (this.readQueue.length === 0) {
	            if (!this.receivedHalfClose) {
	                this.stream.resume();
	            }
	        }
	        else {
	            this.maybePushNextMessage();
	        }
	    }
	    getPeer() {
	        var _a;
	        const socket = (_a = this.stream.session) === null || _a === undefined ? undefined : _a.socket;
	        if (socket === null || socket === undefined ? undefined : socket.remoteAddress) {
	            if (socket.remotePort) {
	                return `${socket.remoteAddress}:${socket.remotePort}`;
	            }
	            else {
	                return socket.remoteAddress;
	            }
	        }
	        else {
	            return 'unknown';
	        }
	    }
	    getDeadline() {
	        return this.deadline;
	    }
	    getHost() {
	        return this.host;
	    }
	}
	serverInterceptors.BaseServerInterceptingCall = BaseServerInterceptingCall;
	function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
	    const methodDefinition = {
	        path: handler.path,
	        requestStream: handler.type === 'clientStream' || handler.type === 'bidi',
	        responseStream: handler.type === 'serverStream' || handler.type === 'bidi',
	        requestDeserialize: handler.deserialize,
	        responseSerialize: handler.serialize,
	    };
	    const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
	    return interceptors.reduce((call, interceptor) => {
	        return interceptor(methodDefinition, call);
	    }, baseCall);
	}
	serverInterceptors.getServerInterceptingCall = getServerInterceptingCall;
	
	return serverInterceptors;
}

var hasRequiredServer;

function requireServer () {
	if (hasRequiredServer) return server;
	hasRequiredServer = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var __runInitializers = (server.__runInitializers) || function (thisArg, initializers, value) {
	    var useValue = arguments.length > 2;
	    for (var i = 0; i < initializers.length; i++) {
	        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	    }
	    return useValue ? value : undefined;
	};
	var __esDecorate = (server.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	    function accept(f) { if (f !== undefined && typeof f !== "function") throw new TypeError("Function expected"); return f; }
	    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	    var _, done = false;
	    for (var i = decorators.length - 1; i >= 0; i--) {
	        var context = {};
	        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
	        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
	        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
	        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
	        if (kind === "accessor") {
	            if (result === undefined) continue;
	            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
	            if (_ = accept(result.get)) descriptor.get = _;
	            if (_ = accept(result.set)) descriptor.set = _;
	            if (_ = accept(result.init)) initializers.unshift(_);
	        }
	        else if (_ = accept(result)) {
	            if (kind === "field") initializers.unshift(_);
	            else descriptor[key] = _;
	        }
	    }
	    if (target) Object.defineProperty(target, contextIn.name, descriptor);
	    done = true;
	};
	Object.defineProperty(server, "__esModule", { value: true });
	server.Server = undefined;
	const http2 = require$$0$f;
	const util = require$$0$7;
	const constants_1 = requireConstants();
	const server_call_1 = requireServerCall();
	const server_credentials_1 = requireServerCredentials();
	const resolver_1 = requireResolver();
	const logging = requireLogging();
	const subchannel_address_1 = requireSubchannelAddress();
	const uri_parser_1 = requireUriParser();
	const channelz_1 = requireChannelz();
	const server_interceptors_1 = requireServerInterceptors();
	const UNLIMITED_CONNECTION_AGE_MS = 2147483647;
	const KEEPALIVE_MAX_TIME_MS = 2147483647;
	const KEEPALIVE_TIMEOUT_MS = 20000;
	const MAX_CONNECTION_IDLE_MS = 2147483647;
	const { HTTP2_HEADER_PATH } = http2.constants;
	const TRACER_NAME = 'server';
	const kMaxAge = Buffer.from('max_age');
	function noop() { }
	/**
	 * Decorator to wrap a class method with util.deprecate
	 * @param message The message to output if the deprecated method is called
	 * @returns
	 */
	function deprecate(message) {
	    return function (target, context) {
	        return util.deprecate(target, message);
	    };
	}
	function getUnimplementedStatusResponse(methodName) {
	    return {
	        code: constants_1.Status.UNIMPLEMENTED,
	        details: `The server does not implement the method ${methodName}`,
	    };
	}
	function getDefaultHandler(handlerType, methodName) {
	    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
	    switch (handlerType) {
	        case 'unary':
	            return (call, callback) => {
	                callback(unimplementedStatusResponse, null);
	            };
	        case 'clientStream':
	            return (call, callback) => {
	                callback(unimplementedStatusResponse, null);
	            };
	        case 'serverStream':
	            return (call) => {
	                call.emit('error', unimplementedStatusResponse);
	            };
	        case 'bidi':
	            return (call) => {
	                call.emit('error', unimplementedStatusResponse);
	            };
	        default:
	            throw new Error(`Invalid handlerType ${handlerType}`);
	    }
	}
	let Server = (() => {
	    var _a;
	    let _instanceExtraInitializers = [];
	    let _start_decorators;
	    return _a = class Server {
	            constructor(options) {
	                var _b, _c, _d, _e, _f, _g;
	                this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), new Map());
	                this.http2Servers = new Map();
	                this.sessionIdleTimeouts = new Map();
	                this.handlers = new Map();
	                this.sessions = new Map();
	                /**
	                 * This field only exists to ensure that the start method throws an error if
	                 * it is called twice, as it did previously.
	                 */
	                this.started = false;
	                this.shutdown = false;
	                this.serverAddressString = 'null';
	                // Channelz Info
	                this.channelzEnabled = true;
	                this.options = options !== null && options !== undefined ? options : {};
	                if (this.options['grpc.enable_channelz'] === 0) {
	                    this.channelzEnabled = false;
	                    this.channelzTrace = new channelz_1.ChannelzTraceStub();
	                    this.callTracker = new channelz_1.ChannelzCallTrackerStub();
	                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
	                }
	                else {
	                    this.channelzTrace = new channelz_1.ChannelzTrace();
	                    this.callTracker = new channelz_1.ChannelzCallTracker();
	                    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
	                    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
	                }
	                this.channelzRef = (0, channelz_1.registerChannelzServer)('server', () => this.getChannelzInfo(), this.channelzEnabled);
	                this.channelzTrace.addTrace('CT_INFO', 'Server created');
	                this.maxConnectionAgeMs =
	                    (_b = this.options['grpc.max_connection_age_ms']) !== null && _b !== undefined ? _b : UNLIMITED_CONNECTION_AGE_MS;
	                this.maxConnectionAgeGraceMs =
	                    (_c = this.options['grpc.max_connection_age_grace_ms']) !== null && _c !== undefined ? _c : UNLIMITED_CONNECTION_AGE_MS;
	                this.keepaliveTimeMs =
	                    (_d = this.options['grpc.keepalive_time_ms']) !== null && _d !== undefined ? _d : KEEPALIVE_MAX_TIME_MS;
	                this.keepaliveTimeoutMs =
	                    (_e = this.options['grpc.keepalive_timeout_ms']) !== null && _e !== undefined ? _e : KEEPALIVE_TIMEOUT_MS;
	                this.sessionIdleTimeout =
	                    (_f = this.options['grpc.max_connection_idle_ms']) !== null && _f !== undefined ? _f : MAX_CONNECTION_IDLE_MS;
	                this.commonServerOptions = {
	                    maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,
	                };
	                if ('grpc-node.max_session_memory' in this.options) {
	                    this.commonServerOptions.maxSessionMemory =
	                        this.options['grpc-node.max_session_memory'];
	                }
	                else {
	                    /* By default, set a very large max session memory limit, to effectively
	                     * disable enforcement of the limit. Some testing indicates that Node's
	                     * behavior degrades badly when this limit is reached, so we solve that
	                     * by disabling the check entirely. */
	                    this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
	                }
	                if ('grpc.max_concurrent_streams' in this.options) {
	                    this.commonServerOptions.settings = {
	                        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],
	                    };
	                }
	                this.interceptors = (_g = this.options.interceptors) !== null && _g !== undefined ? _g : [];
	                this.trace('Server constructed');
	            }
	            getChannelzInfo() {
	                return {
	                    trace: this.channelzTrace,
	                    callTracker: this.callTracker,
	                    listenerChildren: this.listenerChildrenTracker.getChildLists(),
	                    sessionChildren: this.sessionChildrenTracker.getChildLists(),
	                };
	            }
	            getChannelzSessionInfo(session) {
	                var _b, _c, _d;
	                const sessionInfo = this.sessions.get(session);
	                const sessionSocket = session.socket;
	                const remoteAddress = sessionSocket.remoteAddress
	                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)
	                    : null;
	                const localAddress = sessionSocket.localAddress
	                    ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)
	                    : null;
	                let tlsInfo;
	                if (session.encrypted) {
	                    const tlsSocket = sessionSocket;
	                    const cipherInfo = tlsSocket.getCipher();
	                    const certificate = tlsSocket.getCertificate();
	                    const peerCertificate = tlsSocket.getPeerCertificate();
	                    tlsInfo = {
	                        cipherSuiteStandardName: (_b = cipherInfo.standardName) !== null && _b !== undefined ? _b : null,
	                        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
	                        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,
	                        remoteCertificate: peerCertificate && 'raw' in peerCertificate
	                            ? peerCertificate.raw
	                            : null,
	                    };
	                }
	                else {
	                    tlsInfo = null;
	                }
	                const socketInfo = {
	                    remoteAddress: remoteAddress,
	                    localAddress: localAddress,
	                    security: tlsInfo,
	                    remoteName: null,
	                    streamsStarted: sessionInfo.streamTracker.callsStarted,
	                    streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
	                    streamsFailed: sessionInfo.streamTracker.callsFailed,
	                    messagesSent: sessionInfo.messagesSent,
	                    messagesReceived: sessionInfo.messagesReceived,
	                    keepAlivesSent: sessionInfo.keepAlivesSent,
	                    lastLocalStreamCreatedTimestamp: null,
	                    lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
	                    lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
	                    lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
	                    localFlowControlWindow: (_c = session.state.localWindowSize) !== null && _c !== undefined ? _c : null,
	                    remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== undefined ? _d : null,
	                };
	                return socketInfo;
	            }
	            trace(text) {
	                logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);
	            }
	            keepaliveTrace(text) {
	                logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + text);
	            }
	            addProtoService() {
	                throw new Error('Not implemented. Use addService() instead');
	            }
	            addService(service, implementation) {
	                if (service === null ||
	                    typeof service !== 'object' ||
	                    implementation === null ||
	                    typeof implementation !== 'object') {
	                    throw new Error('addService() requires two objects as arguments');
	                }
	                const serviceKeys = Object.keys(service);
	                if (serviceKeys.length === 0) {
	                    throw new Error('Cannot add an empty service to a server');
	                }
	                serviceKeys.forEach(name => {
	                    const attrs = service[name];
	                    let methodType;
	                    if (attrs.requestStream) {
	                        if (attrs.responseStream) {
	                            methodType = 'bidi';
	                        }
	                        else {
	                            methodType = 'clientStream';
	                        }
	                    }
	                    else {
	                        if (attrs.responseStream) {
	                            methodType = 'serverStream';
	                        }
	                        else {
	                            methodType = 'unary';
	                        }
	                    }
	                    let implFn = implementation[name];
	                    let impl;
	                    if (implFn === undefined && typeof attrs.originalName === 'string') {
	                        implFn = implementation[attrs.originalName];
	                    }
	                    if (implFn !== undefined) {
	                        impl = implFn.bind(implementation);
	                    }
	                    else {
	                        impl = getDefaultHandler(methodType, name);
	                    }
	                    const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
	                    if (success === false) {
	                        throw new Error(`Method handler for ${attrs.path} already provided.`);
	                    }
	                });
	            }
	            removeService(service) {
	                if (service === null || typeof service !== 'object') {
	                    throw new Error('removeService() requires object as argument');
	                }
	                const serviceKeys = Object.keys(service);
	                serviceKeys.forEach(name => {
	                    const attrs = service[name];
	                    this.unregister(attrs.path);
	                });
	            }
	            bind(port, creds) {
	                throw new Error('Not implemented. Use bindAsync() instead');
	            }
	            registerListenerToChannelz(boundAddress) {
	                return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
	                    return {
	                        localAddress: boundAddress,
	                        remoteAddress: null,
	                        security: null,
	                        remoteName: null,
	                        streamsStarted: 0,
	                        streamsSucceeded: 0,
	                        streamsFailed: 0,
	                        messagesSent: 0,
	                        messagesReceived: 0,
	                        keepAlivesSent: 0,
	                        lastLocalStreamCreatedTimestamp: null,
	                        lastRemoteStreamCreatedTimestamp: null,
	                        lastMessageSentTimestamp: null,
	                        lastMessageReceivedTimestamp: null,
	                        localFlowControlWindow: null,
	                        remoteFlowControlWindow: null,
	                    };
	                }, this.channelzEnabled);
	            }
	            createHttp2Server(credentials) {
	                let http2Server;
	                if (credentials._isSecure()) {
	                    const credentialsSettings = credentials._getSettings();
	                    const secureServerOptions = Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), credentialsSettings), { enableTrace: this.options['grpc-node.tls_enable_trace'] === 1 });
	                    let areCredentialsValid = credentialsSettings !== null;
	                    http2Server = http2.createSecureServer(secureServerOptions);
	                    http2Server.on('connection', (socket) => {
	                        if (!areCredentialsValid) {
	                            socket.destroy();
	                        }
	                    });
	                    http2Server.on('secureConnection', (socket) => {
	                        /* These errors need to be handled by the user of Http2SecureServer,
	                         * according to https://github.com/nodejs/node/issues/35824 */
	                        socket.on('error', (e) => {
	                            this.trace('An incoming TLS connection closed with error: ' + e.message);
	                        });
	                    });
	                    const credsWatcher = options => {
	                        if (options) {
	                            http2Server.setSecureContext(options);
	                        }
	                        areCredentialsValid = options !== null;
	                    };
	                    credentials._addWatcher(credsWatcher);
	                    http2Server.on('close', () => {
	                        credentials._removeWatcher(credsWatcher);
	                    });
	                }
	                else {
	                    http2Server = http2.createServer(this.commonServerOptions);
	                }
	                http2Server.setTimeout(0, noop);
	                this._setupHandlers(http2Server, credentials._getInterceptors());
	                return http2Server;
	            }
	            bindOneAddress(address, boundPortObject) {
	                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));
	                const http2Server = this.createHttp2Server(boundPortObject.credentials);
	                return new Promise((resolve, reject) => {
	                    const onError = (err) => {
	                        this.trace('Failed to bind ' +
	                            (0, subchannel_address_1.subchannelAddressToString)(address) +
	                            ' with error ' +
	                            err.message);
	                        resolve({
	                            port: 'port' in address ? address.port : 1,
	                            error: err.message,
	                        });
	                    };
	                    http2Server.once('error', onError);
	                    http2Server.listen(address, () => {
	                        const boundAddress = http2Server.address();
	                        let boundSubchannelAddress;
	                        if (typeof boundAddress === 'string') {
	                            boundSubchannelAddress = {
	                                path: boundAddress,
	                            };
	                        }
	                        else {
	                            boundSubchannelAddress = {
	                                host: boundAddress.address,
	                                port: boundAddress.port,
	                            };
	                        }
	                        const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);
	                        this.listenerChildrenTracker.refChild(channelzRef);
	                        this.http2Servers.set(http2Server, {
	                            channelzRef: channelzRef,
	                            sessions: new Set(),
	                        });
	                        boundPortObject.listeningServers.add(http2Server);
	                        this.trace('Successfully bound ' +
	                            (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
	                        resolve({
	                            port: 'port' in boundSubchannelAddress ? boundSubchannelAddress.port : 1,
	                        });
	                        http2Server.removeListener('error', onError);
	                    });
	                });
	            }
	            async bindManyPorts(addressList, boundPortObject) {
	                if (addressList.length === 0) {
	                    return {
	                        count: 0,
	                        port: 0,
	                        errors: [],
	                    };
	                }
	                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
	                    /* If binding to port 0, first try to bind the first address, then bind
	                     * the rest of the address list to the specific port that it binds. */
	                    const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
	                    if (firstAddressResult.error) {
	                        /* If the first address fails to bind, try the same operation starting
	                         * from the second item in the list. */
	                        const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
	                        return Object.assign(Object.assign({}, restAddressResult), { errors: [firstAddressResult.error, ...restAddressResult.errors] });
	                    }
	                    else {
	                        const restAddresses = addressList
	                            .slice(1)
	                            .map(address => (0, subchannel_address_1.isTcpSubchannelAddress)(address)
	                            ? { host: address.host, port: firstAddressResult.port }
	                            : address);
	                        const restAddressResult = await Promise.all(restAddresses.map(address => this.bindOneAddress(address, boundPortObject)));
	                        const allResults = [firstAddressResult, ...restAddressResult];
	                        return {
	                            count: allResults.filter(result => result.error === undefined).length,
	                            port: firstAddressResult.port,
	                            errors: allResults
	                                .filter(result => result.error)
	                                .map(result => result.error),
	                        };
	                    }
	                }
	                else {
	                    const allResults = await Promise.all(addressList.map(address => this.bindOneAddress(address, boundPortObject)));
	                    return {
	                        count: allResults.filter(result => result.error === undefined).length,
	                        port: allResults[0].port,
	                        errors: allResults
	                            .filter(result => result.error)
	                            .map(result => result.error),
	                    };
	                }
	            }
	            async bindAddressList(addressList, boundPortObject) {
	                const bindResult = await this.bindManyPorts(addressList, boundPortObject);
	                if (bindResult.count > 0) {
	                    if (bindResult.count < addressList.length) {
	                        logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
	                    }
	                    return bindResult.port;
	                }
	                else {
	                    const errorString = `No address added out of total ${addressList.length} resolved`;
	                    logging.log(constants_1.LogVerbosity.ERROR, errorString);
	                    throw new Error(`${errorString} errors: [${bindResult.errors.join(',')}]`);
	                }
	            }
	            resolvePort(port) {
	                return new Promise((resolve, reject) => {
	                    const resolverListener = {
	                        onSuccessfulResolution: (endpointList, serviceConfig, serviceConfigError) => {
	                            // We only want one resolution result. Discard all future results
	                            resolverListener.onSuccessfulResolution = () => { };
	                            const addressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
	                            if (addressList.length === 0) {
	                                reject(new Error(`No addresses resolved for port ${port}`));
	                                return;
	                            }
	                            resolve(addressList);
	                        },
	                        onError: error => {
	                            reject(new Error(error.details));
	                        },
	                    };
	                    const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
	                    resolver.updateResolution();
	                });
	            }
	            async bindPort(port, boundPortObject) {
	                const addressList = await this.resolvePort(port);
	                if (boundPortObject.cancelled) {
	                    this.completeUnbind(boundPortObject);
	                    throw new Error('bindAsync operation cancelled by unbind call');
	                }
	                const portNumber = await this.bindAddressList(addressList, boundPortObject);
	                if (boundPortObject.cancelled) {
	                    this.completeUnbind(boundPortObject);
	                    throw new Error('bindAsync operation cancelled by unbind call');
	                }
	                return portNumber;
	            }
	            normalizePort(port) {
	                const initialPortUri = (0, uri_parser_1.parseUri)(port);
	                if (initialPortUri === null) {
	                    throw new Error(`Could not parse port "${port}"`);
	                }
	                const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
	                if (portUri === null) {
	                    throw new Error(`Could not get a default scheme for port "${port}"`);
	                }
	                return portUri;
	            }
	            bindAsync(port, creds, callback) {
	                if (this.shutdown) {
	                    throw new Error('bindAsync called after shutdown');
	                }
	                if (typeof port !== 'string') {
	                    throw new TypeError('port must be a string');
	                }
	                if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
	                    throw new TypeError('creds must be a ServerCredentials object');
	                }
	                if (typeof callback !== 'function') {
	                    throw new TypeError('callback must be a function');
	                }
	                this.trace('bindAsync port=' + port);
	                const portUri = this.normalizePort(port);
	                const deferredCallback = (error, port) => {
	                    process.nextTick(() => callback(error, port));
	                };
	                /* First, if this port is already bound or that bind operation is in
	                 * progress, use that result. */
	                let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
	                if (boundPortObject) {
	                    if (!creds._equals(boundPortObject.credentials)) {
	                        deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
	                        return;
	                    }
	                    /* If that operation has previously been cancelled by an unbind call,
	                     * uncancel it. */
	                    boundPortObject.cancelled = false;
	                    if (boundPortObject.completionPromise) {
	                        boundPortObject.completionPromise.then(portNum => callback(null, portNum), error => callback(error, 0));
	                    }
	                    else {
	                        deferredCallback(null, boundPortObject.portNumber);
	                    }
	                    return;
	                }
	                boundPortObject = {
	                    mapKey: (0, uri_parser_1.uriToString)(portUri),
	                    originalUri: portUri,
	                    completionPromise: null,
	                    cancelled: false,
	                    portNumber: 0,
	                    credentials: creds,
	                    listeningServers: new Set(),
	                };
	                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
	                const completionPromise = this.bindPort(portUri, boundPortObject);
	                boundPortObject.completionPromise = completionPromise;
	                /* If the port number is 0, defer populating the map entry until after the
	                 * bind operation completes and we have a specific port number. Otherwise,
	                 * populate it immediately. */
	                if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
	                    completionPromise.then(portNum => {
	                        const finalUri = {
	                            scheme: portUri.scheme,
	                            authority: portUri.authority,
	                            path: (0, uri_parser_1.combineHostPort)({ host: splitPort.host, port: portNum }),
	                        };
	                        boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
	                        boundPortObject.completionPromise = null;
	                        boundPortObject.portNumber = portNum;
	                        this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
	                        callback(null, portNum);
	                    }, error => {
	                        callback(error, 0);
	                    });
	                }
	                else {
	                    this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
	                    completionPromise.then(portNum => {
	                        boundPortObject.completionPromise = null;
	                        boundPortObject.portNumber = portNum;
	                        callback(null, portNum);
	                    }, error => {
	                        callback(error, 0);
	                    });
	                }
	            }
	            registerInjectorToChannelz() {
	                return (0, channelz_1.registerChannelzSocket)('injector', () => {
	                    return {
	                        localAddress: null,
	                        remoteAddress: null,
	                        security: null,
	                        remoteName: null,
	                        streamsStarted: 0,
	                        streamsSucceeded: 0,
	                        streamsFailed: 0,
	                        messagesSent: 0,
	                        messagesReceived: 0,
	                        keepAlivesSent: 0,
	                        lastLocalStreamCreatedTimestamp: null,
	                        lastRemoteStreamCreatedTimestamp: null,
	                        lastMessageSentTimestamp: null,
	                        lastMessageReceivedTimestamp: null,
	                        localFlowControlWindow: null,
	                        remoteFlowControlWindow: null,
	                    };
	                }, this.channelzEnabled);
	            }
	            createConnectionInjector(credentials) {
	                if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
	                    throw new TypeError('creds must be a ServerCredentials object');
	                }
	                const server = this.createHttp2Server(credentials);
	                const channelzRef = this.registerInjectorToChannelz();
	                if (this.channelzEnabled) {
	                    this.listenerChildrenTracker.refChild(channelzRef);
	                }
	                const sessionsSet = new Set();
	                this.http2Servers.set(server, {
	                    channelzRef: channelzRef,
	                    sessions: sessionsSet
	                });
	                return {
	                    injectConnection: (connection) => {
	                        server.emit('connection', connection);
	                    },
	                    drain: (graceTimeMs) => {
	                        var _b, _c;
	                        for (const session of sessionsSet) {
	                            this.closeSession(session);
	                        }
	                        (_c = (_b = setTimeout(() => {
	                            for (const session of sessionsSet) {
	                                session.destroy(http2.constants.NGHTTP2_CANCEL);
	                            }
	                        }, graceTimeMs)).unref) === null || _c === undefined ? undefined : _c.call(_b);
	                    },
	                    destroy: () => {
	                        this.closeServer(server);
	                        for (const session of sessionsSet) {
	                            this.closeSession(session);
	                        }
	                    }
	                };
	            }
	            closeServer(server, callback) {
	                this.trace('Closing server with address ' + JSON.stringify(server.address()));
	                const serverInfo = this.http2Servers.get(server);
	                server.close(() => {
	                    if (serverInfo) {
	                        this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
	                        (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
	                    }
	                    this.http2Servers.delete(server);
	                    callback === null || callback === undefined ? undefined : callback();
	                });
	            }
	            closeSession(session, callback) {
	                var _b;
	                this.trace('Closing session initiated by ' + ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress));
	                const sessionInfo = this.sessions.get(session);
	                const closeCallback = () => {
	                    if (sessionInfo) {
	                        this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
	                        (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
	                    }
	                    callback === null || callback === undefined ? undefined : callback();
	                };
	                if (session.closed) {
	                    queueMicrotask(closeCallback);
	                }
	                else {
	                    session.close(closeCallback);
	                }
	            }
	            completeUnbind(boundPortObject) {
	                for (const server of boundPortObject.listeningServers) {
	                    const serverInfo = this.http2Servers.get(server);
	                    this.closeServer(server, () => {
	                        boundPortObject.listeningServers.delete(server);
	                    });
	                    if (serverInfo) {
	                        for (const session of serverInfo.sessions) {
	                            this.closeSession(session);
	                        }
	                    }
	                }
	                this.boundPorts.delete(boundPortObject.mapKey);
	            }
	            /**
	             * Unbind a previously bound port, or cancel an in-progress bindAsync
	             * operation. If port 0 was bound, only the actual bound port can be
	             * unbound. For example, if bindAsync was called with "localhost:0" and the
	             * bound port result was 54321, it can be unbound as "localhost:54321".
	             * @param port
	             */
	            unbind(port) {
	                this.trace('unbind port=' + port);
	                const portUri = this.normalizePort(port);
	                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
	                if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
	                    throw new Error('Cannot unbind port 0');
	                }
	                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
	                if (boundPortObject) {
	                    this.trace('unbinding ' +
	                        boundPortObject.mapKey +
	                        ' originally bound as ' +
	                        (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
	                    /* If the bind operation is pending, the cancelled flag will trigger
	                     * the unbind operation later. */
	                    if (boundPortObject.completionPromise) {
	                        boundPortObject.cancelled = true;
	                    }
	                    else {
	                        this.completeUnbind(boundPortObject);
	                    }
	                }
	            }
	            /**
	             * Gracefully close all connections associated with a previously bound port.
	             * After the grace time, forcefully close all remaining open connections.
	             *
	             * If port 0 was bound, only the actual bound port can be
	             * drained. For example, if bindAsync was called with "localhost:0" and the
	             * bound port result was 54321, it can be drained as "localhost:54321".
	             * @param port
	             * @param graceTimeMs
	             * @returns
	             */
	            drain(port, graceTimeMs) {
	                var _b, _c;
	                this.trace('drain port=' + port + ' graceTimeMs=' + graceTimeMs);
	                const portUri = this.normalizePort(port);
	                const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
	                if ((splitPort === null || splitPort === undefined ? undefined : splitPort.port) === 0) {
	                    throw new Error('Cannot drain port 0');
	                }
	                const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
	                if (!boundPortObject) {
	                    return;
	                }
	                const allSessions = new Set();
	                for (const http2Server of boundPortObject.listeningServers) {
	                    const serverEntry = this.http2Servers.get(http2Server);
	                    if (serverEntry) {
	                        for (const session of serverEntry.sessions) {
	                            allSessions.add(session);
	                            this.closeSession(session, () => {
	                                allSessions.delete(session);
	                            });
	                        }
	                    }
	                }
	                /* After the grace time ends, send another goaway to all remaining sessions
	                 * with the CANCEL code. */
	                (_c = (_b = setTimeout(() => {
	                    for (const session of allSessions) {
	                        session.destroy(http2.constants.NGHTTP2_CANCEL);
	                    }
	                }, graceTimeMs)).unref) === null || _c === undefined ? undefined : _c.call(_b);
	            }
	            forceShutdown() {
	                for (const boundPortObject of this.boundPorts.values()) {
	                    boundPortObject.cancelled = true;
	                }
	                this.boundPorts.clear();
	                // Close the server if it is still running.
	                for (const server of this.http2Servers.keys()) {
	                    this.closeServer(server);
	                }
	                // Always destroy any available sessions. It's possible that one or more
	                // tryShutdown() calls are in progress. Don't wait on them to finish.
	                this.sessions.forEach((channelzInfo, session) => {
	                    this.closeSession(session);
	                    // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to
	                    // recognize destroy(code) as a valid signature.
	                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	                    session.destroy(http2.constants.NGHTTP2_CANCEL);
	                });
	                this.sessions.clear();
	                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	                this.shutdown = true;
	            }
	            register(name, handler, serialize, deserialize, type) {
	                if (this.handlers.has(name)) {
	                    return false;
	                }
	                this.handlers.set(name, {
	                    func: handler,
	                    serialize,
	                    deserialize,
	                    type,
	                    path: name,
	                });
	                return true;
	            }
	            unregister(name) {
	                return this.handlers.delete(name);
	            }
	            /**
	             * @deprecated No longer needed as of version 1.10.x
	             */
	            start() {
	                if (this.http2Servers.size === 0 ||
	                    [...this.http2Servers.keys()].every(server => !server.listening)) {
	                    throw new Error('server must be bound in order to start');
	                }
	                if (this.started === true) {
	                    throw new Error('server is already started');
	                }
	                this.started = true;
	            }
	            tryShutdown(callback) {
	                var _b;
	                const wrappedCallback = (error) => {
	                    (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
	                    callback(error);
	                };
	                let pendingChecks = 0;
	                function maybeCallback() {
	                    pendingChecks--;
	                    if (pendingChecks === 0) {
	                        wrappedCallback();
	                    }
	                }
	                this.shutdown = true;
	                for (const [serverKey, server] of this.http2Servers.entries()) {
	                    pendingChecks++;
	                    const serverString = server.channelzRef.name;
	                    this.trace('Waiting for server ' + serverString + ' to close');
	                    this.closeServer(serverKey, () => {
	                        this.trace('Server ' + serverString + ' finished closing');
	                        maybeCallback();
	                    });
	                    for (const session of server.sessions.keys()) {
	                        pendingChecks++;
	                        const sessionString = (_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress;
	                        this.trace('Waiting for session ' + sessionString + ' to close');
	                        this.closeSession(session, () => {
	                            this.trace('Session ' + sessionString + ' finished closing');
	                            maybeCallback();
	                        });
	                    }
	                }
	                if (pendingChecks === 0) {
	                    wrappedCallback();
	                }
	            }
	            addHttp2Port() {
	                throw new Error('Not yet implemented');
	            }
	            /**
	             * Get the channelz reference object for this server. The returned value is
	             * garbage if channelz is disabled for this server.
	             * @returns
	             */
	            getChannelzRef() {
	                return this.channelzRef;
	            }
	            _verifyContentType(stream, headers) {
	                const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
	                if (typeof contentType !== 'string' ||
	                    !contentType.startsWith('application/grpc')) {
	                    stream.respond({
	                        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
	                    }, { endStream: true });
	                    return false;
	                }
	                return true;
	            }
	            _retrieveHandler(path) {
	                this.trace('Received call to method ' +
	                    path +
	                    ' at address ' +
	                    this.serverAddressString);
	                const handler = this.handlers.get(path);
	                if (handler === undefined) {
	                    this.trace('No handler registered for method ' +
	                        path +
	                        '. Sending UNIMPLEMENTED status.');
	                    return null;
	                }
	                return handler;
	            }
	            _respondWithError(err, stream, channelzSessionInfo = null) {
	                var _b, _c;
	                const trailersToSend = Object.assign({ 'grpc-status': (_b = err.code) !== null && _b !== undefined ? _b : constants_1.Status.INTERNAL, 'grpc-message': err.details, [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK, [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto' }, (_c = err.metadata) === null || _c === undefined ? undefined : _c.toHttp2Headers());
	                stream.respond(trailersToSend, { endStream: true });
	                this.callTracker.addCallFailed();
	                channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallFailed();
	            }
	            _channelzHandler(extraInterceptors, stream, headers) {
	                // for handling idle timeout
	                this.onStreamOpened(stream);
	                const channelzSessionInfo = this.sessions.get(stream.session);
	                this.callTracker.addCallStarted();
	                channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallStarted();
	                if (!this._verifyContentType(stream, headers)) {
	                    this.callTracker.addCallFailed();
	                    channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallFailed();
	                    return;
	                }
	                const path = headers[HTTP2_HEADER_PATH];
	                const handler = this._retrieveHandler(path);
	                if (!handler) {
	                    this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);
	                    return;
	                }
	                const callEventTracker = {
	                    addMessageSent: () => {
	                        if (channelzSessionInfo) {
	                            channelzSessionInfo.messagesSent += 1;
	                            channelzSessionInfo.lastMessageSentTimestamp = new Date();
	                        }
	                    },
	                    addMessageReceived: () => {
	                        if (channelzSessionInfo) {
	                            channelzSessionInfo.messagesReceived += 1;
	                            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
	                        }
	                    },
	                    onCallEnd: status => {
	                        if (status.code === constants_1.Status.OK) {
	                            this.callTracker.addCallSucceeded();
	                        }
	                        else {
	                            this.callTracker.addCallFailed();
	                        }
	                    },
	                    onStreamEnd: success => {
	                        if (channelzSessionInfo) {
	                            if (success) {
	                                channelzSessionInfo.streamTracker.addCallSucceeded();
	                            }
	                            else {
	                                channelzSessionInfo.streamTracker.addCallFailed();
	                            }
	                        }
	                    },
	                };
	                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, callEventTracker, handler, this.options);
	                if (!this._runHandlerForCall(call, handler)) {
	                    this.callTracker.addCallFailed();
	                    channelzSessionInfo === null || channelzSessionInfo === undefined ? undefined : channelzSessionInfo.streamTracker.addCallFailed();
	                    call.sendStatus({
	                        code: constants_1.Status.INTERNAL,
	                        details: `Unknown handler type: ${handler.type}`,
	                    });
	                }
	            }
	            _streamHandler(extraInterceptors, stream, headers) {
	                // for handling idle timeout
	                this.onStreamOpened(stream);
	                if (this._verifyContentType(stream, headers) !== true) {
	                    return;
	                }
	                const path = headers[HTTP2_HEADER_PATH];
	                const handler = this._retrieveHandler(path);
	                if (!handler) {
	                    this._respondWithError(getUnimplementedStatusResponse(path), stream, null);
	                    return;
	                }
	                const call = (0, server_interceptors_1.getServerInterceptingCall)([...extraInterceptors, ...this.interceptors], stream, headers, null, handler, this.options);
	                if (!this._runHandlerForCall(call, handler)) {
	                    call.sendStatus({
	                        code: constants_1.Status.INTERNAL,
	                        details: `Unknown handler type: ${handler.type}`,
	                    });
	                }
	            }
	            _runHandlerForCall(call, handler) {
	                const { type } = handler;
	                if (type === 'unary') {
	                    handleUnary(call, handler);
	                }
	                else if (type === 'clientStream') {
	                    handleClientStreaming(call, handler);
	                }
	                else if (type === 'serverStream') {
	                    handleServerStreaming(call, handler);
	                }
	                else if (type === 'bidi') {
	                    handleBidiStreaming(call, handler);
	                }
	                else {
	                    return false;
	                }
	                return true;
	            }
	            _setupHandlers(http2Server, extraInterceptors) {
	                if (http2Server === null) {
	                    return;
	                }
	                const serverAddress = http2Server.address();
	                let serverAddressString = 'null';
	                if (serverAddress) {
	                    if (typeof serverAddress === 'string') {
	                        serverAddressString = serverAddress;
	                    }
	                    else {
	                        serverAddressString = serverAddress.address + ':' + serverAddress.port;
	                    }
	                }
	                this.serverAddressString = serverAddressString;
	                const handler = this.channelzEnabled
	                    ? this._channelzHandler
	                    : this._streamHandler;
	                const sessionHandler = this.channelzEnabled
	                    ? this._channelzSessionHandler(http2Server)
	                    : this._sessionHandler(http2Server);
	                http2Server.on('stream', handler.bind(this, extraInterceptors));
	                http2Server.on('session', sessionHandler);
	            }
	            _sessionHandler(http2Server) {
	                return (session) => {
	                    var _b, _c;
	                    (_b = this.http2Servers.get(http2Server)) === null || _b === undefined ? undefined : _b.sessions.add(session);
	                    let connectionAgeTimer = null;
	                    let connectionAgeGraceTimer = null;
	                    let keepaliveTimer = null;
	                    let sessionClosedByServer = false;
	                    const idleTimeoutObj = this.enableIdleTimeout(session);
	                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                        // Apply a random jitter within a +/-10% range
	                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
	                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
	                        connectionAgeTimer = setTimeout(() => {
	                            var _b, _c;
	                            sessionClosedByServer = true;
	                            this.trace('Connection dropped by max connection age: ' +
	                                ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress));
	                            try {
	                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
	                            }
	                            catch (e) {
	                                // The goaway can't be sent because the session is already closed
	                                session.destroy();
	                                return;
	                            }
	                            session.close();
	                            /* Allow a grace period after sending the GOAWAY before forcibly
	                             * closing the connection. */
	                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                                connectionAgeGraceTimer = setTimeout(() => {
	                                    session.destroy();
	                                }, this.maxConnectionAgeGraceMs);
	                                (_c = connectionAgeGraceTimer.unref) === null || _c === undefined ? undefined : _c.call(connectionAgeGraceTimer);
	                            }
	                        }, this.maxConnectionAgeMs + jitter);
	                        (_c = connectionAgeTimer.unref) === null || _c === undefined ? undefined : _c.call(connectionAgeTimer);
	                    }
	                    const clearKeepaliveTimeout = () => {
	                        if (keepaliveTimer) {
	                            clearTimeout(keepaliveTimer);
	                            keepaliveTimer = null;
	                        }
	                    };
	                    const canSendPing = () => {
	                        return (!session.destroyed &&
	                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
	                            this.keepaliveTimeMs > 0);
	                    };
	                    /* eslint-disable-next-line prefer-const */
	                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer
	                    const maybeStartKeepalivePingTimer = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	                        keepaliveTimer = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            sendPing();
	                        }, this.keepaliveTimeMs);
	                        (_b = keepaliveTimer.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimer);
	                    };
	                    sendPing = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	                        let pingSendError = '';
	                        try {
	                            const pingSentSuccessfully = session.ping((err, duration, payload) => {
	                                clearKeepaliveTimeout();
	                                if (err) {
	                                    this.keepaliveTrace('Ping failed with error: ' + err.message);
	                                    sessionClosedByServer = true;
	                                    session.close();
	                                }
	                                else {
	                                    this.keepaliveTrace('Received ping response');
	                                    maybeStartKeepalivePingTimer();
	                                }
	                            });
	                            if (!pingSentSuccessfully) {
	                                pingSendError = 'Ping returned false';
	                            }
	                        }
	                        catch (e) {
	                            // grpc/grpc-node#2139
	                            pingSendError =
	                                (e instanceof Error ? e.message : '') || 'Unknown error';
	                        }
	                        if (pingSendError) {
	                            this.keepaliveTrace('Ping send failed: ' + pingSendError);
	                            this.trace('Connection dropped due to ping send error: ' + pingSendError);
	                            sessionClosedByServer = true;
	                            session.close();
	                            return;
	                        }
	                        keepaliveTimer = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            this.keepaliveTrace('Ping timeout passed without response');
	                            this.trace('Connection dropped by keepalive timeout');
	                            sessionClosedByServer = true;
	                            session.close();
	                        }, this.keepaliveTimeoutMs);
	                        (_b = keepaliveTimer.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimer);
	                    };
	                    maybeStartKeepalivePingTimer();
	                    session.on('close', () => {
	                        var _b, _c;
	                        if (!sessionClosedByServer) {
	                            this.trace(`Connection dropped by client ${(_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress}`);
	                        }
	                        if (connectionAgeTimer) {
	                            clearTimeout(connectionAgeTimer);
	                        }
	                        if (connectionAgeGraceTimer) {
	                            clearTimeout(connectionAgeGraceTimer);
	                        }
	                        clearKeepaliveTimeout();
	                        if (idleTimeoutObj !== null) {
	                            clearTimeout(idleTimeoutObj.timeout);
	                            this.sessionIdleTimeouts.delete(session);
	                        }
	                        (_c = this.http2Servers.get(http2Server)) === null || _c === undefined ? undefined : _c.sessions.delete(session);
	                    });
	                };
	            }
	            _channelzSessionHandler(http2Server) {
	                return (session) => {
	                    var _b, _c, _d, _e;
	                    const channelzRef = (0, channelz_1.registerChannelzSocket)((_c = (_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress) !== null && _c !== undefined ? _c : 'unknown', this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
	                    const channelzSessionInfo = {
	                        ref: channelzRef,
	                        streamTracker: new channelz_1.ChannelzCallTracker(),
	                        messagesSent: 0,
	                        messagesReceived: 0,
	                        keepAlivesSent: 0,
	                        lastMessageSentTimestamp: null,
	                        lastMessageReceivedTimestamp: null,
	                    };
	                    (_d = this.http2Servers.get(http2Server)) === null || _d === undefined ? undefined : _d.sessions.add(session);
	                    this.sessions.set(session, channelzSessionInfo);
	                    const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
	                    this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);
	                    this.trace('Connection established by client ' + clientAddress);
	                    this.sessionChildrenTracker.refChild(channelzRef);
	                    let connectionAgeTimer = null;
	                    let connectionAgeGraceTimer = null;
	                    let keepaliveTimeout = null;
	                    let sessionClosedByServer = false;
	                    const idleTimeoutObj = this.enableIdleTimeout(session);
	                    if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                        // Apply a random jitter within a +/-10% range
	                        const jitterMagnitude = this.maxConnectionAgeMs / 10;
	                        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
	                        connectionAgeTimer = setTimeout(() => {
	                            var _b;
	                            sessionClosedByServer = true;
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);
	                            try {
	                                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
	                            }
	                            catch (e) {
	                                // The goaway can't be sent because the session is already closed
	                                session.destroy();
	                                return;
	                            }
	                            session.close();
	                            /* Allow a grace period after sending the GOAWAY before forcibly
	                             * closing the connection. */
	                            if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
	                                connectionAgeGraceTimer = setTimeout(() => {
	                                    session.destroy();
	                                }, this.maxConnectionAgeGraceMs);
	                                (_b = connectionAgeGraceTimer.unref) === null || _b === undefined ? undefined : _b.call(connectionAgeGraceTimer);
	                            }
	                        }, this.maxConnectionAgeMs + jitter);
	                        (_e = connectionAgeTimer.unref) === null || _e === undefined ? undefined : _e.call(connectionAgeTimer);
	                    }
	                    const clearKeepaliveTimeout = () => {
	                        if (keepaliveTimeout) {
	                            clearTimeout(keepaliveTimeout);
	                            keepaliveTimeout = null;
	                        }
	                    };
	                    const canSendPing = () => {
	                        return (!session.destroyed &&
	                            this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS &&
	                            this.keepaliveTimeMs > 0);
	                    };
	                    /* eslint-disable-next-line prefer-const */
	                    let sendPing; // hoisted for use in maybeStartKeepalivePingTimer
	                    const maybeStartKeepalivePingTimer = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');
	                        keepaliveTimeout = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            sendPing();
	                        }, this.keepaliveTimeMs);
	                        (_b = keepaliveTimeout.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimeout);
	                    };
	                    sendPing = () => {
	                        var _b;
	                        if (!canSendPing()) {
	                            return;
	                        }
	                        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');
	                        let pingSendError = '';
	                        try {
	                            const pingSentSuccessfully = session.ping((err, duration, payload) => {
	                                clearKeepaliveTimeout();
	                                if (err) {
	                                    this.keepaliveTrace('Ping failed with error: ' + err.message);
	                                    this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to error of a ping frame ' +
	                                        err.message +
	                                        ' return in ' +
	                                        duration);
	                                    sessionClosedByServer = true;
	                                    session.close();
	                                }
	                                else {
	                                    this.keepaliveTrace('Received ping response');
	                                    maybeStartKeepalivePingTimer();
	                                }
	                            });
	                            if (!pingSentSuccessfully) {
	                                pingSendError = 'Ping returned false';
	                            }
	                        }
	                        catch (e) {
	                            // grpc/grpc-node#2139
	                            pingSendError =
	                                (e instanceof Error ? e.message : '') || 'Unknown error';
	                        }
	                        if (pingSendError) {
	                            this.keepaliveTrace('Ping send failed: ' + pingSendError);
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped due to ping send error: ' + pingSendError);
	                            sessionClosedByServer = true;
	                            session.close();
	                            return;
	                        }
	                        channelzSessionInfo.keepAlivesSent += 1;
	                        keepaliveTimeout = setTimeout(() => {
	                            clearKeepaliveTimeout();
	                            this.keepaliveTrace('Ping timeout passed without response');
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);
	                            sessionClosedByServer = true;
	                            session.close();
	                        }, this.keepaliveTimeoutMs);
	                        (_b = keepaliveTimeout.unref) === null || _b === undefined ? undefined : _b.call(keepaliveTimeout);
	                    };
	                    maybeStartKeepalivePingTimer();
	                    session.on('close', () => {
	                        var _b;
	                        if (!sessionClosedByServer) {
	                            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);
	                        }
	                        this.sessionChildrenTracker.unrefChild(channelzRef);
	                        (0, channelz_1.unregisterChannelzRef)(channelzRef);
	                        if (connectionAgeTimer) {
	                            clearTimeout(connectionAgeTimer);
	                        }
	                        if (connectionAgeGraceTimer) {
	                            clearTimeout(connectionAgeGraceTimer);
	                        }
	                        clearKeepaliveTimeout();
	                        if (idleTimeoutObj !== null) {
	                            clearTimeout(idleTimeoutObj.timeout);
	                            this.sessionIdleTimeouts.delete(session);
	                        }
	                        (_b = this.http2Servers.get(http2Server)) === null || _b === undefined ? undefined : _b.sessions.delete(session);
	                        this.sessions.delete(session);
	                    });
	                };
	            }
	            enableIdleTimeout(session) {
	                var _b, _c;
	                if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
	                    return null;
	                }
	                const idleTimeoutObj = {
	                    activeStreams: 0,
	                    lastIdle: Date.now(),
	                    onClose: this.onStreamClose.bind(this, session),
	                    timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session),
	                };
	                (_c = (_b = idleTimeoutObj.timeout).unref) === null || _c === undefined ? undefined : _c.call(_b);
	                this.sessionIdleTimeouts.set(session, idleTimeoutObj);
	                const { socket } = session;
	                this.trace('Enable idle timeout for ' +
	                    socket.remoteAddress +
	                    ':' +
	                    socket.remotePort);
	                return idleTimeoutObj;
	            }
	            onIdleTimeout(ctx, session) {
	                const { socket } = session;
	                const sessionInfo = ctx.sessionIdleTimeouts.get(session);
	                // if it is called while we have activeStreams - timer will not be rescheduled
	                // until last active stream is closed, then it will call .refresh() on the timer
	                // important part is to not clearTimeout(timer) or it becomes unusable
	                // for future refreshes
	                if (sessionInfo !== undefined &&
	                    sessionInfo.activeStreams === 0) {
	                    if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
	                        ctx.trace('Session idle timeout triggered for ' +
	                            (socket === null || socket === undefined ? undefined : socket.remoteAddress) +
	                            ':' +
	                            (socket === null || socket === undefined ? undefined : socket.remotePort) +
	                            ' last idle at ' +
	                            sessionInfo.lastIdle);
	                        ctx.closeSession(session);
	                    }
	                    else {
	                        sessionInfo.timeout.refresh();
	                    }
	                }
	            }
	            onStreamOpened(stream) {
	                const session = stream.session;
	                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
	                if (idleTimeoutObj) {
	                    idleTimeoutObj.activeStreams += 1;
	                    stream.once('close', idleTimeoutObj.onClose);
	                }
	            }
	            onStreamClose(session) {
	                var _b, _c;
	                const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
	                if (idleTimeoutObj) {
	                    idleTimeoutObj.activeStreams -= 1;
	                    if (idleTimeoutObj.activeStreams === 0) {
	                        idleTimeoutObj.lastIdle = Date.now();
	                        idleTimeoutObj.timeout.refresh();
	                        this.trace('Session onStreamClose' +
	                            ((_b = session.socket) === null || _b === undefined ? undefined : _b.remoteAddress) +
	                            ':' +
	                            ((_c = session.socket) === null || _c === undefined ? undefined : _c.remotePort) +
	                            ' at ' +
	                            idleTimeoutObj.lastIdle);
	                    }
	                }
	            }
	        },
	        (() => {
	            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : undefined;
	            _start_decorators = [deprecate('Calling start() is no longer necessary. It can be safely omitted.')];
	            __esDecorate(_a, null, _start_decorators, { kind: "method", name: "start", static: false, private: false, access: { has: obj => "start" in obj, get: obj => obj.start }, metadata: _metadata }, null, _instanceExtraInitializers);
	            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
	        })(),
	        _a;
	})();
	server.Server = Server;
	async function handleUnary(call, handler) {
	    let stream;
	    function respond(err, value, trailer, flags) {
	        if (err) {
	            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
	            return;
	        }
	        call.sendMessage(value, () => {
	            call.sendStatus({
	                code: constants_1.Status.OK,
	                details: 'OK',
	                metadata: trailer !== null && trailer !== undefined ? trailer : null,
	            });
	        });
	    }
	    let requestMetadata;
	    let requestMessage = null;
	    call.start({
	        onReceiveMetadata(metadata) {
	            requestMetadata = metadata;
	            call.startRead();
	        },
	        onReceiveMessage(message) {
	            if (requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received a second request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            requestMessage = message;
	            call.startRead();
	        },
	        onReceiveHalfClose() {
	            if (!requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received no request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
	            try {
	                handler.func(stream, respond);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	            }
	        },
	    });
	}
	function handleClientStreaming(call, handler) {
	    let stream;
	    function respond(err, value, trailer, flags) {
	        if (err) {
	            call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
	            return;
	        }
	        call.sendMessage(value, () => {
	            call.sendStatus({
	                code: constants_1.Status.OK,
	                details: 'OK',
	                metadata: trailer !== null && trailer !== undefined ? trailer : null,
	            });
	        });
	    }
	    call.start({
	        onReceiveMetadata(metadata) {
	            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
	            try {
	                handler.func(stream, respond);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onReceiveMessage(message) {
	            stream.push(message);
	        },
	        onReceiveHalfClose() {
	            stream.push(null);
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	                stream.destroy();
	            }
	        },
	    });
	}
	function handleServerStreaming(call, handler) {
	    let stream;
	    let requestMetadata;
	    let requestMessage = null;
	    call.start({
	        onReceiveMetadata(metadata) {
	            requestMetadata = metadata;
	            call.startRead();
	        },
	        onReceiveMessage(message) {
	            if (requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received a second request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            requestMessage = message;
	            call.startRead();
	        },
	        onReceiveHalfClose() {
	            if (!requestMessage) {
	                call.sendStatus({
	                    code: constants_1.Status.UNIMPLEMENTED,
	                    details: `Received no request message for server streaming method ${handler.path}`,
	                    metadata: null,
	                });
	                return;
	            }
	            stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
	            try {
	                handler.func(stream);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	                stream.destroy();
	            }
	        },
	    });
	}
	function handleBidiStreaming(call, handler) {
	    let stream;
	    call.start({
	        onReceiveMetadata(metadata) {
	            stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
	            try {
	                handler.func(stream);
	            }
	            catch (err) {
	                call.sendStatus({
	                    code: constants_1.Status.UNKNOWN,
	                    details: `Server method handler threw error ${err.message}`,
	                    metadata: null,
	                });
	            }
	        },
	        onReceiveMessage(message) {
	            stream.push(message);
	        },
	        onReceiveHalfClose() {
	            stream.push(null);
	        },
	        onCancel() {
	            if (stream) {
	                stream.cancelled = true;
	                stream.emit('cancelled', 'cancelled');
	                stream.destroy();
	            }
	        },
	    });
	}
	
	return server;
}

var statusBuilder = {};

var hasRequiredStatusBuilder;

function requireStatusBuilder () {
	if (hasRequiredStatusBuilder) return statusBuilder;
	hasRequiredStatusBuilder = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(statusBuilder, "__esModule", { value: true });
	statusBuilder.StatusBuilder = undefined;
	/**
	 * A builder for gRPC status objects.
	 */
	class StatusBuilder {
	    constructor() {
	        this.code = null;
	        this.details = null;
	        this.metadata = null;
	    }
	    /**
	     * Adds a status code to the builder.
	     */
	    withCode(code) {
	        this.code = code;
	        return this;
	    }
	    /**
	     * Adds details to the builder.
	     */
	    withDetails(details) {
	        this.details = details;
	        return this;
	    }
	    /**
	     * Adds metadata to the builder.
	     */
	    withMetadata(metadata) {
	        this.metadata = metadata;
	        return this;
	    }
	    /**
	     * Builds the status object.
	     */
	    build() {
	        const status = {};
	        if (this.code !== null) {
	            status.code = this.code;
	        }
	        if (this.details !== null) {
	            status.details = this.details;
	        }
	        if (this.metadata !== null) {
	            status.metadata = this.metadata;
	        }
	        return status;
	    }
	}
	statusBuilder.StatusBuilder = StatusBuilder;
	
	return statusBuilder;
}

var experimental = {};

var duration = {};

var hasRequiredDuration;

function requireDuration () {
	if (hasRequiredDuration) return duration;
	hasRequiredDuration = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(duration, "__esModule", { value: true });
	duration.parseDuration = duration.isDuration = duration.durationToMs = duration.msToDuration = undefined;
	function msToDuration(millis) {
	    return {
	        seconds: (millis / 1000) | 0,
	        nanos: ((millis % 1000) * 1000000) | 0,
	    };
	}
	duration.msToDuration = msToDuration;
	function durationToMs(duration) {
	    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;
	}
	duration.durationToMs = durationToMs;
	function isDuration(value) {
	    return typeof value.seconds === 'number' && typeof value.nanos === 'number';
	}
	duration.isDuration = isDuration;
	const durationRegex = /^(\d+)(?:\.(\d+))?s$/;
	function parseDuration(value) {
	    const match = value.match(durationRegex);
	    if (!match) {
	        return null;
	    }
	    return {
	        seconds: Number.parseInt(match[1], 10),
	        nanos: match[2] ? Number.parseInt(match[2].padEnd(9, '0'), 10) : 0
	    };
	}
	duration.parseDuration = parseDuration;
	
	return duration;
}

var loadBalancerPickFirst = {};

var hasRequiredLoadBalancerPickFirst;

function requireLoadBalancerPickFirst () {
	if (hasRequiredLoadBalancerPickFirst) return loadBalancerPickFirst;
	hasRequiredLoadBalancerPickFirst = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerPickFirst, "__esModule", { value: true });
	loadBalancerPickFirst.setup = loadBalancerPickFirst.LeafLoadBalancer = loadBalancerPickFirst.PickFirstLoadBalancer = loadBalancerPickFirst.shuffled = loadBalancerPickFirst.PickFirstLoadBalancingConfig = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = requireConnectivityState();
	const picker_1 = requirePicker();
	const subchannel_address_1 = requireSubchannelAddress();
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const subchannel_address_2 = requireSubchannelAddress();
	const net_1 = require$$0$a;
	const TRACER_NAME = 'pick_first';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'pick_first';
	/**
	 * Delay after starting a connection on a subchannel before starting a
	 * connection on the next subchannel in the list, for Happy Eyeballs algorithm.
	 */
	const CONNECTION_DELAY_INTERVAL_MS = 250;
	class PickFirstLoadBalancingConfig {
	    constructor(shuffleAddressList) {
	        this.shuffleAddressList = shuffleAddressList;
	    }
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    toJsonObject() {
	        return {
	            [TYPE_NAME]: {
	                shuffleAddressList: this.shuffleAddressList,
	            },
	        };
	    }
	    getShuffleAddressList() {
	        return this.shuffleAddressList;
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    static createFromJson(obj) {
	        if ('shuffleAddressList' in obj &&
	            !(typeof obj.shuffleAddressList === 'boolean')) {
	            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');
	        }
	        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);
	    }
	}
	loadBalancerPickFirst.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
	/**
	 * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the
	 * picked subchannel.
	 */
	class PickFirstPicker {
	    constructor(subchannel) {
	        this.subchannel = subchannel;
	    }
	    pick(pickArgs) {
	        return {
	            pickResultType: picker_1.PickResultType.COMPLETE,
	            subchannel: this.subchannel,
	            status: null,
	            onCallStarted: null,
	            onCallEnded: null,
	        };
	    }
	}
	/**
	 * Return a new array with the elements of the input array in a random order
	 * @param list The input array
	 * @returns A shuffled array of the elements of list
	 */
	function shuffled(list) {
	    const result = list.slice();
	    for (let i = result.length - 1; i > 1; i--) {
	        const j = Math.floor(Math.random() * (i + 1));
	        const temp = result[i];
	        result[i] = result[j];
	        result[j] = temp;
	    }
	    return result;
	}
	loadBalancerPickFirst.shuffled = shuffled;
	/**
	 * Interleave addresses in addressList by family in accordance with RFC-8304 section 4
	 * @param addressList
	 * @returns
	 */
	function interleaveAddressFamilies(addressList) {
	    const result = [];
	    const ipv6Addresses = [];
	    const ipv4Addresses = [];
	    const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
	    for (const address of addressList) {
	        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
	            ipv6Addresses.push(address);
	        }
	        else {
	            ipv4Addresses.push(address);
	        }
	    }
	    const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
	    const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
	    for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {
	        if (i < firstList.length) {
	            result.push(firstList[i]);
	        }
	        if (i < secondList.length) {
	            result.push(secondList[i]);
	        }
	    }
	    return result;
	}
	const REPORT_HEALTH_STATUS_OPTION_NAME = 'grpc-node.internal.pick-first.report_health_status';
	class PickFirstLoadBalancer {
	    /**
	     * Load balancer that attempts to connect to each backend in the address list
	     * in order, and picks the first one that connects, using it for every
	     * request.
	     * @param channelControlHelper `ChannelControlHelper` instance provided by
	     *     this load balancer's owner.
	     */
	    constructor(channelControlHelper, credentials, options) {
	        this.channelControlHelper = channelControlHelper;
	        /**
	         * The list of subchannels this load balancer is currently attempting to
	         * connect to.
	         */
	        this.children = [];
	        /**
	         * The current connectivity state of the load balancer.
	         */
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        /**
	         * The index within the `subchannels` array of the subchannel with the most
	         * recently started connection attempt.
	         */
	        this.currentSubchannelIndex = 0;
	        /**
	         * The currently picked subchannel used for making calls. Populated if
	         * and only if the load balancer's current state is READY. In that case,
	         * the subchannel's current state is also READY.
	         */
	        this.currentPick = null;
	        /**
	         * Listener callback attached to each subchannel in the `subchannels` list
	         * while establishing a connection.
	         */
	        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
	            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
	        };
	        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
	        /**
	         * The LB policy enters sticky TRANSIENT_FAILURE mode when all
	         * subchannels have failed to connect at least once, and it stays in that
	         * mode until a connection attempt is successful. While in sticky TF mode,
	         * the LB policy continuously attempts to connect to all of its subchannels.
	         */
	        this.stickyTransientFailureMode = false;
	        /**
	         * The most recent error reported by any subchannel as it transitioned to
	         * TRANSIENT_FAILURE.
	         */
	        this.lastError = null;
	        this.latestAddressList = null;
	        this.connectionDelayTimeout = setTimeout(() => { }, 0);
	        clearTimeout(this.connectionDelayTimeout);
	        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
	    }
	    allChildrenHaveReportedTF() {
	        return this.children.every(child => child.hasReportedTransientFailure);
	    }
	    resetChildrenReportedTF() {
	        this.children.every(child => child.hasReportedTransientFailure = false);
	    }
	    calculateAndReportNewState() {
	        if (this.currentPick) {
	            if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
	                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                    details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`,
	                }));
	            }
	            else {
	                this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));
	            }
	        }
	        else if (this.children.length === 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        }
	        else {
	            if (this.stickyTransientFailureMode) {
	                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                    details: `No connection established. Last error: ${this.lastError}`,
	                }));
	            }
	            else {
	                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
	            }
	        }
	    }
	    requestReresolution() {
	        this.channelControlHelper.requestReresolution();
	    }
	    maybeEnterStickyTransientFailureMode() {
	        if (!this.allChildrenHaveReportedTF()) {
	            return;
	        }
	        this.requestReresolution();
	        this.resetChildrenReportedTF();
	        if (this.stickyTransientFailureMode) {
	            this.calculateAndReportNewState();
	            return;
	        }
	        this.stickyTransientFailureMode = true;
	        for (const { subchannel } of this.children) {
	            subchannel.startConnecting();
	        }
	        this.calculateAndReportNewState();
	    }
	    removeCurrentPick() {
	        if (this.currentPick !== null) {
	            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);
	            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());
	            this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
	            // Unref last, to avoid triggering listeners
	            this.currentPick.unref();
	            this.currentPick = null;
	        }
	    }
	    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
	        var _a;
	        if ((_a = this.currentPick) === null || _a === undefined ? undefined : _a.realSubchannelEquals(subchannel)) {
	            if (newState !== connectivity_state_1.ConnectivityState.READY) {
	                this.removeCurrentPick();
	                this.calculateAndReportNewState();
	            }
	            return;
	        }
	        for (const [index, child] of this.children.entries()) {
	            if (subchannel.realSubchannelEquals(child.subchannel)) {
	                if (newState === connectivity_state_1.ConnectivityState.READY) {
	                    this.pickSubchannel(child.subchannel);
	                }
	                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                    child.hasReportedTransientFailure = true;
	                    if (errorMessage) {
	                        this.lastError = errorMessage;
	                    }
	                    this.maybeEnterStickyTransientFailureMode();
	                    if (index === this.currentSubchannelIndex) {
	                        this.startNextSubchannelConnecting(index + 1);
	                    }
	                }
	                child.subchannel.startConnecting();
	                return;
	            }
	        }
	    }
	    startNextSubchannelConnecting(startIndex) {
	        clearTimeout(this.connectionDelayTimeout);
	        for (const [index, child] of this.children.entries()) {
	            if (index >= startIndex) {
	                const subchannelState = child.subchannel.getConnectivityState();
	                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||
	                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
	                    this.startConnecting(index);
	                    return;
	                }
	            }
	        }
	        this.maybeEnterStickyTransientFailureMode();
	    }
	    /**
	     * Have a single subchannel in the `subchannels` list start connecting.
	     * @param subchannelIndex The index into the `subchannels` list.
	     */
	    startConnecting(subchannelIndex) {
	        var _a, _b;
	        clearTimeout(this.connectionDelayTimeout);
	        this.currentSubchannelIndex = subchannelIndex;
	        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===
	            connectivity_state_1.ConnectivityState.IDLE) {
	            trace('Start connecting to subchannel with address ' +
	                this.children[subchannelIndex].subchannel.getAddress());
	            process.nextTick(() => {
	                var _a;
	                (_a = this.children[subchannelIndex]) === null || _a === undefined ? undefined : _a.subchannel.startConnecting();
	            });
	        }
	        this.connectionDelayTimeout = setTimeout(() => {
	            this.startNextSubchannelConnecting(subchannelIndex + 1);
	        }, CONNECTION_DELAY_INTERVAL_MS);
	        (_b = (_a = this.connectionDelayTimeout).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    /**
	     * Declare that the specified subchannel should be used to make requests.
	     * This functions the same independent of whether subchannel is a member of
	     * this.children and whether it is equal to this.currentPick.
	     * Prerequisite: subchannel.getConnectivityState() === READY.
	     * @param subchannel
	     */
	    pickSubchannel(subchannel) {
	        trace('Pick subchannel with address ' + subchannel.getAddress());
	        this.stickyTransientFailureMode = false;
	        /* Ref before removeCurrentPick and resetSubchannelList to avoid the
	         * refcount dropping to 0 during this process. */
	        subchannel.ref();
	        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
	        this.removeCurrentPick();
	        this.resetSubchannelList();
	        subchannel.addConnectivityStateListener(this.subchannelStateListener);
	        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
	        this.currentPick = subchannel;
	        clearTimeout(this.connectionDelayTimeout);
	        this.calculateAndReportNewState();
	    }
	    updateState(newState, picker) {
	        trace(connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        this.currentState = newState;
	        this.channelControlHelper.updateState(newState, picker);
	    }
	    resetSubchannelList() {
	        for (const child of this.children) {
	            /* Always remoev the connectivity state listener. If the subchannel is
	               getting picked, it will be re-added then. */
	            child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
	            /* Refs are counted independently for the children list and the
	             * currentPick, so we call unref whether or not the child is the
	             * currentPick. Channelz child references are also refcounted, so
	             * removeChannelzChild can be handled the same way. */
	            child.subchannel.unref();
	            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
	        }
	        this.currentSubchannelIndex = 0;
	        this.children = [];
	    }
	    connectToAddressList(addressList) {
	        trace('connectToAddressList([' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');
	        const newChildrenList = addressList.map(address => ({
	            subchannel: this.channelControlHelper.createSubchannel(address, {}, null),
	            hasReportedTransientFailure: false,
	        }));
	        for (const { subchannel } of newChildrenList) {
	            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
	                this.pickSubchannel(subchannel);
	                return;
	            }
	        }
	        /* Ref each subchannel before resetting the list, to ensure that
	         * subchannels shared between the list don't drop to 0 refs during the
	         * transition. */
	        for (const { subchannel } of newChildrenList) {
	            subchannel.ref();
	            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
	        }
	        this.resetSubchannelList();
	        this.children = newChildrenList;
	        for (const { subchannel } of this.children) {
	            subchannel.addConnectivityStateListener(this.subchannelStateListener);
	        }
	        for (const child of this.children) {
	            if (child.subchannel.getConnectivityState() ===
	                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
	                child.hasReportedTransientFailure = true;
	            }
	        }
	        this.startNextSubchannelConnecting(0);
	        this.calculateAndReportNewState();
	    }
	    updateAddressList(endpointList, lbConfig) {
	        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
	            return;
	        }
	        /* Previously, an update would be discarded if it was identical to the
	         * previous update, to minimize churn. Now the DNS resolver is
	         * rate-limited, so that is less of a concern. */
	        if (lbConfig.getShuffleAddressList()) {
	            endpointList = shuffled(endpointList);
	        }
	        const rawAddressList = [].concat(...endpointList.map(endpoint => endpoint.addresses));
	        trace('updateAddressList([' + rawAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)) + '])');
	        if (rawAddressList.length === 0) {
	            throw new Error('No addresses in endpoint list passed to pick_first');
	        }
	        const addressList = interleaveAddressFamilies(rawAddressList);
	        this.latestAddressList = addressList;
	        this.connectToAddressList(addressList);
	    }
	    exitIdle() {
	        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE &&
	            this.latestAddressList) {
	            this.connectToAddressList(this.latestAddressList);
	        }
	    }
	    resetBackoff() {
	        /* The pick first load balancer does not have a connection backoff, so this
	         * does nothing */
	    }
	    destroy() {
	        this.resetSubchannelList();
	        this.removeCurrentPick();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerPickFirst.PickFirstLoadBalancer = PickFirstLoadBalancer;
	const LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);
	/**
	 * This class handles the leaf load balancing operations for a single endpoint.
	 * It is a thin wrapper around a PickFirstLoadBalancer with a different API
	 * that more closely reflects how it will be used as a leaf balancer.
	 */
	class LeafLoadBalancer {
	    constructor(endpoint, channelControlHelper, credentials, options) {
	        this.endpoint = endpoint;
	        this.latestState = connectivity_state_1.ConnectivityState.IDLE;
	        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
	            updateState: (connectivityState, picker) => {
	                this.latestState = connectivityState;
	                this.latestPicker = picker;
	                channelControlHelper.updateState(connectivityState, picker);
	            },
	        });
	        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, credentials, Object.assign(Object.assign({}, options), { [REPORT_HEALTH_STATUS_OPTION_NAME]: true }));
	        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
	    }
	    startConnecting() {
	        this.pickFirstBalancer.updateAddressList([this.endpoint], LEAF_CONFIG);
	    }
	    /**
	     * Update the endpoint associated with this LeafLoadBalancer to a new
	     * endpoint. Does not trigger connection establishment if a connection
	     * attempt is not already in progress.
	     * @param newEndpoint
	     */
	    updateEndpoint(newEndpoint) {
	        this.endpoint = newEndpoint;
	        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
	            this.startConnecting();
	        }
	    }
	    getConnectivityState() {
	        return this.latestState;
	    }
	    getPicker() {
	        return this.latestPicker;
	    }
	    getEndpoint() {
	        return this.endpoint;
	    }
	    exitIdle() {
	        this.pickFirstBalancer.exitIdle();
	    }
	    destroy() {
	        this.pickFirstBalancer.destroy();
	    }
	}
	loadBalancerPickFirst.LeafLoadBalancer = LeafLoadBalancer;
	function setup() {
	    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
	    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
	}
	loadBalancerPickFirst.setup = setup;
	
	return loadBalancerPickFirst;
}

var certificateProvider = {};

var hasRequiredCertificateProvider;

function requireCertificateProvider () {
	if (hasRequiredCertificateProvider) return certificateProvider;
	hasRequiredCertificateProvider = 1;
	/*
	 * Copyright 2024 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(certificateProvider, "__esModule", { value: true });
	certificateProvider.FileWatcherCertificateProvider = undefined;
	const fs = require$$0$5;
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const util_1 = require$$0$7;
	const TRACER_NAME = 'certificate_provider';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const readFilePromise = (0, util_1.promisify)(fs.readFile);
	class FileWatcherCertificateProvider {
	    constructor(config) {
	        this.config = config;
	        this.refreshTimer = null;
	        this.fileResultPromise = null;
	        this.latestCaUpdate = null;
	        this.caListeners = new Set();
	        this.latestIdentityUpdate = null;
	        this.identityListeners = new Set();
	        this.lastUpdateTime = null;
	        if ((config.certificateFile === undefined) !== (config.privateKeyFile === undefined)) {
	            throw new Error('certificateFile and privateKeyFile must be set or unset together');
	        }
	        if (config.certificateFile === undefined && config.caCertificateFile === undefined) {
	            throw new Error('At least one of certificateFile and caCertificateFile must be set');
	        }
	        trace('File watcher constructed with config ' + JSON.stringify(config));
	    }
	    updateCertificates() {
	        if (this.fileResultPromise) {
	            return;
	        }
	        this.fileResultPromise = Promise.allSettled([
	            this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),
	            this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),
	            this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()
	        ]);
	        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {
	            if (!this.refreshTimer) {
	                return;
	            }
	            trace('File watcher read certificates certificate' + (certificateResult ? '!=' : '==') + 'null, privateKey' + (privateKeyResult ? '!=' : '==') + 'null, CA certificate' + (caCertificateResult ? '!=' : '==') + 'null');
	            this.lastUpdateTime = new Date();
	            this.fileResultPromise = null;
	            if (certificateResult.status === 'fulfilled' && privateKeyResult.status === 'fulfilled') {
	                this.latestIdentityUpdate = {
	                    certificate: certificateResult.value,
	                    privateKey: privateKeyResult.value
	                };
	            }
	            else {
	                this.latestIdentityUpdate = null;
	            }
	            if (caCertificateResult.status === 'fulfilled') {
	                this.latestCaUpdate = {
	                    caCertificate: caCertificateResult.value
	                };
	            }
	            for (const listener of this.identityListeners) {
	                listener(this.latestIdentityUpdate);
	            }
	            for (const listener of this.caListeners) {
	                listener(this.latestCaUpdate);
	            }
	        });
	        trace('File watcher initiated certificate update');
	    }
	    maybeStartWatchingFiles() {
	        if (!this.refreshTimer) {
	            /* Perform the first read immediately, but only if there was not already
	             * a recent read, to avoid reading from the filesystem significantly more
	             * frequently than configured if the provider quickly switches between
	             * used and unused. */
	            const timeSinceLastUpdate = this.lastUpdateTime ? (new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;
	            if (timeSinceLastUpdate > this.config.refreshIntervalMs) {
	                this.updateCertificates();
	            }
	            if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {
	                // Clear out old updates if they are definitely stale
	                this.latestCaUpdate = null;
	                this.latestIdentityUpdate = null;
	            }
	            this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);
	            trace('File watcher started watching');
	        }
	    }
	    maybeStopWatchingFiles() {
	        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {
	            this.fileResultPromise = null;
	            if (this.refreshTimer) {
	                clearInterval(this.refreshTimer);
	                this.refreshTimer = null;
	            }
	        }
	    }
	    addCaCertificateListener(listener) {
	        this.caListeners.add(listener);
	        this.maybeStartWatchingFiles();
	        process.nextTick(listener, this.latestCaUpdate);
	    }
	    removeCaCertificateListener(listener) {
	        this.caListeners.delete(listener);
	        this.maybeStopWatchingFiles();
	    }
	    addIdentityCertificateListener(listener) {
	        this.identityListeners.add(listener);
	        this.maybeStartWatchingFiles();
	        process.nextTick(listener, this.latestIdentityUpdate);
	    }
	    removeIdentityCertificateListener(listener) {
	        this.identityListeners.delete(listener);
	        this.maybeStopWatchingFiles();
	    }
	}
	certificateProvider.FileWatcherCertificateProvider = FileWatcherCertificateProvider;
	
	return certificateProvider;
}

var hasRequiredExperimental;

function requireExperimental () {
	if (hasRequiredExperimental) return experimental;
	hasRequiredExperimental = 1;
	(function (exports) {
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createCertificateProviderChannelCredentials = exports.FileWatcherCertificateProvider = exports.createCertificateProviderServerCredentials = exports.createServerCredentialsWithInterceptors = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.EndpointMap = exports.endpointHasAddress = exports.endpointToString = exports.subchannelAddressToString = exports.LeafLoadBalancer = exports.isLoadBalancerNameRegistered = exports.parseLoadBalancingConfig = exports.selectLbConfigFromList = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.parseDuration = exports.durationToMs = exports.splitHostPort = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = undefined;
		var logging_1 = requireLogging();
		Object.defineProperty(exports, "trace", { enumerable: true, get: function () { return logging_1.trace; } });
		Object.defineProperty(exports, "log", { enumerable: true, get: function () { return logging_1.log; } });
		var resolver_1 = requireResolver();
		Object.defineProperty(exports, "registerResolver", { enumerable: true, get: function () { return resolver_1.registerResolver; } });
		Object.defineProperty(exports, "createResolver", { enumerable: true, get: function () { return resolver_1.createResolver; } });
		var uri_parser_1 = requireUriParser();
		Object.defineProperty(exports, "uriToString", { enumerable: true, get: function () { return uri_parser_1.uriToString; } });
		Object.defineProperty(exports, "splitHostPort", { enumerable: true, get: function () { return uri_parser_1.splitHostPort; } });
		var duration_1 = requireDuration();
		Object.defineProperty(exports, "durationToMs", { enumerable: true, get: function () { return duration_1.durationToMs; } });
		Object.defineProperty(exports, "parseDuration", { enumerable: true, get: function () { return duration_1.parseDuration; } });
		var backoff_timeout_1 = requireBackoffTimeout();
		Object.defineProperty(exports, "BackoffTimeout", { enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } });
		var load_balancer_1 = requireLoadBalancer();
		Object.defineProperty(exports, "createChildChannelControlHelper", { enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } });
		Object.defineProperty(exports, "registerLoadBalancerType", { enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } });
		Object.defineProperty(exports, "selectLbConfigFromList", { enumerable: true, get: function () { return load_balancer_1.selectLbConfigFromList; } });
		Object.defineProperty(exports, "parseLoadBalancingConfig", { enumerable: true, get: function () { return load_balancer_1.parseLoadBalancingConfig; } });
		Object.defineProperty(exports, "isLoadBalancerNameRegistered", { enumerable: true, get: function () { return load_balancer_1.isLoadBalancerNameRegistered; } });
		var load_balancer_pick_first_1 = requireLoadBalancerPickFirst();
		Object.defineProperty(exports, "LeafLoadBalancer", { enumerable: true, get: function () { return load_balancer_pick_first_1.LeafLoadBalancer; } });
		var subchannel_address_1 = requireSubchannelAddress();
		Object.defineProperty(exports, "subchannelAddressToString", { enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } });
		Object.defineProperty(exports, "endpointToString", { enumerable: true, get: function () { return subchannel_address_1.endpointToString; } });
		Object.defineProperty(exports, "endpointHasAddress", { enumerable: true, get: function () { return subchannel_address_1.endpointHasAddress; } });
		Object.defineProperty(exports, "EndpointMap", { enumerable: true, get: function () { return subchannel_address_1.EndpointMap; } });
		var load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
		Object.defineProperty(exports, "ChildLoadBalancerHandler", { enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } });
		var picker_1 = requirePicker();
		Object.defineProperty(exports, "UnavailablePicker", { enumerable: true, get: function () { return picker_1.UnavailablePicker; } });
		Object.defineProperty(exports, "QueuePicker", { enumerable: true, get: function () { return picker_1.QueuePicker; } });
		Object.defineProperty(exports, "PickResultType", { enumerable: true, get: function () { return picker_1.PickResultType; } });
		var filter_1 = requireFilter();
		Object.defineProperty(exports, "BaseFilter", { enumerable: true, get: function () { return filter_1.BaseFilter; } });
		var filter_stack_1 = requireFilterStack();
		Object.defineProperty(exports, "FilterStackFactory", { enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } });
		var admin_1 = requireAdmin();
		Object.defineProperty(exports, "registerAdminService", { enumerable: true, get: function () { return admin_1.registerAdminService; } });
		var subchannel_interface_1 = requireSubchannelInterface();
		Object.defineProperty(exports, "BaseSubchannelWrapper", { enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } });
		var server_credentials_1 = requireServerCredentials();
		Object.defineProperty(exports, "createServerCredentialsWithInterceptors", { enumerable: true, get: function () { return server_credentials_1.createServerCredentialsWithInterceptors; } });
		Object.defineProperty(exports, "createCertificateProviderServerCredentials", { enumerable: true, get: function () { return server_credentials_1.createCertificateProviderServerCredentials; } });
		var certificate_provider_1 = requireCertificateProvider();
		Object.defineProperty(exports, "FileWatcherCertificateProvider", { enumerable: true, get: function () { return certificate_provider_1.FileWatcherCertificateProvider; } });
		var channel_credentials_1 = requireChannelCredentials();
		Object.defineProperty(exports, "createCertificateProviderChannelCredentials", { enumerable: true, get: function () { return channel_credentials_1.createCertificateProviderChannelCredentials; } });
		
	} (experimental));
	return experimental;
}

var resolverUds = {};

var hasRequiredResolverUds;

function requireResolverUds () {
	if (hasRequiredResolverUds) return resolverUds;
	hasRequiredResolverUds = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(resolverUds, "__esModule", { value: true });
	resolverUds.setup = undefined;
	const resolver_1 = requireResolver();
	class UdsResolver {
	    constructor(target, listener, channelOptions) {
	        this.listener = listener;
	        this.hasReturnedResult = false;
	        this.endpoints = [];
	        let path;
	        if (target.authority === '') {
	            path = '/' + target.path;
	        }
	        else {
	            path = target.path;
	        }
	        this.endpoints = [{ addresses: [{ path }] }];
	    }
	    updateResolution() {
	        if (!this.hasReturnedResult) {
	            this.hasReturnedResult = true;
	            process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
	        }
	    }
	    destroy() {
	        this.hasReturnedResult = false;
	    }
	    static getDefaultAuthority(target) {
	        return 'localhost';
	    }
	}
	function setup() {
	    (0, resolver_1.registerResolver)('unix', UdsResolver);
	}
	resolverUds.setup = setup;
	
	return resolverUds;
}

var resolverIp = {};

var hasRequiredResolverIp;

function requireResolverIp () {
	if (hasRequiredResolverIp) return resolverIp;
	hasRequiredResolverIp = 1;
	/*
	 * Copyright 2021 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(resolverIp, "__esModule", { value: true });
	resolverIp.setup = undefined;
	const net_1 = require$$0$a;
	const constants_1 = requireConstants();
	const metadata_1 = requireMetadata();
	const resolver_1 = requireResolver();
	const uri_parser_1 = requireUriParser();
	const logging = requireLogging();
	const TRACER_NAME = 'ip_resolver';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const IPV4_SCHEME = 'ipv4';
	const IPV6_SCHEME = 'ipv6';
	/**
	 * The default TCP port to connect to if not explicitly specified in the target.
	 */
	const DEFAULT_PORT = 443;
	class IpResolver {
	    constructor(target, listener, channelOptions) {
	        var _a;
	        this.listener = listener;
	        this.endpoints = [];
	        this.error = null;
	        this.hasReturnedResult = false;
	        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));
	        const addresses = [];
	        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
	            this.error = {
	                code: constants_1.Status.UNAVAILABLE,
	                details: `Unrecognized scheme ${target.scheme} in IP resolver`,
	                metadata: new metadata_1.Metadata(),
	            };
	            return;
	        }
	        const pathList = target.path.split(',');
	        for (const path of pathList) {
	            const hostPort = (0, uri_parser_1.splitHostPort)(path);
	            if (hostPort === null) {
	                this.error = {
	                    code: constants_1.Status.UNAVAILABLE,
	                    details: `Failed to parse ${target.scheme} address ${path}`,
	                    metadata: new metadata_1.Metadata(),
	                };
	                return;
	            }
	            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||
	                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {
	                this.error = {
	                    code: constants_1.Status.UNAVAILABLE,
	                    details: `Failed to parse ${target.scheme} address ${path}`,
	                    metadata: new metadata_1.Metadata(),
	                };
	                return;
	            }
	            addresses.push({
	                host: hostPort.host,
	                port: (_a = hostPort.port) !== null && _a !== undefined ? _a : DEFAULT_PORT,
	            });
	        }
	        this.endpoints = addresses.map(address => ({ addresses: [address] }));
	        trace('Parsed ' + target.scheme + ' address list ' + addresses);
	    }
	    updateResolution() {
	        if (!this.hasReturnedResult) {
	            this.hasReturnedResult = true;
	            process.nextTick(() => {
	                if (this.error) {
	                    this.listener.onError(this.error);
	                }
	                else {
	                    this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
	                }
	            });
	        }
	    }
	    destroy() {
	        this.hasReturnedResult = false;
	    }
	    static getDefaultAuthority(target) {
	        return target.path.split(',')[0];
	    }
	}
	function setup() {
	    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
	    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
	}
	resolverIp.setup = setup;
	
	return resolverIp;
}

var loadBalancerRoundRobin = {};

var hasRequiredLoadBalancerRoundRobin;

function requireLoadBalancerRoundRobin () {
	if (hasRequiredLoadBalancerRoundRobin) return loadBalancerRoundRobin;
	hasRequiredLoadBalancerRoundRobin = 1;
	/*
	 * Copyright 2019 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	Object.defineProperty(loadBalancerRoundRobin, "__esModule", { value: true });
	loadBalancerRoundRobin.setup = loadBalancerRoundRobin.RoundRobinLoadBalancer = undefined;
	const load_balancer_1 = requireLoadBalancer();
	const connectivity_state_1 = requireConnectivityState();
	const picker_1 = requirePicker();
	const logging = requireLogging();
	const constants_1 = requireConstants();
	const subchannel_address_1 = requireSubchannelAddress();
	const load_balancer_pick_first_1 = requireLoadBalancerPickFirst();
	const TRACER_NAME = 'round_robin';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'round_robin';
	class RoundRobinLoadBalancingConfig {
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    constructor() { }
	    toJsonObject() {
	        return {
	            [TYPE_NAME]: {},
	        };
	    }
	    // eslint-disable-next-line @typescript-eslint/no-explicit-any
	    static createFromJson(obj) {
	        return new RoundRobinLoadBalancingConfig();
	    }
	}
	class RoundRobinPicker {
	    constructor(children, nextIndex = 0) {
	        this.children = children;
	        this.nextIndex = nextIndex;
	    }
	    pick(pickArgs) {
	        const childPicker = this.children[this.nextIndex].picker;
	        this.nextIndex = (this.nextIndex + 1) % this.children.length;
	        return childPicker.pick(pickArgs);
	    }
	    /**
	     * Check what the next subchannel returned would be. Used by the load
	     * balancer implementation to preserve this part of the picker state if
	     * possible when a subchannel connects or disconnects.
	     */
	    peekNextEndpoint() {
	        return this.children[this.nextIndex].endpoint;
	    }
	}
	class RoundRobinLoadBalancer {
	    constructor(channelControlHelper, credentials, options) {
	        this.channelControlHelper = channelControlHelper;
	        this.credentials = credentials;
	        this.options = options;
	        this.children = [];
	        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
	        this.currentReadyPicker = null;
	        this.updatesPaused = false;
	        this.lastError = null;
	        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
	            updateState: (connectivityState, picker) => {
	                /* Ensure that name resolution is requested again after active
	                 * connections are dropped. This is more aggressive than necessary to
	                 * accomplish that, so we are counting on resolvers to have
	                 * reasonable rate limits. */
	                if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {
	                    this.channelControlHelper.requestReresolution();
	                }
	                this.calculateAndUpdateState();
	            },
	        });
	    }
	    countChildrenWithState(state) {
	        return this.children.filter(child => child.getConnectivityState() === state)
	            .length;
	    }
	    calculateAndUpdateState() {
	        if (this.updatesPaused) {
	            return;
	        }
	        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
	            const readyChildren = this.children.filter(child => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
	            let index = 0;
	            if (this.currentReadyPicker !== null) {
	                const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
	                index = readyChildren.findIndex(child => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
	                if (index < 0) {
	                    index = 0;
	                }
	            }
	            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map(child => ({
	                endpoint: child.getEndpoint(),
	                picker: child.getPicker(),
	            })), index));
	        }
	        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
	        }
	        else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
	            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
	                details: `No connection established. Last error: ${this.lastError}`,
	            }));
	        }
	        else {
	            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
	        }
	        /* round_robin should keep all children connected, this is how we do that.
	         * We can't do this more efficiently in the individual child's updateState
	         * callback because that doesn't have a reference to which child the state
	         * change is associated with. */
	        for (const child of this.children) {
	            if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
	                child.exitIdle();
	            }
	        }
	    }
	    updateState(newState, picker) {
	        trace(connectivity_state_1.ConnectivityState[this.currentState] +
	            ' -> ' +
	            connectivity_state_1.ConnectivityState[newState]);
	        if (newState === connectivity_state_1.ConnectivityState.READY) {
	            this.currentReadyPicker = picker;
	        }
	        else {
	            this.currentReadyPicker = null;
	        }
	        this.currentState = newState;
	        this.channelControlHelper.updateState(newState, picker);
	    }
	    resetSubchannelList() {
	        for (const child of this.children) {
	            child.destroy();
	        }
	    }
	    updateAddressList(endpointList, lbConfig) {
	        this.resetSubchannelList();
	        trace('Connect to endpoint list ' + endpointList.map(subchannel_address_1.endpointToString));
	        this.updatesPaused = true;
	        this.children = endpointList.map(endpoint => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.credentials, this.options));
	        for (const child of this.children) {
	            child.startConnecting();
	        }
	        this.updatesPaused = false;
	        this.calculateAndUpdateState();
	    }
	    exitIdle() {
	        /* The round_robin LB policy is only in the IDLE state if it has no
	         * addresses to try to connect to and it has no picked subchannel.
	         * In that case, there is no meaningful action that can be taken here. */
	    }
	    resetBackoff() {
	        // This LB policy has no backoff to reset
	    }
	    destroy() {
	        this.resetSubchannelList();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerRoundRobin.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
	function setup() {
	    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
	}
	loadBalancerRoundRobin.setup = setup;
	
	return loadBalancerRoundRobin;
}

var loadBalancerOutlierDetection = {};

var hasRequiredLoadBalancerOutlierDetection;

function requireLoadBalancerOutlierDetection () {
	if (hasRequiredLoadBalancerOutlierDetection) return loadBalancerOutlierDetection;
	hasRequiredLoadBalancerOutlierDetection = 1;
	/*
	 * Copyright 2022 gRPC authors.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */
	var _a;
	Object.defineProperty(loadBalancerOutlierDetection, "__esModule", { value: true });
	loadBalancerOutlierDetection.setup = loadBalancerOutlierDetection.OutlierDetectionLoadBalancer = loadBalancerOutlierDetection.OutlierDetectionLoadBalancingConfig = undefined;
	const connectivity_state_1 = requireConnectivityState();
	const constants_1 = requireConstants();
	const duration_1 = requireDuration();
	const experimental_1 = requireExperimental();
	const load_balancer_1 = requireLoadBalancer();
	const load_balancer_child_handler_1 = requireLoadBalancerChildHandler();
	const picker_1 = requirePicker();
	const subchannel_address_1 = requireSubchannelAddress();
	const subchannel_interface_1 = requireSubchannelInterface();
	const logging = requireLogging();
	const TRACER_NAME = 'outlier_detection';
	function trace(text) {
	    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
	}
	const TYPE_NAME = 'outlier_detection';
	const OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== undefined ? _a : 'true') === 'true';
	const defaultSuccessRateEjectionConfig = {
	    stdev_factor: 1900,
	    enforcement_percentage: 100,
	    minimum_hosts: 5,
	    request_volume: 100,
	};
	const defaultFailurePercentageEjectionConfig = {
	    threshold: 85,
	    enforcement_percentage: 100,
	    minimum_hosts: 5,
	    request_volume: 50,
	};
	function validateFieldType(obj, fieldName, expectedType, objectName) {
	    if (fieldName in obj &&
	        obj[fieldName] !== undefined &&
	        typeof obj[fieldName] !== expectedType) {
	        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
	        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
	    }
	}
	function validatePositiveDuration(obj, fieldName, objectName) {
	    const fullFieldName = fieldName;
	    if (fieldName in obj && obj[fieldName] !== undefined) {
	        if (!(0, duration_1.isDuration)(obj[fieldName])) {
	            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
	        }
	        if (!(obj[fieldName].seconds >= 0 &&
	            obj[fieldName].seconds <= 315576000000 &&
	            obj[fieldName].nanos >= 0 &&
	            obj[fieldName].nanos <= 999999999)) {
	            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
	        }
	    }
	}
	function validatePercentage(obj, fieldName, objectName) {
	    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
	    validateFieldType(obj, fieldName, 'number', objectName);
	    if (fieldName in obj &&
	        obj[fieldName] !== undefined &&
	        !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
	        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
	    }
	}
	class OutlierDetectionLoadBalancingConfig {
	    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
	        this.childPolicy = childPolicy;
	        if (childPolicy.getLoadBalancerName() === 'pick_first') {
	            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');
	        }
	        this.intervalMs = intervalMs !== null && intervalMs !== undefined ? intervalMs : 10000;
	        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== undefined ? baseEjectionTimeMs : 30000;
	        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== undefined ? maxEjectionTimeMs : 300000;
	        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== undefined ? maxEjectionPercent : 10;
	        this.successRateEjection = successRateEjection
	            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
	        this.failurePercentageEjection = failurePercentageEjection
	            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
	    }
	    getLoadBalancerName() {
	        return TYPE_NAME;
	    }
	    toJsonObject() {
	        var _a, _b;
	        return {
	            outlier_detection: {
	                interval: (0, duration_1.msToDuration)(this.intervalMs),
	                base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
	                max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
	                max_ejection_percent: this.maxEjectionPercent,
	                success_rate_ejection: (_a = this.successRateEjection) !== null && _a !== undefined ? _a : undefined,
	                failure_percentage_ejection: (_b = this.failurePercentageEjection) !== null && _b !== undefined ? _b : undefined,
	                child_policy: [this.childPolicy.toJsonObject()],
	            },
	        };
	    }
	    getIntervalMs() {
	        return this.intervalMs;
	    }
	    getBaseEjectionTimeMs() {
	        return this.baseEjectionTimeMs;
	    }
	    getMaxEjectionTimeMs() {
	        return this.maxEjectionTimeMs;
	    }
	    getMaxEjectionPercent() {
	        return this.maxEjectionPercent;
	    }
	    getSuccessRateEjectionConfig() {
	        return this.successRateEjection;
	    }
	    getFailurePercentageEjectionConfig() {
	        return this.failurePercentageEjection;
	    }
	    getChildPolicy() {
	        return this.childPolicy;
	    }
	    static createFromJson(obj) {
	        var _a;
	        validatePositiveDuration(obj, 'interval');
	        validatePositiveDuration(obj, 'base_ejection_time');
	        validatePositiveDuration(obj, 'max_ejection_time');
	        validatePercentage(obj, 'max_ejection_percent');
	        if ('success_rate_ejection' in obj &&
	            obj.success_rate_ejection !== undefined) {
	            if (typeof obj.success_rate_ejection !== 'object') {
	                throw new Error('outlier detection config success_rate_ejection must be an object');
	            }
	            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');
	            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');
	            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');
	            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');
	        }
	        if ('failure_percentage_ejection' in obj &&
	            obj.failure_percentage_ejection !== undefined) {
	            if (typeof obj.failure_percentage_ejection !== 'object') {
	                throw new Error('outlier detection config failure_percentage_ejection must be an object');
	            }
	            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');
	            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');
	            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');
	            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');
	        }
	        if (!('child_policy' in obj) || !Array.isArray(obj.child_policy)) {
	            throw new Error('outlier detection config child_policy must be an array');
	        }
	        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
	        if (!childPolicy) {
	            throw new Error('outlier detection config child_policy: no valid recognized policy found');
	        }
	        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== undefined ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
	    }
	}
	loadBalancerOutlierDetection.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
	class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
	    constructor(childSubchannel, mapEntry) {
	        super(childSubchannel);
	        this.mapEntry = mapEntry;
	        this.refCount = 0;
	    }
	    ref() {
	        this.child.ref();
	        this.refCount += 1;
	    }
	    unref() {
	        this.child.unref();
	        this.refCount -= 1;
	        if (this.refCount <= 0) {
	            if (this.mapEntry) {
	                const index = this.mapEntry.subchannelWrappers.indexOf(this);
	                if (index >= 0) {
	                    this.mapEntry.subchannelWrappers.splice(index, 1);
	                }
	            }
	        }
	    }
	    eject() {
	        this.setHealthy(false);
	    }
	    uneject() {
	        this.setHealthy(true);
	    }
	    getMapEntry() {
	        return this.mapEntry;
	    }
	    getWrappedSubchannel() {
	        return this.child;
	    }
	}
	function createEmptyBucket() {
	    return {
	        success: 0,
	        failure: 0,
	    };
	}
	class CallCounter {
	    constructor() {
	        this.activeBucket = createEmptyBucket();
	        this.inactiveBucket = createEmptyBucket();
	    }
	    addSuccess() {
	        this.activeBucket.success += 1;
	    }
	    addFailure() {
	        this.activeBucket.failure += 1;
	    }
	    switchBuckets() {
	        this.inactiveBucket = this.activeBucket;
	        this.activeBucket = createEmptyBucket();
	    }
	    getLastSuccesses() {
	        return this.inactiveBucket.success;
	    }
	    getLastFailures() {
	        return this.inactiveBucket.failure;
	    }
	}
	class OutlierDetectionPicker {
	    constructor(wrappedPicker, countCalls) {
	        this.wrappedPicker = wrappedPicker;
	        this.countCalls = countCalls;
	    }
	    pick(pickArgs) {
	        const wrappedPick = this.wrappedPicker.pick(pickArgs);
	        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
	            const subchannelWrapper = wrappedPick.subchannel;
	            const mapEntry = subchannelWrapper.getMapEntry();
	            if (mapEntry) {
	                let onCallEnded = wrappedPick.onCallEnded;
	                if (this.countCalls) {
	                    onCallEnded = statusCode => {
	                        var _a;
	                        if (statusCode === constants_1.Status.OK) {
	                            mapEntry.counter.addSuccess();
	                        }
	                        else {
	                            mapEntry.counter.addFailure();
	                        }
	                        (_a = wrappedPick.onCallEnded) === null || _a === undefined ? undefined : _a.call(wrappedPick, statusCode);
	                    };
	                }
	                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });
	            }
	            else {
	                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
	            }
	        }
	        else {
	            return wrappedPick;
	        }
	    }
	}
	class OutlierDetectionLoadBalancer {
	    constructor(channelControlHelper, credentials, options) {
	        this.entryMap = new subchannel_address_1.EndpointMap();
	        this.latestConfig = null;
	        this.timerStartTime = null;
	        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
	            createSubchannel: (subchannelAddress, subchannelArgs, credentialsOverride) => {
	                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
	                const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
	                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
	                if ((mapEntry === null || mapEntry === undefined ? undefined : mapEntry.currentEjectionTimestamp) !== null) {
	                    // If the address is ejected, propagate that to the new subchannel wrapper
	                    subchannelWrapper.eject();
	                }
	                mapEntry === null || mapEntry === undefined ? undefined : mapEntry.subchannelWrappers.push(subchannelWrapper);
	                return subchannelWrapper;
	            },
	            updateState: (connectivityState, picker) => {
	                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
	                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
	                }
	                else {
	                    channelControlHelper.updateState(connectivityState, picker);
	                }
	            },
	        }), credentials, options);
	        this.ejectionTimer = setInterval(() => { }, 0);
	        clearInterval(this.ejectionTimer);
	    }
	    isCountingEnabled() {
	        return (this.latestConfig !== null &&
	            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||
	                this.latestConfig.getFailurePercentageEjectionConfig() !== null));
	    }
	    getCurrentEjectionPercent() {
	        let ejectionCount = 0;
	        for (const mapEntry of this.entryMap.values()) {
	            if (mapEntry.currentEjectionTimestamp !== null) {
	                ejectionCount += 1;
	            }
	        }
	        return (ejectionCount * 100) / this.entryMap.size;
	    }
	    runSuccessRateCheck(ejectionTimestamp) {
	        if (!this.latestConfig) {
	            return;
	        }
	        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
	        if (!successRateConfig) {
	            return;
	        }
	        trace('Running success rate check');
	        // Step 1
	        const targetRequestVolume = successRateConfig.request_volume;
	        let addresesWithTargetVolume = 0;
	        const successRates = [];
	        for (const [endpoint, mapEntry] of this.entryMap.entries()) {
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            trace('Stats for ' +
	                (0, subchannel_address_1.endpointToString)(endpoint) +
	                ': successes=' +
	                successes +
	                ' failures=' +
	                failures +
	                ' targetRequestVolume=' +
	                targetRequestVolume);
	            if (successes + failures >= targetRequestVolume) {
	                addresesWithTargetVolume += 1;
	                successRates.push(successes / (successes + failures));
	            }
	        }
	        trace('Found ' +
	            addresesWithTargetVolume +
	            ' success rate candidates; currentEjectionPercent=' +
	            this.getCurrentEjectionPercent() +
	            ' successRates=[' +
	            successRates +
	            ']');
	        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
	            return;
	        }
	        // Step 2
	        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
	        let successRateDeviationSum = 0;
	        for (const rate of successRates) {
	            const deviation = rate - successRateMean;
	            successRateDeviationSum += deviation * deviation;
	        }
	        const successRateVariance = successRateDeviationSum / successRates.length;
	        const successRateStdev = Math.sqrt(successRateVariance);
	        const ejectionThreshold = successRateMean -
	            successRateStdev * (successRateConfig.stdev_factor / 1000);
	        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);
	        // Step 3
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            // Step 3.i
	            if (this.getCurrentEjectionPercent() >=
	                this.latestConfig.getMaxEjectionPercent()) {
	                break;
	            }
	            // Step 3.ii
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            if (successes + failures < targetRequestVolume) {
	                continue;
	            }
	            // Step 3.iii
	            const successRate = successes / (successes + failures);
	            trace('Checking candidate ' + address + ' successRate=' + successRate);
	            if (successRate < ejectionThreshold) {
	                const randomNumber = Math.random() * 100;
	                trace('Candidate ' +
	                    address +
	                    ' randomNumber=' +
	                    randomNumber +
	                    ' enforcement_percentage=' +
	                    successRateConfig.enforcement_percentage);
	                if (randomNumber < successRateConfig.enforcement_percentage) {
	                    trace('Ejecting candidate ' + address);
	                    this.eject(mapEntry, ejectionTimestamp);
	                }
	            }
	        }
	    }
	    runFailurePercentageCheck(ejectionTimestamp) {
	        if (!this.latestConfig) {
	            return;
	        }
	        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
	        if (!failurePercentageConfig) {
	            return;
	        }
	        trace('Running failure percentage check. threshold=' +
	            failurePercentageConfig.threshold +
	            ' request volume threshold=' +
	            failurePercentageConfig.request_volume);
	        // Step 1
	        let addressesWithTargetVolume = 0;
	        for (const mapEntry of this.entryMap.values()) {
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            if (successes + failures >= failurePercentageConfig.request_volume) {
	                addressesWithTargetVolume += 1;
	            }
	        }
	        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
	            return;
	        }
	        // Step 2
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            // Step 2.i
	            if (this.getCurrentEjectionPercent() >=
	                this.latestConfig.getMaxEjectionPercent()) {
	                break;
	            }
	            // Step 2.ii
	            const successes = mapEntry.counter.getLastSuccesses();
	            const failures = mapEntry.counter.getLastFailures();
	            trace('Candidate successes=' + successes + ' failures=' + failures);
	            if (successes + failures < failurePercentageConfig.request_volume) {
	                continue;
	            }
	            // Step 2.iii
	            const failurePercentage = (failures * 100) / (failures + successes);
	            if (failurePercentage > failurePercentageConfig.threshold) {
	                const randomNumber = Math.random() * 100;
	                trace('Candidate ' +
	                    address +
	                    ' randomNumber=' +
	                    randomNumber +
	                    ' enforcement_percentage=' +
	                    failurePercentageConfig.enforcement_percentage);
	                if (randomNumber < failurePercentageConfig.enforcement_percentage) {
	                    trace('Ejecting candidate ' + address);
	                    this.eject(mapEntry, ejectionTimestamp);
	                }
	            }
	        }
	    }
	    eject(mapEntry, ejectionTimestamp) {
	        mapEntry.currentEjectionTimestamp = new Date();
	        mapEntry.ejectionTimeMultiplier += 1;
	        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
	            subchannelWrapper.eject();
	        }
	    }
	    uneject(mapEntry) {
	        mapEntry.currentEjectionTimestamp = null;
	        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
	            subchannelWrapper.uneject();
	        }
	    }
	    switchAllBuckets() {
	        for (const mapEntry of this.entryMap.values()) {
	            mapEntry.counter.switchBuckets();
	        }
	    }
	    startTimer(delayMs) {
	        var _a, _b;
	        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
	        (_b = (_a = this.ejectionTimer).unref) === null || _b === undefined ? undefined : _b.call(_a);
	    }
	    runChecks() {
	        const ejectionTimestamp = new Date();
	        trace('Ejection timer running');
	        this.switchAllBuckets();
	        if (!this.latestConfig) {
	            return;
	        }
	        this.timerStartTime = ejectionTimestamp;
	        this.startTimer(this.latestConfig.getIntervalMs());
	        this.runSuccessRateCheck(ejectionTimestamp);
	        this.runFailurePercentageCheck(ejectionTimestamp);
	        for (const [address, mapEntry] of this.entryMap.entries()) {
	            if (mapEntry.currentEjectionTimestamp === null) {
	                if (mapEntry.ejectionTimeMultiplier > 0) {
	                    mapEntry.ejectionTimeMultiplier -= 1;
	                }
	            }
	            else {
	                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
	                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
	                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
	                returnTime.setMilliseconds(returnTime.getMilliseconds() +
	                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
	                if (returnTime < new Date()) {
	                    trace('Unejecting ' + address);
	                    this.uneject(mapEntry);
	                }
	            }
	        }
	    }
	    updateAddressList(endpointList, lbConfig, attributes) {
	        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
	            return;
	        }
	        for (const endpoint of endpointList) {
	            if (!this.entryMap.has(endpoint)) {
	                trace('Adding map entry for ' + (0, subchannel_address_1.endpointToString)(endpoint));
	                this.entryMap.set(endpoint, {
	                    counter: new CallCounter(),
	                    currentEjectionTimestamp: null,
	                    ejectionTimeMultiplier: 0,
	                    subchannelWrappers: [],
	                });
	            }
	        }
	        this.entryMap.deleteMissing(endpointList);
	        const childPolicy = lbConfig.getChildPolicy();
	        this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);
	        if (lbConfig.getSuccessRateEjectionConfig() ||
	            lbConfig.getFailurePercentageEjectionConfig()) {
	            if (this.timerStartTime) {
	                trace('Previous timer existed. Replacing timer');
	                clearTimeout(this.ejectionTimer);
	                const remainingDelay = lbConfig.getIntervalMs() -
	                    (new Date().getTime() - this.timerStartTime.getTime());
	                this.startTimer(remainingDelay);
	            }
	            else {
	                trace('Starting new timer');
	                this.timerStartTime = new Date();
	                this.startTimer(lbConfig.getIntervalMs());
	                this.switchAllBuckets();
	            }
	        }
	        else {
	            trace('Counting disabled. Cancelling timer.');
	            this.timerStartTime = null;
	            clearTimeout(this.ejectionTimer);
	            for (const mapEntry of this.entryMap.values()) {
	                this.uneject(mapEntry);
	                mapEntry.ejectionTimeMultiplier = 0;
	            }
	        }
	        this.latestConfig = lbConfig;
	    }
	    exitIdle() {
	        this.childBalancer.exitIdle();
	    }
	    resetBackoff() {
	        this.childBalancer.resetBackoff();
	    }
	    destroy() {
	        clearTimeout(this.ejectionTimer);
	        this.childBalancer.destroy();
	    }
	    getTypeName() {
	        return TYPE_NAME;
	    }
	}
	loadBalancerOutlierDetection.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
	function setup() {
	    if (OUTLIER_DETECTION_ENABLED) {
	        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
	    }
	}
	loadBalancerOutlierDetection.setup = setup;
	
	return loadBalancerOutlierDetection;
}

var hasRequiredSrc$3;

function requireSrc$3 () {
	if (hasRequiredSrc$3) return src$5;
	hasRequiredSrc$3 = 1;
	(function (exports) {
		/*
		 * Copyright 2019 gRPC authors.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *     http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 *
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.experimental = exports.ServerInterceptingCall = exports.ResponderBuilder = exports.ServerListenerBuilder = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = undefined;
		const call_credentials_1 = requireCallCredentials();
		Object.defineProperty(exports, "CallCredentials", { enumerable: true, get: function () { return call_credentials_1.CallCredentials; } });
		const channel_1 = requireChannel();
		Object.defineProperty(exports, "Channel", { enumerable: true, get: function () { return channel_1.ChannelImplementation; } });
		const compression_algorithms_1 = requireCompressionAlgorithms();
		Object.defineProperty(exports, "compressionAlgorithms", { enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } });
		const connectivity_state_1 = requireConnectivityState();
		Object.defineProperty(exports, "connectivityState", { enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } });
		const channel_credentials_1 = requireChannelCredentials();
		Object.defineProperty(exports, "ChannelCredentials", { enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } });
		const client_1 = requireClient();
		Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return client_1.Client; } });
		const constants_1 = requireConstants();
		Object.defineProperty(exports, "logVerbosity", { enumerable: true, get: function () { return constants_1.LogVerbosity; } });
		Object.defineProperty(exports, "status", { enumerable: true, get: function () { return constants_1.Status; } });
		Object.defineProperty(exports, "propagate", { enumerable: true, get: function () { return constants_1.Propagate; } });
		const logging = requireLogging();
		const make_client_1 = requireMakeClient();
		Object.defineProperty(exports, "loadPackageDefinition", { enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } });
		Object.defineProperty(exports, "makeClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
		Object.defineProperty(exports, "makeGenericClientConstructor", { enumerable: true, get: function () { return make_client_1.makeClientConstructor; } });
		const metadata_1 = requireMetadata();
		Object.defineProperty(exports, "Metadata", { enumerable: true, get: function () { return metadata_1.Metadata; } });
		const server_1 = requireServer();
		Object.defineProperty(exports, "Server", { enumerable: true, get: function () { return server_1.Server; } });
		const server_credentials_1 = requireServerCredentials();
		Object.defineProperty(exports, "ServerCredentials", { enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } });
		const status_builder_1 = requireStatusBuilder();
		Object.defineProperty(exports, "StatusBuilder", { enumerable: true, get: function () { return status_builder_1.StatusBuilder; } });
		/**** Client Credentials ****/
		// Using assign only copies enumerable properties, which is what we want
		exports.credentials = {
		    /**
		     * Combine a ChannelCredentials with any number of CallCredentials into a
		     * single ChannelCredentials object.
		     * @param channelCredentials The ChannelCredentials object.
		     * @param callCredentials Any number of CallCredentials objects.
		     * @return The resulting ChannelCredentials object.
		     */
		    combineChannelCredentials: (channelCredentials, ...callCredentials) => {
		        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
		    },
		    /**
		     * Combine any number of CallCredentials into a single CallCredentials
		     * object.
		     * @param first The first CallCredentials object.
		     * @param additional Any number of additional CallCredentials objects.
		     * @return The resulting CallCredentials object.
		     */
		    combineCallCredentials: (first, ...additional) => {
		        return additional.reduce((acc, other) => acc.compose(other), first);
		    },
		    // from channel-credentials.ts
		    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
		    createSsl: channel_credentials_1.ChannelCredentials.createSsl,
		    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
		    // from call-credentials.ts
		    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
		    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
		    createEmpty: call_credentials_1.CallCredentials.createEmpty,
		};
		/**
		 * Close a Client object.
		 * @param client The client to close.
		 */
		const closeClient = (client) => client.close();
		exports.closeClient = closeClient;
		const waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
		exports.waitForClientReady = waitForClientReady;
		/* eslint-enable @typescript-eslint/no-explicit-any */
		/**** Unimplemented function stubs ****/
		/* eslint-disable @typescript-eslint/no-explicit-any */
		const loadObject = (value, options) => {
		    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
		};
		exports.loadObject = loadObject;
		const load = (filename, format, options) => {
		    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');
		};
		exports.load = load;
		const setLogger = (logger) => {
		    logging.setLogger(logger);
		};
		exports.setLogger = setLogger;
		const setLogVerbosity = (verbosity) => {
		    logging.setLoggerVerbosity(verbosity);
		};
		exports.setLogVerbosity = setLogVerbosity;
		const getClientChannel = (client) => {
		    return client_1.Client.prototype.getChannel.call(client);
		};
		exports.getClientChannel = getClientChannel;
		var client_interceptors_1 = requireClientInterceptors();
		Object.defineProperty(exports, "ListenerBuilder", { enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } });
		Object.defineProperty(exports, "RequesterBuilder", { enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } });
		Object.defineProperty(exports, "InterceptingCall", { enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } });
		Object.defineProperty(exports, "InterceptorConfigurationError", { enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } });
		var channelz_1 = requireChannelz();
		Object.defineProperty(exports, "getChannelzServiceDefinition", { enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } });
		Object.defineProperty(exports, "getChannelzHandlers", { enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } });
		var admin_1 = requireAdmin();
		Object.defineProperty(exports, "addAdminServicesToServer", { enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } });
		var server_interceptors_1 = requireServerInterceptors();
		Object.defineProperty(exports, "ServerListenerBuilder", { enumerable: true, get: function () { return server_interceptors_1.ServerListenerBuilder; } });
		Object.defineProperty(exports, "ResponderBuilder", { enumerable: true, get: function () { return server_interceptors_1.ResponderBuilder; } });
		Object.defineProperty(exports, "ServerInterceptingCall", { enumerable: true, get: function () { return server_interceptors_1.ServerInterceptingCall; } });
		const experimental = requireExperimental();
		exports.experimental = experimental;
		const resolver_dns = requireResolverDns();
		const resolver_uds = requireResolverUds();
		const resolver_ip = requireResolverIp();
		const load_balancer_pick_first = requireLoadBalancerPickFirst();
		const load_balancer_round_robin = requireLoadBalancerRoundRobin();
		const load_balancer_outlier_detection = requireLoadBalancerOutlierDetection();
		const channelz = requireChannelz();
		(() => {
		    resolver_dns.setup();
		    resolver_uds.setup();
		    resolver_ip.setup();
		    load_balancer_pick_first.setup();
		    load_balancer_round_robin.setup();
		    load_balancer_outlier_detection.setup();
		    channelz.setup();
		})();
		
	} (src$5));
	return src$5;
}

var srcExports$2 = requireSrc$3();

var src$2 = {};

var AsyncHooksContextManager = {};

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(esm$4);

var AbstractAsyncHooksContextManager = {};

var hasRequiredAbstractAsyncHooksContextManager;

function requireAbstractAsyncHooksContextManager () {
	if (hasRequiredAbstractAsyncHooksContextManager) return AbstractAsyncHooksContextManager;
	hasRequiredAbstractAsyncHooksContextManager = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(AbstractAsyncHooksContextManager, "__esModule", { value: true });
	AbstractAsyncHooksContextManager.AbstractAsyncHooksContextManager = undefined;
	const events_1 = require$$0$6;
	const ADD_LISTENER_METHODS = [
	    'addListener',
	    'on',
	    'once',
	    'prependListener',
	    'prependOnceListener',
	];
	let AbstractAsyncHooksContextManager$1 = class AbstractAsyncHooksContextManager {
	    constructor() {
	        this._kOtListeners = Symbol('OtListeners');
	        this._wrapped = false;
	    }
	    /**
	     * Binds a the certain context or the active one to the target function and then returns the target
	     * @param context A context (span) to be bind to target
	     * @param target a function or event emitter. When target or one of its callbacks is called,
	     *  the provided context will be used as the active context for the duration of the call.
	     */
	    bind(context, target) {
	        if (target instanceof events_1.EventEmitter) {
	            return this._bindEventEmitter(context, target);
	        }
	        if (typeof target === 'function') {
	            return this._bindFunction(context, target);
	        }
	        return target;
	    }
	    _bindFunction(context, target) {
	        const manager = this;
	        const contextWrapper = function (...args) {
	            return manager.with(context, () => target.apply(this, args));
	        };
	        Object.defineProperty(contextWrapper, 'length', {
	            enumerable: false,
	            configurable: true,
	            writable: false,
	            value: target.length,
	        });
	        /**
	         * It isn't possible to tell Typescript that contextWrapper is the same as T
	         * so we forced to cast as any here.
	         */
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        return contextWrapper;
	    }
	    /**
	     * By default, EventEmitter call their callback with their context, which we do
	     * not want, instead we will bind a specific context to all callbacks that
	     * go through it.
	     * @param context the context we want to bind
	     * @param ee EventEmitter an instance of EventEmitter to patch
	     */
	    _bindEventEmitter(context, ee) {
	        const map = this._getPatchMap(ee);
	        if (map !== undefined)
	            return ee;
	        this._createPatchMap(ee);
	        // patch methods that add a listener to propagate context
	        ADD_LISTENER_METHODS.forEach(methodName => {
	            if (ee[methodName] === undefined)
	                return;
	            ee[methodName] = this._patchAddListener(ee, ee[methodName], context);
	        });
	        // patch methods that remove a listener
	        if (typeof ee.removeListener === 'function') {
	            ee.removeListener = this._patchRemoveListener(ee, ee.removeListener);
	        }
	        if (typeof ee.off === 'function') {
	            ee.off = this._patchRemoveListener(ee, ee.off);
	        }
	        // patch method that remove all listeners
	        if (typeof ee.removeAllListeners === 'function') {
	            ee.removeAllListeners = this._patchRemoveAllListeners(ee, ee.removeAllListeners);
	        }
	        return ee;
	    }
	    /**
	     * Patch methods that remove a given listener so that we match the "patched"
	     * version of that listener (the one that propagate context).
	     * @param ee EventEmitter instance
	     * @param original reference to the patched method
	     */
	    _patchRemoveListener(ee, original) {
	        const contextManager = this;
	        return function (event, listener) {
	            var _a;
	            const events = (_a = contextManager._getPatchMap(ee)) === null || _a === undefined ? undefined : _a[event];
	            if (events === undefined) {
	                return original.call(this, event, listener);
	            }
	            const patchedListener = events.get(listener);
	            return original.call(this, event, patchedListener || listener);
	        };
	    }
	    /**
	     * Patch methods that remove all listeners so we remove our
	     * internal references for a given event.
	     * @param ee EventEmitter instance
	     * @param original reference to the patched method
	     */
	    _patchRemoveAllListeners(ee, original) {
	        const contextManager = this;
	        return function (event) {
	            const map = contextManager._getPatchMap(ee);
	            if (map !== undefined) {
	                if (arguments.length === 0) {
	                    contextManager._createPatchMap(ee);
	                }
	                else if (map[event] !== undefined) {
	                    delete map[event];
	                }
	            }
	            return original.apply(this, arguments);
	        };
	    }
	    /**
	     * Patch methods on an event emitter instance that can add listeners so we
	     * can force them to propagate a given context.
	     * @param ee EventEmitter instance
	     * @param original reference to the patched method
	     * @param [context] context to propagate when calling listeners
	     */
	    _patchAddListener(ee, original, context) {
	        const contextManager = this;
	        return function (event, listener) {
	            /**
	             * This check is required to prevent double-wrapping the listener.
	             * The implementation for ee.once wraps the listener and calls ee.on.
	             * Without this check, we would wrap that wrapped listener.
	             * This causes an issue because ee.removeListener depends on the onceWrapper
	             * to properly remove the listener. If we wrap their wrapper, we break
	             * that detection.
	             */
	            if (contextManager._wrapped) {
	                return original.call(this, event, listener);
	            }
	            let map = contextManager._getPatchMap(ee);
	            if (map === undefined) {
	                map = contextManager._createPatchMap(ee);
	            }
	            let listeners = map[event];
	            if (listeners === undefined) {
	                listeners = new WeakMap();
	                map[event] = listeners;
	            }
	            const patchedListener = contextManager.bind(context, listener);
	            // store a weak reference of the user listener to ours
	            listeners.set(listener, patchedListener);
	            /**
	             * See comment at the start of this function for the explanation of this property.
	             */
	            contextManager._wrapped = true;
	            try {
	                return original.call(this, event, patchedListener);
	            }
	            finally {
	                contextManager._wrapped = false;
	            }
	        };
	    }
	    _createPatchMap(ee) {
	        const map = Object.create(null);
	        // eslint-disable-next-line @typescript-eslint/no-explicit-any
	        ee[this._kOtListeners] = map;
	        return map;
	    }
	    _getPatchMap(ee) {
	        return ee[this._kOtListeners];
	    }
	};
	AbstractAsyncHooksContextManager.AbstractAsyncHooksContextManager = AbstractAsyncHooksContextManager$1;
	
	return AbstractAsyncHooksContextManager;
}

var hasRequiredAsyncHooksContextManager;

function requireAsyncHooksContextManager () {
	if (hasRequiredAsyncHooksContextManager) return AsyncHooksContextManager;
	hasRequiredAsyncHooksContextManager = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(AsyncHooksContextManager, "__esModule", { value: true });
	AsyncHooksContextManager.AsyncHooksContextManager = undefined;
	const api_1 = require$$0$2;
	const asyncHooks = require$$1$3;
	const AbstractAsyncHooksContextManager_1 = /*@__PURE__*/ requireAbstractAsyncHooksContextManager();
	let AsyncHooksContextManager$1 = class AsyncHooksContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
	    constructor() {
	        super();
	        this._contexts = new Map();
	        this._stack = [];
	        this._asyncHook = asyncHooks.createHook({
	            init: this._init.bind(this),
	            before: this._before.bind(this),
	            after: this._after.bind(this),
	            destroy: this._destroy.bind(this),
	            promiseResolve: this._destroy.bind(this),
	        });
	    }
	    active() {
	        var _a;
	        return (_a = this._stack[this._stack.length - 1]) !== null && _a !== undefined ? _a : api_1.ROOT_CONTEXT;
	    }
	    with(context, fn, thisArg, ...args) {
	        this._enterContext(context);
	        try {
	            return fn.call(thisArg, ...args);
	        }
	        finally {
	            this._exitContext();
	        }
	    }
	    enable() {
	        this._asyncHook.enable();
	        return this;
	    }
	    disable() {
	        this._asyncHook.disable();
	        this._contexts.clear();
	        this._stack = [];
	        return this;
	    }
	    /**
	     * Init hook will be called when userland create a async context, setting the
	     * context as the current one if it exist.
	     * @param uid id of the async context
	     * @param type the resource type
	     */
	    _init(uid, type) {
	        // ignore TIMERWRAP as they combine timers with same timeout which can lead to
	        // false context propagation. TIMERWRAP has been removed in node 11
	        // every timer has it's own `Timeout` resource anyway which is used to propagate
	        // context.
	        if (type === 'TIMERWRAP')
	            return;
	        const context = this._stack[this._stack.length - 1];
	        if (context !== undefined) {
	            this._contexts.set(uid, context);
	        }
	    }
	    /**
	     * Destroy hook will be called when a given context is no longer used so we can
	     * remove its attached context.
	     * @param uid uid of the async context
	     */
	    _destroy(uid) {
	        this._contexts.delete(uid);
	    }
	    /**
	     * Before hook is called just before executing a async context.
	     * @param uid uid of the async context
	     */
	    _before(uid) {
	        const context = this._contexts.get(uid);
	        if (context !== undefined) {
	            this._enterContext(context);
	        }
	    }
	    /**
	     * After hook is called just after completing the execution of a async context.
	     */
	    _after() {
	        this._exitContext();
	    }
	    /**
	     * Set the given context as active
	     */
	    _enterContext(context) {
	        this._stack.push(context);
	    }
	    /**
	     * Remove the context at the root of the stack
	     */
	    _exitContext() {
	        this._stack.pop();
	    }
	};
	AsyncHooksContextManager.AsyncHooksContextManager = AsyncHooksContextManager$1;
	
	return AsyncHooksContextManager;
}

var AsyncLocalStorageContextManager = {};

var hasRequiredAsyncLocalStorageContextManager;

function requireAsyncLocalStorageContextManager () {
	if (hasRequiredAsyncLocalStorageContextManager) return AsyncLocalStorageContextManager;
	hasRequiredAsyncLocalStorageContextManager = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(AsyncLocalStorageContextManager, "__esModule", { value: true });
	AsyncLocalStorageContextManager.AsyncLocalStorageContextManager = undefined;
	const api_1 = require$$0$2;
	const async_hooks_1 = require$$1$3;
	const AbstractAsyncHooksContextManager_1 = /*@__PURE__*/ requireAbstractAsyncHooksContextManager();
	let AsyncLocalStorageContextManager$1 = class AsyncLocalStorageContextManager extends AbstractAsyncHooksContextManager_1.AbstractAsyncHooksContextManager {
	    constructor() {
	        super();
	        this._asyncLocalStorage = new async_hooks_1.AsyncLocalStorage();
	    }
	    active() {
	        var _a;
	        return (_a = this._asyncLocalStorage.getStore()) !== null && _a !== undefined ? _a : api_1.ROOT_CONTEXT;
	    }
	    with(context, fn, thisArg, ...args) {
	        const cb = thisArg == null ? fn : fn.bind(thisArg);
	        return this._asyncLocalStorage.run(context, cb, ...args);
	    }
	    enable() {
	        return this;
	    }
	    disable() {
	        this._asyncLocalStorage.disable();
	        return this;
	    }
	};
	AsyncLocalStorageContextManager.AsyncLocalStorageContextManager = AsyncLocalStorageContextManager$1;
	
	return AsyncLocalStorageContextManager;
}

var hasRequiredSrc$2;

function requireSrc$2 () {
	if (hasRequiredSrc$2) return src$2;
	hasRequiredSrc$2 = 1;
	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.AsyncLocalStorageContextManager = exports.AsyncHooksContextManager = undefined;
		var AsyncHooksContextManager_1 = /*@__PURE__*/ requireAsyncHooksContextManager();
		Object.defineProperty(exports, "AsyncHooksContextManager", { enumerable: true, get: function () { return AsyncHooksContextManager_1.AsyncHooksContextManager; } });
		var AsyncLocalStorageContextManager_1 = /*@__PURE__*/ requireAsyncLocalStorageContextManager();
		Object.defineProperty(exports, "AsyncLocalStorageContextManager", { enumerable: true, get: function () { return AsyncLocalStorageContextManager_1.AsyncLocalStorageContextManager; } });
		
	} (src$2));
	return src$2;
}

var srcExports$1 = /*@__PURE__*/ requireSrc$2();

var src$1 = {};

var OTLPTraceExporter$1 = {};

var src = {};

var convertLegacyOtlpGrpcOptions = {};

var otlpGrpcConfiguration = {};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var OTLPExporterBase = /** @class */ (function () {
    function OTLPExporterBase(_delegate) {
        this._delegate = _delegate;
    }
    /**
     * Export items.
     * @param items
     * @param resultCallback
     */
    OTLPExporterBase.prototype.export = function (items, resultCallback) {
        this._delegate.export(items, resultCallback);
    };
    OTLPExporterBase.prototype.forceFlush = function () {
        return this._delegate.forceFlush();
    };
    OTLPExporterBase.prototype.shutdown = function () {
        return this._delegate.shutdown();
    };
    return OTLPExporterBase;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Interface for handling error
 */
var OTLPExporterError = /** @class */ (function (_super) {
    __extends$3(OTLPExporterError, _super);
    function OTLPExporterError(message, code, data) {
        var _this = _super.call(this, message) || this;
        _this.name = 'OTLPExporterError';
        _this.data = data;
        _this.code = code;
        return _this;
    }
    return OTLPExporterError;
}(Error));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function validateTimeoutMillis(timeoutMillis) {
    if (!Number.isNaN(timeoutMillis) &&
        Number.isFinite(timeoutMillis) &&
        timeoutMillis > 0) {
        return timeoutMillis;
    }
    throw new Error("Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '" + timeoutMillis + "')");
}
function wrapStaticHeadersInFunction(headers) {
    if (headers == null) {
        return undefined;
    }
    return function () { return headers; };
}
/**
 * @param userProvidedConfiguration  Configuration options provided by the user in code.
 * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.
 * @param defaultConfiguration The defaults as defined by the exporter specification
 */
function mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
    var _a, _b, _c, _d, _e, _f;
    return {
        timeoutMillis: validateTimeoutMillis((_b = (_a = userProvidedConfiguration.timeoutMillis) !== null && _a !== undefined ? _a : fallbackConfiguration.timeoutMillis) !== null && _b !== undefined ? _b : defaultConfiguration.timeoutMillis),
        concurrencyLimit: (_d = (_c = userProvidedConfiguration.concurrencyLimit) !== null && _c !== undefined ? _c : fallbackConfiguration.concurrencyLimit) !== null && _d !== undefined ? _d : defaultConfiguration.concurrencyLimit,
        compression: (_f = (_e = userProvidedConfiguration.compression) !== null && _e !== undefined ? _e : fallbackConfiguration.compression) !== null && _f !== undefined ? _f : defaultConfiguration.compression,
    };
}
function getSharedConfigurationDefaults() {
    return {
        timeoutMillis: 10000,
        concurrencyLimit: 30,
        compression: 'none',
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CompressionAlgorithm;
(function (CompressionAlgorithm) {
    CompressionAlgorithm["NONE"] = "none";
    CompressionAlgorithm["GZIP"] = "gzip";
})(CompressionAlgorithm || (CompressionAlgorithm = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : undefined, done: true };
    }
};
var BoundedQueueExportPromiseHandler = /** @class */ (function () {
    /**
     * @param concurrencyLimit maximum promises allowed in a queue at the same time.
     */
    function BoundedQueueExportPromiseHandler(concurrencyLimit) {
        this._sendingPromises = [];
        this._concurrencyLimit = concurrencyLimit;
    }
    BoundedQueueExportPromiseHandler.prototype.pushPromise = function (promise) {
        var _this = this;
        if (this.hasReachedLimit()) {
            throw new Error('Concurrency Limit reached');
        }
        this._sendingPromises.push(promise);
        var popPromise = function () {
            var index = _this._sendingPromises.indexOf(promise);
            _this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
    };
    BoundedQueueExportPromiseHandler.prototype.hasReachedLimit = function () {
        return this._sendingPromises.length >= this._concurrencyLimit;
    };
    BoundedQueueExportPromiseHandler.prototype.awaitAll = function () {
        return __awaiter$4(this, undefined, undefined, function () {
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(this._sendingPromises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return BoundedQueueExportPromiseHandler;
}());
/**
 * Promise queue for keeping track of export promises. Finished promises will be auto-dequeued.
 * Allows for awaiting all promises in the queue.
 */
function createBoundedQueueExportPromiseHandler(options) {
    return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SUPPRESS_TRACING_KEY = createContextKey('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
function suppressTracing(context) {
    return context.setValue(SUPPRESS_TRACING_KEY, true);
}
function unsuppressTracing(context) {
    return context.deleteValue(SUPPRESS_TRACING_KEY);
}
function isTracingSuppressed(context) {
    return context.getValue(SUPPRESS_TRACING_KEY) === true;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var BAGGAGE_KEY_PAIR_SEPARATOR = '=';
var BAGGAGE_PROPERTIES_SEPARATOR = ';';
var BAGGAGE_ITEMS_SEPARATOR = ',';
// Name of the http header used to propagate the baggage
var BAGGAGE_HEADER = 'baggage';
// Maximum number of name-value pairs allowed by w3c spec
var BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
// Maximum number of bytes per a single name-value pair allowed by w3c spec
var BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
// Maximum total length of all name-value pairs allowed by w3c spec
var BAGGAGE_MAX_TOTAL_LENGTH = 8192;

var __read$9 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function serializeKeyPairs(keyPairs) {
    return keyPairs.reduce(function (hValue, current) {
        var value = "" + hValue + (hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : '') + current;
        return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
    }, '');
}
function getKeyPairs(baggage) {
    return baggage.getAllEntries().map(function (_a) {
        var _b = __read$9(_a, 2), key = _b[0], value = _b[1];
        var entry = encodeURIComponent(key) + "=" + encodeURIComponent(value.value);
        // include opaque metadata if provided
        // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation
        if (value.metadata !== undefined) {
            entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
    });
}
function parsePairKeyValue(entry) {
    var valueProps = entry.split(BAGGAGE_PROPERTIES_SEPARATOR);
    if (valueProps.length <= 0)
        return;
    var keyPairPart = valueProps.shift();
    if (!keyPairPart)
        return;
    var separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
    if (separatorIndex <= 0)
        return;
    var key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
    var value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
    var metadata;
    if (valueProps.length > 0) {
        metadata = baggageEntryMetadataFromString(valueProps.join(BAGGAGE_PROPERTIES_SEPARATOR));
    }
    return { key: key, value: value, metadata: metadata };
}
/**
 * Parse a string serialized in the baggage HTTP Format (without metadata):
 * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md
 */
function parseKeyPairsIntoRecord(value) {
    if (typeof value !== 'string' || value.length === 0)
        return {};
    return value
        .split(BAGGAGE_ITEMS_SEPARATOR)
        .map(function (entry) {
        return parsePairKeyValue(entry);
    })
        .filter(function (keyPair) { return keyPair !== undefined && keyPair.value.length > 0; })
        .reduce(function (headers, keyPair) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        headers[keyPair.key] = keyPair.value;
        return headers;
    }, {});
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Propagates {@link Baggage} through Context format propagation.
 *
 * Based on the Baggage specification:
 * https://w3c.github.io/baggage/
 */
var W3CBaggagePropagator = /** @class */ (function () {
    function W3CBaggagePropagator() {
    }
    W3CBaggagePropagator.prototype.inject = function (context, carrier, setter) {
        var baggage = propagation.getBaggage(context);
        if (!baggage || isTracingSuppressed(context))
            return;
        var keyPairs = getKeyPairs(baggage)
            .filter(function (pair) {
            return pair.length <= BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        })
            .slice(0, BAGGAGE_MAX_NAME_VALUE_PAIRS);
        var headerValue = serializeKeyPairs(keyPairs);
        if (headerValue.length > 0) {
            setter.set(carrier, BAGGAGE_HEADER, headerValue);
        }
    };
    W3CBaggagePropagator.prototype.extract = function (context, carrier, getter) {
        var headerValue = getter.get(carrier, BAGGAGE_HEADER);
        var baggageString = Array.isArray(headerValue)
            ? headerValue.join(BAGGAGE_ITEMS_SEPARATOR)
            : headerValue;
        if (!baggageString)
            return context;
        var baggage = {};
        if (baggageString.length === 0) {
            return context;
        }
        var pairs = baggageString.split(BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach(function (entry) {
            var keyPair = parsePairKeyValue(entry);
            if (keyPair) {
                var baggageEntry = { value: keyPair.value };
                if (keyPair.metadata) {
                    baggageEntry.metadata = keyPair.metadata;
                }
                baggage[keyPair.key] = baggageEntry;
            }
        });
        if (Object.entries(baggage).length === 0) {
            return context;
        }
        return propagation.setBaggage(context, propagation.createBaggage(baggage));
    };
    W3CBaggagePropagator.prototype.fields = function () {
        return [BAGGAGE_HEADER];
    };
    return W3CBaggagePropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A utility for returning wall times anchored to a given point in time. Wall time measurements will
 * not be taken from the system, but instead are computed by adding a monotonic clock time
 * to the anchor point.
 *
 * This is needed because the system time can change and result in unexpected situations like
 * spans ending before they are started. Creating an anchored clock for each local root span
 * ensures that span timings and durations are accurate while preventing span times from drifting
 * too far from the system clock.
 *
 * Only creating an anchored clock once per local trace ensures span times are correct relative
 * to each other. For example, a child span will never have a start time before its parent even
 * if the system clock is corrected during the local trace.
 *
 * Heavily inspired by the OTel Java anchored clock
 * https://github.com/open-telemetry/opentelemetry-java/blob/main/sdk/trace/src/main/java/io/opentelemetry/sdk/trace/AnchoredClock.java
 */
var AnchoredClock = /** @class */ (function () {
    /**
     * Create a new AnchoredClock anchored to the current time returned by systemClock.
     *
     * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
     * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
     */
    function AnchoredClock(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
    }
    /**
     * Returns the current time by adding the number of milliseconds since the
     * AnchoredClock was created to the creation epoch time
     */
    AnchoredClock.prototype.now = function () {
        var delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
    };
    return AnchoredClock;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values$7 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$8 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function sanitizeAttributes(attributes) {
    var e_1, _a;
    var out = {};
    if (typeof attributes !== 'object' || attributes == null) {
        return out;
    }
    try {
        for (var _b = __values$7(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read$8(_c.value, 2), key = _d[0], val = _d[1];
            if (!isAttributeKey(key)) {
                diag.warn("Invalid attribute key: " + key);
                continue;
            }
            if (!isAttributeValue(val)) {
                diag.warn("Invalid attribute value set for key: " + key);
                continue;
            }
            if (Array.isArray(val)) {
                out[key] = val.slice();
            }
            else {
                out[key] = val;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return out;
}
function isAttributeKey(key) {
    return typeof key === 'string' && key.length > 0;
}
function isAttributeValue(val) {
    if (val == null) {
        return true;
    }
    if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
    }
    return isValidPrimitiveAttributeValue(val);
}
function isHomogeneousAttributeValueArray(arr) {
    var e_2, _a;
    var type;
    try {
        for (var arr_1 = __values$7(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {
            var element = arr_1_1.value;
            // null/undefined elements are allowed
            if (element == null)
                continue;
            if (!type) {
                if (isValidPrimitiveAttributeValue(element)) {
                    type = typeof element;
                    continue;
                }
                // encountered an invalid primitive
                return false;
            }
            if (typeof element === type) {
                continue;
            }
            return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
function isValidPrimitiveAttributeValue(val) {
    switch (typeof val) {
        case 'number':
        case 'boolean':
        case 'string':
            return true;
    }
    return false;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a function that logs an error using the provided logger, or a
 * console logger if one was not provided.
 */
function loggingErrorHandler() {
    return function (ex) {
        diag.error(stringifyException(ex));
    };
}
/**
 * Converts an exception into a string representation
 * @param {Exception} ex
 */
function stringifyException(ex) {
    if (typeof ex === 'string') {
        return ex;
    }
    else {
        return JSON.stringify(flattenException(ex));
    }
}
/**
 * Flattens an exception into key-value pairs by traversing the prototype chain
 * and coercing values to strings. Duplicate properties will not be overwritten;
 * the first insert wins.
 */
function flattenException(ex) {
    var result = {};
    var current = ex;
    while (current !== null) {
        Object.getOwnPropertyNames(current).forEach(function (propertyName) {
            if (result[propertyName])
                return;
            var value = current[propertyName];
            if (value) {
                result[propertyName] = String(value);
            }
        });
        current = Object.getPrototypeOf(current);
    }
    return result;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The global error handler delegate */
var delegateHandler = loggingErrorHandler();
/**
 * Set the global error handler
 * @param {ErrorHandler} handler
 */
function setGlobalErrorHandler(handler) {
    delegateHandler = handler;
}
/**
 * Return the global error handler
 * @param {Exception} ex
 */
function globalErrorHandler(ex) {
    try {
        delegateHandler(ex);
    }
    catch (_a) { } // eslint-disable-line no-empty
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TracesSamplerValues;
(function (TracesSamplerValues) {
    TracesSamplerValues["AlwaysOff"] = "always_off";
    TracesSamplerValues["AlwaysOn"] = "always_on";
    TracesSamplerValues["ParentBasedAlwaysOff"] = "parentbased_always_off";
    TracesSamplerValues["ParentBasedAlwaysOn"] = "parentbased_always_on";
    TracesSamplerValues["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
    TracesSamplerValues["TraceIdRatio"] = "traceidratio";
})(TracesSamplerValues || (TracesSamplerValues = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DEFAULT_LIST_SEPARATOR = ',';
/**
 * Environment interface to define all names
 */
var ENVIRONMENT_BOOLEAN_KEYS = ['OTEL_SDK_DISABLED'];
function isEnvVarABoolean(key) {
    return (ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1);
}
var ENVIRONMENT_NUMBERS_KEYS = [
    'OTEL_BSP_EXPORT_TIMEOUT',
    'OTEL_BSP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BSP_MAX_QUEUE_SIZE',
    'OTEL_BSP_SCHEDULE_DELAY',
    'OTEL_BLRP_EXPORT_TIMEOUT',
    'OTEL_BLRP_MAX_EXPORT_BATCH_SIZE',
    'OTEL_BLRP_MAX_QUEUE_SIZE',
    'OTEL_BLRP_SCHEDULE_DELAY',
    'OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT',
    'OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT',
    'OTEL_SPAN_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_LINK_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT',
    'OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT',
    'OTEL_EXPORTER_OTLP_TIMEOUT',
    'OTEL_EXPORTER_OTLP_TRACES_TIMEOUT',
    'OTEL_EXPORTER_OTLP_METRICS_TIMEOUT',
    'OTEL_EXPORTER_OTLP_LOGS_TIMEOUT',
    'OTEL_EXPORTER_JAEGER_AGENT_PORT',
];
function isEnvVarANumber(key) {
    return (ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1);
}
var ENVIRONMENT_LISTS_KEYS = [
    'OTEL_NO_PATCH_MODULES',
    'OTEL_PROPAGATORS',
    'OTEL_SEMCONV_STABILITY_OPT_IN',
];
function isEnvVarAList(key) {
    return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
}
var DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
var DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
var DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
/**
 * Default environment variables
 */
var DEFAULT_ENVIRONMENT = {
    OTEL_SDK_DISABLED: false,
    CONTAINER_NAME: '',
    ECS_CONTAINER_METADATA_URI_V4: '',
    ECS_CONTAINER_METADATA_URI: '',
    HOSTNAME: '',
    KUBERNETES_SERVICE_HOST: '',
    NAMESPACE: '',
    OTEL_BSP_EXPORT_TIMEOUT: 30000,
    OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BSP_MAX_QUEUE_SIZE: 2048,
    OTEL_BSP_SCHEDULE_DELAY: 5000,
    OTEL_BLRP_EXPORT_TIMEOUT: 30000,
    OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
    OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
    OTEL_BLRP_SCHEDULE_DELAY: 5000,
    OTEL_EXPORTER_JAEGER_AGENT_HOST: '',
    OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
    OTEL_EXPORTER_JAEGER_ENDPOINT: '',
    OTEL_EXPORTER_JAEGER_PASSWORD: '',
    OTEL_EXPORTER_JAEGER_USER: '',
    OTEL_EXPORTER_OTLP_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: '',
    OTEL_EXPORTER_OTLP_HEADERS: '',
    OTEL_EXPORTER_OTLP_TRACES_HEADERS: '',
    OTEL_EXPORTER_OTLP_METRICS_HEADERS: '',
    OTEL_EXPORTER_OTLP_LOGS_HEADERS: '',
    OTEL_EXPORTER_OTLP_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 10000,
    OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 10000,
    OTEL_EXPORTER_ZIPKIN_ENDPOINT: 'http://localhost:9411/api/v2/spans',
    OTEL_LOG_LEVEL: DiagLogLevel.INFO,
    OTEL_NO_PATCH_MODULES: [],
    OTEL_PROPAGATORS: ['tracecontext', 'baggage'],
    OTEL_RESOURCE_ATTRIBUTES: '',
    OTEL_SERVICE_NAME: '',
    OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
    OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
    OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
    OTEL_SPAN_LINK_COUNT_LIMIT: 128,
    OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
    OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
    OTEL_TRACES_EXPORTER: '',
    OTEL_TRACES_SAMPLER: TracesSamplerValues.ParentBasedAlwaysOn,
    OTEL_TRACES_SAMPLER_ARG: '',
    OTEL_LOGS_EXPORTER: '',
    OTEL_EXPORTER_OTLP_INSECURE: '',
    OTEL_EXPORTER_OTLP_TRACES_INSECURE: '',
    OTEL_EXPORTER_OTLP_METRICS_INSECURE: '',
    OTEL_EXPORTER_OTLP_LOGS_INSECURE: '',
    OTEL_EXPORTER_OTLP_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: '',
    OTEL_EXPORTER_OTLP_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: '',
    OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: '',
    OTEL_EXPORTER_OTLP_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: 'http/protobuf',
    OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: 'cumulative',
    OTEL_SEMCONV_STABILITY_OPT_IN: [],
};
/**
 * @param key
 * @param environment
 * @param values
 */
function parseBoolean(key, environment, values) {
    if (typeof values[key] === 'undefined') {
        return;
    }
    var value = String(values[key]);
    // support case-insensitive "true"
    environment[key] = value.toLowerCase() === 'true';
}
/**
 * Parses a variable as number with number validation
 * @param name
 * @param environment
 * @param values
 * @param min
 * @param max
 */
function parseNumber(name, environment, values, min, max) {
    if (min === undefined) { min = -Infinity; }
    if (max === undefined) { max = Infinity; }
    if (typeof values[name] !== 'undefined') {
        var value = Number(values[name]);
        if (!isNaN(value)) {
            if (value < min) {
                environment[name] = min;
            }
            else if (value > max) {
                environment[name] = max;
            }
            else {
                environment[name] = value;
            }
        }
    }
}
/**
 * Parses list-like strings from input into output.
 * @param name
 * @param environment
 * @param values
 * @param separator
 */
function parseStringList(name, output, input, separator) {
    if (separator === undefined) { separator = DEFAULT_LIST_SEPARATOR; }
    var givenValue = input[name];
    if (typeof givenValue === 'string') {
        output[name] = givenValue.split(separator).map(function (v) { return v.trim(); });
    }
}
// The support string -> DiagLogLevel mappings
var logLevelMap = {
    ALL: DiagLogLevel.ALL,
    VERBOSE: DiagLogLevel.VERBOSE,
    DEBUG: DiagLogLevel.DEBUG,
    INFO: DiagLogLevel.INFO,
    WARN: DiagLogLevel.WARN,
    ERROR: DiagLogLevel.ERROR,
    NONE: DiagLogLevel.NONE,
};
/**
 * Environmentally sets log level if valid log level string is provided
 * @param key
 * @param environment
 * @param values
 */
function setLogLevelFromEnv(key, environment, values) {
    var value = values[key];
    if (typeof value === 'string') {
        var theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
            environment[key] = theLevel;
        }
    }
}
/**
 * Parses environment values
 * @param values
 */
function parseEnvironment(values) {
    var environment = {};
    for (var env in DEFAULT_ENVIRONMENT) {
        var key = env;
        switch (key) {
            case 'OTEL_LOG_LEVEL':
                setLogLevelFromEnv(key, environment, values);
                break;
            default:
                if (isEnvVarABoolean(key)) {
                    parseBoolean(key, environment, values);
                }
                else if (isEnvVarANumber(key)) {
                    parseNumber(key, environment, values);
                }
                else if (isEnvVarAList(key)) {
                    parseStringList(key, environment, values);
                }
                else {
                    var value = values[key];
                    if (typeof value !== 'undefined' && value !== null) {
                        environment[key] = String(value);
                    }
                }
        }
    }
    return environment;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Gets the environment variables
 */
function getEnv() {
    var processEnv = parseEnvironment(process.env);
    return Object.assign({}, DEFAULT_ENVIRONMENT, processEnv);
}
function getEnvWithoutDefaults() {
    return parseEnvironment(process.env);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** only globals that common to node and browsers are allowed */
// eslint-disable-next-line node/no-unsupported-features/es-builtins
var _globalThis = typeof globalThis === 'object' ? globalThis : global;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function intValue(charCode) {
    // 0-9
    if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
    }
    // a-f
    if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
    }
    // A-F
    return charCode - 55;
}
function hexToBinary(hexStr) {
    var buf = new Uint8Array(hexStr.length / 2);
    var offset = 0;
    for (var i = 0; i < hexStr.length; i += 2) {
        var hi = intValue(hexStr.charCodeAt(i));
        var lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = (hi << 4) | lo;
    }
    return buf;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hexToBase64(hexStr) {
    return Buffer.from(hexToBinary(hexStr)).toString('base64');
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SPAN_ID_BYTES$1 = 8;
var TRACE_ID_BYTES$1 = 16;
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 */
var RandomIdGenerator$1 = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = getIdGenerator$1(TRACE_ID_BYTES$1);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = getIdGenerator$1(SPAN_ID_BYTES$1);
    }
    return RandomIdGenerator;
}());
var SHARED_BUFFER$1 = Buffer.allocUnsafe(TRACE_ID_BYTES$1);
function getIdGenerator$1(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes / 4; i++) {
            // unsigned right shift drops decimal part of the number
            // it is required because if a number between 2**32 and 2**32 - 1 is generated, an out of range error is thrown by writeUInt32BE
            SHARED_BUFFER$1.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, i * 4);
        }
        // If buffer is all 0, set the last byte to 1 to guarantee a valid w3c id is generated
        for (var i = 0; i < bytes; i++) {
            if (SHARED_BUFFER$1[i] > 0) {
                break;
            }
            else if (i === bytes - 1) {
                SHARED_BUFFER$1[bytes - 1] = 1;
            }
        }
        return SHARED_BUFFER$1.toString('hex', 0, bytes);
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var otperformance = performance$1;

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION$2 = '1.30.1';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;
/** Constants describing the SDK in use */
var SDK_INFO = (_a = {},
    _a[SEMRESATTRS_TELEMETRY_SDK_NAME] = 'opentelemetry',
    _a[SEMRESATTRS_PROCESS_RUNTIME_NAME] = 'node',
    _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = TELEMETRYSDKLANGUAGEVALUES_NODEJS,
    _a[SEMRESATTRS_TELEMETRY_SDK_VERSION] = VERSION$2,
    _a);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function unrefTimer(timer) {
    timer.unref();
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NANOSECOND_DIGITS = 9;
var NANOSECOND_DIGITS_IN_MILLIS = 6;
var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
/**
 * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).
 * @param epochMillis
 */
function millisToHrTime(epochMillis) {
    var epochSeconds = epochMillis / 1000;
    // Decimals only.
    var seconds = Math.trunc(epochSeconds);
    // Round sub-nanosecond accuracy to nanosecond.
    var nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS);
    return [seconds, nanos];
}
function getTimeOrigin() {
    var timeOrigin = otperformance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        var perf = otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
    }
    return timeOrigin;
}
/**
 * Returns an hrtime calculated via performance component.
 * @param performanceNow
 */
function hrTime(performanceNow) {
    var timeOrigin = millisToHrTime(getTimeOrigin());
    var now = millisToHrTime(typeof performanceNow === 'number' ? performanceNow : otperformance.now());
    return addHrTimes(timeOrigin, now);
}
/**
 *
 * Converts a TimeInput to an HrTime, defaults to _hrtime().
 * @param time
 */
function timeInputToHrTime(time) {
    // process.hrtime
    if (isTimeInputHrTime(time)) {
        return time;
    }
    else if (typeof time === 'number') {
        // Must be a performance.now() if it's smaller than process start time.
        if (time < getTimeOrigin()) {
            return hrTime(time);
        }
        else {
            // epoch milliseconds or performance.timeOrigin
            return millisToHrTime(time);
        }
    }
    else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
    }
    else {
        throw TypeError('Invalid input type');
    }
}
/**
 * Returns a duration of two hrTime.
 * @param startTime
 * @param endTime
 */
function hrTimeDuration(startTime, endTime) {
    var seconds = endTime[0] - startTime[0];
    var nanos = endTime[1] - startTime[1];
    // overflow
    if (nanos < 0) {
        seconds -= 1;
        // negate
        nanos += SECOND_TO_NANOSECONDS;
    }
    return [seconds, nanos];
}
/**
 * Convert hrTime to timestamp, for example "2019-05-14T17:00:00.000123456Z"
 * @param time
 */
function hrTimeToTimeStamp(time) {
    var precision = NANOSECOND_DIGITS;
    var tmp = "" + '0'.repeat(precision) + time[1] + "Z";
    var nanoString = tmp.substring(tmp.length - precision - 1);
    var date = new Date(time[0] * 1000).toISOString();
    return date.replace('000Z', nanoString);
}
/**
 * Convert hrTime to nanoseconds.
 * @param time
 */
function hrTimeToNanoseconds(time) {
    return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
/**
 * Convert hrTime to milliseconds.
 * @param time
 */
function hrTimeToMilliseconds(time) {
    return time[0] * 1e3 + time[1] / 1e6;
}
/**
 * Convert hrTime to microseconds.
 * @param time
 */
function hrTimeToMicroseconds(time) {
    return time[0] * 1e6 + time[1] / 1e3;
}
/**
 * check if time is HrTime
 * @param value
 */
function isTimeInputHrTime(value) {
    return (Array.isArray(value) &&
        value.length === 2 &&
        typeof value[0] === 'number' &&
        typeof value[1] === 'number');
}
/**
 * check if input value is a correct types.TimeInput
 * @param value
 */
function isTimeInput(value) {
    return (isTimeInputHrTime(value) ||
        typeof value === 'number' ||
        value instanceof Date);
}
/**
 * Given 2 HrTime formatted times, return their sum as an HrTime.
 */
function addHrTimes(time1, time2) {
    var out = [time1[0] + time2[0], time1[1] + time2[1]];
    // Nanoseconds
    if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExportResultCode;
(function (ExportResultCode) {
    ExportResultCode[ExportResultCode["SUCCESS"] = 0] = "SUCCESS";
    ExportResultCode[ExportResultCode["FAILED"] = 1] = "FAILED";
})(ExportResultCode || (ExportResultCode = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values$6 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/** Combines multiple propagators into a single propagator. */
var CompositePropagator = /** @class */ (function () {
    /**
     * Construct a composite propagator from a list of propagators.
     *
     * @param [config] Configuration object for composite propagator
     */
    function CompositePropagator(config) {
        if (config === undefined) { config = {}; }
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== undefined ? _a : [];
        this._fields = Array.from(new Set(this._propagators
            // older propagators may not have fields function, null check to be sure
            .map(function (p) { return (typeof p.fields === 'function' ? p.fields() : []); })
            .reduce(function (x, y) { return x.concat(y); }, [])));
    }
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same carrier key, the propagator later in the list
     * will "win".
     *
     * @param context Context to inject
     * @param carrier Carrier into which context will be injected
     */
    CompositePropagator.prototype.inject = function (context, carrier, setter) {
        var e_1, _a;
        try {
            for (var _b = __values$6(this._propagators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propagator = _c.value;
                try {
                    propagator.inject(context, carrier, setter);
                }
                catch (err) {
                    diag.warn("Failed to inject with " + propagator.constructor.name + ". Err: " + err.message);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Run each of the configured propagators with the given context and carrier.
     * Propagators are run in the order they are configured, so if multiple
     * propagators write the same context key, the propagator later in the list
     * will "win".
     *
     * @param context Context to add values to
     * @param carrier Carrier from which to extract context
     */
    CompositePropagator.prototype.extract = function (context, carrier, getter) {
        return this._propagators.reduce(function (ctx, propagator) {
            try {
                return propagator.extract(ctx, carrier, getter);
            }
            catch (err) {
                diag.warn("Failed to extract with " + propagator.constructor.name + ". Err: " + err.message);
            }
            return ctx;
        }, context);
    };
    CompositePropagator.prototype.fields = function () {
        // return a new array so our fields cannot be modified
        return this._fields.slice();
    };
    return CompositePropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var VALID_KEY_CHAR_RANGE = '[_0-9a-z-*/]';
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
/**
 * Key is opaque string up to 256 characters printable. It MUST begin with a
 * lowercase letter, and can only contain lowercase letters a-z, digits 0-9,
 * underscores _, dashes -, asterisks *, and forward slashes /.
 * For multi-tenant vendor scenarios, an at sign (@) can be used to prefix the
 * vendor name. Vendors SHOULD set the tenant ID at the beginning of the key.
 * see https://www.w3.org/TR/trace-context/#key
 */
function validateKey(key) {
    return VALID_KEY_REGEX.test(key);
}
/**
 * Value is opaque string up to 256 characters printable ASCII RFC0020
 * characters (i.e., the range 0x20 to 0x7E) except comma , and =.
 */
function validateValue(value) {
    return (VALID_VALUE_BASE_REGEX.test(value) &&
        !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ',';
var LIST_MEMBER_KEY_VALUE_SPLITTER = '=';
/**
 * TraceState must be a class and not a simple object type because of the spec
 * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).
 *
 * Here is the list of allowed mutations:
 * - New key-value pair should be added into the beginning of the list
 * - The value of any key can be updated. Modified keys MUST be moved to the
 * beginning of the list.
 */
var TraceState = /** @class */ (function () {
    function TraceState(rawTraceState) {
        this._internalState = new Map();
        if (rawTraceState)
            this._parse(rawTraceState);
    }
    TraceState.prototype.set = function (key, value) {
        // TODO: Benchmark the different approaches(map vs list) and
        // use the faster one.
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
            traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
    };
    TraceState.prototype.unset = function (key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
    };
    TraceState.prototype.get = function (key) {
        return this._internalState.get(key);
    };
    TraceState.prototype.serialize = function () {
        var _this = this;
        return this._keys()
            .reduce(function (agg, key) {
            agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
            return agg;
        }, [])
            .join(LIST_MEMBERS_SEPARATOR);
    };
    TraceState.prototype._parse = function (rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
            return;
        this._internalState = rawTraceState
            .split(LIST_MEMBERS_SEPARATOR)
            .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning
            .reduce(function (agg, part) {
            var listMember = part.trim(); // Optional Whitespace (OWS) handling
            var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
            if (i !== -1) {
                var key = listMember.slice(0, i);
                var value = listMember.slice(i + 1, part.length);
                if (validateKey(key) && validateValue(value)) {
                    agg.set(key, value);
                }
            }
            return agg;
        }, new Map());
        // Because of the reverse() requirement, trunc must be done after map is created
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
            this._internalState = new Map(Array.from(this._internalState.entries())
                .reverse() // Use reverse same as original tracestate parse chain
                .slice(0, MAX_TRACE_STATE_ITEMS));
        }
    };
    TraceState.prototype._keys = function () {
        return Array.from(this._internalState.keys()).reverse();
    };
    TraceState.prototype._clone = function () {
        var traceState = new TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
    };
    return TraceState;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TRACE_PARENT_HEADER = 'traceparent';
var TRACE_STATE_HEADER = 'tracestate';
var VERSION$1 = '00';
var VERSION_PART = '(?!ff)[\\da-f]{2}';
var TRACE_ID_PART = '(?![0]{32})[\\da-f]{32}';
var PARENT_ID_PART = '(?![0]{16})[\\da-f]{16}';
var FLAGS_PART = '[\\da-f]{2}';
var TRACE_PARENT_REGEX = new RegExp("^\\s?(" + VERSION_PART + ")-(" + TRACE_ID_PART + ")-(" + PARENT_ID_PART + ")-(" + FLAGS_PART + ")(-.*)?\\s?$");
/**
 * Parses information from the [traceparent] span tag and converts it into {@link SpanContext}
 * @param traceParent - A meta property that comes from server.
 *     It should be dynamically generated server side to have the server's request trace Id,
 *     a parent span Id that was set on the server's request span,
 *     and the trace flags to indicate the server's sampling decision
 *     (01 = sampled, 00 = not sampled).
 *     for example: '{version}-{traceId}-{spanId}-{sampleDecision}'
 *     For more information see {@link https://www.w3.org/TR/trace-context/}
 */
function parseTraceParent(traceParent) {
    var match = TRACE_PARENT_REGEX.exec(traceParent);
    if (!match)
        return null;
    // According to the specification the implementation should be compatible
    // with future versions. If there are more parts, we only reject it if it's using version 00
    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent
    if (match[1] === '00' && match[5])
        return null;
    return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16),
    };
}
/**
 * Propagates {@link SpanContext} through Trace Context format propagation.
 *
 * Based on the Trace Context specification:
 * https://www.w3.org/TR/trace-context/
 */
var W3CTraceContextPropagator = /** @class */ (function () {
    function W3CTraceContextPropagator() {
    }
    W3CTraceContextPropagator.prototype.inject = function (context, carrier, setter) {
        var spanContext = trace.getSpanContext(context);
        if (!spanContext ||
            isTracingSuppressed(context) ||
            !isSpanContextValid(spanContext))
            return;
        var traceParent = VERSION$1 + "-" + spanContext.traceId + "-" + spanContext.spanId + "-0" + Number(spanContext.traceFlags || TraceFlags.NONE).toString(16);
        setter.set(carrier, TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
            setter.set(carrier, TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
    };
    W3CTraceContextPropagator.prototype.extract = function (context, carrier, getter) {
        var traceParentHeader = getter.get(carrier, TRACE_PARENT_HEADER);
        if (!traceParentHeader)
            return context;
        var traceParent = Array.isArray(traceParentHeader)
            ? traceParentHeader[0]
            : traceParentHeader;
        if (typeof traceParent !== 'string')
            return context;
        var spanContext = parseTraceParent(traceParent);
        if (!spanContext)
            return context;
        spanContext.isRemote = true;
        var traceStateHeader = getter.get(carrier, TRACE_STATE_HEADER);
        if (traceStateHeader) {
            // If more than one `tracestate` header is found, we merge them into a
            // single header.
            var state = Array.isArray(traceStateHeader)
                ? traceStateHeader.join(',')
                : traceStateHeader;
            spanContext.traceState = new TraceState(typeof state === 'string' ? state : undefined);
        }
        return trace.setSpanContext(context, spanContext);
    };
    W3CTraceContextPropagator.prototype.fields = function () {
        return [TRACE_PARENT_HEADER, TRACE_STATE_HEADER];
    };
    return W3CTraceContextPropagator;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RPC_METADATA_KEY = createContextKey('OpenTelemetry SDK Context Key RPC_METADATA');
var RPCType;
(function (RPCType) {
    RPCType["HTTP"] = "http";
})(RPCType || (RPCType = {}));
function setRPCMetadata(context, meta) {
    return context.setValue(RPC_METADATA_KEY, meta);
}
function deleteRPCMetadata(context) {
    return context.deleteValue(RPC_METADATA_KEY);
}
function getRPCMetadata(context) {
    return context.getValue(RPC_METADATA_KEY);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples no traces.
 */
var AlwaysOffSampler$1 = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision$1.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples all traces.
 */
var AlwaysOnSampler$1 = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision$1.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var ParentBasedSampler$1 = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new AlwaysOnSampler$1();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== undefined ? _a : new AlwaysOnSampler$1();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== undefined ? _b : new AlwaysOffSampler$1();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== undefined ? _c : new AlwaysOnSampler$1();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== undefined ? _d : new AlwaysOffSampler$1();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @deprecated Use the one defined in @opentelemetry/sdk-trace-base instead.
 * Sampler that samples a given fraction of traces based of trace id deterministically.
 */
var TraceIdRatioBasedSampler$1 = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === undefined) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision$1.RECORD_AND_SAMPLED
                : SamplingDecision$1.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * based on lodash in order to support esm builds without esModuleInterop.
 * lodash is using MIT License.
 **/
var objectTag = '[object Object]';
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
var objectCtorString = funcToString.call(Object);
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
var nativeObjectToString = objectProto.toString;
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return (typeof Ctor == 'function' &&
        Ctor instanceof Ctor &&
        funcToString.call(Ctor) === objectCtorString);
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value)
        ? getRawTag(value)
        : objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    var unmasked = false;
    try {
        value[symToStringTag] = undefined;
        unmasked = true;
    }
    catch (e) {
        // silence
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        }
        else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
    return nativeObjectToString.call(value);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */
var MAX_LEVEL = 20;
/**
 * Merges objects together
 * @param args - objects / values to be merged
 */
function merge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var result = args.shift();
    var objects = new WeakMap();
    while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
    }
    return result;
}
function takeValue(value) {
    if (isArray(value)) {
        return value.slice();
    }
    return value;
}
/**
 * Merges two objects
 * @param one - first object
 * @param two - second object
 * @param level - current deep level
 * @param objects - objects holder that has been already referenced - to prevent
 * cyclic dependency
 */
function mergeTwoObjects(one, two, level, objects) {
    if (level === undefined) { level = 0; }
    var result;
    if (level > MAX_LEVEL) {
        return undefined;
    }
    level++;
    if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
    }
    else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
            for (var i = 0, j = two.length; i < j; i++) {
                result.push(takeValue(two[i]));
            }
        }
        else if (isObject(two)) {
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                result[key] = takeValue(two[key]);
            }
        }
    }
    else if (isObject(one)) {
        if (isObject(two)) {
            if (!shouldMerge(one, two)) {
                return two;
            }
            result = Object.assign({}, one);
            var keys = Object.keys(two);
            for (var i = 0, j = keys.length; i < j; i++) {
                var key = keys[i];
                var twoValue = two[key];
                if (isPrimitive(twoValue)) {
                    if (typeof twoValue === 'undefined') {
                        delete result[key];
                    }
                    else {
                        // result[key] = takeValue(twoValue);
                        result[key] = twoValue;
                    }
                }
                else {
                    var obj1 = result[key];
                    var obj2 = twoValue;
                    if (wasObjectReferenced(one, key, objects) ||
                        wasObjectReferenced(two, key, objects)) {
                        delete result[key];
                    }
                    else {
                        if (isObject(obj1) && isObject(obj2)) {
                            var arr1 = objects.get(obj1) || [];
                            var arr2 = objects.get(obj2) || [];
                            arr1.push({ obj: one, key: key });
                            arr2.push({ obj: two, key: key });
                            objects.set(obj1, arr1);
                            objects.set(obj2, arr2);
                        }
                        result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
                    }
                }
            }
        }
        else {
            result = two;
        }
    }
    return result;
}
/**
 * Function to check if object has been already reference
 * @param obj
 * @param key
 * @param objects
 */
function wasObjectReferenced(obj, key, objects) {
    var arr = objects.get(obj[key]) || [];
    for (var i = 0, j = arr.length; i < j; i++) {
        var info = arr[i];
        if (info.key === key && info.obj === obj) {
            return true;
        }
    }
    return false;
}
function isArray(value) {
    return Array.isArray(value);
}
function isFunction(value) {
    return typeof value === 'function';
}
function isObject(value) {
    return (!isPrimitive(value) &&
        !isArray(value) &&
        !isFunction(value) &&
        typeof value === 'object');
}
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        typeof value === 'undefined' ||
        value instanceof Date ||
        value instanceof RegExp ||
        value === null);
}
function shouldMerge(one, two) {
    if (!isPlainObject(one) || !isPlainObject(two)) {
        return false;
    }
    return true;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Error that is thrown on timeouts.
 */
var TimeoutError = /** @class */ (function (_super) {
    __extends$2(TimeoutError, _super);
    function TimeoutError(message) {
        var _this = _super.call(this, message) || this;
        // manually adjust prototype to retain `instanceof` functionality when targeting ES5, see:
        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error));
/**
 * Adds a timeout to a promise and rejects if the specified timeout has elapsed. Also rejects if the specified promise
 * rejects, and resolves if the specified promise resolves.
 *
 * <p> NOTE: this operation will continue even after it throws a {@link TimeoutError}.
 *
 * @param promise promise to use with timeout.
 * @param timeout the timeout in milliseconds until the returned promise is rejected.
 */
function callWithTimeout(promise, timeout) {
    var timeoutHandle;
    var timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
            reject(new TimeoutError('Operation timed out.'));
        }, timeout);
    });
    return Promise.race([promise, timeoutPromise]).then(function (result) {
        clearTimeout(timeoutHandle);
        return result;
    }, function (reason) {
        clearTimeout(timeoutHandle);
        throw reason;
    });
}

var __values$5 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function urlMatches(url, urlToMatch) {
    if (typeof urlToMatch === 'string') {
        return url === urlToMatch;
    }
    else {
        return !!url.match(urlToMatch);
    }
}
/**
 * Check if {@param url} should be ignored when comparing against {@param ignoredUrls}
 * @param url
 * @param ignoredUrls
 */
function isUrlIgnored(url, ignoredUrls) {
    var e_1, _a;
    if (!ignoredUrls) {
        return false;
    }
    try {
        for (var ignoredUrls_1 = __values$5(ignoredUrls), ignoredUrls_1_1 = ignoredUrls_1.next(); !ignoredUrls_1_1.done; ignoredUrls_1_1 = ignoredUrls_1.next()) {
            var ignoreUrl = ignoredUrls_1_1.value;
            if (urlMatches(url, ignoreUrl)) {
                return true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ignoredUrls_1_1 && !ignoredUrls_1_1.done && (_a = ignoredUrls_1.return)) _a.call(ignoredUrls_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Checks if certain function has been already wrapped
 * @param func
 */
function isWrapped(func) {
    return (typeof func === 'function' &&
        typeof func.__original === 'function' &&
        typeof func.__unwrap === 'function' &&
        func.__wrapped === true);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(Deferred.prototype, "promise", {
        get: function () {
            return this._promise;
        },
        enumerable: false,
        configurable: true
    });
    Deferred.prototype.resolve = function (val) {
        this._resolve(val);
    };
    Deferred.prototype.reject = function (err) {
        this._reject(err);
    };
    return Deferred;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$7 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$2 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * Bind the callback and only invoke the callback once regardless how many times `BindOnceFuture.call` is invoked.
 */
var BindOnceFuture = /** @class */ (function () {
    function BindOnceFuture(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new Deferred();
    }
    Object.defineProperty(BindOnceFuture.prototype, "isCalled", {
        get: function () {
            return this._isCalled;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BindOnceFuture.prototype, "promise", {
        get: function () {
            return this._deferred.promise;
        },
        enumerable: false,
        configurable: true
    });
    BindOnceFuture.prototype.call = function () {
        var _a;
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!this._isCalled) {
            this._isCalled = true;
            try {
                Promise.resolve((_a = this._callback).call.apply(_a, __spreadArray$2([this._that], __read$7(args), false))).then(function (val) { return _this._deferred.resolve(val); }, function (err) { return _this._deferred.reject(err); });
            }
            catch (err) {
                this._deferred.reject(err);
            }
        }
        return this._deferred.promise;
    };
    return BindOnceFuture;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 * Shared functionality used by Exporters while exporting data, including suppression of Traces.
 */
function _export(exporter, arg) {
    return new Promise(function (resolve) {
        // prevent downstream exporter calls from generating spans
        context.with(suppressTracing(context.active()), function () {
            exporter.export(arg, function (result) {
                resolve(result);
            });
        });
    });
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var baggageUtils = {
    getKeyPairs: getKeyPairs,
    serializeKeyPairs: serializeKeyPairs,
    parseKeyPairsIntoRecord: parseKeyPairsIntoRecord,
    parsePairKeyValue: parsePairKeyValue,
};
var internal = {
    _export: _export,
};

var esm$2 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	AlwaysOffSampler: AlwaysOffSampler$1,
	AlwaysOnSampler: AlwaysOnSampler$1,
	AnchoredClock: AnchoredClock,
	BindOnceFuture: BindOnceFuture,
	CompositePropagator: CompositePropagator,
	DEFAULT_ATTRIBUTE_COUNT_LIMIT: DEFAULT_ATTRIBUTE_COUNT_LIMIT,
	DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT: DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
	DEFAULT_ENVIRONMENT: DEFAULT_ENVIRONMENT,
	DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
	DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
	get ExportResultCode () { return ExportResultCode; },
	ParentBasedSampler: ParentBasedSampler$1,
	get RPCType () { return RPCType; },
	RandomIdGenerator: RandomIdGenerator$1,
	SDK_INFO: SDK_INFO,
	TRACE_PARENT_HEADER: TRACE_PARENT_HEADER,
	TRACE_STATE_HEADER: TRACE_STATE_HEADER,
	TimeoutError: TimeoutError,
	TraceIdRatioBasedSampler: TraceIdRatioBasedSampler$1,
	TraceState: TraceState,
	get TracesSamplerValues () { return TracesSamplerValues; },
	VERSION: VERSION$2,
	W3CBaggagePropagator: W3CBaggagePropagator,
	W3CTraceContextPropagator: W3CTraceContextPropagator,
	_globalThis: _globalThis,
	addHrTimes: addHrTimes,
	baggageUtils: baggageUtils,
	callWithTimeout: callWithTimeout,
	deleteRPCMetadata: deleteRPCMetadata,
	getEnv: getEnv,
	getEnvWithoutDefaults: getEnvWithoutDefaults,
	getRPCMetadata: getRPCMetadata,
	getTimeOrigin: getTimeOrigin,
	globalErrorHandler: globalErrorHandler,
	hexToBase64: hexToBase64,
	hexToBinary: hexToBinary,
	hrTime: hrTime,
	hrTimeDuration: hrTimeDuration,
	hrTimeToMicroseconds: hrTimeToMicroseconds,
	hrTimeToMilliseconds: hrTimeToMilliseconds,
	hrTimeToNanoseconds: hrTimeToNanoseconds,
	hrTimeToTimeStamp: hrTimeToTimeStamp,
	internal: internal,
	isAttributeKey: isAttributeKey,
	isAttributeValue: isAttributeValue,
	isTimeInput: isTimeInput,
	isTimeInputHrTime: isTimeInputHrTime,
	isTracingSuppressed: isTracingSuppressed,
	isUrlIgnored: isUrlIgnored,
	isWrapped: isWrapped,
	loggingErrorHandler: loggingErrorHandler,
	merge: merge,
	millisToHrTime: millisToHrTime,
	otperformance: otperformance,
	parseEnvironment: parseEnvironment,
	parseTraceParent: parseTraceParent,
	sanitizeAttributes: sanitizeAttributes,
	setGlobalErrorHandler: setGlobalErrorHandler,
	setRPCMetadata: setRPCMetadata,
	suppressTracing: suppressTracing,
	timeInputToHrTime: timeInputToHrTime,
	unrefTimer: unrefTimer,
	unsuppressTracing: unsuppressTracing,
	urlMatches: urlMatches
});

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isPartialSuccessResponse(response) {
    return Object.prototype.hasOwnProperty.call(response, 'partialSuccess');
}
/**
 * Default response handler that logs a partial success to the console.
 */
function createLoggingPartialSuccessResponseHandler() {
    return {
        handleResponse: function (response) {
            // Partial success MUST never be an empty object according the specification
            // see https://opentelemetry.io/docs/specs/otlp/#partial-success
            if (response == null ||
                !isPartialSuccessResponse(response) ||
                response.partialSuccess == null ||
                Object.keys(response.partialSuccess).length === 0) {
                return;
            }
            diag.warn('Received Partial Success response:', JSON.stringify(response.partialSuccess));
        },
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : undefined, done: true };
    }
};
var OTLPExportDelegate = /** @class */ (function () {
    function OTLPExportDelegate(_transport, _serializer, _responseHandler, _promiseQueue, _timeout) {
        this._transport = _transport;
        this._serializer = _serializer;
        this._responseHandler = _responseHandler;
        this._promiseQueue = _promiseQueue;
        this._timeout = _timeout;
        this._diagLogger = diag.createComponentLogger({
            namespace: 'OTLPExportDelegate',
        });
    }
    OTLPExportDelegate.prototype.export = function (internalRepresentation, resultCallback) {
        var _this = this;
        this._diagLogger.debug('items to be sent', internalRepresentation);
        // don't do any work if too many exports are in progress.
        if (this._promiseQueue.hasReachedLimit()) {
            resultCallback({
                code: ExportResultCode.FAILED,
                error: new Error('Concurrent export limit reached'),
            });
            return;
        }
        var serializedRequest = this._serializer.serializeRequest(internalRepresentation);
        if (serializedRequest == null) {
            resultCallback({
                code: ExportResultCode.FAILED,
                error: new Error('Nothing to send'),
            });
            return;
        }
        this._promiseQueue.pushPromise(this._transport.send(serializedRequest, this._timeout).then(function (response) {
            if (response.status === 'success') {
                if (response.data != null) {
                    try {
                        _this._responseHandler.handleResponse(_this._serializer.deserializeResponse(response.data));
                    }
                    catch (e) {
                        _this._diagLogger.warn('Export succeeded but could not deserialize response - is the response specification compliant?', e, response.data);
                    }
                }
                // No matter the response, we can consider the export still successful.
                resultCallback({
                    code: ExportResultCode.SUCCESS,
                });
                return;
            }
            else if (response.status === 'failure' && response.error) {
                resultCallback({
                    code: ExportResultCode.FAILED,
                    error: response.error,
                });
                return;
            }
            else if (response.status === 'retryable') {
                resultCallback({
                    code: ExportResultCode.FAILED,
                    error: new OTLPExporterError('Export failed with retryable status'),
                });
            }
            else {
                resultCallback({
                    code: ExportResultCode.FAILED,
                    error: new OTLPExporterError('Export failed with unknown error'),
                });
            }
        }, function (reason) {
            return resultCallback({
                code: ExportResultCode.FAILED,
                error: reason,
            });
        }));
    };
    OTLPExportDelegate.prototype.forceFlush = function () {
        return this._promiseQueue.awaitAll();
    };
    OTLPExportDelegate.prototype.shutdown = function () {
        return __awaiter$3(this, undefined, undefined, function () {
            return __generator$3(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._diagLogger.debug('shutdown started');
                        return [4 /*yield*/, this.forceFlush()];
                    case 1:
                        _a.sent();
                        this._transport.shutdown();
                        return [2 /*return*/];
                }
            });
        });
    };
    return OTLPExportDelegate;
}());
/**
 * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all
 * signals.
 */
function createOtlpExportDelegate(components, settings) {
    return new OTLPExportDelegate(components.transport, components.serializer, createLoggingPartialSuccessResponseHandler(), components.promiseHandler, settings.timeout);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createOtlpNetworkExportDelegate(options, serializer, transport) {
    return createOtlpExportDelegate({
        transport: transport,
        serializer: serializer,
        promiseHandler: createBoundedQueueExportPromiseHandler(options),
    }, { timeout: options.timeoutMillis });
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm$1 = /*#__PURE__*/Object.freeze({
	__proto__: null,
	get CompressionAlgorithm () { return CompressionAlgorithm; },
	OTLPExporterBase: OTLPExporterBase,
	OTLPExporterError: OTLPExporterError,
	createOtlpNetworkExportDelegate: createOtlpNetworkExportDelegate,
	getSharedConfigurationDefaults: getSharedConfigurationDefaults,
	mergeOtlpSharedConfigurationWithDefaults: mergeOtlpSharedConfigurationWithDefaults
});

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(esm$1);

var grpcExporterTransport = {};

var createServiceClientConstructor = {};

var hasRequiredCreateServiceClientConstructor;

function requireCreateServiceClientConstructor () {
	if (hasRequiredCreateServiceClientConstructor) return createServiceClientConstructor;
	hasRequiredCreateServiceClientConstructor = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(createServiceClientConstructor, "__esModule", { value: true });
	createServiceClientConstructor.createServiceClientConstructor = undefined;
	const grpc = requireSrc$3();
	/**
	 * Creates a unary service client constructor that, when instantiated, does not serialize/deserialize anything.
	 * Allows for passing in {@link Buffer} directly, serialization can be handled via protobufjs or custom implementations.
	 *
	 * @param path service path
	 * @param name service name
	 */
	function createServiceClientConstructor$1(path, name) {
	    const serviceDefinition = {
	        export: {
	            path: path,
	            requestStream: false,
	            responseStream: false,
	            requestSerialize: (arg) => {
	                return arg;
	            },
	            requestDeserialize: (arg) => {
	                return arg;
	            },
	            responseSerialize: (arg) => {
	                return arg;
	            },
	            responseDeserialize: (arg) => {
	                return arg;
	            },
	        },
	    };
	    return grpc.makeGenericClientConstructor(serviceDefinition, name);
	}
	createServiceClientConstructor.createServiceClientConstructor = createServiceClientConstructor$1;
	
	return createServiceClientConstructor;
}

var hasRequiredGrpcExporterTransport;

function requireGrpcExporterTransport () {
	if (hasRequiredGrpcExporterTransport) return grpcExporterTransport;
	hasRequiredGrpcExporterTransport = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(grpcExporterTransport, "__esModule", { value: true });
	grpcExporterTransport.createOtlpGrpcExporterTransport = grpcExporterTransport.GrpcExporterTransport = grpcExporterTransport.createEmptyMetadata = grpcExporterTransport.createSslCredentials = grpcExporterTransport.createInsecureCredentials = undefined;
	// values taken from '@grpc/grpc-js` so that we don't need to require/import it.
	const GRPC_COMPRESSION_NONE = 0;
	const GRPC_COMPRESSION_GZIP = 2;
	function toGrpcCompression(compression) {
	    return compression === 'gzip' ? GRPC_COMPRESSION_GZIP : GRPC_COMPRESSION_NONE;
	}
	function createInsecureCredentials() {
	    // Lazy-load so that we don't need to require/import '@grpc/grpc-js' before it can be wrapped by instrumentation.
	    const { credentials,
	    // eslint-disable-next-line @typescript-eslint/no-var-requires
	     } = requireSrc$3();
	    return credentials.createInsecure();
	}
	grpcExporterTransport.createInsecureCredentials = createInsecureCredentials;
	function createSslCredentials(rootCert, privateKey, certChain) {
	    // Lazy-load so that we don't need to require/import '@grpc/grpc-js' before it can be wrapped by instrumentation.
	    const { credentials,
	    // eslint-disable-next-line @typescript-eslint/no-var-requires
	     } = requireSrc$3();
	    return credentials.createSsl(rootCert, privateKey, certChain);
	}
	grpcExporterTransport.createSslCredentials = createSslCredentials;
	function createEmptyMetadata() {
	    // Lazy-load so that we don't need to require/import '@grpc/grpc-js' before it can be wrapped by instrumentation.
	    const { Metadata,
	    // eslint-disable-next-line @typescript-eslint/no-var-requires
	     } = requireSrc$3();
	    return new Metadata();
	}
	grpcExporterTransport.createEmptyMetadata = createEmptyMetadata;
	class GrpcExporterTransport {
	    constructor(_parameters) {
	        this._parameters = _parameters;
	    }
	    shutdown() {
	        var _a;
	        (_a = this._client) === null || _a === undefined ? undefined : _a.close();
	    }
	    send(data, timeoutMillis) {
	        // We need to make a for gRPC
	        const buffer = Buffer.from(data);
	        if (this._client == null) {
	            // Lazy require to ensure that grpc is not loaded before instrumentations can wrap it
	            const { createServiceClientConstructor,
	            // eslint-disable-next-line @typescript-eslint/no-var-requires
	             } = /*@__PURE__*/ requireCreateServiceClientConstructor();
	            try {
	                this._metadata = this._parameters.metadata();
	            }
	            catch (error) {
	                return Promise.resolve({
	                    status: 'failure',
	                    error: error,
	                });
	            }
	            const clientConstructor = createServiceClientConstructor(this._parameters.grpcPath, this._parameters.grpcName);
	            try {
	                this._client = new clientConstructor(this._parameters.address, this._parameters.credentials(), {
	                    'grpc.default_compression_algorithm': toGrpcCompression(this._parameters.compression),
	                });
	            }
	            catch (error) {
	                return Promise.resolve({
	                    status: 'failure',
	                    error: error,
	                });
	            }
	        }
	        return new Promise(resolve => {
	            const deadline = Date.now() + timeoutMillis;
	            // this should never happen
	            if (this._metadata == null) {
	                return resolve({
	                    error: new Error('metadata was null'),
	                    status: 'failure',
	                });
	            }
	            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
	            // @ts-ignore The gRPC client constructor is created on runtime, so we don't have any types for the resulting client.
	            this._client.export(buffer, this._metadata, { deadline: deadline }, (err, response) => {
	                if (err) {
	                    resolve({
	                        status: 'failure',
	                        error: err,
	                    });
	                }
	                else {
	                    resolve({
	                        data: response,
	                        status: 'success',
	                    });
	                }
	            });
	        });
	    }
	}
	grpcExporterTransport.GrpcExporterTransport = GrpcExporterTransport;
	function createOtlpGrpcExporterTransport(options) {
	    return new GrpcExporterTransport(options);
	}
	grpcExporterTransport.createOtlpGrpcExporterTransport = createOtlpGrpcExporterTransport;
	
	return grpcExporterTransport;
}

var version = {};

var hasRequiredVersion;

function requireVersion () {
	if (hasRequiredVersion) return version;
	hasRequiredVersion = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(version, "__esModule", { value: true });
	version.VERSION = undefined;
	// this is autogenerated file, see scripts/version-update.js
	version.VERSION = '0.57.1';
	
	return version;
}

var hasRequiredOtlpGrpcConfiguration;

function requireOtlpGrpcConfiguration () {
	if (hasRequiredOtlpGrpcConfiguration) return otlpGrpcConfiguration;
	hasRequiredOtlpGrpcConfiguration = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(otlpGrpcConfiguration, "__esModule", { value: true });
	otlpGrpcConfiguration.getOtlpGrpcDefaultConfiguration = otlpGrpcConfiguration.mergeOtlpGrpcConfigurationWithDefaults = otlpGrpcConfiguration.validateAndNormalizeUrl = undefined;
	const otlp_exporter_base_1 = require$$2$1;
	const grpc_exporter_transport_1 = /*@__PURE__*/ requireGrpcExporterTransport();
	const version_1 = /*@__PURE__*/ requireVersion();
	const url_1 = require$$1$5;
	const api_1 = require$$0$2;
	function validateAndNormalizeUrl(url) {
	    var _a;
	    url = url.trim();
	    const hasProtocol = url.match(/^([\w]{1,8}):\/\//);
	    if (!hasProtocol) {
	        url = `https://${url}`;
	    }
	    const target = new url_1.URL(url);
	    if (target.protocol === 'unix:') {
	        return url;
	    }
	    if (target.pathname && target.pathname !== '/') {
	        api_1.diag.warn('URL path should not be set when using grpc, the path part of the URL will be ignored.');
	    }
	    if (target.protocol !== '' && !((_a = target.protocol) === null || _a === undefined ? undefined : _a.match(/^(http)s?:$/))) {
	        api_1.diag.warn('URL protocol should be http(s)://. Using http://.');
	    }
	    return target.host;
	}
	otlpGrpcConfiguration.validateAndNormalizeUrl = validateAndNormalizeUrl;
	function overrideMetadataEntriesIfNotPresent(metadata, additionalMetadata) {
	    for (const [key, value] of Object.entries(additionalMetadata.getMap())) {
	        // only override with env var data if the key has no values.
	        // not using Metadata.merge() as it will keep both values.
	        if (metadata.get(key).length < 1) {
	            metadata.set(key, value);
	        }
	    }
	}
	function mergeOtlpGrpcConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
	    var _a, _b, _c, _d, _e;
	    const rawUrl = (_b = (_a = userProvidedConfiguration.url) !== null && _a !== undefined ? _a : fallbackConfiguration.url) !== null && _b !== undefined ? _b : defaultConfiguration.url;
	    return Object.assign(Object.assign({}, (0, otlp_exporter_base_1.mergeOtlpSharedConfigurationWithDefaults)(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration)), { metadata: () => {
	            var _a, _b, _c, _d;
	            const metadata = defaultConfiguration.metadata();
	            overrideMetadataEntriesIfNotPresent(metadata, 
	            // clone to ensure we don't modify what the user gave us in case they hold on to the returned reference
	            (_b = (_a = userProvidedConfiguration.metadata) === null || _a === undefined ? undefined : _a.call(userProvidedConfiguration).clone()) !== null && _b !== undefined ? _b : (0, grpc_exporter_transport_1.createEmptyMetadata)());
	            overrideMetadataEntriesIfNotPresent(metadata, (_d = (_c = fallbackConfiguration.metadata) === null || _c === undefined ? undefined : _c.call(fallbackConfiguration)) !== null && _d !== undefined ? _d : (0, grpc_exporter_transport_1.createEmptyMetadata)());
	            return metadata;
	        }, url: validateAndNormalizeUrl(rawUrl), credentials: (_e = (_c = userProvidedConfiguration.credentials) !== null && _c !== undefined ? _c : (_d = fallbackConfiguration.credentials) === null || _d === undefined ? undefined : _d.call(fallbackConfiguration, rawUrl)) !== null && _e !== undefined ? _e : defaultConfiguration.credentials(rawUrl) });
	}
	otlpGrpcConfiguration.mergeOtlpGrpcConfigurationWithDefaults = mergeOtlpGrpcConfigurationWithDefaults;
	function getOtlpGrpcDefaultConfiguration() {
	    return Object.assign(Object.assign({}, (0, otlp_exporter_base_1.getSharedConfigurationDefaults)()), { metadata: () => {
	            const metadata = (0, grpc_exporter_transport_1.createEmptyMetadata)();
	            metadata.set('User-Agent', `OTel-OTLP-Exporter-JavaScript/${version_1.VERSION}`);
	            return metadata;
	        }, url: 'http://localhost:4317', credentials: (url) => {
	            if (url.startsWith('http://')) {
	                return () => (0, grpc_exporter_transport_1.createInsecureCredentials)();
	            }
	            else {
	                return () => (0, grpc_exporter_transport_1.createSslCredentials)();
	            }
	        } });
	}
	otlpGrpcConfiguration.getOtlpGrpcDefaultConfiguration = getOtlpGrpcDefaultConfiguration;
	
	return otlpGrpcConfiguration;
}

var otlpGrpcEnvConfiguration = {};

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(esm$2);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isExportRetryable(statusCode) {
    var retryCodes = [429, 502, 503, 504];
    return retryCodes.includes(statusCode);
}
function parseRetryAfterToMills(retryAfter) {
    if (retryAfter == null) {
        return undefined;
    }
    var seconds = Number.parseInt(retryAfter, 10);
    if (Number.isInteger(seconds)) {
        return seconds > 0 ? seconds * 1000 : -1;
    }
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives
    var delay = new Date(retryAfter).getTime() - Date.now();
    if (delay >= 0) {
        return delay;
    }
    return 0;
}

var __assign$4 = (undefined && undefined.__assign) || function () {
    __assign$4 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$4.apply(this, arguments);
};
/**
 * Sends data using http
 * @param params
 * @param agent
 * @param data
 * @param onDone
 * @param timeoutMillis
 */
function sendWithHttp(params, agent, data, onDone, timeoutMillis) {
    var parsedUrl = new URL(params.url);
    var nodeVersion = Number(process.versions.node.split('.')[0]);
    var options = {
        hostname: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname,
        method: 'POST',
        headers: __assign$4({}, params.headers()),
        agent: agent,
    };
    var request = parsedUrl.protocol === 'http:' ? require$$2$3.request : https.request;
    var req = request(options, function (res) {
        var responseData = [];
        res.on('data', function (chunk) { return responseData.push(chunk); });
        res.on('end', function () {
            if (res.statusCode && res.statusCode < 299) {
                onDone({
                    status: 'success',
                    data: Buffer.concat(responseData),
                });
            }
            else if (res.statusCode && isExportRetryable(res.statusCode)) {
                onDone({
                    status: 'retryable',
                    retryInMillis: parseRetryAfterToMills(res.headers['retry-after']),
                });
            }
            else {
                var error = new OTLPExporterError(res.statusMessage, res.statusCode, Buffer.concat(responseData).toString());
                onDone({
                    status: 'failure',
                    error: error,
                });
            }
        });
    });
    req.setTimeout(timeoutMillis, function () {
        req.destroy();
        onDone({
            status: 'failure',
            error: new Error('Request Timeout'),
        });
    });
    req.on('error', function (error) {
        onDone({
            status: 'failure',
            error: error,
        });
    });
    var reportTimeoutErrorEvent = nodeVersion >= 14 ? 'close' : 'abort';
    req.on(reportTimeoutErrorEvent, function () {
        onDone({
            status: 'failure',
            error: new Error('Request timed out'),
        });
    });
    compressAndSend(req, params.compression, data, function (error) {
        onDone({
            status: 'failure',
            error: error,
        });
    });
}
function compressAndSend(req, compression, data, onError) {
    var dataStream = readableFromUint8Array(data);
    if (compression === 'gzip') {
        req.setHeader('Content-Encoding', 'gzip');
        dataStream = dataStream
            .on('error', onError)
            .pipe(require$$3$2.createGzip())
            .on('error', onError);
    }
    dataStream.pipe(req).on('error', onError);
}
function readableFromUint8Array(buff) {
    var readable = new Readable();
    readable.push(buff);
    readable.push(null);
    return readable;
}
function createHttpAgent(rawUrl, agentOptions) {
    var parsedUrl = new URL(rawUrl);
    var Agent = parsedUrl.protocol === 'http:' ? require$$2$3.Agent : https.Agent;
    return new Agent(agentOptions);
}

var httpTransportUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	compressAndSend: compressAndSend,
	createHttpAgent: createHttpAgent,
	sendWithHttp: sendWithHttp
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(httpTransportUtils);

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : undefined, done: true };
    }
};
var HttpExporterTransport = /** @class */ (function () {
    function HttpExporterTransport(_parameters) {
        this._parameters = _parameters;
        this._send = null;
        this._agent = null;
    }
    HttpExporterTransport.prototype.send = function (data, timeoutMillis) {
        return __awaiter$2(this, undefined, undefined, function () {
            var _a, sendWithHttp, createHttpAgent;
            var _this = this;
            return __generator$2(this, function (_b) {
                if (this._send == null) {
                    _a = require$$0, sendWithHttp = _a.sendWithHttp, createHttpAgent = _a.createHttpAgent;
                    this._agent = createHttpAgent(this._parameters.url, this._parameters.agentOptions);
                    this._send = sendWithHttp;
                }
                return [2 /*return*/, new Promise(function (resolve) {
                        var _a;
                        // this will always be defined
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        (_a = _this._send) === null || _a === undefined ? undefined : _a.call(_this, _this._parameters, _this._agent, data, function (result) {
                            resolve(result);
                        }, timeoutMillis);
                    })];
            });
        });
    };
    HttpExporterTransport.prototype.shutdown = function () {
        // intentionally left empty, nothing to do.
    };
    return HttpExporterTransport;
}());
function createHttpExporterTransport(parameters) {
    return new HttpExporterTransport(parameters);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : undefined, done: true };
    }
};
var MAX_ATTEMPTS = 5;
var INITIAL_BACKOFF = 1000;
var MAX_BACKOFF = 5000;
var BACKOFF_MULTIPLIER = 1.5;
var JITTER = 0.2;
/**
 * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]
 */
function getJitter() {
    return Math.random() * (2 * JITTER) - JITTER;
}
var RetryingTransport = /** @class */ (function () {
    function RetryingTransport(_transport) {
        this._transport = _transport;
    }
    RetryingTransport.prototype.retry = function (data, timeoutMillis, inMillis) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                _this._transport.send(data, timeoutMillis).then(resolve, reject);
            }, inMillis);
        });
    };
    RetryingTransport.prototype.send = function (data, timeoutMillis) {
        var _a;
        return __awaiter$1(this, undefined, undefined, function () {
            var deadline, result, attempts, nextBackoff, backoff, retryInMillis, remainingTimeoutMillis;
            return __generator$1(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        deadline = Date.now() + timeoutMillis;
                        return [4 /*yield*/, this._transport.send(data, timeoutMillis)];
                    case 1:
                        result = _b.sent();
                        attempts = MAX_ATTEMPTS;
                        nextBackoff = INITIAL_BACKOFF;
                        _b.label = 2;
                    case 2:
                        if (!(result.status === 'retryable' && attempts > 0)) return [3 /*break*/, 4];
                        attempts--;
                        backoff = Math.max(Math.min(nextBackoff, MAX_BACKOFF) + getJitter(), 0);
                        nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;
                        retryInMillis = (_a = result.retryInMillis) !== null && _a !== undefined ? _a : backoff;
                        remainingTimeoutMillis = deadline - Date.now();
                        if (retryInMillis > remainingTimeoutMillis) {
                            return [2 /*return*/, result];
                        }
                        return [4 /*yield*/, this.retry(data, remainingTimeoutMillis, retryInMillis)];
                    case 3:
                        result = _b.sent();
                        return [3 /*break*/, 2];
                    case 4: return [2 /*return*/, result];
                }
            });
        });
    };
    RetryingTransport.prototype.shutdown = function () {
        return this._transport.shutdown();
    };
    return RetryingTransport;
}());
/**
 * Creates an Exporter Transport that retries on 'retryable' response.
 */
function createRetryingTransport(options) {
    return new RetryingTransport(options.transport);
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createOtlpHttpExportDelegate(options, serializer) {
    return createOtlpExportDelegate({
        transport: createRetryingTransport({
            transport: createHttpExporterTransport(options),
        }),
        serializer: serializer,
        promiseHandler: createBoundedQueueExportPromiseHandler(options),
    }, { timeout: options.timeoutMillis });
}

function parseAndValidateTimeoutFromEnv(timeoutEnvVar) {
    var _a;
    var envTimeout = (_a = process.env[timeoutEnvVar]) === null || _a === undefined ? undefined : _a.trim();
    if (envTimeout != null && envTimeout !== '') {
        var definedTimeout = Number(envTimeout);
        if (!Number.isNaN(definedTimeout) &&
            Number.isFinite(definedTimeout) &&
            definedTimeout > 0) {
            return definedTimeout;
        }
        diag.warn("Configuration: " + timeoutEnvVar + " is invalid, expected number greater than 0 (actual: " + envTimeout + ")");
    }
    return undefined;
}
function getTimeoutFromEnv(signalIdentifier) {
    var specificTimeout = parseAndValidateTimeoutFromEnv("OTEL_EXPORTER_OTLP_" + signalIdentifier + "_TIMEOUT");
    var nonSpecificTimeout = parseAndValidateTimeoutFromEnv('OTEL_EXPORTER_OTLP_TIMEOUT');
    return specificTimeout !== null && specificTimeout !== undefined ? specificTimeout : nonSpecificTimeout;
}
function parseAndValidateCompressionFromEnv(compressionEnvVar) {
    var _a;
    var compression = (_a = process.env[compressionEnvVar]) === null || _a === undefined ? undefined : _a.trim();
    if (compression === '') {
        return undefined;
    }
    if (compression == null || compression === 'none' || compression === 'gzip') {
        return compression;
    }
    diag.warn("Configuration: " + compressionEnvVar + " is invalid, expected 'none' or 'gzip' (actual: '" + compression + "')");
    return undefined;
}
function getCompressionFromEnv(signalIdentifier) {
    var specificCompression = parseAndValidateCompressionFromEnv("OTEL_EXPORTER_OTLP_" + signalIdentifier + "_COMPRESSION");
    var nonSpecificCompression = parseAndValidateCompressionFromEnv('OTEL_EXPORTER_OTLP_COMPRESSION');
    return specificCompression !== null && specificCompression !== undefined ? specificCompression : nonSpecificCompression;
}
function getSharedConfigurationFromEnvironment(signalIdentifier) {
    return {
        timeoutMillis: getTimeoutFromEnv(signalIdentifier),
        compression: getCompressionFromEnv(signalIdentifier),
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read$6 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/**
 * Parses headers from config leaving only those that have defined values
 * @param partialHeaders
 */
function validateAndNormalizeHeaders(partialHeaders) {
    return function () {
        var _a;
        var headers = {};
        Object.entries((_a = partialHeaders === null || partialHeaders === undefined ? undefined : partialHeaders()) !== null && _a !== undefined ? _a : {}).forEach(function (_a) {
            var _b = __read$6(_a, 2), key = _b[0], value = _b[1];
            if (typeof value !== 'undefined') {
                headers[key] = String(value);
            }
            else {
                diag.warn("Header \"" + key + "\" has invalid value (" + value + ") and will be ignored");
            }
        });
        return headers;
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign$3 = (undefined && undefined.__assign) || function () {
    __assign$3 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$3.apply(this, arguments);
};
function mergeHeaders(userProvidedHeaders, fallbackHeaders, defaultHeaders) {
    var requiredHeaders = __assign$3({}, defaultHeaders());
    var headers = {};
    return function () {
        // add fallback ones first
        if (fallbackHeaders != null) {
            Object.assign(headers, fallbackHeaders());
        }
        // override with user-provided ones
        if (userProvidedHeaders != null) {
            Object.assign(headers, userProvidedHeaders());
        }
        // override required ones.
        return Object.assign(headers, requiredHeaders);
    };
}
function validateUserProvidedUrl(url) {
    if (url == null) {
        return undefined;
    }
    try {
        new URL(url);
        return url;
    }
    catch (e) {
        throw new Error("Configuration: Could not parse user-provided export URL: '" + url + "'");
    }
}
/**
 * @param userProvidedConfiguration  Configuration options provided by the user in code.
 * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.
 * @param defaultConfiguration The defaults as defined by the exporter specification
 */
function mergeOtlpHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
    var _a, _b, _c, _d;
    return __assign$3(__assign$3({}, mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration)), { headers: mergeHeaders(validateAndNormalizeHeaders(userProvidedConfiguration.headers), fallbackConfiguration.headers, defaultConfiguration.headers), url: (_b = (_a = validateUserProvidedUrl(userProvidedConfiguration.url)) !== null && _a !== undefined ? _a : fallbackConfiguration.url) !== null && _b !== undefined ? _b : defaultConfiguration.url, agentOptions: (_d = (_c = userProvidedConfiguration.agentOptions) !== null && _c !== undefined ? _c : fallbackConfiguration.agentOptions) !== null && _d !== undefined ? _d : defaultConfiguration.agentOptions });
}
function getHttpConfigurationDefaults(requiredHeaders, signalResourcePath) {
    return __assign$3(__assign$3({}, getSharedConfigurationDefaults()), { headers: function () { return requiredHeaders; }, url: 'http://localhost:4318/' + signalResourcePath, agentOptions: { keepAlive: true } });
}

var __assign$2 = (undefined && undefined.__assign) || function () {
    __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};
function getStaticHeadersFromEnv(signalIdentifier) {
    var _a, _b;
    var signalSpecificRawHeaders = (_a = process.env["OTEL_EXPORTER_OTLP_" + signalIdentifier + "_HEADERS"]) === null || _a === undefined ? undefined : _a.trim();
    var nonSignalSpecificRawHeaders = (_b = process.env['OTEL_EXPORTER_OTLP_HEADERS']) === null || _b === undefined ? undefined : _b.trim();
    var signalSpecificHeaders = baggageUtils.parseKeyPairsIntoRecord(signalSpecificRawHeaders);
    var nonSignalSpecificHeaders = baggageUtils.parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders);
    if (Object.keys(signalSpecificHeaders).length === 0 &&
        Object.keys(nonSignalSpecificHeaders).length === 0) {
        return undefined;
    }
    // headers are combined instead of overwritten, with the specific headers taking precedence over
    // the non-specific ones.
    return Object.assign({}, baggageUtils.parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders), baggageUtils.parseKeyPairsIntoRecord(signalSpecificRawHeaders));
}
function appendRootPathToUrlIfNeeded(url) {
    try {
        var parsedUrl = new URL(url);
        // This will automatically append '/' if there's no root path.
        return parsedUrl.toString();
    }
    catch (_a) {
        diag.warn("Configuration: Could not parse environment-provided export URL: '" + url + "', falling back to undefined");
        return undefined;
    }
}
function appendResourcePathToUrl(url, path) {
    try {
        // just try to parse, if it fails we catch and warn.
        new URL(url);
    }
    catch (_a) {
        diag.warn("Configuration: Could not parse environment-provided export URL: '" + url + "', falling back to undefined");
        return undefined;
    }
    if (!url.endsWith('/')) {
        url = url + '/';
    }
    url += path;
    try {
        // just try to parse, if it fails we catch and warn.
        new URL(url);
    }
    catch (_b) {
        diag.warn("Configuration: Provided URL appended with '" + path + "' is not a valid URL, using 'undefined' instead of '" + url + "'");
        return undefined;
    }
    return url;
}
function getNonSpecificUrlFromEnv(signalResourcePath) {
    var _a;
    var envUrl = (_a = process.env.OTEL_EXPORTER_OTLP_ENDPOINT) === null || _a === undefined ? undefined : _a.trim();
    if (envUrl == null || envUrl === '') {
        return undefined;
    }
    return appendResourcePathToUrl(envUrl, signalResourcePath);
}
function getSpecificUrlFromEnv(signalIdentifier) {
    var _a;
    var envUrl = (_a = process.env["OTEL_EXPORTER_OTLP_" + signalIdentifier + "_ENDPOINT"]) === null || _a === undefined ? undefined : _a.trim();
    if (envUrl == null || envUrl === '') {
        return undefined;
    }
    return appendRootPathToUrlIfNeeded(envUrl);
}
/**
 * Reads and returns configuration from the environment
 *
 * @param signalIdentifier all caps part in environment variables that identifies the signal (e.g.: METRICS, TRACES, LOGS)
 * @param signalResourcePath signal resource path to append if necessary (e.g.: v1/metrics, v1/traces, v1/logs)
 */
function getHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath) {
    var _a;
    return __assign$2(__assign$2({}, getSharedConfigurationFromEnvironment(signalIdentifier)), { url: (_a = getSpecificUrlFromEnv(signalIdentifier)) !== null && _a !== undefined ? _a : getNonSpecificUrlFromEnv(signalResourcePath), headers: wrapStaticHeadersInFunction(getStaticHeadersFromEnv(signalIdentifier)) });
}

function convertLegacyAgentOptions(config) {
    // populate keepAlive for use with new settings
    if ((config === null || config === undefined ? undefined : config.keepAlive) != null) {
        if (config.httpAgentOptions != null) {
            if (config.httpAgentOptions.keepAlive == null) {
                // specific setting is not set, populate with non-specific setting.
                config.httpAgentOptions.keepAlive = config.keepAlive;
            }
            // do nothing, use specific setting otherwise
        }
        else {
            // populate specific option if AgentOptions does not exist.
            config.httpAgentOptions = {
                keepAlive: config.keepAlive,
            };
        }
    }
    return config.httpAgentOptions;
}
/**
 * @deprecated this will be removed in 2.0
 * @param config
 * @param signalIdentifier
 * @param signalResourcePath
 * @param requiredHeaders
 */
function convertLegacyHttpOptions(config, signalIdentifier, signalResourcePath, requiredHeaders) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (config.metadata) {
        diag.warn('Metadata cannot be set when using http');
    }
    return mergeOtlpHttpConfigurationWithDefaults({
        url: config.url,
        headers: wrapStaticHeadersInFunction(config.headers),
        concurrencyLimit: config.concurrencyLimit,
        timeoutMillis: config.timeoutMillis,
        compression: config.compression,
        agentOptions: convertLegacyAgentOptions(config),
    }, getHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath), getHttpConfigurationDefaults(requiredHeaders, signalResourcePath));
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var indexNodeHttp = /*#__PURE__*/Object.freeze({
	__proto__: null,
	convertLegacyHttpOptions: convertLegacyHttpOptions,
	createOtlpHttpExportDelegate: createOtlpHttpExportDelegate,
	getSharedConfigurationFromEnvironment: getSharedConfigurationFromEnvironment
});

var require$$2 = /*@__PURE__*/getAugmentedNamespace(indexNodeHttp);

var hasRequiredOtlpGrpcEnvConfiguration;

function requireOtlpGrpcEnvConfiguration () {
	if (hasRequiredOtlpGrpcEnvConfiguration) return otlpGrpcEnvConfiguration;
	hasRequiredOtlpGrpcEnvConfiguration = 1;
	Object.defineProperty(otlpGrpcEnvConfiguration, "__esModule", { value: true });
	otlpGrpcEnvConfiguration.getOtlpGrpcConfigurationFromEnv = undefined;
	const core_1 = require$$0$1;
	const grpc_exporter_transport_1 = /*@__PURE__*/ requireGrpcExporterTransport();
	const node_http_1 = require$$2;
	const fs = require$$0$5;
	const path = require$$1$6;
	const api_1 = require$$0$2;
	function fallbackIfNullishOrBlank(signalSpecific, nonSignalSpecific) {
	    if (signalSpecific != null && signalSpecific !== '') {
	        return signalSpecific;
	    }
	    if (nonSignalSpecific != null && nonSignalSpecific !== '') {
	        return nonSignalSpecific;
	    }
	    return undefined;
	}
	function getMetadataFromEnv(signalIdentifier) {
	    var _a, _b;
	    const signalSpecificRawHeaders = (_a = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_HEADERS`]) === null || _a === undefined ? undefined : _a.trim();
	    const nonSignalSpecificRawHeaders = (_b = process.env['OTEL_EXPORTER_OTLP_HEADERS']) === null || _b === undefined ? undefined : _b.trim();
	    const signalSpecificHeaders = core_1.baggageUtils.parseKeyPairsIntoRecord(signalSpecificRawHeaders);
	    const nonSignalSpecificHeaders = core_1.baggageUtils.parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders);
	    if (Object.keys(signalSpecificHeaders).length === 0 &&
	        Object.keys(nonSignalSpecificHeaders).length === 0) {
	        return undefined;
	    }
	    const mergeHeaders = Object.assign({}, nonSignalSpecificHeaders, signalSpecificHeaders);
	    const metadata = (0, grpc_exporter_transport_1.createEmptyMetadata)();
	    // for this to work, metadata MUST be empty - otherwise `Metadata#set()` will merge items.
	    for (const [key, value] of Object.entries(mergeHeaders)) {
	        metadata.set(key, value);
	    }
	    return metadata;
	}
	function getMetadataProviderFromEnv(signalIdentifier) {
	    const metadata = getMetadataFromEnv(signalIdentifier);
	    if (metadata == null) {
	        return undefined;
	    }
	    return () => metadata;
	}
	function getUrlFromEnv(signalIdentifier) {
	    // This does not change the string beyond trimming on purpose.
	    // Normally a user would just use a host and port for gRPC, but the OTLP Exporter specification requires us to
	    // use the raw provided endpoint to derive credential settings. Therefore, we only normalize right when
	    // we merge user-provided, env-provided and defaults together, and we have determined which credentials to use.
	    //
	    // Examples:
	    // - example.test:4317 -> use secure credentials from environment (or provided via code)
	    // - http://example.test:4317 -> use insecure credentials if nothing else is provided
	    // - https://example.test:4317 -> use secure credentials from environment (or provided via code)
	    var _a, _b;
	    const specificEndpoint = (_a = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_ENDPOINT`]) === null || _a === undefined ? undefined : _a.trim();
	    const nonSpecificEndpoint = (_b = process.env[`OTEL_EXPORTER_OTLP_ENDPOINT`]) === null || _b === undefined ? undefined : _b.trim();
	    return fallbackIfNullishOrBlank(specificEndpoint, nonSpecificEndpoint);
	}
	/**
	 * Determines whether the env var for insecure credentials is set to {@code true}.
	 *
	 * It will allow the following values as {@code true}
	 * - 'true'
	 * - 'true   '
	 * - '   true'
	 * - 'TrUE'
	 * - 'TRUE'
	 *
	 * It will not allow:
	 * - 'true false'
	 * - 'false true'
	 * - 'true!'
	 * - 'true,true'
	 * - '1'
	 * - ' '
	 *
	 * @param signalIdentifier
	 */
	function getInsecureSettingFromEnv(signalIdentifier) {
	    var _a, _b;
	    const signalSpecificInsecureValue = (_a = process.env[`OTEL_EXPORTER_OTLP_${signalIdentifier}_INSECURE`]) === null || _a === undefined ? undefined : _a.toLowerCase().trim();
	    const nonSignalSpecificInsecureValue = (_b = process.env[`OTEL_EXPORTER_OTLP_INSECURE`]) === null || _b === undefined ? undefined : _b.toLowerCase().trim();
	    return (fallbackIfNullishOrBlank(signalSpecificInsecureValue, nonSignalSpecificInsecureValue) === 'true');
	}
	function readFileFromEnv(signalSpecificEnvVar, nonSignalSpecificEnvVar, warningMessage) {
	    var _a, _b;
	    const signalSpecificPath = (_a = process.env[signalSpecificEnvVar]) === null || _a === undefined ? undefined : _a.trim();
	    const nonSignalSpecificPath = (_b = process.env[nonSignalSpecificEnvVar]) === null || _b === undefined ? undefined : _b.trim();
	    const filePath = fallbackIfNullishOrBlank(signalSpecificPath, nonSignalSpecificPath);
	    if (filePath != null) {
	        try {
	            return fs.readFileSync(path.resolve(process.cwd(), filePath));
	        }
	        catch (_c) {
	            api_1.diag.warn(warningMessage);
	            return undefined;
	        }
	    }
	    else {
	        return undefined;
	    }
	}
	function getClientCertificateFromEnv(signalIdentifier) {
	    return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_CERTIFICATE`, 'OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE', 'Failed to read client certificate chain file');
	}
	function getClientKeyFromEnv(signalIdentifier) {
	    return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_KEY`, 'OTEL_EXPORTER_OTLP_CLIENT_KEY', 'Failed to read client certificate private key file');
	}
	function getRootCertificateFromEnv(signalIdentifier) {
	    return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CERTIFICATE`, 'OTEL_EXPORTER_OTLP_CERTIFICATE', 'Failed to read root certificate file');
	}
	function getCredentialsFromEnvIgnoreInsecure(signalIdentifier) {
	    const clientKey = getClientKeyFromEnv(signalIdentifier);
	    const clientCertificate = getClientCertificateFromEnv(signalIdentifier);
	    const rootCertificate = getRootCertificateFromEnv(signalIdentifier);
	    // if the chain is not intact, @grpc/grpc-js will throw. This is fine when a user provides it in code, but env var
	    // config is not allowed to throw, so we add this safeguard and try to make the best of it here.
	    const clientChainIntact = clientKey != null && clientCertificate != null;
	    if (rootCertificate != null && !clientChainIntact) {
	        api_1.diag.warn('Client key and certificate must both be provided, but one was missing - attempting to create credentials from just the root certificate');
	        return (0, grpc_exporter_transport_1.createSslCredentials)(getRootCertificateFromEnv(signalIdentifier));
	    }
	    return (0, grpc_exporter_transport_1.createSslCredentials)(rootCertificate, clientKey, clientCertificate);
	}
	function getCredentialsFromEnv(signalIdentifier) {
	    if (getInsecureSettingFromEnv(signalIdentifier)) {
	        return (0, grpc_exporter_transport_1.createInsecureCredentials)();
	    }
	    return getCredentialsFromEnvIgnoreInsecure(signalIdentifier);
	}
	function getOtlpGrpcConfigurationFromEnv(signalIdentifier) {
	    return Object.assign(Object.assign({}, (0, node_http_1.getSharedConfigurationFromEnvironment)(signalIdentifier)), { metadata: getMetadataProviderFromEnv(signalIdentifier), url: getUrlFromEnv(signalIdentifier), credentials: (finalResolvedUrl) => {
	            // Always assume insecure on http:// and secure on https://, the protocol always takes precedence over the insecure setting.
	            // note: the spec does not make any exception for
	            // - "localhost:4317". If the protocol is omitted, credentials are required unless insecure is set
	            // - "unix://", as it's neither http:// nor https:// and therefore credentials are required unless insecure is set
	            if (finalResolvedUrl.startsWith('http://')) {
	                return () => {
	                    return (0, grpc_exporter_transport_1.createInsecureCredentials)();
	                };
	            }
	            else if (finalResolvedUrl.startsWith('https://')) {
	                return () => {
	                    return getCredentialsFromEnvIgnoreInsecure(signalIdentifier);
	                };
	            }
	            // defer to env settings in this case
	            return () => {
	                return getCredentialsFromEnv(signalIdentifier);
	            };
	        } });
	}
	otlpGrpcEnvConfiguration.getOtlpGrpcConfigurationFromEnv = getOtlpGrpcConfigurationFromEnv;
	
	return otlpGrpcEnvConfiguration;
}

var hasRequiredConvertLegacyOtlpGrpcOptions;

function requireConvertLegacyOtlpGrpcOptions () {
	if (hasRequiredConvertLegacyOtlpGrpcOptions) return convertLegacyOtlpGrpcOptions;
	hasRequiredConvertLegacyOtlpGrpcOptions = 1;
	Object.defineProperty(convertLegacyOtlpGrpcOptions, "__esModule", { value: true });
	convertLegacyOtlpGrpcOptions.convertLegacyOtlpGrpcOptions = undefined;
	const api_1 = require$$0$2;
	const otlp_grpc_configuration_1 = /*@__PURE__*/ requireOtlpGrpcConfiguration();
	const grpc_exporter_transport_1 = /*@__PURE__*/ requireGrpcExporterTransport();
	const otlp_grpc_env_configuration_1 = /*@__PURE__*/ requireOtlpGrpcEnvConfiguration();
	/**
	 * @deprecated
	 * @param config
	 * @param signalIdentifier
	 */
	function convertLegacyOtlpGrpcOptions$1(config, signalIdentifier) {
	    if (config.headers) {
	        api_1.diag.warn('Headers cannot be set when using grpc');
	    }
	    // keep credentials locally in case user updates the reference on the config object
	    const userProvidedCredentials = config.credentials;
	    return (0, otlp_grpc_configuration_1.mergeOtlpGrpcConfigurationWithDefaults)({
	        url: config.url,
	        metadata: () => {
	            var _a;
	            // metadata resolution strategy is merge, so we can return empty here, and it will not override the rest of the settings.
	            return (_a = config.metadata) !== null && _a !== undefined ? _a : (0, grpc_exporter_transport_1.createEmptyMetadata)();
	        },
	        compression: config.compression,
	        timeoutMillis: config.timeoutMillis,
	        concurrencyLimit: config.concurrencyLimit,
	        credentials: userProvidedCredentials != null
	            ? () => userProvidedCredentials
	            : undefined,
	    }, (0, otlp_grpc_env_configuration_1.getOtlpGrpcConfigurationFromEnv)(signalIdentifier), (0, otlp_grpc_configuration_1.getOtlpGrpcDefaultConfiguration)());
	}
	convertLegacyOtlpGrpcOptions.convertLegacyOtlpGrpcOptions = convertLegacyOtlpGrpcOptions$1;
	
	return convertLegacyOtlpGrpcOptions;
}

var otlpGrpcExportDelegate = {};

var hasRequiredOtlpGrpcExportDelegate;

function requireOtlpGrpcExportDelegate () {
	if (hasRequiredOtlpGrpcExportDelegate) return otlpGrpcExportDelegate;
	hasRequiredOtlpGrpcExportDelegate = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(otlpGrpcExportDelegate, "__esModule", { value: true });
	otlpGrpcExportDelegate.createOtlpGrpcExportDelegate = undefined;
	const otlp_exporter_base_1 = require$$2$1;
	const grpc_exporter_transport_1 = /*@__PURE__*/ requireGrpcExporterTransport();
	function createOtlpGrpcExportDelegate(options, serializer, grpcName, grpcPath) {
	    return (0, otlp_exporter_base_1.createOtlpNetworkExportDelegate)(options, serializer, (0, grpc_exporter_transport_1.createOtlpGrpcExporterTransport)({
	        address: options.url,
	        compression: options.compression,
	        credentials: options.credentials,
	        metadata: options.metadata,
	        grpcName,
	        grpcPath,
	    }));
	}
	otlpGrpcExportDelegate.createOtlpGrpcExportDelegate = createOtlpGrpcExportDelegate;
	
	return otlpGrpcExportDelegate;
}

var hasRequiredSrc$1;

function requireSrc$1 () {
	if (hasRequiredSrc$1) return src;
	hasRequiredSrc$1 = 1;
	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		Object.defineProperty(exports, "__esModule", { value: true });
		exports.createOtlpGrpcExportDelegate = exports.convertLegacyOtlpGrpcOptions = undefined;
		var convert_legacy_otlp_grpc_options_1 = /*@__PURE__*/ requireConvertLegacyOtlpGrpcOptions();
		Object.defineProperty(exports, "convertLegacyOtlpGrpcOptions", { enumerable: true, get: function () { return convert_legacy_otlp_grpc_options_1.convertLegacyOtlpGrpcOptions; } });
		var otlp_grpc_export_delegate_1 = /*@__PURE__*/ requireOtlpGrpcExportDelegate();
		Object.defineProperty(exports, "createOtlpGrpcExportDelegate", { enumerable: true, get: function () { return otlp_grpc_export_delegate_1.createOtlpGrpcExportDelegate; } });
		
	} (src));
	return src;
}

var minimal;
var hasRequiredMinimal;

function requireMinimal () {
	if (hasRequiredMinimal) return minimal;
	hasRequiredMinimal = 1;
	minimal = requireIndexMinimal();
	return minimal;
}

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

var root;
var hasRequiredRoot;

function requireRoot () {
	if (hasRequiredRoot) return root;
	hasRequiredRoot = 1;
	var $protobuf = requireMinimal();
	// Common aliases
	var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
	// Exported root namespace
	var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
	$root.opentelemetry = (function () {
	    /**
	     * Namespace opentelemetry.
	     * @exports opentelemetry
	     * @namespace
	     */
	    var opentelemetry = {};
	    opentelemetry.proto = (function () {
	        /**
	         * Namespace proto.
	         * @memberof opentelemetry
	         * @namespace
	         */
	        var proto = {};
	        proto.common = (function () {
	            /**
	             * Namespace common.
	             * @memberof opentelemetry.proto
	             * @namespace
	             */
	            var common = {};
	            common.v1 = (function () {
	                /**
	                 * Namespace v1.
	                 * @memberof opentelemetry.proto.common
	                 * @namespace
	                 */
	                var v1 = {};
	                v1.AnyValue = (function () {
	                    /**
	                     * Properties of an AnyValue.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @interface IAnyValue
	                     * @property {string|null} [stringValue] AnyValue stringValue
	                     * @property {boolean|null} [boolValue] AnyValue boolValue
	                     * @property {number|Long|null} [intValue] AnyValue intValue
	                     * @property {number|null} [doubleValue] AnyValue doubleValue
	                     * @property {opentelemetry.proto.common.v1.IArrayValue|null} [arrayValue] AnyValue arrayValue
	                     * @property {opentelemetry.proto.common.v1.IKeyValueList|null} [kvlistValue] AnyValue kvlistValue
	                     * @property {Uint8Array|null} [bytesValue] AnyValue bytesValue
	                     */
	                    /**
	                     * Constructs a new AnyValue.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @classdesc Represents an AnyValue.
	                     * @implements IAnyValue
	                     * @constructor
	                     * @param {opentelemetry.proto.common.v1.IAnyValue=} [properties] Properties to set
	                     */
	                    function AnyValue(properties) {
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * AnyValue stringValue.
	                     * @member {string|null|undefined} stringValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.stringValue = null;
	                    /**
	                     * AnyValue boolValue.
	                     * @member {boolean|null|undefined} boolValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.boolValue = null;
	                    /**
	                     * AnyValue intValue.
	                     * @member {number|Long|null|undefined} intValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.intValue = null;
	                    /**
	                     * AnyValue doubleValue.
	                     * @member {number|null|undefined} doubleValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.doubleValue = null;
	                    /**
	                     * AnyValue arrayValue.
	                     * @member {opentelemetry.proto.common.v1.IArrayValue|null|undefined} arrayValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.arrayValue = null;
	                    /**
	                     * AnyValue kvlistValue.
	                     * @member {opentelemetry.proto.common.v1.IKeyValueList|null|undefined} kvlistValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.kvlistValue = null;
	                    /**
	                     * AnyValue bytesValue.
	                     * @member {Uint8Array|null|undefined} bytesValue
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    AnyValue.prototype.bytesValue = null;
	                    // OneOf field names bound to virtual getters and setters
	                    var $oneOfFields;
	                    /**
	                     * AnyValue value.
	                     * @member {"stringValue"|"boolValue"|"intValue"|"doubleValue"|"arrayValue"|"kvlistValue"|"bytesValue"|undefined} value
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     */
	                    Object.defineProperty(AnyValue.prototype, "value", {
	                        get: $util.oneOfGetter($oneOfFields = ["stringValue", "boolValue", "intValue", "doubleValue", "arrayValue", "kvlistValue", "bytesValue"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    /**
	                     * Creates a new AnyValue instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IAnyValue=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue instance
	                     */
	                    AnyValue.create = function create(properties) {
	                        return new AnyValue(properties);
	                    };
	                    /**
	                     * Encodes the specified AnyValue message. Does not implicitly {@link opentelemetry.proto.common.v1.AnyValue.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IAnyValue} message AnyValue message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    AnyValue.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
	                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.stringValue);
	                        if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
	                            writer.uint32(/* id 2, wireType 0 =*/ 16).bool(message.boolValue);
	                        if (message.intValue != null && Object.hasOwnProperty.call(message, "intValue"))
	                            writer.uint32(/* id 3, wireType 0 =*/ 24).int64(message.intValue);
	                        if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
	                            writer.uint32(/* id 4, wireType 1 =*/ 33).double(message.doubleValue);
	                        if (message.arrayValue != null && Object.hasOwnProperty.call(message, "arrayValue"))
	                            $root.opentelemetry.proto.common.v1.ArrayValue.encode(message.arrayValue, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
	                        if (message.kvlistValue != null && Object.hasOwnProperty.call(message, "kvlistValue"))
	                            $root.opentelemetry.proto.common.v1.KeyValueList.encode(message.kvlistValue, writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
	                        if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
	                            writer.uint32(/* id 7, wireType 2 =*/ 58).bytes(message.bytesValue);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified AnyValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.AnyValue.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IAnyValue} message AnyValue message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    AnyValue.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes an AnyValue message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    AnyValue.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.AnyValue();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.stringValue = reader.string();
	                                    break;
	                                }
	                                case 2: {
	                                    message.boolValue = reader.bool();
	                                    break;
	                                }
	                                case 3: {
	                                    message.intValue = reader.int64();
	                                    break;
	                                }
	                                case 4: {
	                                    message.doubleValue = reader.double();
	                                    break;
	                                }
	                                case 5: {
	                                    message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 6: {
	                                    message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 7: {
	                                    message.bytesValue = reader.bytes();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes an AnyValue message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    AnyValue.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies an AnyValue message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    AnyValue.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        var properties = {};
	                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
	                            properties.value = 1;
	                            if (!$util.isString(message.stringValue))
	                                return "stringValue: string expected";
	                        }
	                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            if (typeof message.boolValue !== "boolean")
	                                return "boolValue: boolean expected";
	                        }
	                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
	                                return "intValue: integer|Long expected";
	                        }
	                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            if (typeof message.doubleValue !== "number")
	                                return "doubleValue: number expected";
	                        }
	                        if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            {
	                                var error = $root.opentelemetry.proto.common.v1.ArrayValue.verify(message.arrayValue);
	                                if (error)
	                                    return "arrayValue." + error;
	                            }
	                        }
	                        if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValueList.verify(message.kvlistValue);
	                                if (error)
	                                    return "kvlistValue." + error;
	                            }
	                        }
	                        if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
	                                return "bytesValue: buffer expected";
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates an AnyValue message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.common.v1.AnyValue} AnyValue
	                     */
	                    AnyValue.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.common.v1.AnyValue)
	                            return object;
	                        var message = new $root.opentelemetry.proto.common.v1.AnyValue();
	                        if (object.stringValue != null)
	                            message.stringValue = String(object.stringValue);
	                        if (object.boolValue != null)
	                            message.boolValue = Boolean(object.boolValue);
	                        if (object.intValue != null)
	                            if ($util.Long)
	                                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;
	                            else if (typeof object.intValue === "string")
	                                message.intValue = parseInt(object.intValue, 10);
	                            else if (typeof object.intValue === "number")
	                                message.intValue = object.intValue;
	                            else if (typeof object.intValue === "object")
	                                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();
	                        if (object.doubleValue != null)
	                            message.doubleValue = Number(object.doubleValue);
	                        if (object.arrayValue != null) {
	                            if (typeof object.arrayValue !== "object")
	                                throw TypeError(".opentelemetry.proto.common.v1.AnyValue.arrayValue: object expected");
	                            message.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.fromObject(object.arrayValue);
	                        }
	                        if (object.kvlistValue != null) {
	                            if (typeof object.kvlistValue !== "object")
	                                throw TypeError(".opentelemetry.proto.common.v1.AnyValue.kvlistValue: object expected");
	                            message.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.fromObject(object.kvlistValue);
	                        }
	                        if (object.bytesValue != null)
	                            if (typeof object.bytesValue === "string")
	                                $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
	                            else if (object.bytesValue.length >= 0)
	                                message.bytesValue = object.bytesValue;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from an AnyValue message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.AnyValue} message AnyValue
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    AnyValue.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
	                            object.stringValue = message.stringValue;
	                            if (options.oneofs)
	                                object.value = "stringValue";
	                        }
	                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
	                            object.boolValue = message.boolValue;
	                            if (options.oneofs)
	                                object.value = "boolValue";
	                        }
	                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
	                            if (typeof message.intValue === "number")
	                                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;
	                            else
	                                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;
	                            if (options.oneofs)
	                                object.value = "intValue";
	                        }
	                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
	                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
	                            if (options.oneofs)
	                                object.value = "doubleValue";
	                        }
	                        if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
	                            object.arrayValue = $root.opentelemetry.proto.common.v1.ArrayValue.toObject(message.arrayValue, options);
	                            if (options.oneofs)
	                                object.value = "arrayValue";
	                        }
	                        if (message.kvlistValue != null && message.hasOwnProperty("kvlistValue")) {
	                            object.kvlistValue = $root.opentelemetry.proto.common.v1.KeyValueList.toObject(message.kvlistValue, options);
	                            if (options.oneofs)
	                                object.value = "kvlistValue";
	                        }
	                        if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
	                            object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
	                            if (options.oneofs)
	                                object.value = "bytesValue";
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this AnyValue to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    AnyValue.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for AnyValue
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.common.v1.AnyValue
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    AnyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.common.v1.AnyValue";
	                    };
	                    return AnyValue;
	                })();
	                v1.ArrayValue = (function () {
	                    /**
	                     * Properties of an ArrayValue.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @interface IArrayValue
	                     * @property {Array.<opentelemetry.proto.common.v1.IAnyValue>|null} [values] ArrayValue values
	                     */
	                    /**
	                     * Constructs a new ArrayValue.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @classdesc Represents an ArrayValue.
	                     * @implements IArrayValue
	                     * @constructor
	                     * @param {opentelemetry.proto.common.v1.IArrayValue=} [properties] Properties to set
	                     */
	                    function ArrayValue(properties) {
	                        this.values = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ArrayValue values.
	                     * @member {Array.<opentelemetry.proto.common.v1.IAnyValue>} values
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @instance
	                     */
	                    ArrayValue.prototype.values = $util.emptyArray;
	                    /**
	                     * Creates a new ArrayValue instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IArrayValue=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue instance
	                     */
	                    ArrayValue.create = function create(properties) {
	                        return new ArrayValue(properties);
	                    };
	                    /**
	                     * Encodes the specified ArrayValue message. Does not implicitly {@link opentelemetry.proto.common.v1.ArrayValue.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IArrayValue} message ArrayValue message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ArrayValue.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.values != null && message.values.length)
	                            for (var i = 0; i < message.values.length; ++i)
	                                $root.opentelemetry.proto.common.v1.AnyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ArrayValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.ArrayValue.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IArrayValue} message ArrayValue message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes an ArrayValue message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ArrayValue.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.ArrayValue();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.values && message.values.length))
	                                        message.values = [];
	                                    message.values.push($root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes an ArrayValue message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ArrayValue.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies an ArrayValue message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ArrayValue.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.values != null && message.hasOwnProperty("values")) {
	                            if (!Array.isArray(message.values))
	                                return "values: array expected";
	                            for (var i = 0; i < message.values.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.values[i]);
	                                if (error)
	                                    return "values." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates an ArrayValue message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.common.v1.ArrayValue} ArrayValue
	                     */
	                    ArrayValue.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.common.v1.ArrayValue)
	                            return object;
	                        var message = new $root.opentelemetry.proto.common.v1.ArrayValue();
	                        if (object.values) {
	                            if (!Array.isArray(object.values))
	                                throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: array expected");
	                            message.values = [];
	                            for (var i = 0; i < object.values.length; ++i) {
	                                if (typeof object.values[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.common.v1.ArrayValue.values: object expected");
	                                message.values[i] = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.values[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from an ArrayValue message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.ArrayValue} message ArrayValue
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ArrayValue.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.values = [];
	                        if (message.values && message.values.length) {
	                            object.values = [];
	                            for (var j = 0; j < message.values.length; ++j)
	                                object.values[j] = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.values[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this ArrayValue to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ArrayValue.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ArrayValue
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.common.v1.ArrayValue
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ArrayValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.common.v1.ArrayValue";
	                    };
	                    return ArrayValue;
	                })();
	                v1.KeyValueList = (function () {
	                    /**
	                     * Properties of a KeyValueList.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @interface IKeyValueList
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [values] KeyValueList values
	                     */
	                    /**
	                     * Constructs a new KeyValueList.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @classdesc Represents a KeyValueList.
	                     * @implements IKeyValueList
	                     * @constructor
	                     * @param {opentelemetry.proto.common.v1.IKeyValueList=} [properties] Properties to set
	                     */
	                    function KeyValueList(properties) {
	                        this.values = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * KeyValueList values.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} values
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @instance
	                     */
	                    KeyValueList.prototype.values = $util.emptyArray;
	                    /**
	                     * Creates a new KeyValueList instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IKeyValueList=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList instance
	                     */
	                    KeyValueList.create = function create(properties) {
	                        return new KeyValueList(properties);
	                    };
	                    /**
	                     * Encodes the specified KeyValueList message. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValueList.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IKeyValueList} message KeyValueList message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    KeyValueList.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.values != null && message.values.length)
	                            for (var i = 0; i < message.values.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified KeyValueList message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValueList.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IKeyValueList} message KeyValueList message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    KeyValueList.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a KeyValueList message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    KeyValueList.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValueList();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.values && message.values.length))
	                                        message.values = [];
	                                    message.values.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a KeyValueList message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    KeyValueList.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a KeyValueList message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    KeyValueList.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.values != null && message.hasOwnProperty("values")) {
	                            if (!Array.isArray(message.values))
	                                return "values: array expected";
	                            for (var i = 0; i < message.values.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.values[i]);
	                                if (error)
	                                    return "values." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a KeyValueList message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.common.v1.KeyValueList} KeyValueList
	                     */
	                    KeyValueList.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.common.v1.KeyValueList)
	                            return object;
	                        var message = new $root.opentelemetry.proto.common.v1.KeyValueList();
	                        if (object.values) {
	                            if (!Array.isArray(object.values))
	                                throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: array expected");
	                            message.values = [];
	                            for (var i = 0; i < object.values.length; ++i) {
	                                if (typeof object.values[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.common.v1.KeyValueList.values: object expected");
	                                message.values[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.values[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a KeyValueList message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.KeyValueList} message KeyValueList
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    KeyValueList.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.values = [];
	                        if (message.values && message.values.length) {
	                            object.values = [];
	                            for (var j = 0; j < message.values.length; ++j)
	                                object.values[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.values[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this KeyValueList to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    KeyValueList.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for KeyValueList
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.common.v1.KeyValueList
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    KeyValueList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValueList";
	                    };
	                    return KeyValueList;
	                })();
	                v1.KeyValue = (function () {
	                    /**
	                     * Properties of a KeyValue.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @interface IKeyValue
	                     * @property {string|null} [key] KeyValue key
	                     * @property {opentelemetry.proto.common.v1.IAnyValue|null} [value] KeyValue value
	                     */
	                    /**
	                     * Constructs a new KeyValue.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @classdesc Represents a KeyValue.
	                     * @implements IKeyValue
	                     * @constructor
	                     * @param {opentelemetry.proto.common.v1.IKeyValue=} [properties] Properties to set
	                     */
	                    function KeyValue(properties) {
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * KeyValue key.
	                     * @member {string|null|undefined} key
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @instance
	                     */
	                    KeyValue.prototype.key = null;
	                    /**
	                     * KeyValue value.
	                     * @member {opentelemetry.proto.common.v1.IAnyValue|null|undefined} value
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @instance
	                     */
	                    KeyValue.prototype.value = null;
	                    /**
	                     * Creates a new KeyValue instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IKeyValue=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue instance
	                     */
	                    KeyValue.create = function create(properties) {
	                        return new KeyValue(properties);
	                    };
	                    /**
	                     * Encodes the specified KeyValue message. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValue.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IKeyValue} message KeyValue message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    KeyValue.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.key != null && Object.hasOwnProperty.call(message, "key"))
	                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.key);
	                        if (message.value != null && Object.hasOwnProperty.call(message, "value"))
	                            $root.opentelemetry.proto.common.v1.AnyValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified KeyValue message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.KeyValue.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IKeyValue} message KeyValue message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    KeyValue.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a KeyValue message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    KeyValue.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.KeyValue();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.key = reader.string();
	                                    break;
	                                }
	                                case 2: {
	                                    message.value = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a KeyValue message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    KeyValue.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a KeyValue message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    KeyValue.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.key != null && message.hasOwnProperty("key"))
	                            if (!$util.isString(message.key))
	                                return "key: string expected";
	                        if (message.value != null && message.hasOwnProperty("value")) {
	                            var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.value);
	                            if (error)
	                                return "value." + error;
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a KeyValue message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.common.v1.KeyValue} KeyValue
	                     */
	                    KeyValue.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.common.v1.KeyValue)
	                            return object;
	                        var message = new $root.opentelemetry.proto.common.v1.KeyValue();
	                        if (object.key != null)
	                            message.key = String(object.key);
	                        if (object.value != null) {
	                            if (typeof object.value !== "object")
	                                throw TypeError(".opentelemetry.proto.common.v1.KeyValue.value: object expected");
	                            message.value = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.value);
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a KeyValue message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.KeyValue} message KeyValue
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    KeyValue.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.defaults) {
	                            object.key = "";
	                            object.value = null;
	                        }
	                        if (message.key != null && message.hasOwnProperty("key"))
	                            object.key = message.key;
	                        if (message.value != null && message.hasOwnProperty("value"))
	                            object.value = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.value, options);
	                        return object;
	                    };
	                    /**
	                     * Converts this KeyValue to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    KeyValue.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for KeyValue
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.common.v1.KeyValue
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    KeyValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.common.v1.KeyValue";
	                    };
	                    return KeyValue;
	                })();
	                v1.InstrumentationScope = (function () {
	                    /**
	                     * Properties of an InstrumentationScope.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @interface IInstrumentationScope
	                     * @property {string|null} [name] InstrumentationScope name
	                     * @property {string|null} [version] InstrumentationScope version
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] InstrumentationScope attributes
	                     * @property {number|null} [droppedAttributesCount] InstrumentationScope droppedAttributesCount
	                     */
	                    /**
	                     * Constructs a new InstrumentationScope.
	                     * @memberof opentelemetry.proto.common.v1
	                     * @classdesc Represents an InstrumentationScope.
	                     * @implements IInstrumentationScope
	                     * @constructor
	                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope=} [properties] Properties to set
	                     */
	                    function InstrumentationScope(properties) {
	                        this.attributes = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * InstrumentationScope name.
	                     * @member {string|null|undefined} name
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @instance
	                     */
	                    InstrumentationScope.prototype.name = null;
	                    /**
	                     * InstrumentationScope version.
	                     * @member {string|null|undefined} version
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @instance
	                     */
	                    InstrumentationScope.prototype.version = null;
	                    /**
	                     * InstrumentationScope attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @instance
	                     */
	                    InstrumentationScope.prototype.attributes = $util.emptyArray;
	                    /**
	                     * InstrumentationScope droppedAttributesCount.
	                     * @member {number|null|undefined} droppedAttributesCount
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @instance
	                     */
	                    InstrumentationScope.prototype.droppedAttributesCount = null;
	                    /**
	                     * Creates a new InstrumentationScope instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope instance
	                     */
	                    InstrumentationScope.create = function create(properties) {
	                        return new InstrumentationScope(properties);
	                    };
	                    /**
	                     * Encodes the specified InstrumentationScope message. Does not implicitly {@link opentelemetry.proto.common.v1.InstrumentationScope.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope} message InstrumentationScope message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    InstrumentationScope.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
	                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
	                        if (message.version != null && Object.hasOwnProperty.call(message, "version"))
	                            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.version);
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
	                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
	                            writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.droppedAttributesCount);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified InstrumentationScope message, length delimited. Does not implicitly {@link opentelemetry.proto.common.v1.InstrumentationScope.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.IInstrumentationScope} message InstrumentationScope message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    InstrumentationScope.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes an InstrumentationScope message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    InstrumentationScope.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.name = reader.string();
	                                    break;
	                                }
	                                case 2: {
	                                    message.version = reader.string();
	                                    break;
	                                }
	                                case 3: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 4: {
	                                    message.droppedAttributesCount = reader.uint32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes an InstrumentationScope message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    InstrumentationScope.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies an InstrumentationScope message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    InstrumentationScope.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.name != null && message.hasOwnProperty("name"))
	                            if (!$util.isString(message.name))
	                                return "name: string expected";
	                        if (message.version != null && message.hasOwnProperty("version"))
	                            if (!$util.isString(message.version))
	                                return "version: string expected";
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            if (!$util.isInteger(message.droppedAttributesCount))
	                                return "droppedAttributesCount: integer expected";
	                        return null;
	                    };
	                    /**
	                     * Creates an InstrumentationScope message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.common.v1.InstrumentationScope} InstrumentationScope
	                     */
	                    InstrumentationScope.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.common.v1.InstrumentationScope)
	                            return object;
	                        var message = new $root.opentelemetry.proto.common.v1.InstrumentationScope();
	                        if (object.name != null)
	                            message.name = String(object.name);
	                        if (object.version != null)
	                            message.version = String(object.version);
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.common.v1.InstrumentationScope.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.droppedAttributesCount != null)
	                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from an InstrumentationScope message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {opentelemetry.proto.common.v1.InstrumentationScope} message InstrumentationScope
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    InstrumentationScope.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.attributes = [];
	                        if (options.defaults) {
	                            object.name = "";
	                            object.version = "";
	                            object.droppedAttributesCount = 0;
	                        }
	                        if (message.name != null && message.hasOwnProperty("name"))
	                            object.name = message.name;
	                        if (message.version != null && message.hasOwnProperty("version"))
	                            object.version = message.version;
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            object.droppedAttributesCount = message.droppedAttributesCount;
	                        return object;
	                    };
	                    /**
	                     * Converts this InstrumentationScope to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    InstrumentationScope.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for InstrumentationScope
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.common.v1.InstrumentationScope
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    InstrumentationScope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.common.v1.InstrumentationScope";
	                    };
	                    return InstrumentationScope;
	                })();
	                return v1;
	            })();
	            return common;
	        })();
	        proto.resource = (function () {
	            /**
	             * Namespace resource.
	             * @memberof opentelemetry.proto
	             * @namespace
	             */
	            var resource = {};
	            resource.v1 = (function () {
	                /**
	                 * Namespace v1.
	                 * @memberof opentelemetry.proto.resource
	                 * @namespace
	                 */
	                var v1 = {};
	                v1.Resource = (function () {
	                    /**
	                     * Properties of a Resource.
	                     * @memberof opentelemetry.proto.resource.v1
	                     * @interface IResource
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Resource attributes
	                     * @property {number|null} [droppedAttributesCount] Resource droppedAttributesCount
	                     */
	                    /**
	                     * Constructs a new Resource.
	                     * @memberof opentelemetry.proto.resource.v1
	                     * @classdesc Represents a Resource.
	                     * @implements IResource
	                     * @constructor
	                     * @param {opentelemetry.proto.resource.v1.IResource=} [properties] Properties to set
	                     */
	                    function Resource(properties) {
	                        this.attributes = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Resource attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @instance
	                     */
	                    Resource.prototype.attributes = $util.emptyArray;
	                    /**
	                     * Resource droppedAttributesCount.
	                     * @member {number|null|undefined} droppedAttributesCount
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @instance
	                     */
	                    Resource.prototype.droppedAttributesCount = null;
	                    /**
	                     * Creates a new Resource instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {opentelemetry.proto.resource.v1.IResource=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource instance
	                     */
	                    Resource.create = function create(properties) {
	                        return new Resource(properties);
	                    };
	                    /**
	                     * Encodes the specified Resource message. Does not implicitly {@link opentelemetry.proto.resource.v1.Resource.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {opentelemetry.proto.resource.v1.IResource} message Resource message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Resource.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
	                            writer.uint32(/* id 2, wireType 0 =*/ 16).uint32(message.droppedAttributesCount);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Resource message, length delimited. Does not implicitly {@link opentelemetry.proto.resource.v1.Resource.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {opentelemetry.proto.resource.v1.IResource} message Resource message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Resource.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Resource message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Resource.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.resource.v1.Resource();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.droppedAttributesCount = reader.uint32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Resource message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Resource.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Resource message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Resource.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            if (!$util.isInteger(message.droppedAttributesCount))
	                                return "droppedAttributesCount: integer expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a Resource message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.resource.v1.Resource} Resource
	                     */
	                    Resource.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.resource.v1.Resource)
	                            return object;
	                        var message = new $root.opentelemetry.proto.resource.v1.Resource();
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.resource.v1.Resource.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.droppedAttributesCount != null)
	                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Resource message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {opentelemetry.proto.resource.v1.Resource} message Resource
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Resource.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.attributes = [];
	                        if (options.defaults)
	                            object.droppedAttributesCount = 0;
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            object.droppedAttributesCount = message.droppedAttributesCount;
	                        return object;
	                    };
	                    /**
	                     * Converts this Resource to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Resource.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Resource
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.resource.v1.Resource
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Resource.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.resource.v1.Resource";
	                    };
	                    return Resource;
	                })();
	                return v1;
	            })();
	            return resource;
	        })();
	        proto.trace = (function () {
	            /**
	             * Namespace trace.
	             * @memberof opentelemetry.proto
	             * @namespace
	             */
	            var trace = {};
	            trace.v1 = (function () {
	                /**
	                 * Namespace v1.
	                 * @memberof opentelemetry.proto.trace
	                 * @namespace
	                 */
	                var v1 = {};
	                v1.TracesData = (function () {
	                    /**
	                     * Properties of a TracesData.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @interface ITracesData
	                     * @property {Array.<opentelemetry.proto.trace.v1.IResourceSpans>|null} [resourceSpans] TracesData resourceSpans
	                     */
	                    /**
	                     * Constructs a new TracesData.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @classdesc Represents a TracesData.
	                     * @implements ITracesData
	                     * @constructor
	                     * @param {opentelemetry.proto.trace.v1.ITracesData=} [properties] Properties to set
	                     */
	                    function TracesData(properties) {
	                        this.resourceSpans = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * TracesData resourceSpans.
	                     * @member {Array.<opentelemetry.proto.trace.v1.IResourceSpans>} resourceSpans
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @instance
	                     */
	                    TracesData.prototype.resourceSpans = $util.emptyArray;
	                    /**
	                     * Creates a new TracesData instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ITracesData=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData instance
	                     */
	                    TracesData.create = function create(properties) {
	                        return new TracesData(properties);
	                    };
	                    /**
	                     * Encodes the specified TracesData message. Does not implicitly {@link opentelemetry.proto.trace.v1.TracesData.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ITracesData} message TracesData message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    TracesData.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.resourceSpans != null && message.resourceSpans.length)
	                            for (var i = 0; i < message.resourceSpans.length; ++i)
	                                $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified TracesData message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.TracesData.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ITracesData} message TracesData message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    TracesData.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a TracesData message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    TracesData.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.TracesData();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.resourceSpans && message.resourceSpans.length))
	                                        message.resourceSpans = [];
	                                    message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a TracesData message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    TracesData.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a TracesData message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    TracesData.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
	                            if (!Array.isArray(message.resourceSpans))
	                                return "resourceSpans: array expected";
	                            for (var i = 0; i < message.resourceSpans.length; ++i) {
	                                var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);
	                                if (error)
	                                    return "resourceSpans." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a TracesData message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.trace.v1.TracesData} TracesData
	                     */
	                    TracesData.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.trace.v1.TracesData)
	                            return object;
	                        var message = new $root.opentelemetry.proto.trace.v1.TracesData();
	                        if (object.resourceSpans) {
	                            if (!Array.isArray(object.resourceSpans))
	                                throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: array expected");
	                            message.resourceSpans = [];
	                            for (var i = 0; i < object.resourceSpans.length; ++i) {
	                                if (typeof object.resourceSpans[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.trace.v1.TracesData.resourceSpans: object expected");
	                                message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a TracesData message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.TracesData} message TracesData
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    TracesData.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.resourceSpans = [];
	                        if (message.resourceSpans && message.resourceSpans.length) {
	                            object.resourceSpans = [];
	                            for (var j = 0; j < message.resourceSpans.length; ++j)
	                                object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this TracesData to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    TracesData.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for TracesData
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.trace.v1.TracesData
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    TracesData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.trace.v1.TracesData";
	                    };
	                    return TracesData;
	                })();
	                v1.ResourceSpans = (function () {
	                    /**
	                     * Properties of a ResourceSpans.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @interface IResourceSpans
	                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceSpans resource
	                     * @property {Array.<opentelemetry.proto.trace.v1.IScopeSpans>|null} [scopeSpans] ResourceSpans scopeSpans
	                     * @property {string|null} [schemaUrl] ResourceSpans schemaUrl
	                     */
	                    /**
	                     * Constructs a new ResourceSpans.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @classdesc Represents a ResourceSpans.
	                     * @implements IResourceSpans
	                     * @constructor
	                     * @param {opentelemetry.proto.trace.v1.IResourceSpans=} [properties] Properties to set
	                     */
	                    function ResourceSpans(properties) {
	                        this.scopeSpans = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ResourceSpans resource.
	                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @instance
	                     */
	                    ResourceSpans.prototype.resource = null;
	                    /**
	                     * ResourceSpans scopeSpans.
	                     * @member {Array.<opentelemetry.proto.trace.v1.IScopeSpans>} scopeSpans
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @instance
	                     */
	                    ResourceSpans.prototype.scopeSpans = $util.emptyArray;
	                    /**
	                     * ResourceSpans schemaUrl.
	                     * @member {string|null|undefined} schemaUrl
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @instance
	                     */
	                    ResourceSpans.prototype.schemaUrl = null;
	                    /**
	                     * Creates a new ResourceSpans instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IResourceSpans=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans instance
	                     */
	                    ResourceSpans.create = function create(properties) {
	                        return new ResourceSpans(properties);
	                    };
	                    /**
	                     * Encodes the specified ResourceSpans message. Does not implicitly {@link opentelemetry.proto.trace.v1.ResourceSpans.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IResourceSpans} message ResourceSpans message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ResourceSpans.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
	                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.scopeSpans != null && message.scopeSpans.length)
	                            for (var i = 0; i < message.scopeSpans.length; ++i)
	                                $root.opentelemetry.proto.trace.v1.ScopeSpans.encode(message.scopeSpans[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.schemaUrl);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ResourceSpans message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.ResourceSpans.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IResourceSpans} message ResourceSpans message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ResourceSpans.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a ResourceSpans message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ResourceSpans.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 2: {
	                                    if (!(message.scopeSpans && message.scopeSpans.length))
	                                        message.scopeSpans = [];
	                                    message.scopeSpans.push($root.opentelemetry.proto.trace.v1.ScopeSpans.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 3: {
	                                    message.schemaUrl = reader.string();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a ResourceSpans message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ResourceSpans.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a ResourceSpans message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ResourceSpans.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.resource != null && message.hasOwnProperty("resource")) {
	                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
	                            if (error)
	                                return "resource." + error;
	                        }
	                        if (message.scopeSpans != null && message.hasOwnProperty("scopeSpans")) {
	                            if (!Array.isArray(message.scopeSpans))
	                                return "scopeSpans: array expected";
	                            for (var i = 0; i < message.scopeSpans.length; ++i) {
	                                var error = $root.opentelemetry.proto.trace.v1.ScopeSpans.verify(message.scopeSpans[i]);
	                                if (error)
	                                    return "scopeSpans." + error;
	                            }
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            if (!$util.isString(message.schemaUrl))
	                                return "schemaUrl: string expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a ResourceSpans message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.trace.v1.ResourceSpans} ResourceSpans
	                     */
	                    ResourceSpans.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.trace.v1.ResourceSpans)
	                            return object;
	                        var message = new $root.opentelemetry.proto.trace.v1.ResourceSpans();
	                        if (object.resource != null) {
	                            if (typeof object.resource !== "object")
	                                throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.resource: object expected");
	                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
	                        }
	                        if (object.scopeSpans) {
	                            if (!Array.isArray(object.scopeSpans))
	                                throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: array expected");
	                            message.scopeSpans = [];
	                            for (var i = 0; i < object.scopeSpans.length; ++i) {
	                                if (typeof object.scopeSpans[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.trace.v1.ResourceSpans.scopeSpans: object expected");
	                                message.scopeSpans[i] = $root.opentelemetry.proto.trace.v1.ScopeSpans.fromObject(object.scopeSpans[i]);
	                            }
	                        }
	                        if (object.schemaUrl != null)
	                            message.schemaUrl = String(object.schemaUrl);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a ResourceSpans message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ResourceSpans} message ResourceSpans
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ResourceSpans.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.scopeSpans = [];
	                        if (options.defaults) {
	                            object.resource = null;
	                            object.schemaUrl = "";
	                        }
	                        if (message.resource != null && message.hasOwnProperty("resource"))
	                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
	                        if (message.scopeSpans && message.scopeSpans.length) {
	                            object.scopeSpans = [];
	                            for (var j = 0; j < message.scopeSpans.length; ++j)
	                                object.scopeSpans[j] = $root.opentelemetry.proto.trace.v1.ScopeSpans.toObject(message.scopeSpans[j], options);
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            object.schemaUrl = message.schemaUrl;
	                        return object;
	                    };
	                    /**
	                     * Converts this ResourceSpans to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ResourceSpans.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ResourceSpans
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.trace.v1.ResourceSpans
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ResourceSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.trace.v1.ResourceSpans";
	                    };
	                    return ResourceSpans;
	                })();
	                v1.ScopeSpans = (function () {
	                    /**
	                     * Properties of a ScopeSpans.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @interface IScopeSpans
	                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeSpans scope
	                     * @property {Array.<opentelemetry.proto.trace.v1.ISpan>|null} [spans] ScopeSpans spans
	                     * @property {string|null} [schemaUrl] ScopeSpans schemaUrl
	                     */
	                    /**
	                     * Constructs a new ScopeSpans.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @classdesc Represents a ScopeSpans.
	                     * @implements IScopeSpans
	                     * @constructor
	                     * @param {opentelemetry.proto.trace.v1.IScopeSpans=} [properties] Properties to set
	                     */
	                    function ScopeSpans(properties) {
	                        this.spans = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ScopeSpans scope.
	                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @instance
	                     */
	                    ScopeSpans.prototype.scope = null;
	                    /**
	                     * ScopeSpans spans.
	                     * @member {Array.<opentelemetry.proto.trace.v1.ISpan>} spans
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @instance
	                     */
	                    ScopeSpans.prototype.spans = $util.emptyArray;
	                    /**
	                     * ScopeSpans schemaUrl.
	                     * @member {string|null|undefined} schemaUrl
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @instance
	                     */
	                    ScopeSpans.prototype.schemaUrl = null;
	                    /**
	                     * Creates a new ScopeSpans instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IScopeSpans=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans instance
	                     */
	                    ScopeSpans.create = function create(properties) {
	                        return new ScopeSpans(properties);
	                    };
	                    /**
	                     * Encodes the specified ScopeSpans message. Does not implicitly {@link opentelemetry.proto.trace.v1.ScopeSpans.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IScopeSpans} message ScopeSpans message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ScopeSpans.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
	                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.spans != null && message.spans.length)
	                            for (var i = 0; i < message.spans.length; ++i)
	                                $root.opentelemetry.proto.trace.v1.Span.encode(message.spans[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.schemaUrl);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ScopeSpans message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.ScopeSpans.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IScopeSpans} message ScopeSpans message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ScopeSpans.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a ScopeSpans message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ScopeSpans.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 2: {
	                                    if (!(message.spans && message.spans.length))
	                                        message.spans = [];
	                                    message.spans.push($root.opentelemetry.proto.trace.v1.Span.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 3: {
	                                    message.schemaUrl = reader.string();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a ScopeSpans message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ScopeSpans.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a ScopeSpans message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ScopeSpans.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.scope != null && message.hasOwnProperty("scope")) {
	                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
	                            if (error)
	                                return "scope." + error;
	                        }
	                        if (message.spans != null && message.hasOwnProperty("spans")) {
	                            if (!Array.isArray(message.spans))
	                                return "spans: array expected";
	                            for (var i = 0; i < message.spans.length; ++i) {
	                                var error = $root.opentelemetry.proto.trace.v1.Span.verify(message.spans[i]);
	                                if (error)
	                                    return "spans." + error;
	                            }
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            if (!$util.isString(message.schemaUrl))
	                                return "schemaUrl: string expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a ScopeSpans message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.trace.v1.ScopeSpans} ScopeSpans
	                     */
	                    ScopeSpans.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.trace.v1.ScopeSpans)
	                            return object;
	                        var message = new $root.opentelemetry.proto.trace.v1.ScopeSpans();
	                        if (object.scope != null) {
	                            if (typeof object.scope !== "object")
	                                throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.scope: object expected");
	                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
	                        }
	                        if (object.spans) {
	                            if (!Array.isArray(object.spans))
	                                throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: array expected");
	                            message.spans = [];
	                            for (var i = 0; i < object.spans.length; ++i) {
	                                if (typeof object.spans[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.trace.v1.ScopeSpans.spans: object expected");
	                                message.spans[i] = $root.opentelemetry.proto.trace.v1.Span.fromObject(object.spans[i]);
	                            }
	                        }
	                        if (object.schemaUrl != null)
	                            message.schemaUrl = String(object.schemaUrl);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a ScopeSpans message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ScopeSpans} message ScopeSpans
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ScopeSpans.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.spans = [];
	                        if (options.defaults) {
	                            object.scope = null;
	                            object.schemaUrl = "";
	                        }
	                        if (message.scope != null && message.hasOwnProperty("scope"))
	                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
	                        if (message.spans && message.spans.length) {
	                            object.spans = [];
	                            for (var j = 0; j < message.spans.length; ++j)
	                                object.spans[j] = $root.opentelemetry.proto.trace.v1.Span.toObject(message.spans[j], options);
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            object.schemaUrl = message.schemaUrl;
	                        return object;
	                    };
	                    /**
	                     * Converts this ScopeSpans to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ScopeSpans.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ScopeSpans
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.trace.v1.ScopeSpans
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ScopeSpans.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.trace.v1.ScopeSpans";
	                    };
	                    return ScopeSpans;
	                })();
	                v1.Span = (function () {
	                    /**
	                     * Properties of a Span.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @interface ISpan
	                     * @property {Uint8Array|null} [traceId] Span traceId
	                     * @property {Uint8Array|null} [spanId] Span spanId
	                     * @property {string|null} [traceState] Span traceState
	                     * @property {Uint8Array|null} [parentSpanId] Span parentSpanId
	                     * @property {string|null} [name] Span name
	                     * @property {opentelemetry.proto.trace.v1.Span.SpanKind|null} [kind] Span kind
	                     * @property {number|Long|null} [startTimeUnixNano] Span startTimeUnixNano
	                     * @property {number|Long|null} [endTimeUnixNano] Span endTimeUnixNano
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Span attributes
	                     * @property {number|null} [droppedAttributesCount] Span droppedAttributesCount
	                     * @property {Array.<opentelemetry.proto.trace.v1.Span.IEvent>|null} [events] Span events
	                     * @property {number|null} [droppedEventsCount] Span droppedEventsCount
	                     * @property {Array.<opentelemetry.proto.trace.v1.Span.ILink>|null} [links] Span links
	                     * @property {number|null} [droppedLinksCount] Span droppedLinksCount
	                     * @property {opentelemetry.proto.trace.v1.IStatus|null} [status] Span status
	                     */
	                    /**
	                     * Constructs a new Span.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @classdesc Represents a Span.
	                     * @implements ISpan
	                     * @constructor
	                     * @param {opentelemetry.proto.trace.v1.ISpan=} [properties] Properties to set
	                     */
	                    function Span(properties) {
	                        this.attributes = [];
	                        this.events = [];
	                        this.links = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Span traceId.
	                     * @member {Uint8Array|null|undefined} traceId
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.traceId = null;
	                    /**
	                     * Span spanId.
	                     * @member {Uint8Array|null|undefined} spanId
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.spanId = null;
	                    /**
	                     * Span traceState.
	                     * @member {string|null|undefined} traceState
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.traceState = null;
	                    /**
	                     * Span parentSpanId.
	                     * @member {Uint8Array|null|undefined} parentSpanId
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.parentSpanId = null;
	                    /**
	                     * Span name.
	                     * @member {string|null|undefined} name
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.name = null;
	                    /**
	                     * Span kind.
	                     * @member {opentelemetry.proto.trace.v1.Span.SpanKind|null|undefined} kind
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.kind = null;
	                    /**
	                     * Span startTimeUnixNano.
	                     * @member {number|Long|null|undefined} startTimeUnixNano
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.startTimeUnixNano = null;
	                    /**
	                     * Span endTimeUnixNano.
	                     * @member {number|Long|null|undefined} endTimeUnixNano
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.endTimeUnixNano = null;
	                    /**
	                     * Span attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.attributes = $util.emptyArray;
	                    /**
	                     * Span droppedAttributesCount.
	                     * @member {number|null|undefined} droppedAttributesCount
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.droppedAttributesCount = null;
	                    /**
	                     * Span events.
	                     * @member {Array.<opentelemetry.proto.trace.v1.Span.IEvent>} events
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.events = $util.emptyArray;
	                    /**
	                     * Span droppedEventsCount.
	                     * @member {number|null|undefined} droppedEventsCount
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.droppedEventsCount = null;
	                    /**
	                     * Span links.
	                     * @member {Array.<opentelemetry.proto.trace.v1.Span.ILink>} links
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.links = $util.emptyArray;
	                    /**
	                     * Span droppedLinksCount.
	                     * @member {number|null|undefined} droppedLinksCount
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.droppedLinksCount = null;
	                    /**
	                     * Span status.
	                     * @member {opentelemetry.proto.trace.v1.IStatus|null|undefined} status
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     */
	                    Span.prototype.status = null;
	                    /**
	                     * Creates a new Span instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ISpan=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.trace.v1.Span} Span instance
	                     */
	                    Span.create = function create(properties) {
	                        return new Span(properties);
	                    };
	                    /**
	                     * Encodes the specified Span message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ISpan} message Span message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Span.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
	                            writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.traceId);
	                        if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
	                            writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.spanId);
	                        if (message.traceState != null && Object.hasOwnProperty.call(message, "traceState"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.traceState);
	                        if (message.parentSpanId != null && Object.hasOwnProperty.call(message, "parentSpanId"))
	                            writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.parentSpanId);
	                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
	                            writer.uint32(/* id 5, wireType 2 =*/ 42).string(message.name);
	                        if (message.kind != null && Object.hasOwnProperty.call(message, "kind"))
	                            writer.uint32(/* id 6, wireType 0 =*/ 48).int32(message.kind);
	                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
	                            writer.uint32(/* id 7, wireType 1 =*/ 57).fixed64(message.startTimeUnixNano);
	                        if (message.endTimeUnixNano != null && Object.hasOwnProperty.call(message, "endTimeUnixNano"))
	                            writer.uint32(/* id 8, wireType 1 =*/ 65).fixed64(message.endTimeUnixNano);
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
	                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
	                            writer.uint32(/* id 10, wireType 0 =*/ 80).uint32(message.droppedAttributesCount);
	                        if (message.events != null && message.events.length)
	                            for (var i = 0; i < message.events.length; ++i)
	                                $root.opentelemetry.proto.trace.v1.Span.Event.encode(message.events[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
	                        if (message.droppedEventsCount != null && Object.hasOwnProperty.call(message, "droppedEventsCount"))
	                            writer.uint32(/* id 12, wireType 0 =*/ 96).uint32(message.droppedEventsCount);
	                        if (message.links != null && message.links.length)
	                            for (var i = 0; i < message.links.length; ++i)
	                                $root.opentelemetry.proto.trace.v1.Span.Link.encode(message.links[i], writer.uint32(/* id 13, wireType 2 =*/ 106).fork()).ldelim();
	                        if (message.droppedLinksCount != null && Object.hasOwnProperty.call(message, "droppedLinksCount"))
	                            writer.uint32(/* id 14, wireType 0 =*/ 112).uint32(message.droppedLinksCount);
	                        if (message.status != null && Object.hasOwnProperty.call(message, "status"))
	                            $root.opentelemetry.proto.trace.v1.Status.encode(message.status, writer.uint32(/* id 15, wireType 2 =*/ 122).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Span message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.ISpan} message Span message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Span.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Span message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.trace.v1.Span} Span
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Span.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.traceId = reader.bytes();
	                                    break;
	                                }
	                                case 2: {
	                                    message.spanId = reader.bytes();
	                                    break;
	                                }
	                                case 3: {
	                                    message.traceState = reader.string();
	                                    break;
	                                }
	                                case 4: {
	                                    message.parentSpanId = reader.bytes();
	                                    break;
	                                }
	                                case 5: {
	                                    message.name = reader.string();
	                                    break;
	                                }
	                                case 6: {
	                                    message.kind = reader.int32();
	                                    break;
	                                }
	                                case 7: {
	                                    message.startTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 8: {
	                                    message.endTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 9: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 10: {
	                                    message.droppedAttributesCount = reader.uint32();
	                                    break;
	                                }
	                                case 11: {
	                                    if (!(message.events && message.events.length))
	                                        message.events = [];
	                                    message.events.push($root.opentelemetry.proto.trace.v1.Span.Event.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 12: {
	                                    message.droppedEventsCount = reader.uint32();
	                                    break;
	                                }
	                                case 13: {
	                                    if (!(message.links && message.links.length))
	                                        message.links = [];
	                                    message.links.push($root.opentelemetry.proto.trace.v1.Span.Link.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 14: {
	                                    message.droppedLinksCount = reader.uint32();
	                                    break;
	                                }
	                                case 15: {
	                                    message.status = $root.opentelemetry.proto.trace.v1.Status.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Span message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.trace.v1.Span} Span
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Span.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Span message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Span.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.traceId != null && message.hasOwnProperty("traceId"))
	                            if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
	                                return "traceId: buffer expected";
	                        if (message.spanId != null && message.hasOwnProperty("spanId"))
	                            if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
	                                return "spanId: buffer expected";
	                        if (message.traceState != null && message.hasOwnProperty("traceState"))
	                            if (!$util.isString(message.traceState))
	                                return "traceState: string expected";
	                        if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId"))
	                            if (!(message.parentSpanId && typeof message.parentSpanId.length === "number" || $util.isString(message.parentSpanId)))
	                                return "parentSpanId: buffer expected";
	                        if (message.name != null && message.hasOwnProperty("name"))
	                            if (!$util.isString(message.name))
	                                return "name: string expected";
	                        if (message.kind != null && message.hasOwnProperty("kind"))
	                            switch (message.kind) {
	                                default:
	                                    return "kind: enum value expected";
	                                case 0:
	                                case 1:
	                                case 2:
	                                case 3:
	                                case 4:
	                                case 5:
	                                    break;
	                            }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
	                                return "startTimeUnixNano: integer|Long expected";
	                        if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano"))
	                            if (!$util.isInteger(message.endTimeUnixNano) && !(message.endTimeUnixNano && $util.isInteger(message.endTimeUnixNano.low) && $util.isInteger(message.endTimeUnixNano.high)))
	                                return "endTimeUnixNano: integer|Long expected";
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            if (!$util.isInteger(message.droppedAttributesCount))
	                                return "droppedAttributesCount: integer expected";
	                        if (message.events != null && message.hasOwnProperty("events")) {
	                            if (!Array.isArray(message.events))
	                                return "events: array expected";
	                            for (var i = 0; i < message.events.length; ++i) {
	                                var error = $root.opentelemetry.proto.trace.v1.Span.Event.verify(message.events[i]);
	                                if (error)
	                                    return "events." + error;
	                            }
	                        }
	                        if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount"))
	                            if (!$util.isInteger(message.droppedEventsCount))
	                                return "droppedEventsCount: integer expected";
	                        if (message.links != null && message.hasOwnProperty("links")) {
	                            if (!Array.isArray(message.links))
	                                return "links: array expected";
	                            for (var i = 0; i < message.links.length; ++i) {
	                                var error = $root.opentelemetry.proto.trace.v1.Span.Link.verify(message.links[i]);
	                                if (error)
	                                    return "links." + error;
	                            }
	                        }
	                        if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount"))
	                            if (!$util.isInteger(message.droppedLinksCount))
	                                return "droppedLinksCount: integer expected";
	                        if (message.status != null && message.hasOwnProperty("status")) {
	                            var error = $root.opentelemetry.proto.trace.v1.Status.verify(message.status);
	                            if (error)
	                                return "status." + error;
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a Span message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.trace.v1.Span} Span
	                     */
	                    Span.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.trace.v1.Span)
	                            return object;
	                        var message = new $root.opentelemetry.proto.trace.v1.Span();
	                        if (object.traceId != null)
	                            if (typeof object.traceId === "string")
	                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
	                            else if (object.traceId.length >= 0)
	                                message.traceId = object.traceId;
	                        if (object.spanId != null)
	                            if (typeof object.spanId === "string")
	                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
	                            else if (object.spanId.length >= 0)
	                                message.spanId = object.spanId;
	                        if (object.traceState != null)
	                            message.traceState = String(object.traceState);
	                        if (object.parentSpanId != null)
	                            if (typeof object.parentSpanId === "string")
	                                $util.base64.decode(object.parentSpanId, message.parentSpanId = $util.newBuffer($util.base64.length(object.parentSpanId)), 0);
	                            else if (object.parentSpanId.length >= 0)
	                                message.parentSpanId = object.parentSpanId;
	                        if (object.name != null)
	                            message.name = String(object.name);
	                        switch (object.kind) {
	                            default:
	                                if (typeof object.kind === "number") {
	                                    message.kind = object.kind;
	                                    break;
	                                }
	                                break;
	                            case "SPAN_KIND_UNSPECIFIED":
	                            case 0:
	                                message.kind = 0;
	                                break;
	                            case "SPAN_KIND_INTERNAL":
	                            case 1:
	                                message.kind = 1;
	                                break;
	                            case "SPAN_KIND_SERVER":
	                            case 2:
	                                message.kind = 2;
	                                break;
	                            case "SPAN_KIND_CLIENT":
	                            case 3:
	                                message.kind = 3;
	                                break;
	                            case "SPAN_KIND_PRODUCER":
	                            case 4:
	                                message.kind = 4;
	                                break;
	                            case "SPAN_KIND_CONSUMER":
	                            case 5:
	                                message.kind = 5;
	                                break;
	                        }
	                        if (object.startTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
	                            else if (typeof object.startTimeUnixNano === "string")
	                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
	                            else if (typeof object.startTimeUnixNano === "number")
	                                message.startTimeUnixNano = object.startTimeUnixNano;
	                            else if (typeof object.startTimeUnixNano === "object")
	                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
	                        if (object.endTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.endTimeUnixNano = $util.Long.fromValue(object.endTimeUnixNano)).unsigned = false;
	                            else if (typeof object.endTimeUnixNano === "string")
	                                message.endTimeUnixNano = parseInt(object.endTimeUnixNano, 10);
	                            else if (typeof object.endTimeUnixNano === "number")
	                                message.endTimeUnixNano = object.endTimeUnixNano;
	                            else if (typeof object.endTimeUnixNano === "object")
	                                message.endTimeUnixNano = new $util.LongBits(object.endTimeUnixNano.low >>> 0, object.endTimeUnixNano.high >>> 0).toNumber();
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.trace.v1.Span.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.droppedAttributesCount != null)
	                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
	                        if (object.events) {
	                            if (!Array.isArray(object.events))
	                                throw TypeError(".opentelemetry.proto.trace.v1.Span.events: array expected");
	                            message.events = [];
	                            for (var i = 0; i < object.events.length; ++i) {
	                                if (typeof object.events[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.trace.v1.Span.events: object expected");
	                                message.events[i] = $root.opentelemetry.proto.trace.v1.Span.Event.fromObject(object.events[i]);
	                            }
	                        }
	                        if (object.droppedEventsCount != null)
	                            message.droppedEventsCount = object.droppedEventsCount >>> 0;
	                        if (object.links) {
	                            if (!Array.isArray(object.links))
	                                throw TypeError(".opentelemetry.proto.trace.v1.Span.links: array expected");
	                            message.links = [];
	                            for (var i = 0; i < object.links.length; ++i) {
	                                if (typeof object.links[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.trace.v1.Span.links: object expected");
	                                message.links[i] = $root.opentelemetry.proto.trace.v1.Span.Link.fromObject(object.links[i]);
	                            }
	                        }
	                        if (object.droppedLinksCount != null)
	                            message.droppedLinksCount = object.droppedLinksCount >>> 0;
	                        if (object.status != null) {
	                            if (typeof object.status !== "object")
	                                throw TypeError(".opentelemetry.proto.trace.v1.Span.status: object expected");
	                            message.status = $root.opentelemetry.proto.trace.v1.Status.fromObject(object.status);
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Span message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.Span} message Span
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Span.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults) {
	                            object.attributes = [];
	                            object.events = [];
	                            object.links = [];
	                        }
	                        if (options.defaults) {
	                            if (options.bytes === String)
	                                object.traceId = "";
	                            else {
	                                object.traceId = [];
	                                if (options.bytes !== Array)
	                                    object.traceId = $util.newBuffer(object.traceId);
	                            }
	                            if (options.bytes === String)
	                                object.spanId = "";
	                            else {
	                                object.spanId = [];
	                                if (options.bytes !== Array)
	                                    object.spanId = $util.newBuffer(object.spanId);
	                            }
	                            object.traceState = "";
	                            if (options.bytes === String)
	                                object.parentSpanId = "";
	                            else {
	                                object.parentSpanId = [];
	                                if (options.bytes !== Array)
	                                    object.parentSpanId = $util.newBuffer(object.parentSpanId);
	                            }
	                            object.name = "";
	                            object.kind = options.enums === String ? "SPAN_KIND_UNSPECIFIED" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.startTimeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.endTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.endTimeUnixNano = options.longs === String ? "0" : 0;
	                            object.droppedAttributesCount = 0;
	                            object.droppedEventsCount = 0;
	                            object.droppedLinksCount = 0;
	                            object.status = null;
	                        }
	                        if (message.traceId != null && message.hasOwnProperty("traceId"))
	                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
	                        if (message.spanId != null && message.hasOwnProperty("spanId"))
	                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
	                        if (message.traceState != null && message.hasOwnProperty("traceState"))
	                            object.traceState = message.traceState;
	                        if (message.parentSpanId != null && message.hasOwnProperty("parentSpanId"))
	                            object.parentSpanId = options.bytes === String ? $util.base64.encode(message.parentSpanId, 0, message.parentSpanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentSpanId) : message.parentSpanId;
	                        if (message.name != null && message.hasOwnProperty("name"))
	                            object.name = message.name;
	                        if (message.kind != null && message.hasOwnProperty("kind"))
	                            object.kind = options.enums === String ? $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] === undefined ? message.kind : $root.opentelemetry.proto.trace.v1.Span.SpanKind[message.kind] : message.kind;
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (typeof message.startTimeUnixNano === "number")
	                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
	                            else
	                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
	                        if (message.endTimeUnixNano != null && message.hasOwnProperty("endTimeUnixNano"))
	                            if (typeof message.endTimeUnixNano === "number")
	                                object.endTimeUnixNano = options.longs === String ? String(message.endTimeUnixNano) : message.endTimeUnixNano;
	                            else
	                                object.endTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.endTimeUnixNano.low >>> 0, message.endTimeUnixNano.high >>> 0).toNumber() : message.endTimeUnixNano;
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            object.droppedAttributesCount = message.droppedAttributesCount;
	                        if (message.events && message.events.length) {
	                            object.events = [];
	                            for (var j = 0; j < message.events.length; ++j)
	                                object.events[j] = $root.opentelemetry.proto.trace.v1.Span.Event.toObject(message.events[j], options);
	                        }
	                        if (message.droppedEventsCount != null && message.hasOwnProperty("droppedEventsCount"))
	                            object.droppedEventsCount = message.droppedEventsCount;
	                        if (message.links && message.links.length) {
	                            object.links = [];
	                            for (var j = 0; j < message.links.length; ++j)
	                                object.links[j] = $root.opentelemetry.proto.trace.v1.Span.Link.toObject(message.links[j], options);
	                        }
	                        if (message.droppedLinksCount != null && message.hasOwnProperty("droppedLinksCount"))
	                            object.droppedLinksCount = message.droppedLinksCount;
	                        if (message.status != null && message.hasOwnProperty("status"))
	                            object.status = $root.opentelemetry.proto.trace.v1.Status.toObject(message.status, options);
	                        return object;
	                    };
	                    /**
	                     * Converts this Span to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Span.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Span
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.trace.v1.Span
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Span.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span";
	                    };
	                    /**
	                     * SpanKind enum.
	                     * @name opentelemetry.proto.trace.v1.Span.SpanKind
	                     * @enum {number}
	                     * @property {number} SPAN_KIND_UNSPECIFIED=0 SPAN_KIND_UNSPECIFIED value
	                     * @property {number} SPAN_KIND_INTERNAL=1 SPAN_KIND_INTERNAL value
	                     * @property {number} SPAN_KIND_SERVER=2 SPAN_KIND_SERVER value
	                     * @property {number} SPAN_KIND_CLIENT=3 SPAN_KIND_CLIENT value
	                     * @property {number} SPAN_KIND_PRODUCER=4 SPAN_KIND_PRODUCER value
	                     * @property {number} SPAN_KIND_CONSUMER=5 SPAN_KIND_CONSUMER value
	                     */
	                    Span.SpanKind = (function () {
	                        var valuesById = {}, values = Object.create(valuesById);
	                        values[valuesById[0] = "SPAN_KIND_UNSPECIFIED"] = 0;
	                        values[valuesById[1] = "SPAN_KIND_INTERNAL"] = 1;
	                        values[valuesById[2] = "SPAN_KIND_SERVER"] = 2;
	                        values[valuesById[3] = "SPAN_KIND_CLIENT"] = 3;
	                        values[valuesById[4] = "SPAN_KIND_PRODUCER"] = 4;
	                        values[valuesById[5] = "SPAN_KIND_CONSUMER"] = 5;
	                        return values;
	                    })();
	                    Span.Event = (function () {
	                        /**
	                         * Properties of an Event.
	                         * @memberof opentelemetry.proto.trace.v1.Span
	                         * @interface IEvent
	                         * @property {number|Long|null} [timeUnixNano] Event timeUnixNano
	                         * @property {string|null} [name] Event name
	                         * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Event attributes
	                         * @property {number|null} [droppedAttributesCount] Event droppedAttributesCount
	                         */
	                        /**
	                         * Constructs a new Event.
	                         * @memberof opentelemetry.proto.trace.v1.Span
	                         * @classdesc Represents an Event.
	                         * @implements IEvent
	                         * @constructor
	                         * @param {opentelemetry.proto.trace.v1.Span.IEvent=} [properties] Properties to set
	                         */
	                        function Event(properties) {
	                            this.attributes = [];
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * Event timeUnixNano.
	                         * @member {number|Long|null|undefined} timeUnixNano
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @instance
	                         */
	                        Event.prototype.timeUnixNano = null;
	                        /**
	                         * Event name.
	                         * @member {string|null|undefined} name
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @instance
	                         */
	                        Event.prototype.name = null;
	                        /**
	                         * Event attributes.
	                         * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @instance
	                         */
	                        Event.prototype.attributes = $util.emptyArray;
	                        /**
	                         * Event droppedAttributesCount.
	                         * @member {number|null|undefined} droppedAttributesCount
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @instance
	                         */
	                        Event.prototype.droppedAttributesCount = null;
	                        /**
	                         * Creates a new Event instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.IEvent=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event instance
	                         */
	                        Event.create = function create(properties) {
	                            return new Event(properties);
	                        };
	                        /**
	                         * Encodes the specified Event message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Event.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.IEvent} message Event message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        Event.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                                writer.uint32(/* id 1, wireType 1 =*/ 9).fixed64(message.timeUnixNano);
	                            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
	                                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.name);
	                            if (message.attributes != null && message.attributes.length)
	                                for (var i = 0; i < message.attributes.length; ++i)
	                                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();
	                            if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
	                                writer.uint32(/* id 4, wireType 0 =*/ 32).uint32(message.droppedAttributesCount);
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified Event message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Event.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.IEvent} message Event message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        Event.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an Event message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        Event.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Event();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.timeUnixNano = reader.fixed64();
	                                        break;
	                                    }
	                                    case 2: {
	                                        message.name = reader.string();
	                                        break;
	                                    }
	                                    case 3: {
	                                        if (!(message.attributes && message.attributes.length))
	                                            message.attributes = [];
	                                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                        break;
	                                    }
	                                    case 4: {
	                                        message.droppedAttributesCount = reader.uint32();
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an Event message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        Event.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an Event message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        Event.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                                if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                    return "timeUnixNano: integer|Long expected";
	                            if (message.name != null && message.hasOwnProperty("name"))
	                                if (!$util.isString(message.name))
	                                    return "name: string expected";
	                            if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                                if (!Array.isArray(message.attributes))
	                                    return "attributes: array expected";
	                                for (var i = 0; i < message.attributes.length; ++i) {
	                                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                    if (error)
	                                        return "attributes." + error;
	                                }
	                            }
	                            if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                                if (!$util.isInteger(message.droppedAttributesCount))
	                                    return "droppedAttributesCount: integer expected";
	                            return null;
	                        };
	                        /**
	                         * Creates an Event message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.trace.v1.Span.Event} Event
	                         */
	                        Event.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Event)
	                                return object;
	                            var message = new $root.opentelemetry.proto.trace.v1.Span.Event();
	                            if (object.timeUnixNano != null)
	                                if ($util.Long)
	                                    (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                                else if (typeof object.timeUnixNano === "string")
	                                    message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                                else if (typeof object.timeUnixNano === "number")
	                                    message.timeUnixNano = object.timeUnixNano;
	                                else if (typeof object.timeUnixNano === "object")
	                                    message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                            if (object.name != null)
	                                message.name = String(object.name);
	                            if (object.attributes) {
	                                if (!Array.isArray(object.attributes))
	                                    throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: array expected");
	                                message.attributes = [];
	                                for (var i = 0; i < object.attributes.length; ++i) {
	                                    if (typeof object.attributes[i] !== "object")
	                                        throw TypeError(".opentelemetry.proto.trace.v1.Span.Event.attributes: object expected");
	                                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                                }
	                            }
	                            if (object.droppedAttributesCount != null)
	                                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an Event message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.Event} message Event
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        Event.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.arrays || options.defaults)
	                                object.attributes = [];
	                            if (options.defaults) {
	                                if ($util.Long) {
	                                    var long = new $util.Long(0, 0, false);
	                                    object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                                }
	                                else
	                                    object.timeUnixNano = options.longs === String ? "0" : 0;
	                                object.name = "";
	                                object.droppedAttributesCount = 0;
	                            }
	                            if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                                if (typeof message.timeUnixNano === "number")
	                                    object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                                else
	                                    object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                            if (message.name != null && message.hasOwnProperty("name"))
	                                object.name = message.name;
	                            if (message.attributes && message.attributes.length) {
	                                object.attributes = [];
	                                for (var j = 0; j < message.attributes.length; ++j)
	                                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                            }
	                            if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                                object.droppedAttributesCount = message.droppedAttributesCount;
	                            return object;
	                        };
	                        /**
	                         * Converts this Event to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        Event.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for Event
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.trace.v1.Span.Event
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        Event.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Event";
	                        };
	                        return Event;
	                    })();
	                    Span.Link = (function () {
	                        /**
	                         * Properties of a Link.
	                         * @memberof opentelemetry.proto.trace.v1.Span
	                         * @interface ILink
	                         * @property {Uint8Array|null} [traceId] Link traceId
	                         * @property {Uint8Array|null} [spanId] Link spanId
	                         * @property {string|null} [traceState] Link traceState
	                         * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] Link attributes
	                         * @property {number|null} [droppedAttributesCount] Link droppedAttributesCount
	                         */
	                        /**
	                         * Constructs a new Link.
	                         * @memberof opentelemetry.proto.trace.v1.Span
	                         * @classdesc Represents a Link.
	                         * @implements ILink
	                         * @constructor
	                         * @param {opentelemetry.proto.trace.v1.Span.ILink=} [properties] Properties to set
	                         */
	                        function Link(properties) {
	                            this.attributes = [];
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * Link traceId.
	                         * @member {Uint8Array|null|undefined} traceId
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @instance
	                         */
	                        Link.prototype.traceId = null;
	                        /**
	                         * Link spanId.
	                         * @member {Uint8Array|null|undefined} spanId
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @instance
	                         */
	                        Link.prototype.spanId = null;
	                        /**
	                         * Link traceState.
	                         * @member {string|null|undefined} traceState
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @instance
	                         */
	                        Link.prototype.traceState = null;
	                        /**
	                         * Link attributes.
	                         * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @instance
	                         */
	                        Link.prototype.attributes = $util.emptyArray;
	                        /**
	                         * Link droppedAttributesCount.
	                         * @member {number|null|undefined} droppedAttributesCount
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @instance
	                         */
	                        Link.prototype.droppedAttributesCount = null;
	                        /**
	                         * Creates a new Link instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.ILink=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link instance
	                         */
	                        Link.create = function create(properties) {
	                            return new Link(properties);
	                        };
	                        /**
	                         * Encodes the specified Link message. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Link.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.ILink} message Link message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        Link.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
	                                writer.uint32(/* id 1, wireType 2 =*/ 10).bytes(message.traceId);
	                            if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
	                                writer.uint32(/* id 2, wireType 2 =*/ 18).bytes(message.spanId);
	                            if (message.traceState != null && Object.hasOwnProperty.call(message, "traceState"))
	                                writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.traceState);
	                            if (message.attributes != null && message.attributes.length)
	                                for (var i = 0; i < message.attributes.length; ++i)
	                                    $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 4, wireType 2 =*/ 34).fork()).ldelim();
	                            if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
	                                writer.uint32(/* id 5, wireType 0 =*/ 40).uint32(message.droppedAttributesCount);
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified Link message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Span.Link.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.ILink} message Link message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        Link.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes a Link message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        Link.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Span.Link();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.traceId = reader.bytes();
	                                        break;
	                                    }
	                                    case 2: {
	                                        message.spanId = reader.bytes();
	                                        break;
	                                    }
	                                    case 3: {
	                                        message.traceState = reader.string();
	                                        break;
	                                    }
	                                    case 4: {
	                                        if (!(message.attributes && message.attributes.length))
	                                            message.attributes = [];
	                                        message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                        break;
	                                    }
	                                    case 5: {
	                                        message.droppedAttributesCount = reader.uint32();
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes a Link message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        Link.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies a Link message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        Link.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.traceId != null && message.hasOwnProperty("traceId"))
	                                if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
	                                    return "traceId: buffer expected";
	                            if (message.spanId != null && message.hasOwnProperty("spanId"))
	                                if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
	                                    return "spanId: buffer expected";
	                            if (message.traceState != null && message.hasOwnProperty("traceState"))
	                                if (!$util.isString(message.traceState))
	                                    return "traceState: string expected";
	                            if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                                if (!Array.isArray(message.attributes))
	                                    return "attributes: array expected";
	                                for (var i = 0; i < message.attributes.length; ++i) {
	                                    var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                    if (error)
	                                        return "attributes." + error;
	                                }
	                            }
	                            if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                                if (!$util.isInteger(message.droppedAttributesCount))
	                                    return "droppedAttributesCount: integer expected";
	                            return null;
	                        };
	                        /**
	                         * Creates a Link message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.trace.v1.Span.Link} Link
	                         */
	                        Link.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.trace.v1.Span.Link)
	                                return object;
	                            var message = new $root.opentelemetry.proto.trace.v1.Span.Link();
	                            if (object.traceId != null)
	                                if (typeof object.traceId === "string")
	                                    $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
	                                else if (object.traceId.length >= 0)
	                                    message.traceId = object.traceId;
	                            if (object.spanId != null)
	                                if (typeof object.spanId === "string")
	                                    $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
	                                else if (object.spanId.length >= 0)
	                                    message.spanId = object.spanId;
	                            if (object.traceState != null)
	                                message.traceState = String(object.traceState);
	                            if (object.attributes) {
	                                if (!Array.isArray(object.attributes))
	                                    throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: array expected");
	                                message.attributes = [];
	                                for (var i = 0; i < object.attributes.length; ++i) {
	                                    if (typeof object.attributes[i] !== "object")
	                                        throw TypeError(".opentelemetry.proto.trace.v1.Span.Link.attributes: object expected");
	                                    message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                                }
	                            }
	                            if (object.droppedAttributesCount != null)
	                                message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from a Link message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {opentelemetry.proto.trace.v1.Span.Link} message Link
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        Link.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.arrays || options.defaults)
	                                object.attributes = [];
	                            if (options.defaults) {
	                                if (options.bytes === String)
	                                    object.traceId = "";
	                                else {
	                                    object.traceId = [];
	                                    if (options.bytes !== Array)
	                                        object.traceId = $util.newBuffer(object.traceId);
	                                }
	                                if (options.bytes === String)
	                                    object.spanId = "";
	                                else {
	                                    object.spanId = [];
	                                    if (options.bytes !== Array)
	                                        object.spanId = $util.newBuffer(object.spanId);
	                                }
	                                object.traceState = "";
	                                object.droppedAttributesCount = 0;
	                            }
	                            if (message.traceId != null && message.hasOwnProperty("traceId"))
	                                object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
	                            if (message.spanId != null && message.hasOwnProperty("spanId"))
	                                object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
	                            if (message.traceState != null && message.hasOwnProperty("traceState"))
	                                object.traceState = message.traceState;
	                            if (message.attributes && message.attributes.length) {
	                                object.attributes = [];
	                                for (var j = 0; j < message.attributes.length; ++j)
	                                    object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                            }
	                            if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                                object.droppedAttributesCount = message.droppedAttributesCount;
	                            return object;
	                        };
	                        /**
	                         * Converts this Link to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        Link.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for Link
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.trace.v1.Span.Link
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        Link.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Span.Link";
	                        };
	                        return Link;
	                    })();
	                    return Span;
	                })();
	                v1.Status = (function () {
	                    /**
	                     * Properties of a Status.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @interface IStatus
	                     * @property {string|null} [message] Status message
	                     * @property {opentelemetry.proto.trace.v1.Status.StatusCode|null} [code] Status code
	                     */
	                    /**
	                     * Constructs a new Status.
	                     * @memberof opentelemetry.proto.trace.v1
	                     * @classdesc Represents a Status.
	                     * @implements IStatus
	                     * @constructor
	                     * @param {opentelemetry.proto.trace.v1.IStatus=} [properties] Properties to set
	                     */
	                    function Status(properties) {
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Status message.
	                     * @member {string|null|undefined} message
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @instance
	                     */
	                    Status.prototype.message = null;
	                    /**
	                     * Status code.
	                     * @member {opentelemetry.proto.trace.v1.Status.StatusCode|null|undefined} code
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @instance
	                     */
	                    Status.prototype.code = null;
	                    /**
	                     * Creates a new Status instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IStatus=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.trace.v1.Status} Status instance
	                     */
	                    Status.create = function create(properties) {
	                        return new Status(properties);
	                    };
	                    /**
	                     * Encodes the specified Status message. Does not implicitly {@link opentelemetry.proto.trace.v1.Status.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IStatus} message Status message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Status.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.message != null && Object.hasOwnProperty.call(message, "message"))
	                            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.message);
	                        if (message.code != null && Object.hasOwnProperty.call(message, "code"))
	                            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.code);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Status message, length delimited. Does not implicitly {@link opentelemetry.proto.trace.v1.Status.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.IStatus} message Status message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Status.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Status message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.trace.v1.Status} Status
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Status.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.trace.v1.Status();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 2: {
	                                    message.message = reader.string();
	                                    break;
	                                }
	                                case 3: {
	                                    message.code = reader.int32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Status message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.trace.v1.Status} Status
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Status.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Status message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Status.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.message != null && message.hasOwnProperty("message"))
	                            if (!$util.isString(message.message))
	                                return "message: string expected";
	                        if (message.code != null && message.hasOwnProperty("code"))
	                            switch (message.code) {
	                                default:
	                                    return "code: enum value expected";
	                                case 0:
	                                case 1:
	                                case 2:
	                                    break;
	                            }
	                        return null;
	                    };
	                    /**
	                     * Creates a Status message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.trace.v1.Status} Status
	                     */
	                    Status.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.trace.v1.Status)
	                            return object;
	                        var message = new $root.opentelemetry.proto.trace.v1.Status();
	                        if (object.message != null)
	                            message.message = String(object.message);
	                        switch (object.code) {
	                            default:
	                                if (typeof object.code === "number") {
	                                    message.code = object.code;
	                                    break;
	                                }
	                                break;
	                            case "STATUS_CODE_UNSET":
	                            case 0:
	                                message.code = 0;
	                                break;
	                            case "STATUS_CODE_OK":
	                            case 1:
	                                message.code = 1;
	                                break;
	                            case "STATUS_CODE_ERROR":
	                            case 2:
	                                message.code = 2;
	                                break;
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Status message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {opentelemetry.proto.trace.v1.Status} message Status
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Status.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.defaults) {
	                            object.message = "";
	                            object.code = options.enums === String ? "STATUS_CODE_UNSET" : 0;
	                        }
	                        if (message.message != null && message.hasOwnProperty("message"))
	                            object.message = message.message;
	                        if (message.code != null && message.hasOwnProperty("code"))
	                            object.code = options.enums === String ? $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] === undefined ? message.code : $root.opentelemetry.proto.trace.v1.Status.StatusCode[message.code] : message.code;
	                        return object;
	                    };
	                    /**
	                     * Converts this Status to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Status.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Status
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.trace.v1.Status
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.trace.v1.Status";
	                    };
	                    /**
	                     * StatusCode enum.
	                     * @name opentelemetry.proto.trace.v1.Status.StatusCode
	                     * @enum {number}
	                     * @property {number} STATUS_CODE_UNSET=0 STATUS_CODE_UNSET value
	                     * @property {number} STATUS_CODE_OK=1 STATUS_CODE_OK value
	                     * @property {number} STATUS_CODE_ERROR=2 STATUS_CODE_ERROR value
	                     */
	                    Status.StatusCode = (function () {
	                        var valuesById = {}, values = Object.create(valuesById);
	                        values[valuesById[0] = "STATUS_CODE_UNSET"] = 0;
	                        values[valuesById[1] = "STATUS_CODE_OK"] = 1;
	                        values[valuesById[2] = "STATUS_CODE_ERROR"] = 2;
	                        return values;
	                    })();
	                    return Status;
	                })();
	                return v1;
	            })();
	            return trace;
	        })();
	        proto.collector = (function () {
	            /**
	             * Namespace collector.
	             * @memberof opentelemetry.proto
	             * @namespace
	             */
	            var collector = {};
	            collector.trace = (function () {
	                /**
	                 * Namespace trace.
	                 * @memberof opentelemetry.proto.collector
	                 * @namespace
	                 */
	                var trace = {};
	                trace.v1 = (function () {
	                    /**
	                     * Namespace v1.
	                     * @memberof opentelemetry.proto.collector.trace
	                     * @namespace
	                     */
	                    var v1 = {};
	                    v1.TraceService = (function () {
	                        /**
	                         * Constructs a new TraceService service.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @classdesc Represents a TraceService
	                         * @extends $protobuf.rpc.Service
	                         * @constructor
	                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
	                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	                         */
	                        function TraceService(rpcImpl, requestDelimited, responseDelimited) {
	                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
	                        }
	                        (TraceService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TraceService;
	                        /**
	                         * Creates new TraceService service using the specified rpc implementation.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService
	                         * @static
	                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
	                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	                         * @returns {TraceService} RPC service. Useful where requests and/or responses are streamed.
	                         */
	                        TraceService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
	                            return new this(rpcImpl, requestDelimited, responseDelimited);
	                        };
	                        /**
	                         * Callback as used by {@link opentelemetry.proto.collector.trace.v1.TraceService#export_}.
	                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService
	                         * @typedef ExportCallback
	                         * @type {function}
	                         * @param {Error|null} error Error, if any
	                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} [response] ExportTraceServiceResponse
	                         */
	                        /**
	                         * Calls Export.
	                         * @function export
	                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService
	                         * @instance
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} request ExportTraceServiceRequest message or plain object
	                         * @param {opentelemetry.proto.collector.trace.v1.TraceService.ExportCallback} callback Node-style callback called with the error, if any, and ExportTraceServiceResponse
	                         * @returns {undefined}
	                         * @variation 1
	                         */
	                        Object.defineProperty(TraceService.prototype["export"] = function export_(request, callback) {
	                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest, $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse, request, callback);
	                        }, "name", { value: "Export" });
	                        /**
	                         * Calls Export.
	                         * @function export
	                         * @memberof opentelemetry.proto.collector.trace.v1.TraceService
	                         * @instance
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} request ExportTraceServiceRequest message or plain object
	                         * @returns {Promise<opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse>} Promise
	                         * @variation 2
	                         */
	                        return TraceService;
	                    })();
	                    v1.ExportTraceServiceRequest = (function () {
	                        /**
	                         * Properties of an ExportTraceServiceRequest.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @interface IExportTraceServiceRequest
	                         * @property {Array.<opentelemetry.proto.trace.v1.IResourceSpans>|null} [resourceSpans] ExportTraceServiceRequest resourceSpans
	                         */
	                        /**
	                         * Constructs a new ExportTraceServiceRequest.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @classdesc Represents an ExportTraceServiceRequest.
	                         * @implements IExportTraceServiceRequest
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest=} [properties] Properties to set
	                         */
	                        function ExportTraceServiceRequest(properties) {
	                            this.resourceSpans = [];
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportTraceServiceRequest resourceSpans.
	                         * @member {Array.<opentelemetry.proto.trace.v1.IResourceSpans>} resourceSpans
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @instance
	                         */
	                        ExportTraceServiceRequest.prototype.resourceSpans = $util.emptyArray;
	                        /**
	                         * Creates a new ExportTraceServiceRequest instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest instance
	                         */
	                        ExportTraceServiceRequest.create = function create(properties) {
	                            return new ExportTraceServiceRequest(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportTraceServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} message ExportTraceServiceRequest message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportTraceServiceRequest.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.resourceSpans != null && message.resourceSpans.length)
	                                for (var i = 0; i < message.resourceSpans.length; ++i)
	                                    $root.opentelemetry.proto.trace.v1.ResourceSpans.encode(message.resourceSpans[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportTraceServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceRequest} message ExportTraceServiceRequest message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportTraceServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportTraceServiceRequest message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportTraceServiceRequest.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        if (!(message.resourceSpans && message.resourceSpans.length))
	                                            message.resourceSpans = [];
	                                        message.resourceSpans.push($root.opentelemetry.proto.trace.v1.ResourceSpans.decode(reader, reader.uint32()));
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportTraceServiceRequest message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportTraceServiceRequest.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportTraceServiceRequest message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportTraceServiceRequest.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.resourceSpans != null && message.hasOwnProperty("resourceSpans")) {
	                                if (!Array.isArray(message.resourceSpans))
	                                    return "resourceSpans: array expected";
	                                for (var i = 0; i < message.resourceSpans.length; ++i) {
	                                    var error = $root.opentelemetry.proto.trace.v1.ResourceSpans.verify(message.resourceSpans[i]);
	                                    if (error)
	                                        return "resourceSpans." + error;
	                                }
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportTraceServiceRequest message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} ExportTraceServiceRequest
	                         */
	                        ExportTraceServiceRequest.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest();
	                            if (object.resourceSpans) {
	                                if (!Array.isArray(object.resourceSpans))
	                                    throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: array expected");
	                                message.resourceSpans = [];
	                                for (var i = 0; i < object.resourceSpans.length; ++i) {
	                                    if (typeof object.resourceSpans[i] !== "object")
	                                        throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest.resourceSpans: object expected");
	                                    message.resourceSpans[i] = $root.opentelemetry.proto.trace.v1.ResourceSpans.fromObject(object.resourceSpans[i]);
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportTraceServiceRequest message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest} message ExportTraceServiceRequest
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportTraceServiceRequest.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.arrays || options.defaults)
	                                object.resourceSpans = [];
	                            if (message.resourceSpans && message.resourceSpans.length) {
	                                object.resourceSpans = [];
	                                for (var j = 0; j < message.resourceSpans.length; ++j)
	                                    object.resourceSpans[j] = $root.opentelemetry.proto.trace.v1.ResourceSpans.toObject(message.resourceSpans[j], options);
	                            }
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportTraceServiceRequest to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportTraceServiceRequest.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportTraceServiceRequest
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportTraceServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest";
	                        };
	                        return ExportTraceServiceRequest;
	                    })();
	                    v1.ExportTraceServiceResponse = (function () {
	                        /**
	                         * Properties of an ExportTraceServiceResponse.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @interface IExportTraceServiceResponse
	                         * @property {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess|null} [partialSuccess] ExportTraceServiceResponse partialSuccess
	                         */
	                        /**
	                         * Constructs a new ExportTraceServiceResponse.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @classdesc Represents an ExportTraceServiceResponse.
	                         * @implements IExportTraceServiceResponse
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse=} [properties] Properties to set
	                         */
	                        function ExportTraceServiceResponse(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportTraceServiceResponse partialSuccess.
	                         * @member {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess|null|undefined} partialSuccess
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @instance
	                         */
	                        ExportTraceServiceResponse.prototype.partialSuccess = null;
	                        /**
	                         * Creates a new ExportTraceServiceResponse instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse instance
	                         */
	                        ExportTraceServiceResponse.create = function create(properties) {
	                            return new ExportTraceServiceResponse(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportTraceServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse} message ExportTraceServiceResponse message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportTraceServiceResponse.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
	                                $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportTraceServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTraceServiceResponse} message ExportTraceServiceResponse message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportTraceServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportTraceServiceResponse message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportTraceServiceResponse.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.decode(reader, reader.uint32());
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportTraceServiceResponse message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportTraceServiceResponse.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportTraceServiceResponse message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportTraceServiceResponse.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
	                                var error = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify(message.partialSuccess);
	                                if (error)
	                                    return "partialSuccess." + error;
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportTraceServiceResponse message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} ExportTraceServiceResponse
	                         */
	                        ExportTraceServiceResponse.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse();
	                            if (object.partialSuccess != null) {
	                                if (typeof object.partialSuccess !== "object")
	                                    throw TypeError(".opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse.partialSuccess: object expected");
	                                message.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.fromObject(object.partialSuccess);
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportTraceServiceResponse message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse} message ExportTraceServiceResponse
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportTraceServiceResponse.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults)
	                                object.partialSuccess = null;
	                            if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
	                                object.partialSuccess = $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.toObject(message.partialSuccess, options);
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportTraceServiceResponse to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportTraceServiceResponse.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportTraceServiceResponse
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportTraceServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTraceServiceResponse";
	                        };
	                        return ExportTraceServiceResponse;
	                    })();
	                    v1.ExportTracePartialSuccess = (function () {
	                        /**
	                         * Properties of an ExportTracePartialSuccess.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @interface IExportTracePartialSuccess
	                         * @property {number|Long|null} [rejectedSpans] ExportTracePartialSuccess rejectedSpans
	                         * @property {string|null} [errorMessage] ExportTracePartialSuccess errorMessage
	                         */
	                        /**
	                         * Constructs a new ExportTracePartialSuccess.
	                         * @memberof opentelemetry.proto.collector.trace.v1
	                         * @classdesc Represents an ExportTracePartialSuccess.
	                         * @implements IExportTracePartialSuccess
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess=} [properties] Properties to set
	                         */
	                        function ExportTracePartialSuccess(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportTracePartialSuccess rejectedSpans.
	                         * @member {number|Long|null|undefined} rejectedSpans
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @instance
	                         */
	                        ExportTracePartialSuccess.prototype.rejectedSpans = null;
	                        /**
	                         * ExportTracePartialSuccess errorMessage.
	                         * @member {string|null|undefined} errorMessage
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @instance
	                         */
	                        ExportTracePartialSuccess.prototype.errorMessage = null;
	                        /**
	                         * Creates a new ExportTracePartialSuccess instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess instance
	                         */
	                        ExportTracePartialSuccess.create = function create(properties) {
	                            return new ExportTracePartialSuccess(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportTracePartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess} message ExportTracePartialSuccess message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportTracePartialSuccess.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.rejectedSpans != null && Object.hasOwnProperty.call(message, "rejectedSpans"))
	                                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.rejectedSpans);
	                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
	                                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.errorMessage);
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportTracePartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.IExportTracePartialSuccess} message ExportTracePartialSuccess message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportTracePartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportTracePartialSuccess message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportTracePartialSuccess.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.rejectedSpans = reader.int64();
	                                        break;
	                                    }
	                                    case 2: {
	                                        message.errorMessage = reader.string();
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportTracePartialSuccess message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportTracePartialSuccess.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportTracePartialSuccess message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportTracePartialSuccess.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans"))
	                                if (!$util.isInteger(message.rejectedSpans) && !(message.rejectedSpans && $util.isInteger(message.rejectedSpans.low) && $util.isInteger(message.rejectedSpans.high)))
	                                    return "rejectedSpans: integer|Long expected";
	                            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
	                                if (!$util.isString(message.errorMessage))
	                                    return "errorMessage: string expected";
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportTracePartialSuccess message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} ExportTracePartialSuccess
	                         */
	                        ExportTracePartialSuccess.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess();
	                            if (object.rejectedSpans != null)
	                                if ($util.Long)
	                                    (message.rejectedSpans = $util.Long.fromValue(object.rejectedSpans)).unsigned = false;
	                                else if (typeof object.rejectedSpans === "string")
	                                    message.rejectedSpans = parseInt(object.rejectedSpans, 10);
	                                else if (typeof object.rejectedSpans === "number")
	                                    message.rejectedSpans = object.rejectedSpans;
	                                else if (typeof object.rejectedSpans === "object")
	                                    message.rejectedSpans = new $util.LongBits(object.rejectedSpans.low >>> 0, object.rejectedSpans.high >>> 0).toNumber();
	                            if (object.errorMessage != null)
	                                message.errorMessage = String(object.errorMessage);
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportTracePartialSuccess message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess} message ExportTracePartialSuccess
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportTracePartialSuccess.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults) {
	                                if ($util.Long) {
	                                    var long = new $util.Long(0, 0, false);
	                                    object.rejectedSpans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                                }
	                                else
	                                    object.rejectedSpans = options.longs === String ? "0" : 0;
	                                object.errorMessage = "";
	                            }
	                            if (message.rejectedSpans != null && message.hasOwnProperty("rejectedSpans"))
	                                if (typeof message.rejectedSpans === "number")
	                                    object.rejectedSpans = options.longs === String ? String(message.rejectedSpans) : message.rejectedSpans;
	                                else
	                                    object.rejectedSpans = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedSpans) : options.longs === Number ? new $util.LongBits(message.rejectedSpans.low >>> 0, message.rejectedSpans.high >>> 0).toNumber() : message.rejectedSpans;
	                            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
	                                object.errorMessage = message.errorMessage;
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportTracePartialSuccess to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportTracePartialSuccess.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportTracePartialSuccess
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportTracePartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.trace.v1.ExportTracePartialSuccess";
	                        };
	                        return ExportTracePartialSuccess;
	                    })();
	                    return v1;
	                })();
	                return trace;
	            })();
	            collector.metrics = (function () {
	                /**
	                 * Namespace metrics.
	                 * @memberof opentelemetry.proto.collector
	                 * @namespace
	                 */
	                var metrics = {};
	                metrics.v1 = (function () {
	                    /**
	                     * Namespace v1.
	                     * @memberof opentelemetry.proto.collector.metrics
	                     * @namespace
	                     */
	                    var v1 = {};
	                    v1.MetricsService = (function () {
	                        /**
	                         * Constructs a new MetricsService service.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @classdesc Represents a MetricsService
	                         * @extends $protobuf.rpc.Service
	                         * @constructor
	                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
	                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	                         */
	                        function MetricsService(rpcImpl, requestDelimited, responseDelimited) {
	                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
	                        }
	                        (MetricsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsService;
	                        /**
	                         * Creates new MetricsService service using the specified rpc implementation.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService
	                         * @static
	                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
	                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	                         * @returns {MetricsService} RPC service. Useful where requests and/or responses are streamed.
	                         */
	                        MetricsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
	                            return new this(rpcImpl, requestDelimited, responseDelimited);
	                        };
	                        /**
	                         * Callback as used by {@link opentelemetry.proto.collector.metrics.v1.MetricsService#export_}.
	                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService
	                         * @typedef ExportCallback
	                         * @type {function}
	                         * @param {Error|null} error Error, if any
	                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} [response] ExportMetricsServiceResponse
	                         */
	                        /**
	                         * Calls Export.
	                         * @function export
	                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService
	                         * @instance
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} request ExportMetricsServiceRequest message or plain object
	                         * @param {opentelemetry.proto.collector.metrics.v1.MetricsService.ExportCallback} callback Node-style callback called with the error, if any, and ExportMetricsServiceResponse
	                         * @returns {undefined}
	                         * @variation 1
	                         */
	                        Object.defineProperty(MetricsService.prototype["export"] = function export_(request, callback) {
	                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest, $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse, request, callback);
	                        }, "name", { value: "Export" });
	                        /**
	                         * Calls Export.
	                         * @function export
	                         * @memberof opentelemetry.proto.collector.metrics.v1.MetricsService
	                         * @instance
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} request ExportMetricsServiceRequest message or plain object
	                         * @returns {Promise<opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse>} Promise
	                         * @variation 2
	                         */
	                        return MetricsService;
	                    })();
	                    v1.ExportMetricsServiceRequest = (function () {
	                        /**
	                         * Properties of an ExportMetricsServiceRequest.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @interface IExportMetricsServiceRequest
	                         * @property {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>|null} [resourceMetrics] ExportMetricsServiceRequest resourceMetrics
	                         */
	                        /**
	                         * Constructs a new ExportMetricsServiceRequest.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @classdesc Represents an ExportMetricsServiceRequest.
	                         * @implements IExportMetricsServiceRequest
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest=} [properties] Properties to set
	                         */
	                        function ExportMetricsServiceRequest(properties) {
	                            this.resourceMetrics = [];
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportMetricsServiceRequest resourceMetrics.
	                         * @member {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>} resourceMetrics
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @instance
	                         */
	                        ExportMetricsServiceRequest.prototype.resourceMetrics = $util.emptyArray;
	                        /**
	                         * Creates a new ExportMetricsServiceRequest instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest instance
	                         */
	                        ExportMetricsServiceRequest.create = function create(properties) {
	                            return new ExportMetricsServiceRequest(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportMetricsServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} message ExportMetricsServiceRequest message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportMetricsServiceRequest.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.resourceMetrics != null && message.resourceMetrics.length)
	                                for (var i = 0; i < message.resourceMetrics.length; ++i)
	                                    $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportMetricsServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceRequest} message ExportMetricsServiceRequest message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportMetricsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportMetricsServiceRequest message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportMetricsServiceRequest.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        if (!(message.resourceMetrics && message.resourceMetrics.length))
	                                            message.resourceMetrics = [];
	                                        message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportMetricsServiceRequest message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportMetricsServiceRequest.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportMetricsServiceRequest message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportMetricsServiceRequest.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
	                                if (!Array.isArray(message.resourceMetrics))
	                                    return "resourceMetrics: array expected";
	                                for (var i = 0; i < message.resourceMetrics.length; ++i) {
	                                    var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);
	                                    if (error)
	                                        return "resourceMetrics." + error;
	                                }
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportMetricsServiceRequest message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} ExportMetricsServiceRequest
	                         */
	                        ExportMetricsServiceRequest.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest();
	                            if (object.resourceMetrics) {
	                                if (!Array.isArray(object.resourceMetrics))
	                                    throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: array expected");
	                                message.resourceMetrics = [];
	                                for (var i = 0; i < object.resourceMetrics.length; ++i) {
	                                    if (typeof object.resourceMetrics[i] !== "object")
	                                        throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest.resourceMetrics: object expected");
	                                    message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportMetricsServiceRequest message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest} message ExportMetricsServiceRequest
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportMetricsServiceRequest.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.arrays || options.defaults)
	                                object.resourceMetrics = [];
	                            if (message.resourceMetrics && message.resourceMetrics.length) {
	                                object.resourceMetrics = [];
	                                for (var j = 0; j < message.resourceMetrics.length; ++j)
	                                    object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);
	                            }
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportMetricsServiceRequest to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportMetricsServiceRequest.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportMetricsServiceRequest
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportMetricsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest";
	                        };
	                        return ExportMetricsServiceRequest;
	                    })();
	                    v1.ExportMetricsServiceResponse = (function () {
	                        /**
	                         * Properties of an ExportMetricsServiceResponse.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @interface IExportMetricsServiceResponse
	                         * @property {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess|null} [partialSuccess] ExportMetricsServiceResponse partialSuccess
	                         */
	                        /**
	                         * Constructs a new ExportMetricsServiceResponse.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @classdesc Represents an ExportMetricsServiceResponse.
	                         * @implements IExportMetricsServiceResponse
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse=} [properties] Properties to set
	                         */
	                        function ExportMetricsServiceResponse(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportMetricsServiceResponse partialSuccess.
	                         * @member {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess|null|undefined} partialSuccess
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @instance
	                         */
	                        ExportMetricsServiceResponse.prototype.partialSuccess = null;
	                        /**
	                         * Creates a new ExportMetricsServiceResponse instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse instance
	                         */
	                        ExportMetricsServiceResponse.create = function create(properties) {
	                            return new ExportMetricsServiceResponse(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportMetricsServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse} message ExportMetricsServiceResponse message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportMetricsServiceResponse.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
	                                $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportMetricsServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsServiceResponse} message ExportMetricsServiceResponse message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportMetricsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportMetricsServiceResponse message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportMetricsServiceResponse.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.decode(reader, reader.uint32());
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportMetricsServiceResponse message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportMetricsServiceResponse.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportMetricsServiceResponse message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportMetricsServiceResponse.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
	                                var error = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify(message.partialSuccess);
	                                if (error)
	                                    return "partialSuccess." + error;
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportMetricsServiceResponse message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} ExportMetricsServiceResponse
	                         */
	                        ExportMetricsServiceResponse.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse();
	                            if (object.partialSuccess != null) {
	                                if (typeof object.partialSuccess !== "object")
	                                    throw TypeError(".opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse.partialSuccess: object expected");
	                                message.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.fromObject(object.partialSuccess);
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportMetricsServiceResponse message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse} message ExportMetricsServiceResponse
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportMetricsServiceResponse.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults)
	                                object.partialSuccess = null;
	                            if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
	                                object.partialSuccess = $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.toObject(message.partialSuccess, options);
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportMetricsServiceResponse to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportMetricsServiceResponse.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportMetricsServiceResponse
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportMetricsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceResponse";
	                        };
	                        return ExportMetricsServiceResponse;
	                    })();
	                    v1.ExportMetricsPartialSuccess = (function () {
	                        /**
	                         * Properties of an ExportMetricsPartialSuccess.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @interface IExportMetricsPartialSuccess
	                         * @property {number|Long|null} [rejectedDataPoints] ExportMetricsPartialSuccess rejectedDataPoints
	                         * @property {string|null} [errorMessage] ExportMetricsPartialSuccess errorMessage
	                         */
	                        /**
	                         * Constructs a new ExportMetricsPartialSuccess.
	                         * @memberof opentelemetry.proto.collector.metrics.v1
	                         * @classdesc Represents an ExportMetricsPartialSuccess.
	                         * @implements IExportMetricsPartialSuccess
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess=} [properties] Properties to set
	                         */
	                        function ExportMetricsPartialSuccess(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportMetricsPartialSuccess rejectedDataPoints.
	                         * @member {number|Long|null|undefined} rejectedDataPoints
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @instance
	                         */
	                        ExportMetricsPartialSuccess.prototype.rejectedDataPoints = null;
	                        /**
	                         * ExportMetricsPartialSuccess errorMessage.
	                         * @member {string|null|undefined} errorMessage
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @instance
	                         */
	                        ExportMetricsPartialSuccess.prototype.errorMessage = null;
	                        /**
	                         * Creates a new ExportMetricsPartialSuccess instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess instance
	                         */
	                        ExportMetricsPartialSuccess.create = function create(properties) {
	                            return new ExportMetricsPartialSuccess(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportMetricsPartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess} message ExportMetricsPartialSuccess message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportMetricsPartialSuccess.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.rejectedDataPoints != null && Object.hasOwnProperty.call(message, "rejectedDataPoints"))
	                                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.rejectedDataPoints);
	                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
	                                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.errorMessage);
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportMetricsPartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.IExportMetricsPartialSuccess} message ExportMetricsPartialSuccess message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportMetricsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportMetricsPartialSuccess message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportMetricsPartialSuccess.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.rejectedDataPoints = reader.int64();
	                                        break;
	                                    }
	                                    case 2: {
	                                        message.errorMessage = reader.string();
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportMetricsPartialSuccess message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportMetricsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportMetricsPartialSuccess message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportMetricsPartialSuccess.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints"))
	                                if (!$util.isInteger(message.rejectedDataPoints) && !(message.rejectedDataPoints && $util.isInteger(message.rejectedDataPoints.low) && $util.isInteger(message.rejectedDataPoints.high)))
	                                    return "rejectedDataPoints: integer|Long expected";
	                            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
	                                if (!$util.isString(message.errorMessage))
	                                    return "errorMessage: string expected";
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportMetricsPartialSuccess message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} ExportMetricsPartialSuccess
	                         */
	                        ExportMetricsPartialSuccess.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess();
	                            if (object.rejectedDataPoints != null)
	                                if ($util.Long)
	                                    (message.rejectedDataPoints = $util.Long.fromValue(object.rejectedDataPoints)).unsigned = false;
	                                else if (typeof object.rejectedDataPoints === "string")
	                                    message.rejectedDataPoints = parseInt(object.rejectedDataPoints, 10);
	                                else if (typeof object.rejectedDataPoints === "number")
	                                    message.rejectedDataPoints = object.rejectedDataPoints;
	                                else if (typeof object.rejectedDataPoints === "object")
	                                    message.rejectedDataPoints = new $util.LongBits(object.rejectedDataPoints.low >>> 0, object.rejectedDataPoints.high >>> 0).toNumber();
	                            if (object.errorMessage != null)
	                                message.errorMessage = String(object.errorMessage);
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportMetricsPartialSuccess message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess} message ExportMetricsPartialSuccess
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportMetricsPartialSuccess.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults) {
	                                if ($util.Long) {
	                                    var long = new $util.Long(0, 0, false);
	                                    object.rejectedDataPoints = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                                }
	                                else
	                                    object.rejectedDataPoints = options.longs === String ? "0" : 0;
	                                object.errorMessage = "";
	                            }
	                            if (message.rejectedDataPoints != null && message.hasOwnProperty("rejectedDataPoints"))
	                                if (typeof message.rejectedDataPoints === "number")
	                                    object.rejectedDataPoints = options.longs === String ? String(message.rejectedDataPoints) : message.rejectedDataPoints;
	                                else
	                                    object.rejectedDataPoints = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedDataPoints) : options.longs === Number ? new $util.LongBits(message.rejectedDataPoints.low >>> 0, message.rejectedDataPoints.high >>> 0).toNumber() : message.rejectedDataPoints;
	                            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
	                                object.errorMessage = message.errorMessage;
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportMetricsPartialSuccess to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportMetricsPartialSuccess.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportMetricsPartialSuccess
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportMetricsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.metrics.v1.ExportMetricsPartialSuccess";
	                        };
	                        return ExportMetricsPartialSuccess;
	                    })();
	                    return v1;
	                })();
	                return metrics;
	            })();
	            collector.logs = (function () {
	                /**
	                 * Namespace logs.
	                 * @memberof opentelemetry.proto.collector
	                 * @namespace
	                 */
	                var logs = {};
	                logs.v1 = (function () {
	                    /**
	                     * Namespace v1.
	                     * @memberof opentelemetry.proto.collector.logs
	                     * @namespace
	                     */
	                    var v1 = {};
	                    v1.LogsService = (function () {
	                        /**
	                         * Constructs a new LogsService service.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @classdesc Represents a LogsService
	                         * @extends $protobuf.rpc.Service
	                         * @constructor
	                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
	                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	                         */
	                        function LogsService(rpcImpl, requestDelimited, responseDelimited) {
	                            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
	                        }
	                        (LogsService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = LogsService;
	                        /**
	                         * Creates new LogsService service using the specified rpc implementation.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService
	                         * @static
	                         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
	                         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
	                         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
	                         * @returns {LogsService} RPC service. Useful where requests and/or responses are streamed.
	                         */
	                        LogsService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
	                            return new this(rpcImpl, requestDelimited, responseDelimited);
	                        };
	                        /**
	                         * Callback as used by {@link opentelemetry.proto.collector.logs.v1.LogsService#export_}.
	                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService
	                         * @typedef ExportCallback
	                         * @type {function}
	                         * @param {Error|null} error Error, if any
	                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} [response] ExportLogsServiceResponse
	                         */
	                        /**
	                         * Calls Export.
	                         * @function export
	                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService
	                         * @instance
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} request ExportLogsServiceRequest message or plain object
	                         * @param {opentelemetry.proto.collector.logs.v1.LogsService.ExportCallback} callback Node-style callback called with the error, if any, and ExportLogsServiceResponse
	                         * @returns {undefined}
	                         * @variation 1
	                         */
	                        Object.defineProperty(LogsService.prototype["export"] = function export_(request, callback) {
	                            return this.rpcCall(export_, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest, $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse, request, callback);
	                        }, "name", { value: "Export" });
	                        /**
	                         * Calls Export.
	                         * @function export
	                         * @memberof opentelemetry.proto.collector.logs.v1.LogsService
	                         * @instance
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} request ExportLogsServiceRequest message or plain object
	                         * @returns {Promise<opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse>} Promise
	                         * @variation 2
	                         */
	                        return LogsService;
	                    })();
	                    v1.ExportLogsServiceRequest = (function () {
	                        /**
	                         * Properties of an ExportLogsServiceRequest.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @interface IExportLogsServiceRequest
	                         * @property {Array.<opentelemetry.proto.logs.v1.IResourceLogs>|null} [resourceLogs] ExportLogsServiceRequest resourceLogs
	                         */
	                        /**
	                         * Constructs a new ExportLogsServiceRequest.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @classdesc Represents an ExportLogsServiceRequest.
	                         * @implements IExportLogsServiceRequest
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest=} [properties] Properties to set
	                         */
	                        function ExportLogsServiceRequest(properties) {
	                            this.resourceLogs = [];
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportLogsServiceRequest resourceLogs.
	                         * @member {Array.<opentelemetry.proto.logs.v1.IResourceLogs>} resourceLogs
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @instance
	                         */
	                        ExportLogsServiceRequest.prototype.resourceLogs = $util.emptyArray;
	                        /**
	                         * Creates a new ExportLogsServiceRequest instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest instance
	                         */
	                        ExportLogsServiceRequest.create = function create(properties) {
	                            return new ExportLogsServiceRequest(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportLogsServiceRequest message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} message ExportLogsServiceRequest message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportLogsServiceRequest.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.resourceLogs != null && message.resourceLogs.length)
	                                for (var i = 0; i < message.resourceLogs.length; ++i)
	                                    $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportLogsServiceRequest message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceRequest} message ExportLogsServiceRequest message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportLogsServiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportLogsServiceRequest message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportLogsServiceRequest.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        if (!(message.resourceLogs && message.resourceLogs.length))
	                                            message.resourceLogs = [];
	                                        message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportLogsServiceRequest message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportLogsServiceRequest.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportLogsServiceRequest message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportLogsServiceRequest.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
	                                if (!Array.isArray(message.resourceLogs))
	                                    return "resourceLogs: array expected";
	                                for (var i = 0; i < message.resourceLogs.length; ++i) {
	                                    var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);
	                                    if (error)
	                                        return "resourceLogs." + error;
	                                }
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportLogsServiceRequest message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} ExportLogsServiceRequest
	                         */
	                        ExportLogsServiceRequest.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest();
	                            if (object.resourceLogs) {
	                                if (!Array.isArray(object.resourceLogs))
	                                    throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: array expected");
	                                message.resourceLogs = [];
	                                for (var i = 0; i < object.resourceLogs.length; ++i) {
	                                    if (typeof object.resourceLogs[i] !== "object")
	                                        throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest.resourceLogs: object expected");
	                                    message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportLogsServiceRequest message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest} message ExportLogsServiceRequest
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportLogsServiceRequest.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.arrays || options.defaults)
	                                object.resourceLogs = [];
	                            if (message.resourceLogs && message.resourceLogs.length) {
	                                object.resourceLogs = [];
	                                for (var j = 0; j < message.resourceLogs.length; ++j)
	                                    object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);
	                            }
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportLogsServiceRequest to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportLogsServiceRequest.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportLogsServiceRequest
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportLogsServiceRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest";
	                        };
	                        return ExportLogsServiceRequest;
	                    })();
	                    v1.ExportLogsServiceResponse = (function () {
	                        /**
	                         * Properties of an ExportLogsServiceResponse.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @interface IExportLogsServiceResponse
	                         * @property {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess|null} [partialSuccess] ExportLogsServiceResponse partialSuccess
	                         */
	                        /**
	                         * Constructs a new ExportLogsServiceResponse.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @classdesc Represents an ExportLogsServiceResponse.
	                         * @implements IExportLogsServiceResponse
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse=} [properties] Properties to set
	                         */
	                        function ExportLogsServiceResponse(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportLogsServiceResponse partialSuccess.
	                         * @member {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess|null|undefined} partialSuccess
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @instance
	                         */
	                        ExportLogsServiceResponse.prototype.partialSuccess = null;
	                        /**
	                         * Creates a new ExportLogsServiceResponse instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse instance
	                         */
	                        ExportLogsServiceResponse.create = function create(properties) {
	                            return new ExportLogsServiceResponse(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportLogsServiceResponse message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse} message ExportLogsServiceResponse message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportLogsServiceResponse.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.partialSuccess != null && Object.hasOwnProperty.call(message, "partialSuccess"))
	                                $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.encode(message.partialSuccess, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportLogsServiceResponse message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsServiceResponse} message ExportLogsServiceResponse message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportLogsServiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportLogsServiceResponse message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportLogsServiceResponse.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.decode(reader, reader.uint32());
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportLogsServiceResponse message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportLogsServiceResponse.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportLogsServiceResponse message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportLogsServiceResponse.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess")) {
	                                var error = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify(message.partialSuccess);
	                                if (error)
	                                    return "partialSuccess." + error;
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportLogsServiceResponse message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} ExportLogsServiceResponse
	                         */
	                        ExportLogsServiceResponse.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse();
	                            if (object.partialSuccess != null) {
	                                if (typeof object.partialSuccess !== "object")
	                                    throw TypeError(".opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse.partialSuccess: object expected");
	                                message.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.fromObject(object.partialSuccess);
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportLogsServiceResponse message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse} message ExportLogsServiceResponse
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportLogsServiceResponse.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults)
	                                object.partialSuccess = null;
	                            if (message.partialSuccess != null && message.hasOwnProperty("partialSuccess"))
	                                object.partialSuccess = $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.toObject(message.partialSuccess, options);
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportLogsServiceResponse to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportLogsServiceResponse.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportLogsServiceResponse
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportLogsServiceResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsServiceResponse";
	                        };
	                        return ExportLogsServiceResponse;
	                    })();
	                    v1.ExportLogsPartialSuccess = (function () {
	                        /**
	                         * Properties of an ExportLogsPartialSuccess.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @interface IExportLogsPartialSuccess
	                         * @property {number|Long|null} [rejectedLogRecords] ExportLogsPartialSuccess rejectedLogRecords
	                         * @property {string|null} [errorMessage] ExportLogsPartialSuccess errorMessage
	                         */
	                        /**
	                         * Constructs a new ExportLogsPartialSuccess.
	                         * @memberof opentelemetry.proto.collector.logs.v1
	                         * @classdesc Represents an ExportLogsPartialSuccess.
	                         * @implements IExportLogsPartialSuccess
	                         * @constructor
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess=} [properties] Properties to set
	                         */
	                        function ExportLogsPartialSuccess(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ExportLogsPartialSuccess rejectedLogRecords.
	                         * @member {number|Long|null|undefined} rejectedLogRecords
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @instance
	                         */
	                        ExportLogsPartialSuccess.prototype.rejectedLogRecords = null;
	                        /**
	                         * ExportLogsPartialSuccess errorMessage.
	                         * @member {string|null|undefined} errorMessage
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @instance
	                         */
	                        ExportLogsPartialSuccess.prototype.errorMessage = null;
	                        /**
	                         * Creates a new ExportLogsPartialSuccess instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess instance
	                         */
	                        ExportLogsPartialSuccess.create = function create(properties) {
	                            return new ExportLogsPartialSuccess(properties);
	                        };
	                        /**
	                         * Encodes the specified ExportLogsPartialSuccess message. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess} message ExportLogsPartialSuccess message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportLogsPartialSuccess.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.rejectedLogRecords != null && Object.hasOwnProperty.call(message, "rejectedLogRecords"))
	                                writer.uint32(/* id 1, wireType 0 =*/ 8).int64(message.rejectedLogRecords);
	                            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
	                                writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.errorMessage);
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ExportLogsPartialSuccess message, length delimited. Does not implicitly {@link opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.IExportLogsPartialSuccess} message ExportLogsPartialSuccess message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ExportLogsPartialSuccess.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes an ExportLogsPartialSuccess message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportLogsPartialSuccess.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.rejectedLogRecords = reader.int64();
	                                        break;
	                                    }
	                                    case 2: {
	                                        message.errorMessage = reader.string();
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes an ExportLogsPartialSuccess message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ExportLogsPartialSuccess.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies an ExportLogsPartialSuccess message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ExportLogsPartialSuccess.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords"))
	                                if (!$util.isInteger(message.rejectedLogRecords) && !(message.rejectedLogRecords && $util.isInteger(message.rejectedLogRecords.low) && $util.isInteger(message.rejectedLogRecords.high)))
	                                    return "rejectedLogRecords: integer|Long expected";
	                            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
	                                if (!$util.isString(message.errorMessage))
	                                    return "errorMessage: string expected";
	                            return null;
	                        };
	                        /**
	                         * Creates an ExportLogsPartialSuccess message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} ExportLogsPartialSuccess
	                         */
	                        ExportLogsPartialSuccess.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess)
	                                return object;
	                            var message = new $root.opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess();
	                            if (object.rejectedLogRecords != null)
	                                if ($util.Long)
	                                    (message.rejectedLogRecords = $util.Long.fromValue(object.rejectedLogRecords)).unsigned = false;
	                                else if (typeof object.rejectedLogRecords === "string")
	                                    message.rejectedLogRecords = parseInt(object.rejectedLogRecords, 10);
	                                else if (typeof object.rejectedLogRecords === "number")
	                                    message.rejectedLogRecords = object.rejectedLogRecords;
	                                else if (typeof object.rejectedLogRecords === "object")
	                                    message.rejectedLogRecords = new $util.LongBits(object.rejectedLogRecords.low >>> 0, object.rejectedLogRecords.high >>> 0).toNumber();
	                            if (object.errorMessage != null)
	                                message.errorMessage = String(object.errorMessage);
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from an ExportLogsPartialSuccess message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess} message ExportLogsPartialSuccess
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ExportLogsPartialSuccess.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults) {
	                                if ($util.Long) {
	                                    var long = new $util.Long(0, 0, false);
	                                    object.rejectedLogRecords = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                                }
	                                else
	                                    object.rejectedLogRecords = options.longs === String ? "0" : 0;
	                                object.errorMessage = "";
	                            }
	                            if (message.rejectedLogRecords != null && message.hasOwnProperty("rejectedLogRecords"))
	                                if (typeof message.rejectedLogRecords === "number")
	                                    object.rejectedLogRecords = options.longs === String ? String(message.rejectedLogRecords) : message.rejectedLogRecords;
	                                else
	                                    object.rejectedLogRecords = options.longs === String ? $util.Long.prototype.toString.call(message.rejectedLogRecords) : options.longs === Number ? new $util.LongBits(message.rejectedLogRecords.low >>> 0, message.rejectedLogRecords.high >>> 0).toNumber() : message.rejectedLogRecords;
	                            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
	                                object.errorMessage = message.errorMessage;
	                            return object;
	                        };
	                        /**
	                         * Converts this ExportLogsPartialSuccess to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ExportLogsPartialSuccess.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ExportLogsPartialSuccess
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ExportLogsPartialSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.collector.logs.v1.ExportLogsPartialSuccess";
	                        };
	                        return ExportLogsPartialSuccess;
	                    })();
	                    return v1;
	                })();
	                return logs;
	            })();
	            return collector;
	        })();
	        proto.metrics = (function () {
	            /**
	             * Namespace metrics.
	             * @memberof opentelemetry.proto
	             * @namespace
	             */
	            var metrics = {};
	            metrics.v1 = (function () {
	                /**
	                 * Namespace v1.
	                 * @memberof opentelemetry.proto.metrics
	                 * @namespace
	                 */
	                var v1 = {};
	                v1.MetricsData = (function () {
	                    /**
	                     * Properties of a MetricsData.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IMetricsData
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>|null} [resourceMetrics] MetricsData resourceMetrics
	                     */
	                    /**
	                     * Constructs a new MetricsData.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a MetricsData.
	                     * @implements IMetricsData
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IMetricsData=} [properties] Properties to set
	                     */
	                    function MetricsData(properties) {
	                        this.resourceMetrics = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * MetricsData resourceMetrics.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IResourceMetrics>} resourceMetrics
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @instance
	                     */
	                    MetricsData.prototype.resourceMetrics = $util.emptyArray;
	                    /**
	                     * Creates a new MetricsData instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IMetricsData=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData instance
	                     */
	                    MetricsData.create = function create(properties) {
	                        return new MetricsData(properties);
	                    };
	                    /**
	                     * Encodes the specified MetricsData message. Does not implicitly {@link opentelemetry.proto.metrics.v1.MetricsData.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IMetricsData} message MetricsData message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    MetricsData.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.resourceMetrics != null && message.resourceMetrics.length)
	                            for (var i = 0; i < message.resourceMetrics.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.ResourceMetrics.encode(message.resourceMetrics[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified MetricsData message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.MetricsData.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IMetricsData} message MetricsData message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    MetricsData.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a MetricsData message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    MetricsData.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.MetricsData();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.resourceMetrics && message.resourceMetrics.length))
	                                        message.resourceMetrics = [];
	                                    message.resourceMetrics.push($root.opentelemetry.proto.metrics.v1.ResourceMetrics.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a MetricsData message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    MetricsData.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a MetricsData message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    MetricsData.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.resourceMetrics != null && message.hasOwnProperty("resourceMetrics")) {
	                            if (!Array.isArray(message.resourceMetrics))
	                                return "resourceMetrics: array expected";
	                            for (var i = 0; i < message.resourceMetrics.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.verify(message.resourceMetrics[i]);
	                                if (error)
	                                    return "resourceMetrics." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a MetricsData message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.MetricsData} MetricsData
	                     */
	                    MetricsData.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.MetricsData)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.MetricsData();
	                        if (object.resourceMetrics) {
	                            if (!Array.isArray(object.resourceMetrics))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: array expected");
	                            message.resourceMetrics = [];
	                            for (var i = 0; i < object.resourceMetrics.length; ++i) {
	                                if (typeof object.resourceMetrics[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.MetricsData.resourceMetrics: object expected");
	                                message.resourceMetrics[i] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.fromObject(object.resourceMetrics[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a MetricsData message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.MetricsData} message MetricsData
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    MetricsData.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.resourceMetrics = [];
	                        if (message.resourceMetrics && message.resourceMetrics.length) {
	                            object.resourceMetrics = [];
	                            for (var j = 0; j < message.resourceMetrics.length; ++j)
	                                object.resourceMetrics[j] = $root.opentelemetry.proto.metrics.v1.ResourceMetrics.toObject(message.resourceMetrics[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this MetricsData to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    MetricsData.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for MetricsData
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.MetricsData
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    MetricsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.MetricsData";
	                    };
	                    return MetricsData;
	                })();
	                v1.ResourceMetrics = (function () {
	                    /**
	                     * Properties of a ResourceMetrics.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IResourceMetrics
	                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceMetrics resource
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IScopeMetrics>|null} [scopeMetrics] ResourceMetrics scopeMetrics
	                     * @property {string|null} [schemaUrl] ResourceMetrics schemaUrl
	                     */
	                    /**
	                     * Constructs a new ResourceMetrics.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a ResourceMetrics.
	                     * @implements IResourceMetrics
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics=} [properties] Properties to set
	                     */
	                    function ResourceMetrics(properties) {
	                        this.scopeMetrics = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ResourceMetrics resource.
	                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @instance
	                     */
	                    ResourceMetrics.prototype.resource = null;
	                    /**
	                     * ResourceMetrics scopeMetrics.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IScopeMetrics>} scopeMetrics
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @instance
	                     */
	                    ResourceMetrics.prototype.scopeMetrics = $util.emptyArray;
	                    /**
	                     * ResourceMetrics schemaUrl.
	                     * @member {string|null|undefined} schemaUrl
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @instance
	                     */
	                    ResourceMetrics.prototype.schemaUrl = null;
	                    /**
	                     * Creates a new ResourceMetrics instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics instance
	                     */
	                    ResourceMetrics.create = function create(properties) {
	                        return new ResourceMetrics(properties);
	                    };
	                    /**
	                     * Encodes the specified ResourceMetrics message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ResourceMetrics.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics} message ResourceMetrics message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ResourceMetrics.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
	                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.scopeMetrics != null && message.scopeMetrics.length)
	                            for (var i = 0; i < message.scopeMetrics.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.ScopeMetrics.encode(message.scopeMetrics[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.schemaUrl);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ResourceMetrics message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ResourceMetrics.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IResourceMetrics} message ResourceMetrics message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ResourceMetrics.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a ResourceMetrics message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ResourceMetrics.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 2: {
	                                    if (!(message.scopeMetrics && message.scopeMetrics.length))
	                                        message.scopeMetrics = [];
	                                    message.scopeMetrics.push($root.opentelemetry.proto.metrics.v1.ScopeMetrics.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 3: {
	                                    message.schemaUrl = reader.string();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a ResourceMetrics message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ResourceMetrics.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a ResourceMetrics message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ResourceMetrics.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.resource != null && message.hasOwnProperty("resource")) {
	                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
	                            if (error)
	                                return "resource." + error;
	                        }
	                        if (message.scopeMetrics != null && message.hasOwnProperty("scopeMetrics")) {
	                            if (!Array.isArray(message.scopeMetrics))
	                                return "scopeMetrics: array expected";
	                            for (var i = 0; i < message.scopeMetrics.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.verify(message.scopeMetrics[i]);
	                                if (error)
	                                    return "scopeMetrics." + error;
	                            }
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            if (!$util.isString(message.schemaUrl))
	                                return "schemaUrl: string expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a ResourceMetrics message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.ResourceMetrics} ResourceMetrics
	                     */
	                    ResourceMetrics.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ResourceMetrics)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.ResourceMetrics();
	                        if (object.resource != null) {
	                            if (typeof object.resource !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.resource: object expected");
	                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
	                        }
	                        if (object.scopeMetrics) {
	                            if (!Array.isArray(object.scopeMetrics))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: array expected");
	                            message.scopeMetrics = [];
	                            for (var i = 0; i < object.scopeMetrics.length; ++i) {
	                                if (typeof object.scopeMetrics[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.ResourceMetrics.scopeMetrics: object expected");
	                                message.scopeMetrics[i] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.fromObject(object.scopeMetrics[i]);
	                            }
	                        }
	                        if (object.schemaUrl != null)
	                            message.schemaUrl = String(object.schemaUrl);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a ResourceMetrics message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ResourceMetrics} message ResourceMetrics
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ResourceMetrics.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.scopeMetrics = [];
	                        if (options.defaults) {
	                            object.resource = null;
	                            object.schemaUrl = "";
	                        }
	                        if (message.resource != null && message.hasOwnProperty("resource"))
	                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
	                        if (message.scopeMetrics && message.scopeMetrics.length) {
	                            object.scopeMetrics = [];
	                            for (var j = 0; j < message.scopeMetrics.length; ++j)
	                                object.scopeMetrics[j] = $root.opentelemetry.proto.metrics.v1.ScopeMetrics.toObject(message.scopeMetrics[j], options);
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            object.schemaUrl = message.schemaUrl;
	                        return object;
	                    };
	                    /**
	                     * Converts this ResourceMetrics to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ResourceMetrics.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ResourceMetrics
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.ResourceMetrics
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ResourceMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ResourceMetrics";
	                    };
	                    return ResourceMetrics;
	                })();
	                v1.ScopeMetrics = (function () {
	                    /**
	                     * Properties of a ScopeMetrics.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IScopeMetrics
	                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeMetrics scope
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IMetric>|null} [metrics] ScopeMetrics metrics
	                     * @property {string|null} [schemaUrl] ScopeMetrics schemaUrl
	                     */
	                    /**
	                     * Constructs a new ScopeMetrics.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a ScopeMetrics.
	                     * @implements IScopeMetrics
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics=} [properties] Properties to set
	                     */
	                    function ScopeMetrics(properties) {
	                        this.metrics = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ScopeMetrics scope.
	                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @instance
	                     */
	                    ScopeMetrics.prototype.scope = null;
	                    /**
	                     * ScopeMetrics metrics.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IMetric>} metrics
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @instance
	                     */
	                    ScopeMetrics.prototype.metrics = $util.emptyArray;
	                    /**
	                     * ScopeMetrics schemaUrl.
	                     * @member {string|null|undefined} schemaUrl
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @instance
	                     */
	                    ScopeMetrics.prototype.schemaUrl = null;
	                    /**
	                     * Creates a new ScopeMetrics instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics instance
	                     */
	                    ScopeMetrics.create = function create(properties) {
	                        return new ScopeMetrics(properties);
	                    };
	                    /**
	                     * Encodes the specified ScopeMetrics message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ScopeMetrics.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics} message ScopeMetrics message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ScopeMetrics.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
	                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.metrics != null && message.metrics.length)
	                            for (var i = 0; i < message.metrics.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.Metric.encode(message.metrics[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.schemaUrl);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ScopeMetrics message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ScopeMetrics.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IScopeMetrics} message ScopeMetrics message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ScopeMetrics.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a ScopeMetrics message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ScopeMetrics.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 2: {
	                                    if (!(message.metrics && message.metrics.length))
	                                        message.metrics = [];
	                                    message.metrics.push($root.opentelemetry.proto.metrics.v1.Metric.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 3: {
	                                    message.schemaUrl = reader.string();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a ScopeMetrics message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ScopeMetrics.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a ScopeMetrics message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ScopeMetrics.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.scope != null && message.hasOwnProperty("scope")) {
	                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
	                            if (error)
	                                return "scope." + error;
	                        }
	                        if (message.metrics != null && message.hasOwnProperty("metrics")) {
	                            if (!Array.isArray(message.metrics))
	                                return "metrics: array expected";
	                            for (var i = 0; i < message.metrics.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.Metric.verify(message.metrics[i]);
	                                if (error)
	                                    return "metrics." + error;
	                            }
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            if (!$util.isString(message.schemaUrl))
	                                return "schemaUrl: string expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a ScopeMetrics message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.ScopeMetrics} ScopeMetrics
	                     */
	                    ScopeMetrics.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ScopeMetrics)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.ScopeMetrics();
	                        if (object.scope != null) {
	                            if (typeof object.scope !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.scope: object expected");
	                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
	                        }
	                        if (object.metrics) {
	                            if (!Array.isArray(object.metrics))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: array expected");
	                            message.metrics = [];
	                            for (var i = 0; i < object.metrics.length; ++i) {
	                                if (typeof object.metrics[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.ScopeMetrics.metrics: object expected");
	                                message.metrics[i] = $root.opentelemetry.proto.metrics.v1.Metric.fromObject(object.metrics[i]);
	                            }
	                        }
	                        if (object.schemaUrl != null)
	                            message.schemaUrl = String(object.schemaUrl);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a ScopeMetrics message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ScopeMetrics} message ScopeMetrics
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ScopeMetrics.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.metrics = [];
	                        if (options.defaults) {
	                            object.scope = null;
	                            object.schemaUrl = "";
	                        }
	                        if (message.scope != null && message.hasOwnProperty("scope"))
	                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
	                        if (message.metrics && message.metrics.length) {
	                            object.metrics = [];
	                            for (var j = 0; j < message.metrics.length; ++j)
	                                object.metrics[j] = $root.opentelemetry.proto.metrics.v1.Metric.toObject(message.metrics[j], options);
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            object.schemaUrl = message.schemaUrl;
	                        return object;
	                    };
	                    /**
	                     * Converts this ScopeMetrics to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ScopeMetrics.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ScopeMetrics
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.ScopeMetrics
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ScopeMetrics.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ScopeMetrics";
	                    };
	                    return ScopeMetrics;
	                })();
	                v1.Metric = (function () {
	                    /**
	                     * Properties of a Metric.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IMetric
	                     * @property {string|null} [name] Metric name
	                     * @property {string|null} [description] Metric description
	                     * @property {string|null} [unit] Metric unit
	                     * @property {opentelemetry.proto.metrics.v1.IGauge|null} [gauge] Metric gauge
	                     * @property {opentelemetry.proto.metrics.v1.ISum|null} [sum] Metric sum
	                     * @property {opentelemetry.proto.metrics.v1.IHistogram|null} [histogram] Metric histogram
	                     * @property {opentelemetry.proto.metrics.v1.IExponentialHistogram|null} [exponentialHistogram] Metric exponentialHistogram
	                     * @property {opentelemetry.proto.metrics.v1.ISummary|null} [summary] Metric summary
	                     */
	                    /**
	                     * Constructs a new Metric.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a Metric.
	                     * @implements IMetric
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IMetric=} [properties] Properties to set
	                     */
	                    function Metric(properties) {
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Metric name.
	                     * @member {string|null|undefined} name
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.name = null;
	                    /**
	                     * Metric description.
	                     * @member {string|null|undefined} description
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.description = null;
	                    /**
	                     * Metric unit.
	                     * @member {string|null|undefined} unit
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.unit = null;
	                    /**
	                     * Metric gauge.
	                     * @member {opentelemetry.proto.metrics.v1.IGauge|null|undefined} gauge
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.gauge = null;
	                    /**
	                     * Metric sum.
	                     * @member {opentelemetry.proto.metrics.v1.ISum|null|undefined} sum
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.sum = null;
	                    /**
	                     * Metric histogram.
	                     * @member {opentelemetry.proto.metrics.v1.IHistogram|null|undefined} histogram
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.histogram = null;
	                    /**
	                     * Metric exponentialHistogram.
	                     * @member {opentelemetry.proto.metrics.v1.IExponentialHistogram|null|undefined} exponentialHistogram
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.exponentialHistogram = null;
	                    /**
	                     * Metric summary.
	                     * @member {opentelemetry.proto.metrics.v1.ISummary|null|undefined} summary
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Metric.prototype.summary = null;
	                    // OneOf field names bound to virtual getters and setters
	                    var $oneOfFields;
	                    /**
	                     * Metric data.
	                     * @member {"gauge"|"sum"|"histogram"|"exponentialHistogram"|"summary"|undefined} data
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     */
	                    Object.defineProperty(Metric.prototype, "data", {
	                        get: $util.oneOfGetter($oneOfFields = ["gauge", "sum", "histogram", "exponentialHistogram", "summary"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    /**
	                     * Creates a new Metric instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IMetric=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric instance
	                     */
	                    Metric.create = function create(properties) {
	                        return new Metric(properties);
	                    };
	                    /**
	                     * Encodes the specified Metric message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Metric.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IMetric} message Metric message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Metric.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.name != null && Object.hasOwnProperty.call(message, "name"))
	                            writer.uint32(/* id 1, wireType 2 =*/ 10).string(message.name);
	                        if (message.description != null && Object.hasOwnProperty.call(message, "description"))
	                            writer.uint32(/* id 2, wireType 2 =*/ 18).string(message.description);
	                        if (message.unit != null && Object.hasOwnProperty.call(message, "unit"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.unit);
	                        if (message.gauge != null && Object.hasOwnProperty.call(message, "gauge"))
	                            $root.opentelemetry.proto.metrics.v1.Gauge.encode(message.gauge, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
	                        if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
	                            $root.opentelemetry.proto.metrics.v1.Sum.encode(message.sum, writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
	                        if (message.histogram != null && Object.hasOwnProperty.call(message, "histogram"))
	                            $root.opentelemetry.proto.metrics.v1.Histogram.encode(message.histogram, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
	                        if (message.exponentialHistogram != null && Object.hasOwnProperty.call(message, "exponentialHistogram"))
	                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.encode(message.exponentialHistogram, writer.uint32(/* id 10, wireType 2 =*/ 82).fork()).ldelim();
	                        if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
	                            $root.opentelemetry.proto.metrics.v1.Summary.encode(message.summary, writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Metric message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Metric.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IMetric} message Metric message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Metric.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Metric message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Metric.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Metric();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.name = reader.string();
	                                    break;
	                                }
	                                case 2: {
	                                    message.description = reader.string();
	                                    break;
	                                }
	                                case 3: {
	                                    message.unit = reader.string();
	                                    break;
	                                }
	                                case 5: {
	                                    message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 7: {
	                                    message.sum = $root.opentelemetry.proto.metrics.v1.Sum.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 9: {
	                                    message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 10: {
	                                    message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 11: {
	                                    message.summary = $root.opentelemetry.proto.metrics.v1.Summary.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Metric message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Metric.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Metric message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Metric.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        var properties = {};
	                        if (message.name != null && message.hasOwnProperty("name"))
	                            if (!$util.isString(message.name))
	                                return "name: string expected";
	                        if (message.description != null && message.hasOwnProperty("description"))
	                            if (!$util.isString(message.description))
	                                return "description: string expected";
	                        if (message.unit != null && message.hasOwnProperty("unit"))
	                            if (!$util.isString(message.unit))
	                                return "unit: string expected";
	                        if (message.gauge != null && message.hasOwnProperty("gauge")) {
	                            properties.data = 1;
	                            {
	                                var error = $root.opentelemetry.proto.metrics.v1.Gauge.verify(message.gauge);
	                                if (error)
	                                    return "gauge." + error;
	                            }
	                        }
	                        if (message.sum != null && message.hasOwnProperty("sum")) {
	                            if (properties.data === 1)
	                                return "data: multiple values";
	                            properties.data = 1;
	                            {
	                                var error = $root.opentelemetry.proto.metrics.v1.Sum.verify(message.sum);
	                                if (error)
	                                    return "sum." + error;
	                            }
	                        }
	                        if (message.histogram != null && message.hasOwnProperty("histogram")) {
	                            if (properties.data === 1)
	                                return "data: multiple values";
	                            properties.data = 1;
	                            {
	                                var error = $root.opentelemetry.proto.metrics.v1.Histogram.verify(message.histogram);
	                                if (error)
	                                    return "histogram." + error;
	                            }
	                        }
	                        if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
	                            if (properties.data === 1)
	                                return "data: multiple values";
	                            properties.data = 1;
	                            {
	                                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.verify(message.exponentialHistogram);
	                                if (error)
	                                    return "exponentialHistogram." + error;
	                            }
	                        }
	                        if (message.summary != null && message.hasOwnProperty("summary")) {
	                            if (properties.data === 1)
	                                return "data: multiple values";
	                            properties.data = 1;
	                            {
	                                var error = $root.opentelemetry.proto.metrics.v1.Summary.verify(message.summary);
	                                if (error)
	                                    return "summary." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a Metric message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.Metric} Metric
	                     */
	                    Metric.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Metric)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.Metric();
	                        if (object.name != null)
	                            message.name = String(object.name);
	                        if (object.description != null)
	                            message.description = String(object.description);
	                        if (object.unit != null)
	                            message.unit = String(object.unit);
	                        if (object.gauge != null) {
	                            if (typeof object.gauge !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Metric.gauge: object expected");
	                            message.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.fromObject(object.gauge);
	                        }
	                        if (object.sum != null) {
	                            if (typeof object.sum !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Metric.sum: object expected");
	                            message.sum = $root.opentelemetry.proto.metrics.v1.Sum.fromObject(object.sum);
	                        }
	                        if (object.histogram != null) {
	                            if (typeof object.histogram !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Metric.histogram: object expected");
	                            message.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.fromObject(object.histogram);
	                        }
	                        if (object.exponentialHistogram != null) {
	                            if (typeof object.exponentialHistogram !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Metric.exponentialHistogram: object expected");
	                            message.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.fromObject(object.exponentialHistogram);
	                        }
	                        if (object.summary != null) {
	                            if (typeof object.summary !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Metric.summary: object expected");
	                            message.summary = $root.opentelemetry.proto.metrics.v1.Summary.fromObject(object.summary);
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Metric message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.Metric} message Metric
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Metric.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.defaults) {
	                            object.name = "";
	                            object.description = "";
	                            object.unit = "";
	                        }
	                        if (message.name != null && message.hasOwnProperty("name"))
	                            object.name = message.name;
	                        if (message.description != null && message.hasOwnProperty("description"))
	                            object.description = message.description;
	                        if (message.unit != null && message.hasOwnProperty("unit"))
	                            object.unit = message.unit;
	                        if (message.gauge != null && message.hasOwnProperty("gauge")) {
	                            object.gauge = $root.opentelemetry.proto.metrics.v1.Gauge.toObject(message.gauge, options);
	                            if (options.oneofs)
	                                object.data = "gauge";
	                        }
	                        if (message.sum != null && message.hasOwnProperty("sum")) {
	                            object.sum = $root.opentelemetry.proto.metrics.v1.Sum.toObject(message.sum, options);
	                            if (options.oneofs)
	                                object.data = "sum";
	                        }
	                        if (message.histogram != null && message.hasOwnProperty("histogram")) {
	                            object.histogram = $root.opentelemetry.proto.metrics.v1.Histogram.toObject(message.histogram, options);
	                            if (options.oneofs)
	                                object.data = "histogram";
	                        }
	                        if (message.exponentialHistogram != null && message.hasOwnProperty("exponentialHistogram")) {
	                            object.exponentialHistogram = $root.opentelemetry.proto.metrics.v1.ExponentialHistogram.toObject(message.exponentialHistogram, options);
	                            if (options.oneofs)
	                                object.data = "exponentialHistogram";
	                        }
	                        if (message.summary != null && message.hasOwnProperty("summary")) {
	                            object.summary = $root.opentelemetry.proto.metrics.v1.Summary.toObject(message.summary, options);
	                            if (options.oneofs)
	                                object.data = "summary";
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this Metric to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Metric.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Metric
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.Metric
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Metric.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Metric";
	                    };
	                    return Metric;
	                })();
	                v1.Gauge = (function () {
	                    /**
	                     * Properties of a Gauge.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IGauge
	                     * @property {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>|null} [dataPoints] Gauge dataPoints
	                     */
	                    /**
	                     * Constructs a new Gauge.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a Gauge.
	                     * @implements IGauge
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IGauge=} [properties] Properties to set
	                     */
	                    function Gauge(properties) {
	                        this.dataPoints = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Gauge dataPoints.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>} dataPoints
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @instance
	                     */
	                    Gauge.prototype.dataPoints = $util.emptyArray;
	                    /**
	                     * Creates a new Gauge instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IGauge=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge instance
	                     */
	                    Gauge.create = function create(properties) {
	                        return new Gauge(properties);
	                    };
	                    /**
	                     * Encodes the specified Gauge message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Gauge.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IGauge} message Gauge message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Gauge.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.dataPoints != null && message.dataPoints.length)
	                            for (var i = 0; i < message.dataPoints.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Gauge message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Gauge.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IGauge} message Gauge message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Gauge.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Gauge message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Gauge.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Gauge();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.dataPoints && message.dataPoints.length))
	                                        message.dataPoints = [];
	                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Gauge message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Gauge.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Gauge message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Gauge.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
	                            if (!Array.isArray(message.dataPoints))
	                                return "dataPoints: array expected";
	                            for (var i = 0; i < message.dataPoints.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);
	                                if (error)
	                                    return "dataPoints." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a Gauge message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.Gauge} Gauge
	                     */
	                    Gauge.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Gauge)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.Gauge();
	                        if (object.dataPoints) {
	                            if (!Array.isArray(object.dataPoints))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: array expected");
	                            message.dataPoints = [];
	                            for (var i = 0; i < object.dataPoints.length; ++i) {
	                                if (typeof object.dataPoints[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.Gauge.dataPoints: object expected");
	                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Gauge message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.Gauge} message Gauge
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Gauge.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.dataPoints = [];
	                        if (message.dataPoints && message.dataPoints.length) {
	                            object.dataPoints = [];
	                            for (var j = 0; j < message.dataPoints.length; ++j)
	                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this Gauge to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Gauge.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Gauge
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.Gauge
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Gauge.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Gauge";
	                    };
	                    return Gauge;
	                })();
	                v1.Sum = (function () {
	                    /**
	                     * Properties of a Sum.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface ISum
	                     * @property {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>|null} [dataPoints] Sum dataPoints
	                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] Sum aggregationTemporality
	                     * @property {boolean|null} [isMonotonic] Sum isMonotonic
	                     */
	                    /**
	                     * Constructs a new Sum.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a Sum.
	                     * @implements ISum
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.ISum=} [properties] Properties to set
	                     */
	                    function Sum(properties) {
	                        this.dataPoints = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Sum dataPoints.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.INumberDataPoint>} dataPoints
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @instance
	                     */
	                    Sum.prototype.dataPoints = $util.emptyArray;
	                    /**
	                     * Sum aggregationTemporality.
	                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @instance
	                     */
	                    Sum.prototype.aggregationTemporality = null;
	                    /**
	                     * Sum isMonotonic.
	                     * @member {boolean|null|undefined} isMonotonic
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @instance
	                     */
	                    Sum.prototype.isMonotonic = null;
	                    /**
	                     * Creates a new Sum instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISum=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum instance
	                     */
	                    Sum.create = function create(properties) {
	                        return new Sum(properties);
	                    };
	                    /**
	                     * Encodes the specified Sum message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Sum.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISum} message Sum message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Sum.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.dataPoints != null && message.dataPoints.length)
	                            for (var i = 0; i < message.dataPoints.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.NumberDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
	                            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.aggregationTemporality);
	                        if (message.isMonotonic != null && Object.hasOwnProperty.call(message, "isMonotonic"))
	                            writer.uint32(/* id 3, wireType 0 =*/ 24).bool(message.isMonotonic);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Sum message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Sum.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISum} message Sum message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Sum.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Sum message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Sum.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Sum();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.dataPoints && message.dataPoints.length))
	                                        message.dataPoints = [];
	                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.NumberDataPoint.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.aggregationTemporality = reader.int32();
	                                    break;
	                                }
	                                case 3: {
	                                    message.isMonotonic = reader.bool();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Sum message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Sum.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Sum message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Sum.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
	                            if (!Array.isArray(message.dataPoints))
	                                return "dataPoints: array expected";
	                            for (var i = 0; i < message.dataPoints.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.verify(message.dataPoints[i]);
	                                if (error)
	                                    return "dataPoints." + error;
	                            }
	                        }
	                        if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
	                            switch (message.aggregationTemporality) {
	                                default:
	                                    return "aggregationTemporality: enum value expected";
	                                case 0:
	                                case 1:
	                                case 2:
	                                    break;
	                            }
	                        if (message.isMonotonic != null && message.hasOwnProperty("isMonotonic"))
	                            if (typeof message.isMonotonic !== "boolean")
	                                return "isMonotonic: boolean expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a Sum message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.Sum} Sum
	                     */
	                    Sum.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Sum)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.Sum();
	                        if (object.dataPoints) {
	                            if (!Array.isArray(object.dataPoints))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: array expected");
	                            message.dataPoints = [];
	                            for (var i = 0; i < object.dataPoints.length; ++i) {
	                                if (typeof object.dataPoints[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.Sum.dataPoints: object expected");
	                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.fromObject(object.dataPoints[i]);
	                            }
	                        }
	                        switch (object.aggregationTemporality) {
	                            default:
	                                if (typeof object.aggregationTemporality === "number") {
	                                    message.aggregationTemporality = object.aggregationTemporality;
	                                    break;
	                                }
	                                break;
	                            case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
	                            case 0:
	                                message.aggregationTemporality = 0;
	                                break;
	                            case "AGGREGATION_TEMPORALITY_DELTA":
	                            case 1:
	                                message.aggregationTemporality = 1;
	                                break;
	                            case "AGGREGATION_TEMPORALITY_CUMULATIVE":
	                            case 2:
	                                message.aggregationTemporality = 2;
	                                break;
	                        }
	                        if (object.isMonotonic != null)
	                            message.isMonotonic = Boolean(object.isMonotonic);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Sum message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.Sum} message Sum
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Sum.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.dataPoints = [];
	                        if (options.defaults) {
	                            object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
	                            object.isMonotonic = false;
	                        }
	                        if (message.dataPoints && message.dataPoints.length) {
	                            object.dataPoints = [];
	                            for (var j = 0; j < message.dataPoints.length; ++j)
	                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.NumberDataPoint.toObject(message.dataPoints[j], options);
	                        }
	                        if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
	                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
	                        if (message.isMonotonic != null && message.hasOwnProperty("isMonotonic"))
	                            object.isMonotonic = message.isMonotonic;
	                        return object;
	                    };
	                    /**
	                     * Converts this Sum to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Sum.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Sum
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.Sum
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Sum.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Sum";
	                    };
	                    return Sum;
	                })();
	                v1.Histogram = (function () {
	                    /**
	                     * Properties of a Histogram.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IHistogram
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IHistogramDataPoint>|null} [dataPoints] Histogram dataPoints
	                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] Histogram aggregationTemporality
	                     */
	                    /**
	                     * Constructs a new Histogram.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a Histogram.
	                     * @implements IHistogram
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IHistogram=} [properties] Properties to set
	                     */
	                    function Histogram(properties) {
	                        this.dataPoints = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Histogram dataPoints.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IHistogramDataPoint>} dataPoints
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @instance
	                     */
	                    Histogram.prototype.dataPoints = $util.emptyArray;
	                    /**
	                     * Histogram aggregationTemporality.
	                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @instance
	                     */
	                    Histogram.prototype.aggregationTemporality = null;
	                    /**
	                     * Creates a new Histogram instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IHistogram=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram instance
	                     */
	                    Histogram.create = function create(properties) {
	                        return new Histogram(properties);
	                    };
	                    /**
	                     * Encodes the specified Histogram message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Histogram.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IHistogram} message Histogram message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Histogram.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.dataPoints != null && message.dataPoints.length)
	                            for (var i = 0; i < message.dataPoints.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
	                            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.aggregationTemporality);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Histogram message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Histogram.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IHistogram} message Histogram message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Histogram.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Histogram message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Histogram.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Histogram();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.dataPoints && message.dataPoints.length))
	                                        message.dataPoints = [];
	                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.HistogramDataPoint.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.aggregationTemporality = reader.int32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Histogram message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Histogram.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Histogram message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Histogram.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
	                            if (!Array.isArray(message.dataPoints))
	                                return "dataPoints: array expected";
	                            for (var i = 0; i < message.dataPoints.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.verify(message.dataPoints[i]);
	                                if (error)
	                                    return "dataPoints." + error;
	                            }
	                        }
	                        if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
	                            switch (message.aggregationTemporality) {
	                                default:
	                                    return "aggregationTemporality: enum value expected";
	                                case 0:
	                                case 1:
	                                case 2:
	                                    break;
	                            }
	                        return null;
	                    };
	                    /**
	                     * Creates a Histogram message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.Histogram} Histogram
	                     */
	                    Histogram.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Histogram)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.Histogram();
	                        if (object.dataPoints) {
	                            if (!Array.isArray(object.dataPoints))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: array expected");
	                            message.dataPoints = [];
	                            for (var i = 0; i < object.dataPoints.length; ++i) {
	                                if (typeof object.dataPoints[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.Histogram.dataPoints: object expected");
	                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.fromObject(object.dataPoints[i]);
	                            }
	                        }
	                        switch (object.aggregationTemporality) {
	                            default:
	                                if (typeof object.aggregationTemporality === "number") {
	                                    message.aggregationTemporality = object.aggregationTemporality;
	                                    break;
	                                }
	                                break;
	                            case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
	                            case 0:
	                                message.aggregationTemporality = 0;
	                                break;
	                            case "AGGREGATION_TEMPORALITY_DELTA":
	                            case 1:
	                                message.aggregationTemporality = 1;
	                                break;
	                            case "AGGREGATION_TEMPORALITY_CUMULATIVE":
	                            case 2:
	                                message.aggregationTemporality = 2;
	                                break;
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Histogram message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.Histogram} message Histogram
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Histogram.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.dataPoints = [];
	                        if (options.defaults)
	                            object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
	                        if (message.dataPoints && message.dataPoints.length) {
	                            object.dataPoints = [];
	                            for (var j = 0; j < message.dataPoints.length; ++j)
	                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.HistogramDataPoint.toObject(message.dataPoints[j], options);
	                        }
	                        if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
	                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
	                        return object;
	                    };
	                    /**
	                     * Converts this Histogram to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Histogram.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Histogram
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.Histogram
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Histogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Histogram";
	                    };
	                    return Histogram;
	                })();
	                v1.ExponentialHistogram = (function () {
	                    /**
	                     * Properties of an ExponentialHistogram.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IExponentialHistogram
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint>|null} [dataPoints] ExponentialHistogram dataPoints
	                     * @property {opentelemetry.proto.metrics.v1.AggregationTemporality|null} [aggregationTemporality] ExponentialHistogram aggregationTemporality
	                     */
	                    /**
	                     * Constructs a new ExponentialHistogram.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents an ExponentialHistogram.
	                     * @implements IExponentialHistogram
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram=} [properties] Properties to set
	                     */
	                    function ExponentialHistogram(properties) {
	                        this.dataPoints = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ExponentialHistogram dataPoints.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint>} dataPoints
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @instance
	                     */
	                    ExponentialHistogram.prototype.dataPoints = $util.emptyArray;
	                    /**
	                     * ExponentialHistogram aggregationTemporality.
	                     * @member {opentelemetry.proto.metrics.v1.AggregationTemporality|null|undefined} aggregationTemporality
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @instance
	                     */
	                    ExponentialHistogram.prototype.aggregationTemporality = null;
	                    /**
	                     * Creates a new ExponentialHistogram instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram instance
	                     */
	                    ExponentialHistogram.create = function create(properties) {
	                        return new ExponentialHistogram(properties);
	                    };
	                    /**
	                     * Encodes the specified ExponentialHistogram message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogram.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram} message ExponentialHistogram message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ExponentialHistogram.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.dataPoints != null && message.dataPoints.length)
	                            for (var i = 0; i < message.dataPoints.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.aggregationTemporality != null && Object.hasOwnProperty.call(message, "aggregationTemporality"))
	                            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.aggregationTemporality);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ExponentialHistogram message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogram.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogram} message ExponentialHistogram message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ExponentialHistogram.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes an ExponentialHistogram message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ExponentialHistogram.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.dataPoints && message.dataPoints.length))
	                                        message.dataPoints = [];
	                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.aggregationTemporality = reader.int32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes an ExponentialHistogram message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ExponentialHistogram.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies an ExponentialHistogram message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ExponentialHistogram.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
	                            if (!Array.isArray(message.dataPoints))
	                                return "dataPoints: array expected";
	                            for (var i = 0; i < message.dataPoints.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify(message.dataPoints[i]);
	                                if (error)
	                                    return "dataPoints." + error;
	                            }
	                        }
	                        if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
	                            switch (message.aggregationTemporality) {
	                                default:
	                                    return "aggregationTemporality: enum value expected";
	                                case 0:
	                                case 1:
	                                case 2:
	                                    break;
	                            }
	                        return null;
	                    };
	                    /**
	                     * Creates an ExponentialHistogram message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogram} ExponentialHistogram
	                     */
	                    ExponentialHistogram.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogram)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogram();
	                        if (object.dataPoints) {
	                            if (!Array.isArray(object.dataPoints))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: array expected");
	                            message.dataPoints = [];
	                            for (var i = 0; i < object.dataPoints.length; ++i) {
	                                if (typeof object.dataPoints[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogram.dataPoints: object expected");
	                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.fromObject(object.dataPoints[i]);
	                            }
	                        }
	                        switch (object.aggregationTemporality) {
	                            default:
	                                if (typeof object.aggregationTemporality === "number") {
	                                    message.aggregationTemporality = object.aggregationTemporality;
	                                    break;
	                                }
	                                break;
	                            case "AGGREGATION_TEMPORALITY_UNSPECIFIED":
	                            case 0:
	                                message.aggregationTemporality = 0;
	                                break;
	                            case "AGGREGATION_TEMPORALITY_DELTA":
	                            case 1:
	                                message.aggregationTemporality = 1;
	                                break;
	                            case "AGGREGATION_TEMPORALITY_CUMULATIVE":
	                            case 2:
	                                message.aggregationTemporality = 2;
	                                break;
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from an ExponentialHistogram message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ExponentialHistogram} message ExponentialHistogram
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ExponentialHistogram.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.dataPoints = [];
	                        if (options.defaults)
	                            object.aggregationTemporality = options.enums === String ? "AGGREGATION_TEMPORALITY_UNSPECIFIED" : 0;
	                        if (message.dataPoints && message.dataPoints.length) {
	                            object.dataPoints = [];
	                            for (var j = 0; j < message.dataPoints.length; ++j)
	                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.toObject(message.dataPoints[j], options);
	                        }
	                        if (message.aggregationTemporality != null && message.hasOwnProperty("aggregationTemporality"))
	                            object.aggregationTemporality = options.enums === String ? $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] === undefined ? message.aggregationTemporality : $root.opentelemetry.proto.metrics.v1.AggregationTemporality[message.aggregationTemporality] : message.aggregationTemporality;
	                        return object;
	                    };
	                    /**
	                     * Converts this ExponentialHistogram to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ExponentialHistogram.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ExponentialHistogram
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogram
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ExponentialHistogram.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogram";
	                    };
	                    return ExponentialHistogram;
	                })();
	                v1.Summary = (function () {
	                    /**
	                     * Properties of a Summary.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface ISummary
	                     * @property {Array.<opentelemetry.proto.metrics.v1.ISummaryDataPoint>|null} [dataPoints] Summary dataPoints
	                     */
	                    /**
	                     * Constructs a new Summary.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a Summary.
	                     * @implements ISummary
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.ISummary=} [properties] Properties to set
	                     */
	                    function Summary(properties) {
	                        this.dataPoints = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Summary dataPoints.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.ISummaryDataPoint>} dataPoints
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @instance
	                     */
	                    Summary.prototype.dataPoints = $util.emptyArray;
	                    /**
	                     * Creates a new Summary instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISummary=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary instance
	                     */
	                    Summary.create = function create(properties) {
	                        return new Summary(properties);
	                    };
	                    /**
	                     * Encodes the specified Summary message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Summary.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISummary} message Summary message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Summary.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.dataPoints != null && message.dataPoints.length)
	                            for (var i = 0; i < message.dataPoints.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.encode(message.dataPoints[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Summary message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Summary.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISummary} message Summary message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Summary.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a Summary message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Summary.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Summary();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.dataPoints && message.dataPoints.length))
	                                        message.dataPoints = [];
	                                    message.dataPoints.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a Summary message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Summary.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a Summary message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Summary.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.dataPoints != null && message.hasOwnProperty("dataPoints")) {
	                            if (!Array.isArray(message.dataPoints))
	                                return "dataPoints: array expected";
	                            for (var i = 0; i < message.dataPoints.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.verify(message.dataPoints[i]);
	                                if (error)
	                                    return "dataPoints." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a Summary message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.Summary} Summary
	                     */
	                    Summary.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Summary)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.Summary();
	                        if (object.dataPoints) {
	                            if (!Array.isArray(object.dataPoints))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: array expected");
	                            message.dataPoints = [];
	                            for (var i = 0; i < object.dataPoints.length; ++i) {
	                                if (typeof object.dataPoints[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.Summary.dataPoints: object expected");
	                                message.dataPoints[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.fromObject(object.dataPoints[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a Summary message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.Summary} message Summary
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Summary.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.dataPoints = [];
	                        if (message.dataPoints && message.dataPoints.length) {
	                            object.dataPoints = [];
	                            for (var j = 0; j < message.dataPoints.length; ++j)
	                                object.dataPoints[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.toObject(message.dataPoints[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this Summary to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Summary.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Summary
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.Summary
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Summary.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Summary";
	                    };
	                    return Summary;
	                })();
	                /**
	                 * AggregationTemporality enum.
	                 * @name opentelemetry.proto.metrics.v1.AggregationTemporality
	                 * @enum {number}
	                 * @property {number} AGGREGATION_TEMPORALITY_UNSPECIFIED=0 AGGREGATION_TEMPORALITY_UNSPECIFIED value
	                 * @property {number} AGGREGATION_TEMPORALITY_DELTA=1 AGGREGATION_TEMPORALITY_DELTA value
	                 * @property {number} AGGREGATION_TEMPORALITY_CUMULATIVE=2 AGGREGATION_TEMPORALITY_CUMULATIVE value
	                 */
	                v1.AggregationTemporality = (function () {
	                    var valuesById = {}, values = Object.create(valuesById);
	                    values[valuesById[0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0;
	                    values[valuesById[1] = "AGGREGATION_TEMPORALITY_DELTA"] = 1;
	                    values[valuesById[2] = "AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2;
	                    return values;
	                })();
	                /**
	                 * DataPointFlags enum.
	                 * @name opentelemetry.proto.metrics.v1.DataPointFlags
	                 * @enum {number}
	                 * @property {number} DATA_POINT_FLAGS_DO_NOT_USE=0 DATA_POINT_FLAGS_DO_NOT_USE value
	                 * @property {number} DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK=1 DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK value
	                 */
	                v1.DataPointFlags = (function () {
	                    var valuesById = {}, values = Object.create(valuesById);
	                    values[valuesById[0] = "DATA_POINT_FLAGS_DO_NOT_USE"] = 0;
	                    values[valuesById[1] = "DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK"] = 1;
	                    return values;
	                })();
	                v1.NumberDataPoint = (function () {
	                    /**
	                     * Properties of a NumberDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface INumberDataPoint
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] NumberDataPoint attributes
	                     * @property {number|Long|null} [startTimeUnixNano] NumberDataPoint startTimeUnixNano
	                     * @property {number|Long|null} [timeUnixNano] NumberDataPoint timeUnixNano
	                     * @property {number|null} [asDouble] NumberDataPoint asDouble
	                     * @property {number|Long|null} [asInt] NumberDataPoint asInt
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] NumberDataPoint exemplars
	                     * @property {number|null} [flags] NumberDataPoint flags
	                     */
	                    /**
	                     * Constructs a new NumberDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a NumberDataPoint.
	                     * @implements INumberDataPoint
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint=} [properties] Properties to set
	                     */
	                    function NumberDataPoint(properties) {
	                        this.attributes = [];
	                        this.exemplars = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * NumberDataPoint attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.attributes = $util.emptyArray;
	                    /**
	                     * NumberDataPoint startTimeUnixNano.
	                     * @member {number|Long|null|undefined} startTimeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.startTimeUnixNano = null;
	                    /**
	                     * NumberDataPoint timeUnixNano.
	                     * @member {number|Long|null|undefined} timeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.timeUnixNano = null;
	                    /**
	                     * NumberDataPoint asDouble.
	                     * @member {number|null|undefined} asDouble
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.asDouble = null;
	                    /**
	                     * NumberDataPoint asInt.
	                     * @member {number|Long|null|undefined} asInt
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.asInt = null;
	                    /**
	                     * NumberDataPoint exemplars.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.exemplars = $util.emptyArray;
	                    /**
	                     * NumberDataPoint flags.
	                     * @member {number|null|undefined} flags
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    NumberDataPoint.prototype.flags = null;
	                    // OneOf field names bound to virtual getters and setters
	                    var $oneOfFields;
	                    /**
	                     * NumberDataPoint value.
	                     * @member {"asDouble"|"asInt"|undefined} value
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     */
	                    Object.defineProperty(NumberDataPoint.prototype, "value", {
	                        get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    /**
	                     * Creates a new NumberDataPoint instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint instance
	                     */
	                    NumberDataPoint.create = function create(properties) {
	                        return new NumberDataPoint(properties);
	                    };
	                    /**
	                     * Encodes the specified NumberDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.NumberDataPoint.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint} message NumberDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    NumberDataPoint.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
	                            writer.uint32(/* id 2, wireType 1 =*/ 17).fixed64(message.startTimeUnixNano);
	                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                            writer.uint32(/* id 3, wireType 1 =*/ 25).fixed64(message.timeUnixNano);
	                        if (message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble"))
	                            writer.uint32(/* id 4, wireType 1 =*/ 33).double(message.asDouble);
	                        if (message.exemplars != null && message.exemplars.length)
	                            for (var i = 0; i < message.exemplars.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
	                        if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt"))
	                            writer.uint32(/* id 6, wireType 1 =*/ 49).sfixed64(message.asInt);
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
	                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
	                            writer.uint32(/* id 8, wireType 0 =*/ 64).uint32(message.flags);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified NumberDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.NumberDataPoint.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.INumberDataPoint} message NumberDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    NumberDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a NumberDataPoint message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    NumberDataPoint.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 7: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.startTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 3: {
	                                    message.timeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 4: {
	                                    message.asDouble = reader.double();
	                                    break;
	                                }
	                                case 6: {
	                                    message.asInt = reader.sfixed64();
	                                    break;
	                                }
	                                case 5: {
	                                    if (!(message.exemplars && message.exemplars.length))
	                                        message.exemplars = [];
	                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 8: {
	                                    message.flags = reader.uint32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a NumberDataPoint message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    NumberDataPoint.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a NumberDataPoint message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    NumberDataPoint.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        var properties = {};
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
	                                return "startTimeUnixNano: integer|Long expected";
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                return "timeUnixNano: integer|Long expected";
	                        if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
	                            properties.value = 1;
	                            if (typeof message.asDouble !== "number")
	                                return "asDouble: number expected";
	                        }
	                        if (message.asInt != null && message.hasOwnProperty("asInt")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
	                                return "asInt: integer|Long expected";
	                        }
	                        if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
	                            if (!Array.isArray(message.exemplars))
	                                return "exemplars: array expected";
	                            for (var i = 0; i < message.exemplars.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
	                                if (error)
	                                    return "exemplars." + error;
	                            }
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            if (!$util.isInteger(message.flags))
	                                return "flags: integer expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a NumberDataPoint message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.NumberDataPoint} NumberDataPoint
	                     */
	                    NumberDataPoint.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.NumberDataPoint)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.NumberDataPoint();
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.startTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
	                            else if (typeof object.startTimeUnixNano === "string")
	                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
	                            else if (typeof object.startTimeUnixNano === "number")
	                                message.startTimeUnixNano = object.startTimeUnixNano;
	                            else if (typeof object.startTimeUnixNano === "object")
	                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
	                        if (object.timeUnixNano != null)
	                            if ($util.Long)
	                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                            else if (typeof object.timeUnixNano === "string")
	                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                            else if (typeof object.timeUnixNano === "number")
	                                message.timeUnixNano = object.timeUnixNano;
	                            else if (typeof object.timeUnixNano === "object")
	                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                        if (object.asDouble != null)
	                            message.asDouble = Number(object.asDouble);
	                        if (object.asInt != null)
	                            if ($util.Long)
	                                (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;
	                            else if (typeof object.asInt === "string")
	                                message.asInt = parseInt(object.asInt, 10);
	                            else if (typeof object.asInt === "number")
	                                message.asInt = object.asInt;
	                            else if (typeof object.asInt === "object")
	                                message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();
	                        if (object.exemplars) {
	                            if (!Array.isArray(object.exemplars))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: array expected");
	                            message.exemplars = [];
	                            for (var i = 0; i < object.exemplars.length; ++i) {
	                                if (typeof object.exemplars[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.NumberDataPoint.exemplars: object expected");
	                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
	                            }
	                        }
	                        if (object.flags != null)
	                            message.flags = object.flags >>> 0;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a NumberDataPoint message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.NumberDataPoint} message NumberDataPoint
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    NumberDataPoint.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults) {
	                            object.exemplars = [];
	                            object.attributes = [];
	                        }
	                        if (options.defaults) {
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.startTimeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.timeUnixNano = options.longs === String ? "0" : 0;
	                            object.flags = 0;
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (typeof message.startTimeUnixNano === "number")
	                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
	                            else
	                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (typeof message.timeUnixNano === "number")
	                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                            else
	                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                        if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
	                            object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;
	                            if (options.oneofs)
	                                object.value = "asDouble";
	                        }
	                        if (message.exemplars && message.exemplars.length) {
	                            object.exemplars = [];
	                            for (var j = 0; j < message.exemplars.length; ++j)
	                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
	                        }
	                        if (message.asInt != null && message.hasOwnProperty("asInt")) {
	                            if (typeof message.asInt === "number")
	                                object.asInt = options.longs === String ? String(message.asInt) : message.asInt;
	                            else
	                                object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;
	                            if (options.oneofs)
	                                object.value = "asInt";
	                        }
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            object.flags = message.flags;
	                        return object;
	                    };
	                    /**
	                     * Converts this NumberDataPoint to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    NumberDataPoint.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for NumberDataPoint
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.NumberDataPoint
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    NumberDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.NumberDataPoint";
	                    };
	                    return NumberDataPoint;
	                })();
	                v1.HistogramDataPoint = (function () {
	                    /**
	                     * Properties of a HistogramDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IHistogramDataPoint
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] HistogramDataPoint attributes
	                     * @property {number|Long|null} [startTimeUnixNano] HistogramDataPoint startTimeUnixNano
	                     * @property {number|Long|null} [timeUnixNano] HistogramDataPoint timeUnixNano
	                     * @property {number|Long|null} [count] HistogramDataPoint count
	                     * @property {number|null} [sum] HistogramDataPoint sum
	                     * @property {Array.<number|Long>|null} [bucketCounts] HistogramDataPoint bucketCounts
	                     * @property {Array.<number>|null} [explicitBounds] HistogramDataPoint explicitBounds
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] HistogramDataPoint exemplars
	                     * @property {number|null} [flags] HistogramDataPoint flags
	                     * @property {number|null} [min] HistogramDataPoint min
	                     * @property {number|null} [max] HistogramDataPoint max
	                     */
	                    /**
	                     * Constructs a new HistogramDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a HistogramDataPoint.
	                     * @implements IHistogramDataPoint
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint=} [properties] Properties to set
	                     */
	                    function HistogramDataPoint(properties) {
	                        this.attributes = [];
	                        this.bucketCounts = [];
	                        this.explicitBounds = [];
	                        this.exemplars = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * HistogramDataPoint attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.attributes = $util.emptyArray;
	                    /**
	                     * HistogramDataPoint startTimeUnixNano.
	                     * @member {number|Long|null|undefined} startTimeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.startTimeUnixNano = null;
	                    /**
	                     * HistogramDataPoint timeUnixNano.
	                     * @member {number|Long|null|undefined} timeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.timeUnixNano = null;
	                    /**
	                     * HistogramDataPoint count.
	                     * @member {number|Long|null|undefined} count
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.count = null;
	                    /**
	                     * HistogramDataPoint sum.
	                     * @member {number|null|undefined} sum
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.sum = null;
	                    /**
	                     * HistogramDataPoint bucketCounts.
	                     * @member {Array.<number|Long>} bucketCounts
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.bucketCounts = $util.emptyArray;
	                    /**
	                     * HistogramDataPoint explicitBounds.
	                     * @member {Array.<number>} explicitBounds
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.explicitBounds = $util.emptyArray;
	                    /**
	                     * HistogramDataPoint exemplars.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.exemplars = $util.emptyArray;
	                    /**
	                     * HistogramDataPoint flags.
	                     * @member {number|null|undefined} flags
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.flags = null;
	                    /**
	                     * HistogramDataPoint min.
	                     * @member {number|null|undefined} min
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.min = null;
	                    /**
	                     * HistogramDataPoint max.
	                     * @member {number|null|undefined} max
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     */
	                    HistogramDataPoint.prototype.max = null;
	                    // OneOf field names bound to virtual getters and setters
	                    var $oneOfFields;
	                    // Virtual OneOf for proto3 optional field
	                    Object.defineProperty(HistogramDataPoint.prototype, "_sum", {
	                        get: $util.oneOfGetter($oneOfFields = ["sum"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    // Virtual OneOf for proto3 optional field
	                    Object.defineProperty(HistogramDataPoint.prototype, "_min", {
	                        get: $util.oneOfGetter($oneOfFields = ["min"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    // Virtual OneOf for proto3 optional field
	                    Object.defineProperty(HistogramDataPoint.prototype, "_max", {
	                        get: $util.oneOfGetter($oneOfFields = ["max"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    /**
	                     * Creates a new HistogramDataPoint instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint instance
	                     */
	                    HistogramDataPoint.create = function create(properties) {
	                        return new HistogramDataPoint(properties);
	                    };
	                    /**
	                     * Encodes the specified HistogramDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.HistogramDataPoint.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint} message HistogramDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    HistogramDataPoint.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
	                            writer.uint32(/* id 2, wireType 1 =*/ 17).fixed64(message.startTimeUnixNano);
	                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                            writer.uint32(/* id 3, wireType 1 =*/ 25).fixed64(message.timeUnixNano);
	                        if (message.count != null && Object.hasOwnProperty.call(message, "count"))
	                            writer.uint32(/* id 4, wireType 1 =*/ 33).fixed64(message.count);
	                        if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
	                            writer.uint32(/* id 5, wireType 1 =*/ 41).double(message.sum);
	                        if (message.bucketCounts != null && message.bucketCounts.length) {
	                            writer.uint32(/* id 6, wireType 2 =*/ 50).fork();
	                            for (var i = 0; i < message.bucketCounts.length; ++i)
	                                writer.fixed64(message.bucketCounts[i]);
	                            writer.ldelim();
	                        }
	                        if (message.explicitBounds != null && message.explicitBounds.length) {
	                            writer.uint32(/* id 7, wireType 2 =*/ 58).fork();
	                            for (var i = 0; i < message.explicitBounds.length; ++i)
	                                writer.double(message.explicitBounds[i]);
	                            writer.ldelim();
	                        }
	                        if (message.exemplars != null && message.exemplars.length)
	                            for (var i = 0; i < message.exemplars.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
	                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
	                            writer.uint32(/* id 10, wireType 0 =*/ 80).uint32(message.flags);
	                        if (message.min != null && Object.hasOwnProperty.call(message, "min"))
	                            writer.uint32(/* id 11, wireType 1 =*/ 89).double(message.min);
	                        if (message.max != null && Object.hasOwnProperty.call(message, "max"))
	                            writer.uint32(/* id 12, wireType 1 =*/ 97).double(message.max);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified HistogramDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.HistogramDataPoint.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IHistogramDataPoint} message HistogramDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    HistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a HistogramDataPoint message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    HistogramDataPoint.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 9: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.startTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 3: {
	                                    message.timeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 4: {
	                                    message.count = reader.fixed64();
	                                    break;
	                                }
	                                case 5: {
	                                    message.sum = reader.double();
	                                    break;
	                                }
	                                case 6: {
	                                    if (!(message.bucketCounts && message.bucketCounts.length))
	                                        message.bucketCounts = [];
	                                    if ((tag & 7) === 2) {
	                                        var end2 = reader.uint32() + reader.pos;
	                                        while (reader.pos < end2)
	                                            message.bucketCounts.push(reader.fixed64());
	                                    }
	                                    else
	                                        message.bucketCounts.push(reader.fixed64());
	                                    break;
	                                }
	                                case 7: {
	                                    if (!(message.explicitBounds && message.explicitBounds.length))
	                                        message.explicitBounds = [];
	                                    if ((tag & 7) === 2) {
	                                        var end2 = reader.uint32() + reader.pos;
	                                        while (reader.pos < end2)
	                                            message.explicitBounds.push(reader.double());
	                                    }
	                                    else
	                                        message.explicitBounds.push(reader.double());
	                                    break;
	                                }
	                                case 8: {
	                                    if (!(message.exemplars && message.exemplars.length))
	                                        message.exemplars = [];
	                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 10: {
	                                    message.flags = reader.uint32();
	                                    break;
	                                }
	                                case 11: {
	                                    message.min = reader.double();
	                                    break;
	                                }
	                                case 12: {
	                                    message.max = reader.double();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a HistogramDataPoint message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    HistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a HistogramDataPoint message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    HistogramDataPoint.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
	                                return "startTimeUnixNano: integer|Long expected";
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                return "timeUnixNano: integer|Long expected";
	                        if (message.count != null && message.hasOwnProperty("count"))
	                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
	                                return "count: integer|Long expected";
	                        if (message.sum != null && message.hasOwnProperty("sum")) {
	                            if (typeof message.sum !== "number")
	                                return "sum: number expected";
	                        }
	                        if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
	                            if (!Array.isArray(message.bucketCounts))
	                                return "bucketCounts: array expected";
	                            for (var i = 0; i < message.bucketCounts.length; ++i)
	                                if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))
	                                    return "bucketCounts: integer|Long[] expected";
	                        }
	                        if (message.explicitBounds != null && message.hasOwnProperty("explicitBounds")) {
	                            if (!Array.isArray(message.explicitBounds))
	                                return "explicitBounds: array expected";
	                            for (var i = 0; i < message.explicitBounds.length; ++i)
	                                if (typeof message.explicitBounds[i] !== "number")
	                                    return "explicitBounds: number[] expected";
	                        }
	                        if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
	                            if (!Array.isArray(message.exemplars))
	                                return "exemplars: array expected";
	                            for (var i = 0; i < message.exemplars.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
	                                if (error)
	                                    return "exemplars." + error;
	                            }
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            if (!$util.isInteger(message.flags))
	                                return "flags: integer expected";
	                        if (message.min != null && message.hasOwnProperty("min")) {
	                            if (typeof message.min !== "number")
	                                return "min: number expected";
	                        }
	                        if (message.max != null && message.hasOwnProperty("max")) {
	                            if (typeof message.max !== "number")
	                                return "max: number expected";
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a HistogramDataPoint message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.HistogramDataPoint} HistogramDataPoint
	                     */
	                    HistogramDataPoint.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.HistogramDataPoint)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.HistogramDataPoint();
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.startTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
	                            else if (typeof object.startTimeUnixNano === "string")
	                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
	                            else if (typeof object.startTimeUnixNano === "number")
	                                message.startTimeUnixNano = object.startTimeUnixNano;
	                            else if (typeof object.startTimeUnixNano === "object")
	                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
	                        if (object.timeUnixNano != null)
	                            if ($util.Long)
	                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                            else if (typeof object.timeUnixNano === "string")
	                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                            else if (typeof object.timeUnixNano === "number")
	                                message.timeUnixNano = object.timeUnixNano;
	                            else if (typeof object.timeUnixNano === "object")
	                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                        if (object.count != null)
	                            if ($util.Long)
	                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;
	                            else if (typeof object.count === "string")
	                                message.count = parseInt(object.count, 10);
	                            else if (typeof object.count === "number")
	                                message.count = object.count;
	                            else if (typeof object.count === "object")
	                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
	                        if (object.sum != null)
	                            message.sum = Number(object.sum);
	                        if (object.bucketCounts) {
	                            if (!Array.isArray(object.bucketCounts))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.bucketCounts: array expected");
	                            message.bucketCounts = [];
	                            for (var i = 0; i < object.bucketCounts.length; ++i)
	                                if ($util.Long)
	                                    (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = false;
	                                else if (typeof object.bucketCounts[i] === "string")
	                                    message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);
	                                else if (typeof object.bucketCounts[i] === "number")
	                                    message.bucketCounts[i] = object.bucketCounts[i];
	                                else if (typeof object.bucketCounts[i] === "object")
	                                    message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber();
	                        }
	                        if (object.explicitBounds) {
	                            if (!Array.isArray(object.explicitBounds))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.explicitBounds: array expected");
	                            message.explicitBounds = [];
	                            for (var i = 0; i < object.explicitBounds.length; ++i)
	                                message.explicitBounds[i] = Number(object.explicitBounds[i]);
	                        }
	                        if (object.exemplars) {
	                            if (!Array.isArray(object.exemplars))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: array expected");
	                            message.exemplars = [];
	                            for (var i = 0; i < object.exemplars.length; ++i) {
	                                if (typeof object.exemplars[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.HistogramDataPoint.exemplars: object expected");
	                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
	                            }
	                        }
	                        if (object.flags != null)
	                            message.flags = object.flags >>> 0;
	                        if (object.min != null)
	                            message.min = Number(object.min);
	                        if (object.max != null)
	                            message.max = Number(object.max);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a HistogramDataPoint message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.HistogramDataPoint} message HistogramDataPoint
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    HistogramDataPoint.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults) {
	                            object.bucketCounts = [];
	                            object.explicitBounds = [];
	                            object.exemplars = [];
	                            object.attributes = [];
	                        }
	                        if (options.defaults) {
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.startTimeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.timeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.count = options.longs === String ? "0" : 0;
	                            object.flags = 0;
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (typeof message.startTimeUnixNano === "number")
	                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
	                            else
	                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (typeof message.timeUnixNano === "number")
	                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                            else
	                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                        if (message.count != null && message.hasOwnProperty("count"))
	                            if (typeof message.count === "number")
	                                object.count = options.longs === String ? String(message.count) : message.count;
	                            else
	                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
	                        if (message.sum != null && message.hasOwnProperty("sum")) {
	                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
	                            if (options.oneofs)
	                                object._sum = "sum";
	                        }
	                        if (message.bucketCounts && message.bucketCounts.length) {
	                            object.bucketCounts = [];
	                            for (var j = 0; j < message.bucketCounts.length; ++j)
	                                if (typeof message.bucketCounts[j] === "number")
	                                    object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];
	                                else
	                                    object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber() : message.bucketCounts[j];
	                        }
	                        if (message.explicitBounds && message.explicitBounds.length) {
	                            object.explicitBounds = [];
	                            for (var j = 0; j < message.explicitBounds.length; ++j)
	                                object.explicitBounds[j] = options.json && !isFinite(message.explicitBounds[j]) ? String(message.explicitBounds[j]) : message.explicitBounds[j];
	                        }
	                        if (message.exemplars && message.exemplars.length) {
	                            object.exemplars = [];
	                            for (var j = 0; j < message.exemplars.length; ++j)
	                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
	                        }
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            object.flags = message.flags;
	                        if (message.min != null && message.hasOwnProperty("min")) {
	                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
	                            if (options.oneofs)
	                                object._min = "min";
	                        }
	                        if (message.max != null && message.hasOwnProperty("max")) {
	                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
	                            if (options.oneofs)
	                                object._max = "max";
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this HistogramDataPoint to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    HistogramDataPoint.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for HistogramDataPoint
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.HistogramDataPoint
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    HistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.HistogramDataPoint";
	                    };
	                    return HistogramDataPoint;
	                })();
	                v1.ExponentialHistogramDataPoint = (function () {
	                    /**
	                     * Properties of an ExponentialHistogramDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IExponentialHistogramDataPoint
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] ExponentialHistogramDataPoint attributes
	                     * @property {number|Long|null} [startTimeUnixNano] ExponentialHistogramDataPoint startTimeUnixNano
	                     * @property {number|Long|null} [timeUnixNano] ExponentialHistogramDataPoint timeUnixNano
	                     * @property {number|Long|null} [count] ExponentialHistogramDataPoint count
	                     * @property {number|null} [sum] ExponentialHistogramDataPoint sum
	                     * @property {number|null} [scale] ExponentialHistogramDataPoint scale
	                     * @property {number|Long|null} [zeroCount] ExponentialHistogramDataPoint zeroCount
	                     * @property {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null} [positive] ExponentialHistogramDataPoint positive
	                     * @property {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null} [negative] ExponentialHistogramDataPoint negative
	                     * @property {number|null} [flags] ExponentialHistogramDataPoint flags
	                     * @property {Array.<opentelemetry.proto.metrics.v1.IExemplar>|null} [exemplars] ExponentialHistogramDataPoint exemplars
	                     * @property {number|null} [min] ExponentialHistogramDataPoint min
	                     * @property {number|null} [max] ExponentialHistogramDataPoint max
	                     * @property {number|null} [zeroThreshold] ExponentialHistogramDataPoint zeroThreshold
	                     */
	                    /**
	                     * Constructs a new ExponentialHistogramDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents an ExponentialHistogramDataPoint.
	                     * @implements IExponentialHistogramDataPoint
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint=} [properties] Properties to set
	                     */
	                    function ExponentialHistogramDataPoint(properties) {
	                        this.attributes = [];
	                        this.exemplars = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ExponentialHistogramDataPoint attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.attributes = $util.emptyArray;
	                    /**
	                     * ExponentialHistogramDataPoint startTimeUnixNano.
	                     * @member {number|Long|null|undefined} startTimeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.startTimeUnixNano = null;
	                    /**
	                     * ExponentialHistogramDataPoint timeUnixNano.
	                     * @member {number|Long|null|undefined} timeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.timeUnixNano = null;
	                    /**
	                     * ExponentialHistogramDataPoint count.
	                     * @member {number|Long|null|undefined} count
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.count = null;
	                    /**
	                     * ExponentialHistogramDataPoint sum.
	                     * @member {number|null|undefined} sum
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.sum = null;
	                    /**
	                     * ExponentialHistogramDataPoint scale.
	                     * @member {number|null|undefined} scale
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.scale = null;
	                    /**
	                     * ExponentialHistogramDataPoint zeroCount.
	                     * @member {number|Long|null|undefined} zeroCount
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.zeroCount = null;
	                    /**
	                     * ExponentialHistogramDataPoint positive.
	                     * @member {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null|undefined} positive
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.positive = null;
	                    /**
	                     * ExponentialHistogramDataPoint negative.
	                     * @member {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets|null|undefined} negative
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.negative = null;
	                    /**
	                     * ExponentialHistogramDataPoint flags.
	                     * @member {number|null|undefined} flags
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.flags = null;
	                    /**
	                     * ExponentialHistogramDataPoint exemplars.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.IExemplar>} exemplars
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.exemplars = $util.emptyArray;
	                    /**
	                     * ExponentialHistogramDataPoint min.
	                     * @member {number|null|undefined} min
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.min = null;
	                    /**
	                     * ExponentialHistogramDataPoint max.
	                     * @member {number|null|undefined} max
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.max = null;
	                    /**
	                     * ExponentialHistogramDataPoint zeroThreshold.
	                     * @member {number|null|undefined} zeroThreshold
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     */
	                    ExponentialHistogramDataPoint.prototype.zeroThreshold = null;
	                    // OneOf field names bound to virtual getters and setters
	                    var $oneOfFields;
	                    // Virtual OneOf for proto3 optional field
	                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_sum", {
	                        get: $util.oneOfGetter($oneOfFields = ["sum"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    // Virtual OneOf for proto3 optional field
	                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_min", {
	                        get: $util.oneOfGetter($oneOfFields = ["min"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    // Virtual OneOf for proto3 optional field
	                    Object.defineProperty(ExponentialHistogramDataPoint.prototype, "_max", {
	                        get: $util.oneOfGetter($oneOfFields = ["max"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    /**
	                     * Creates a new ExponentialHistogramDataPoint instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint instance
	                     */
	                    ExponentialHistogramDataPoint.create = function create(properties) {
	                        return new ExponentialHistogramDataPoint(properties);
	                    };
	                    /**
	                     * Encodes the specified ExponentialHistogramDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint} message ExponentialHistogramDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ExponentialHistogramDataPoint.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
	                            writer.uint32(/* id 2, wireType 1 =*/ 17).fixed64(message.startTimeUnixNano);
	                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                            writer.uint32(/* id 3, wireType 1 =*/ 25).fixed64(message.timeUnixNano);
	                        if (message.count != null && Object.hasOwnProperty.call(message, "count"))
	                            writer.uint32(/* id 4, wireType 1 =*/ 33).fixed64(message.count);
	                        if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
	                            writer.uint32(/* id 5, wireType 1 =*/ 41).double(message.sum);
	                        if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
	                            writer.uint32(/* id 6, wireType 0 =*/ 48).sint32(message.scale);
	                        if (message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount"))
	                            writer.uint32(/* id 7, wireType 1 =*/ 57).fixed64(message.zeroCount);
	                        if (message.positive != null && Object.hasOwnProperty.call(message, "positive"))
	                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.positive, writer.uint32(/* id 8, wireType 2 =*/ 66).fork()).ldelim();
	                        if (message.negative != null && Object.hasOwnProperty.call(message, "negative"))
	                            $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.encode(message.negative, writer.uint32(/* id 9, wireType 2 =*/ 74).fork()).ldelim();
	                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
	                            writer.uint32(/* id 10, wireType 0 =*/ 80).uint32(message.flags);
	                        if (message.exemplars != null && message.exemplars.length)
	                            for (var i = 0; i < message.exemplars.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.Exemplar.encode(message.exemplars[i], writer.uint32(/* id 11, wireType 2 =*/ 90).fork()).ldelim();
	                        if (message.min != null && Object.hasOwnProperty.call(message, "min"))
	                            writer.uint32(/* id 12, wireType 1 =*/ 97).double(message.min);
	                        if (message.max != null && Object.hasOwnProperty.call(message, "max"))
	                            writer.uint32(/* id 13, wireType 1 =*/ 105).double(message.max);
	                        if (message.zeroThreshold != null && Object.hasOwnProperty.call(message, "zeroThreshold"))
	                            writer.uint32(/* id 14, wireType 1 =*/ 113).double(message.zeroThreshold);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ExponentialHistogramDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExponentialHistogramDataPoint} message ExponentialHistogramDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ExponentialHistogramDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes an ExponentialHistogramDataPoint message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ExponentialHistogramDataPoint.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.startTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 3: {
	                                    message.timeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 4: {
	                                    message.count = reader.fixed64();
	                                    break;
	                                }
	                                case 5: {
	                                    message.sum = reader.double();
	                                    break;
	                                }
	                                case 6: {
	                                    message.scale = reader.sint32();
	                                    break;
	                                }
	                                case 7: {
	                                    message.zeroCount = reader.fixed64();
	                                    break;
	                                }
	                                case 8: {
	                                    message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 9: {
	                                    message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 10: {
	                                    message.flags = reader.uint32();
	                                    break;
	                                }
	                                case 11: {
	                                    if (!(message.exemplars && message.exemplars.length))
	                                        message.exemplars = [];
	                                    message.exemplars.push($root.opentelemetry.proto.metrics.v1.Exemplar.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 12: {
	                                    message.min = reader.double();
	                                    break;
	                                }
	                                case 13: {
	                                    message.max = reader.double();
	                                    break;
	                                }
	                                case 14: {
	                                    message.zeroThreshold = reader.double();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes an ExponentialHistogramDataPoint message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ExponentialHistogramDataPoint.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies an ExponentialHistogramDataPoint message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ExponentialHistogramDataPoint.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
	                                return "startTimeUnixNano: integer|Long expected";
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                return "timeUnixNano: integer|Long expected";
	                        if (message.count != null && message.hasOwnProperty("count"))
	                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
	                                return "count: integer|Long expected";
	                        if (message.sum != null && message.hasOwnProperty("sum")) {
	                            if (typeof message.sum !== "number")
	                                return "sum: number expected";
	                        }
	                        if (message.scale != null && message.hasOwnProperty("scale"))
	                            if (!$util.isInteger(message.scale))
	                                return "scale: integer expected";
	                        if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
	                            if (!$util.isInteger(message.zeroCount) && !(message.zeroCount && $util.isInteger(message.zeroCount.low) && $util.isInteger(message.zeroCount.high)))
	                                return "zeroCount: integer|Long expected";
	                        if (message.positive != null && message.hasOwnProperty("positive")) {
	                            var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.positive);
	                            if (error)
	                                return "positive." + error;
	                        }
	                        if (message.negative != null && message.hasOwnProperty("negative")) {
	                            var error = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify(message.negative);
	                            if (error)
	                                return "negative." + error;
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            if (!$util.isInteger(message.flags))
	                                return "flags: integer expected";
	                        if (message.exemplars != null && message.hasOwnProperty("exemplars")) {
	                            if (!Array.isArray(message.exemplars))
	                                return "exemplars: array expected";
	                            for (var i = 0; i < message.exemplars.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.Exemplar.verify(message.exemplars[i]);
	                                if (error)
	                                    return "exemplars." + error;
	                            }
	                        }
	                        if (message.min != null && message.hasOwnProperty("min")) {
	                            if (typeof message.min !== "number")
	                                return "min: number expected";
	                        }
	                        if (message.max != null && message.hasOwnProperty("max")) {
	                            if (typeof message.max !== "number")
	                                return "max: number expected";
	                        }
	                        if (message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold"))
	                            if (typeof message.zeroThreshold !== "number")
	                                return "zeroThreshold: number expected";
	                        return null;
	                    };
	                    /**
	                     * Creates an ExponentialHistogramDataPoint message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} ExponentialHistogramDataPoint
	                     */
	                    ExponentialHistogramDataPoint.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint();
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.startTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
	                            else if (typeof object.startTimeUnixNano === "string")
	                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
	                            else if (typeof object.startTimeUnixNano === "number")
	                                message.startTimeUnixNano = object.startTimeUnixNano;
	                            else if (typeof object.startTimeUnixNano === "object")
	                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
	                        if (object.timeUnixNano != null)
	                            if ($util.Long)
	                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                            else if (typeof object.timeUnixNano === "string")
	                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                            else if (typeof object.timeUnixNano === "number")
	                                message.timeUnixNano = object.timeUnixNano;
	                            else if (typeof object.timeUnixNano === "object")
	                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                        if (object.count != null)
	                            if ($util.Long)
	                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;
	                            else if (typeof object.count === "string")
	                                message.count = parseInt(object.count, 10);
	                            else if (typeof object.count === "number")
	                                message.count = object.count;
	                            else if (typeof object.count === "object")
	                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
	                        if (object.sum != null)
	                            message.sum = Number(object.sum);
	                        if (object.scale != null)
	                            message.scale = object.scale | 0;
	                        if (object.zeroCount != null)
	                            if ($util.Long)
	                                (message.zeroCount = $util.Long.fromValue(object.zeroCount)).unsigned = false;
	                            else if (typeof object.zeroCount === "string")
	                                message.zeroCount = parseInt(object.zeroCount, 10);
	                            else if (typeof object.zeroCount === "number")
	                                message.zeroCount = object.zeroCount;
	                            else if (typeof object.zeroCount === "object")
	                                message.zeroCount = new $util.LongBits(object.zeroCount.low >>> 0, object.zeroCount.high >>> 0).toNumber();
	                        if (object.positive != null) {
	                            if (typeof object.positive !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.positive: object expected");
	                            message.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.positive);
	                        }
	                        if (object.negative != null) {
	                            if (typeof object.negative !== "object")
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.negative: object expected");
	                            message.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.fromObject(object.negative);
	                        }
	                        if (object.flags != null)
	                            message.flags = object.flags >>> 0;
	                        if (object.exemplars) {
	                            if (!Array.isArray(object.exemplars))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: array expected");
	                            message.exemplars = [];
	                            for (var i = 0; i < object.exemplars.length; ++i) {
	                                if (typeof object.exemplars[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.exemplars: object expected");
	                                message.exemplars[i] = $root.opentelemetry.proto.metrics.v1.Exemplar.fromObject(object.exemplars[i]);
	                            }
	                        }
	                        if (object.min != null)
	                            message.min = Number(object.min);
	                        if (object.max != null)
	                            message.max = Number(object.max);
	                        if (object.zeroThreshold != null)
	                            message.zeroThreshold = Number(object.zeroThreshold);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from an ExponentialHistogramDataPoint message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint} message ExponentialHistogramDataPoint
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ExponentialHistogramDataPoint.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults) {
	                            object.attributes = [];
	                            object.exemplars = [];
	                        }
	                        if (options.defaults) {
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.startTimeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.timeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.count = options.longs === String ? "0" : 0;
	                            object.scale = 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.zeroCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.zeroCount = options.longs === String ? "0" : 0;
	                            object.positive = null;
	                            object.negative = null;
	                            object.flags = 0;
	                            object.zeroThreshold = 0;
	                        }
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (typeof message.startTimeUnixNano === "number")
	                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
	                            else
	                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (typeof message.timeUnixNano === "number")
	                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                            else
	                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                        if (message.count != null && message.hasOwnProperty("count"))
	                            if (typeof message.count === "number")
	                                object.count = options.longs === String ? String(message.count) : message.count;
	                            else
	                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
	                        if (message.sum != null && message.hasOwnProperty("sum")) {
	                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
	                            if (options.oneofs)
	                                object._sum = "sum";
	                        }
	                        if (message.scale != null && message.hasOwnProperty("scale"))
	                            object.scale = message.scale;
	                        if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
	                            if (typeof message.zeroCount === "number")
	                                object.zeroCount = options.longs === String ? String(message.zeroCount) : message.zeroCount;
	                            else
	                                object.zeroCount = options.longs === String ? $util.Long.prototype.toString.call(message.zeroCount) : options.longs === Number ? new $util.LongBits(message.zeroCount.low >>> 0, message.zeroCount.high >>> 0).toNumber() : message.zeroCount;
	                        if (message.positive != null && message.hasOwnProperty("positive"))
	                            object.positive = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.positive, options);
	                        if (message.negative != null && message.hasOwnProperty("negative"))
	                            object.negative = $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.toObject(message.negative, options);
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            object.flags = message.flags;
	                        if (message.exemplars && message.exemplars.length) {
	                            object.exemplars = [];
	                            for (var j = 0; j < message.exemplars.length; ++j)
	                                object.exemplars[j] = $root.opentelemetry.proto.metrics.v1.Exemplar.toObject(message.exemplars[j], options);
	                        }
	                        if (message.min != null && message.hasOwnProperty("min")) {
	                            object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
	                            if (options.oneofs)
	                                object._min = "min";
	                        }
	                        if (message.max != null && message.hasOwnProperty("max")) {
	                            object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
	                            if (options.oneofs)
	                                object._max = "max";
	                        }
	                        if (message.zeroThreshold != null && message.hasOwnProperty("zeroThreshold"))
	                            object.zeroThreshold = options.json && !isFinite(message.zeroThreshold) ? String(message.zeroThreshold) : message.zeroThreshold;
	                        return object;
	                    };
	                    /**
	                     * Converts this ExponentialHistogramDataPoint to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ExponentialHistogramDataPoint.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ExponentialHistogramDataPoint
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ExponentialHistogramDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint";
	                    };
	                    ExponentialHistogramDataPoint.Buckets = (function () {
	                        /**
	                         * Properties of a Buckets.
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                         * @interface IBuckets
	                         * @property {number|null} [offset] Buckets offset
	                         * @property {Array.<number|Long>|null} [bucketCounts] Buckets bucketCounts
	                         */
	                        /**
	                         * Constructs a new Buckets.
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
	                         * @classdesc Represents a Buckets.
	                         * @implements IBuckets
	                         * @constructor
	                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets=} [properties] Properties to set
	                         */
	                        function Buckets(properties) {
	                            this.bucketCounts = [];
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * Buckets offset.
	                         * @member {number|null|undefined} offset
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @instance
	                         */
	                        Buckets.prototype.offset = null;
	                        /**
	                         * Buckets bucketCounts.
	                         * @member {Array.<number|Long>} bucketCounts
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @instance
	                         */
	                        Buckets.prototype.bucketCounts = $util.emptyArray;
	                        /**
	                         * Creates a new Buckets instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets instance
	                         */
	                        Buckets.create = function create(properties) {
	                            return new Buckets(properties);
	                        };
	                        /**
	                         * Encodes the specified Buckets message. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets} message Buckets message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        Buckets.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
	                                writer.uint32(/* id 1, wireType 0 =*/ 8).sint32(message.offset);
	                            if (message.bucketCounts != null && message.bucketCounts.length) {
	                                writer.uint32(/* id 2, wireType 2 =*/ 18).fork();
	                                for (var i = 0; i < message.bucketCounts.length; ++i)
	                                    writer.uint64(message.bucketCounts[i]);
	                                writer.ldelim();
	                            }
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified Buckets message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.IBuckets} message Buckets message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        Buckets.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes a Buckets message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        Buckets.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.offset = reader.sint32();
	                                        break;
	                                    }
	                                    case 2: {
	                                        if (!(message.bucketCounts && message.bucketCounts.length))
	                                            message.bucketCounts = [];
	                                        if ((tag & 7) === 2) {
	                                            var end2 = reader.uint32() + reader.pos;
	                                            while (reader.pos < end2)
	                                                message.bucketCounts.push(reader.uint64());
	                                        }
	                                        else
	                                            message.bucketCounts.push(reader.uint64());
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes a Buckets message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        Buckets.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies a Buckets message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        Buckets.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.offset != null && message.hasOwnProperty("offset"))
	                                if (!$util.isInteger(message.offset))
	                                    return "offset: integer expected";
	                            if (message.bucketCounts != null && message.hasOwnProperty("bucketCounts")) {
	                                if (!Array.isArray(message.bucketCounts))
	                                    return "bucketCounts: array expected";
	                                for (var i = 0; i < message.bucketCounts.length; ++i)
	                                    if (!$util.isInteger(message.bucketCounts[i]) && !(message.bucketCounts[i] && $util.isInteger(message.bucketCounts[i].low) && $util.isInteger(message.bucketCounts[i].high)))
	                                        return "bucketCounts: integer|Long[] expected";
	                            }
	                            return null;
	                        };
	                        /**
	                         * Creates a Buckets message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} Buckets
	                         */
	                        Buckets.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets)
	                                return object;
	                            var message = new $root.opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets();
	                            if (object.offset != null)
	                                message.offset = object.offset | 0;
	                            if (object.bucketCounts) {
	                                if (!Array.isArray(object.bucketCounts))
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets.bucketCounts: array expected");
	                                message.bucketCounts = [];
	                                for (var i = 0; i < object.bucketCounts.length; ++i)
	                                    if ($util.Long)
	                                        (message.bucketCounts[i] = $util.Long.fromValue(object.bucketCounts[i])).unsigned = true;
	                                    else if (typeof object.bucketCounts[i] === "string")
	                                        message.bucketCounts[i] = parseInt(object.bucketCounts[i], 10);
	                                    else if (typeof object.bucketCounts[i] === "number")
	                                        message.bucketCounts[i] = object.bucketCounts[i];
	                                    else if (typeof object.bucketCounts[i] === "object")
	                                        message.bucketCounts[i] = new $util.LongBits(object.bucketCounts[i].low >>> 0, object.bucketCounts[i].high >>> 0).toNumber(true);
	                            }
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from a Buckets message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets} message Buckets
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        Buckets.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.arrays || options.defaults)
	                                object.bucketCounts = [];
	                            if (options.defaults)
	                                object.offset = 0;
	                            if (message.offset != null && message.hasOwnProperty("offset"))
	                                object.offset = message.offset;
	                            if (message.bucketCounts && message.bucketCounts.length) {
	                                object.bucketCounts = [];
	                                for (var j = 0; j < message.bucketCounts.length; ++j)
	                                    if (typeof message.bucketCounts[j] === "number")
	                                        object.bucketCounts[j] = options.longs === String ? String(message.bucketCounts[j]) : message.bucketCounts[j];
	                                    else
	                                        object.bucketCounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.bucketCounts[j]) : options.longs === Number ? new $util.LongBits(message.bucketCounts[j].low >>> 0, message.bucketCounts[j].high >>> 0).toNumber(true) : message.bucketCounts[j];
	                            }
	                            return object;
	                        };
	                        /**
	                         * Converts this Buckets to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        Buckets.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for Buckets
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        Buckets.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets";
	                        };
	                        return Buckets;
	                    })();
	                    return ExponentialHistogramDataPoint;
	                })();
	                v1.SummaryDataPoint = (function () {
	                    /**
	                     * Properties of a SummaryDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface ISummaryDataPoint
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] SummaryDataPoint attributes
	                     * @property {number|Long|null} [startTimeUnixNano] SummaryDataPoint startTimeUnixNano
	                     * @property {number|Long|null} [timeUnixNano] SummaryDataPoint timeUnixNano
	                     * @property {number|Long|null} [count] SummaryDataPoint count
	                     * @property {number|null} [sum] SummaryDataPoint sum
	                     * @property {Array.<opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile>|null} [quantileValues] SummaryDataPoint quantileValues
	                     * @property {number|null} [flags] SummaryDataPoint flags
	                     */
	                    /**
	                     * Constructs a new SummaryDataPoint.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents a SummaryDataPoint.
	                     * @implements ISummaryDataPoint
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint=} [properties] Properties to set
	                     */
	                    function SummaryDataPoint(properties) {
	                        this.attributes = [];
	                        this.quantileValues = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * SummaryDataPoint attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.attributes = $util.emptyArray;
	                    /**
	                     * SummaryDataPoint startTimeUnixNano.
	                     * @member {number|Long|null|undefined} startTimeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.startTimeUnixNano = null;
	                    /**
	                     * SummaryDataPoint timeUnixNano.
	                     * @member {number|Long|null|undefined} timeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.timeUnixNano = null;
	                    /**
	                     * SummaryDataPoint count.
	                     * @member {number|Long|null|undefined} count
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.count = null;
	                    /**
	                     * SummaryDataPoint sum.
	                     * @member {number|null|undefined} sum
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.sum = null;
	                    /**
	                     * SummaryDataPoint quantileValues.
	                     * @member {Array.<opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile>} quantileValues
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.quantileValues = $util.emptyArray;
	                    /**
	                     * SummaryDataPoint flags.
	                     * @member {number|null|undefined} flags
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     */
	                    SummaryDataPoint.prototype.flags = null;
	                    /**
	                     * Creates a new SummaryDataPoint instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint instance
	                     */
	                    SummaryDataPoint.create = function create(properties) {
	                        return new SummaryDataPoint(properties);
	                    };
	                    /**
	                     * Encodes the specified SummaryDataPoint message. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint} message SummaryDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    SummaryDataPoint.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.startTimeUnixNano != null && Object.hasOwnProperty.call(message, "startTimeUnixNano"))
	                            writer.uint32(/* id 2, wireType 1 =*/ 17).fixed64(message.startTimeUnixNano);
	                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                            writer.uint32(/* id 3, wireType 1 =*/ 25).fixed64(message.timeUnixNano);
	                        if (message.count != null && Object.hasOwnProperty.call(message, "count"))
	                            writer.uint32(/* id 4, wireType 1 =*/ 33).fixed64(message.count);
	                        if (message.sum != null && Object.hasOwnProperty.call(message, "sum"))
	                            writer.uint32(/* id 5, wireType 1 =*/ 41).double(message.sum);
	                        if (message.quantileValues != null && message.quantileValues.length)
	                            for (var i = 0; i < message.quantileValues.length; ++i)
	                                $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.encode(message.quantileValues[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
	                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
	                            writer.uint32(/* id 8, wireType 0 =*/ 64).uint32(message.flags);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified SummaryDataPoint message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.ISummaryDataPoint} message SummaryDataPoint message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    SummaryDataPoint.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a SummaryDataPoint message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    SummaryDataPoint.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 7: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.startTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 3: {
	                                    message.timeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 4: {
	                                    message.count = reader.fixed64();
	                                    break;
	                                }
	                                case 5: {
	                                    message.sum = reader.double();
	                                    break;
	                                }
	                                case 6: {
	                                    if (!(message.quantileValues && message.quantileValues.length))
	                                        message.quantileValues = [];
	                                    message.quantileValues.push($root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 8: {
	                                    message.flags = reader.uint32();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a SummaryDataPoint message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    SummaryDataPoint.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a SummaryDataPoint message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    SummaryDataPoint.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (!$util.isInteger(message.startTimeUnixNano) && !(message.startTimeUnixNano && $util.isInteger(message.startTimeUnixNano.low) && $util.isInteger(message.startTimeUnixNano.high)))
	                                return "startTimeUnixNano: integer|Long expected";
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                return "timeUnixNano: integer|Long expected";
	                        if (message.count != null && message.hasOwnProperty("count"))
	                            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
	                                return "count: integer|Long expected";
	                        if (message.sum != null && message.hasOwnProperty("sum"))
	                            if (typeof message.sum !== "number")
	                                return "sum: number expected";
	                        if (message.quantileValues != null && message.hasOwnProperty("quantileValues")) {
	                            if (!Array.isArray(message.quantileValues))
	                                return "quantileValues: array expected";
	                            for (var i = 0; i < message.quantileValues.length; ++i) {
	                                var error = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify(message.quantileValues[i]);
	                                if (error)
	                                    return "quantileValues." + error;
	                            }
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            if (!$util.isInteger(message.flags))
	                                return "flags: integer expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a SummaryDataPoint message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint} SummaryDataPoint
	                     */
	                    SummaryDataPoint.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint();
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.startTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.startTimeUnixNano = $util.Long.fromValue(object.startTimeUnixNano)).unsigned = false;
	                            else if (typeof object.startTimeUnixNano === "string")
	                                message.startTimeUnixNano = parseInt(object.startTimeUnixNano, 10);
	                            else if (typeof object.startTimeUnixNano === "number")
	                                message.startTimeUnixNano = object.startTimeUnixNano;
	                            else if (typeof object.startTimeUnixNano === "object")
	                                message.startTimeUnixNano = new $util.LongBits(object.startTimeUnixNano.low >>> 0, object.startTimeUnixNano.high >>> 0).toNumber();
	                        if (object.timeUnixNano != null)
	                            if ($util.Long)
	                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                            else if (typeof object.timeUnixNano === "string")
	                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                            else if (typeof object.timeUnixNano === "number")
	                                message.timeUnixNano = object.timeUnixNano;
	                            else if (typeof object.timeUnixNano === "object")
	                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                        if (object.count != null)
	                            if ($util.Long)
	                                (message.count = $util.Long.fromValue(object.count)).unsigned = false;
	                            else if (typeof object.count === "string")
	                                message.count = parseInt(object.count, 10);
	                            else if (typeof object.count === "number")
	                                message.count = object.count;
	                            else if (typeof object.count === "object")
	                                message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
	                        if (object.sum != null)
	                            message.sum = Number(object.sum);
	                        if (object.quantileValues) {
	                            if (!Array.isArray(object.quantileValues))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: array expected");
	                            message.quantileValues = [];
	                            for (var i = 0; i < object.quantileValues.length; ++i) {
	                                if (typeof object.quantileValues[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.SummaryDataPoint.quantileValues: object expected");
	                                message.quantileValues[i] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.fromObject(object.quantileValues[i]);
	                            }
	                        }
	                        if (object.flags != null)
	                            message.flags = object.flags >>> 0;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a SummaryDataPoint message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint} message SummaryDataPoint
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    SummaryDataPoint.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults) {
	                            object.quantileValues = [];
	                            object.attributes = [];
	                        }
	                        if (options.defaults) {
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.startTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.startTimeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.timeUnixNano = options.longs === String ? "0" : 0;
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.count = options.longs === String ? "0" : 0;
	                            object.sum = 0;
	                            object.flags = 0;
	                        }
	                        if (message.startTimeUnixNano != null && message.hasOwnProperty("startTimeUnixNano"))
	                            if (typeof message.startTimeUnixNano === "number")
	                                object.startTimeUnixNano = options.longs === String ? String(message.startTimeUnixNano) : message.startTimeUnixNano;
	                            else
	                                object.startTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.startTimeUnixNano.low >>> 0, message.startTimeUnixNano.high >>> 0).toNumber() : message.startTimeUnixNano;
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (typeof message.timeUnixNano === "number")
	                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                            else
	                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                        if (message.count != null && message.hasOwnProperty("count"))
	                            if (typeof message.count === "number")
	                                object.count = options.longs === String ? String(message.count) : message.count;
	                            else
	                                object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
	                        if (message.sum != null && message.hasOwnProperty("sum"))
	                            object.sum = options.json && !isFinite(message.sum) ? String(message.sum) : message.sum;
	                        if (message.quantileValues && message.quantileValues.length) {
	                            object.quantileValues = [];
	                            for (var j = 0; j < message.quantileValues.length; ++j)
	                                object.quantileValues[j] = $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.toObject(message.quantileValues[j], options);
	                        }
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            object.flags = message.flags;
	                        return object;
	                    };
	                    /**
	                     * Converts this SummaryDataPoint to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    SummaryDataPoint.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for SummaryDataPoint
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    SummaryDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint";
	                    };
	                    SummaryDataPoint.ValueAtQuantile = (function () {
	                        /**
	                         * Properties of a ValueAtQuantile.
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                         * @interface IValueAtQuantile
	                         * @property {number|null} [quantile] ValueAtQuantile quantile
	                         * @property {number|null} [value] ValueAtQuantile value
	                         */
	                        /**
	                         * Constructs a new ValueAtQuantile.
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint
	                         * @classdesc Represents a ValueAtQuantile.
	                         * @implements IValueAtQuantile
	                         * @constructor
	                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile=} [properties] Properties to set
	                         */
	                        function ValueAtQuantile(properties) {
	                            if (properties)
	                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                    if (properties[keys[i]] != null)
	                                        this[keys[i]] = properties[keys[i]];
	                        }
	                        /**
	                         * ValueAtQuantile quantile.
	                         * @member {number|null|undefined} quantile
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @instance
	                         */
	                        ValueAtQuantile.prototype.quantile = null;
	                        /**
	                         * ValueAtQuantile value.
	                         * @member {number|null|undefined} value
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @instance
	                         */
	                        ValueAtQuantile.prototype.value = null;
	                        /**
	                         * Creates a new ValueAtQuantile instance using the specified properties.
	                         * @function create
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile=} [properties] Properties to set
	                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile instance
	                         */
	                        ValueAtQuantile.create = function create(properties) {
	                            return new ValueAtQuantile(properties);
	                        };
	                        /**
	                         * Encodes the specified ValueAtQuantile message. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify|verify} messages.
	                         * @function encode
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile} message ValueAtQuantile message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ValueAtQuantile.encode = function encode(message, writer) {
	                            if (!writer)
	                                writer = $Writer.create();
	                            if (message.quantile != null && Object.hasOwnProperty.call(message, "quantile"))
	                                writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.quantile);
	                            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
	                                writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.value);
	                            return writer;
	                        };
	                        /**
	                         * Encodes the specified ValueAtQuantile message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile.verify|verify} messages.
	                         * @function encodeDelimited
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.IValueAtQuantile} message ValueAtQuantile message or plain object to encode
	                         * @param {$protobuf.Writer} [writer] Writer to encode to
	                         * @returns {$protobuf.Writer} Writer
	                         */
	                        ValueAtQuantile.encodeDelimited = function encodeDelimited(message, writer) {
	                            return this.encode(message, writer).ldelim();
	                        };
	                        /**
	                         * Decodes a ValueAtQuantile message from the specified reader or buffer.
	                         * @function decode
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @param {number} [length] Message length if known beforehand
	                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ValueAtQuantile.decode = function decode(reader, length) {
	                            if (!(reader instanceof $Reader))
	                                reader = $Reader.create(reader);
	                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();
	                            while (reader.pos < end) {
	                                var tag = reader.uint32();
	                                switch (tag >>> 3) {
	                                    case 1: {
	                                        message.quantile = reader.double();
	                                        break;
	                                    }
	                                    case 2: {
	                                        message.value = reader.double();
	                                        break;
	                                    }
	                                    default:
	                                        reader.skipType(tag & 7);
	                                        break;
	                                }
	                            }
	                            return message;
	                        };
	                        /**
	                         * Decodes a ValueAtQuantile message from the specified reader or buffer, length delimited.
	                         * @function decodeDelimited
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile
	                         * @throws {Error} If the payload is not a reader or valid buffer
	                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                         */
	                        ValueAtQuantile.decodeDelimited = function decodeDelimited(reader) {
	                            if (!(reader instanceof $Reader))
	                                reader = new $Reader(reader);
	                            return this.decode(reader, reader.uint32());
	                        };
	                        /**
	                         * Verifies a ValueAtQuantile message.
	                         * @function verify
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {Object.<string,*>} message Plain object to verify
	                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                         */
	                        ValueAtQuantile.verify = function verify(message) {
	                            if (typeof message !== "object" || message === null)
	                                return "object expected";
	                            if (message.quantile != null && message.hasOwnProperty("quantile"))
	                                if (typeof message.quantile !== "number")
	                                    return "quantile: number expected";
	                            if (message.value != null && message.hasOwnProperty("value"))
	                                if (typeof message.value !== "number")
	                                    return "value: number expected";
	                            return null;
	                        };
	                        /**
	                         * Creates a ValueAtQuantile message from a plain object. Also converts values to their respective internal types.
	                         * @function fromObject
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {Object.<string,*>} object Plain object
	                         * @returns {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} ValueAtQuantile
	                         */
	                        ValueAtQuantile.fromObject = function fromObject(object) {
	                            if (object instanceof $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile)
	                                return object;
	                            var message = new $root.opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile();
	                            if (object.quantile != null)
	                                message.quantile = Number(object.quantile);
	                            if (object.value != null)
	                                message.value = Number(object.value);
	                            return message;
	                        };
	                        /**
	                         * Creates a plain object from a ValueAtQuantile message. Also converts values to other types if specified.
	                         * @function toObject
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile} message ValueAtQuantile
	                         * @param {$protobuf.IConversionOptions} [options] Conversion options
	                         * @returns {Object.<string,*>} Plain object
	                         */
	                        ValueAtQuantile.toObject = function toObject(message, options) {
	                            if (!options)
	                                options = {};
	                            var object = {};
	                            if (options.defaults) {
	                                object.quantile = 0;
	                                object.value = 0;
	                            }
	                            if (message.quantile != null && message.hasOwnProperty("quantile"))
	                                object.quantile = options.json && !isFinite(message.quantile) ? String(message.quantile) : message.quantile;
	                            if (message.value != null && message.hasOwnProperty("value"))
	                                object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
	                            return object;
	                        };
	                        /**
	                         * Converts this ValueAtQuantile to JSON.
	                         * @function toJSON
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @instance
	                         * @returns {Object.<string,*>} JSON object
	                         */
	                        ValueAtQuantile.prototype.toJSON = function toJSON() {
	                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                        };
	                        /**
	                         * Gets the default type url for ValueAtQuantile
	                         * @function getTypeUrl
	                         * @memberof opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
	                         * @static
	                         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                         * @returns {string} The default type url
	                         */
	                        ValueAtQuantile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                            if (typeUrlPrefix === undefined) {
	                                typeUrlPrefix = "type.googleapis.com";
	                            }
	                            return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile";
	                        };
	                        return ValueAtQuantile;
	                    })();
	                    return SummaryDataPoint;
	                })();
	                v1.Exemplar = (function () {
	                    /**
	                     * Properties of an Exemplar.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @interface IExemplar
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [filteredAttributes] Exemplar filteredAttributes
	                     * @property {number|Long|null} [timeUnixNano] Exemplar timeUnixNano
	                     * @property {number|null} [asDouble] Exemplar asDouble
	                     * @property {number|Long|null} [asInt] Exemplar asInt
	                     * @property {Uint8Array|null} [spanId] Exemplar spanId
	                     * @property {Uint8Array|null} [traceId] Exemplar traceId
	                     */
	                    /**
	                     * Constructs a new Exemplar.
	                     * @memberof opentelemetry.proto.metrics.v1
	                     * @classdesc Represents an Exemplar.
	                     * @implements IExemplar
	                     * @constructor
	                     * @param {opentelemetry.proto.metrics.v1.IExemplar=} [properties] Properties to set
	                     */
	                    function Exemplar(properties) {
	                        this.filteredAttributes = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * Exemplar filteredAttributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} filteredAttributes
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Exemplar.prototype.filteredAttributes = $util.emptyArray;
	                    /**
	                     * Exemplar timeUnixNano.
	                     * @member {number|Long|null|undefined} timeUnixNano
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Exemplar.prototype.timeUnixNano = null;
	                    /**
	                     * Exemplar asDouble.
	                     * @member {number|null|undefined} asDouble
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Exemplar.prototype.asDouble = null;
	                    /**
	                     * Exemplar asInt.
	                     * @member {number|Long|null|undefined} asInt
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Exemplar.prototype.asInt = null;
	                    /**
	                     * Exemplar spanId.
	                     * @member {Uint8Array|null|undefined} spanId
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Exemplar.prototype.spanId = null;
	                    /**
	                     * Exemplar traceId.
	                     * @member {Uint8Array|null|undefined} traceId
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Exemplar.prototype.traceId = null;
	                    // OneOf field names bound to virtual getters and setters
	                    var $oneOfFields;
	                    /**
	                     * Exemplar value.
	                     * @member {"asDouble"|"asInt"|undefined} value
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     */
	                    Object.defineProperty(Exemplar.prototype, "value", {
	                        get: $util.oneOfGetter($oneOfFields = ["asDouble", "asInt"]),
	                        set: $util.oneOfSetter($oneOfFields)
	                    });
	                    /**
	                     * Creates a new Exemplar instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExemplar=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar instance
	                     */
	                    Exemplar.create = function create(properties) {
	                        return new Exemplar(properties);
	                    };
	                    /**
	                     * Encodes the specified Exemplar message. Does not implicitly {@link opentelemetry.proto.metrics.v1.Exemplar.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExemplar} message Exemplar message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Exemplar.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                            writer.uint32(/* id 2, wireType 1 =*/ 17).fixed64(message.timeUnixNano);
	                        if (message.asDouble != null && Object.hasOwnProperty.call(message, "asDouble"))
	                            writer.uint32(/* id 3, wireType 1 =*/ 25).double(message.asDouble);
	                        if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
	                            writer.uint32(/* id 4, wireType 2 =*/ 34).bytes(message.spanId);
	                        if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
	                            writer.uint32(/* id 5, wireType 2 =*/ 42).bytes(message.traceId);
	                        if (message.asInt != null && Object.hasOwnProperty.call(message, "asInt"))
	                            writer.uint32(/* id 6, wireType 1 =*/ 49).sfixed64(message.asInt);
	                        if (message.filteredAttributes != null && message.filteredAttributes.length)
	                            for (var i = 0; i < message.filteredAttributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.filteredAttributes[i], writer.uint32(/* id 7, wireType 2 =*/ 58).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified Exemplar message, length delimited. Does not implicitly {@link opentelemetry.proto.metrics.v1.Exemplar.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.IExemplar} message Exemplar message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    Exemplar.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes an Exemplar message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Exemplar.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.metrics.v1.Exemplar();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 7: {
	                                    if (!(message.filteredAttributes && message.filteredAttributes.length))
	                                        message.filteredAttributes = [];
	                                    message.filteredAttributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 2: {
	                                    message.timeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 3: {
	                                    message.asDouble = reader.double();
	                                    break;
	                                }
	                                case 6: {
	                                    message.asInt = reader.sfixed64();
	                                    break;
	                                }
	                                case 4: {
	                                    message.spanId = reader.bytes();
	                                    break;
	                                }
	                                case 5: {
	                                    message.traceId = reader.bytes();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes an Exemplar message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    Exemplar.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies an Exemplar message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    Exemplar.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        var properties = {};
	                        if (message.filteredAttributes != null && message.hasOwnProperty("filteredAttributes")) {
	                            if (!Array.isArray(message.filteredAttributes))
	                                return "filteredAttributes: array expected";
	                            for (var i = 0; i < message.filteredAttributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.filteredAttributes[i]);
	                                if (error)
	                                    return "filteredAttributes." + error;
	                            }
	                        }
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                return "timeUnixNano: integer|Long expected";
	                        if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
	                            properties.value = 1;
	                            if (typeof message.asDouble !== "number")
	                                return "asDouble: number expected";
	                        }
	                        if (message.asInt != null && message.hasOwnProperty("asInt")) {
	                            if (properties.value === 1)
	                                return "value: multiple values";
	                            properties.value = 1;
	                            if (!$util.isInteger(message.asInt) && !(message.asInt && $util.isInteger(message.asInt.low) && $util.isInteger(message.asInt.high)))
	                                return "asInt: integer|Long expected";
	                        }
	                        if (message.spanId != null && message.hasOwnProperty("spanId"))
	                            if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
	                                return "spanId: buffer expected";
	                        if (message.traceId != null && message.hasOwnProperty("traceId"))
	                            if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
	                                return "traceId: buffer expected";
	                        return null;
	                    };
	                    /**
	                     * Creates an Exemplar message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.metrics.v1.Exemplar} Exemplar
	                     */
	                    Exemplar.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.metrics.v1.Exemplar)
	                            return object;
	                        var message = new $root.opentelemetry.proto.metrics.v1.Exemplar();
	                        if (object.filteredAttributes) {
	                            if (!Array.isArray(object.filteredAttributes))
	                                throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: array expected");
	                            message.filteredAttributes = [];
	                            for (var i = 0; i < object.filteredAttributes.length; ++i) {
	                                if (typeof object.filteredAttributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.metrics.v1.Exemplar.filteredAttributes: object expected");
	                                message.filteredAttributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.filteredAttributes[i]);
	                            }
	                        }
	                        if (object.timeUnixNano != null)
	                            if ($util.Long)
	                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                            else if (typeof object.timeUnixNano === "string")
	                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                            else if (typeof object.timeUnixNano === "number")
	                                message.timeUnixNano = object.timeUnixNano;
	                            else if (typeof object.timeUnixNano === "object")
	                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                        if (object.asDouble != null)
	                            message.asDouble = Number(object.asDouble);
	                        if (object.asInt != null)
	                            if ($util.Long)
	                                (message.asInt = $util.Long.fromValue(object.asInt)).unsigned = false;
	                            else if (typeof object.asInt === "string")
	                                message.asInt = parseInt(object.asInt, 10);
	                            else if (typeof object.asInt === "number")
	                                message.asInt = object.asInt;
	                            else if (typeof object.asInt === "object")
	                                message.asInt = new $util.LongBits(object.asInt.low >>> 0, object.asInt.high >>> 0).toNumber();
	                        if (object.spanId != null)
	                            if (typeof object.spanId === "string")
	                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
	                            else if (object.spanId.length >= 0)
	                                message.spanId = object.spanId;
	                        if (object.traceId != null)
	                            if (typeof object.traceId === "string")
	                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
	                            else if (object.traceId.length >= 0)
	                                message.traceId = object.traceId;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from an Exemplar message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {opentelemetry.proto.metrics.v1.Exemplar} message Exemplar
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    Exemplar.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.filteredAttributes = [];
	                        if (options.defaults) {
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.timeUnixNano = options.longs === String ? "0" : 0;
	                            if (options.bytes === String)
	                                object.spanId = "";
	                            else {
	                                object.spanId = [];
	                                if (options.bytes !== Array)
	                                    object.spanId = $util.newBuffer(object.spanId);
	                            }
	                            if (options.bytes === String)
	                                object.traceId = "";
	                            else {
	                                object.traceId = [];
	                                if (options.bytes !== Array)
	                                    object.traceId = $util.newBuffer(object.traceId);
	                            }
	                        }
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (typeof message.timeUnixNano === "number")
	                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                            else
	                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                        if (message.asDouble != null && message.hasOwnProperty("asDouble")) {
	                            object.asDouble = options.json && !isFinite(message.asDouble) ? String(message.asDouble) : message.asDouble;
	                            if (options.oneofs)
	                                object.value = "asDouble";
	                        }
	                        if (message.spanId != null && message.hasOwnProperty("spanId"))
	                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
	                        if (message.traceId != null && message.hasOwnProperty("traceId"))
	                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
	                        if (message.asInt != null && message.hasOwnProperty("asInt")) {
	                            if (typeof message.asInt === "number")
	                                object.asInt = options.longs === String ? String(message.asInt) : message.asInt;
	                            else
	                                object.asInt = options.longs === String ? $util.Long.prototype.toString.call(message.asInt) : options.longs === Number ? new $util.LongBits(message.asInt.low >>> 0, message.asInt.high >>> 0).toNumber() : message.asInt;
	                            if (options.oneofs)
	                                object.value = "asInt";
	                        }
	                        if (message.filteredAttributes && message.filteredAttributes.length) {
	                            object.filteredAttributes = [];
	                            for (var j = 0; j < message.filteredAttributes.length; ++j)
	                                object.filteredAttributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.filteredAttributes[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this Exemplar to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    Exemplar.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for Exemplar
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.metrics.v1.Exemplar
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    Exemplar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.metrics.v1.Exemplar";
	                    };
	                    return Exemplar;
	                })();
	                return v1;
	            })();
	            return metrics;
	        })();
	        proto.logs = (function () {
	            /**
	             * Namespace logs.
	             * @memberof opentelemetry.proto
	             * @namespace
	             */
	            var logs = {};
	            logs.v1 = (function () {
	                /**
	                 * Namespace v1.
	                 * @memberof opentelemetry.proto.logs
	                 * @namespace
	                 */
	                var v1 = {};
	                v1.LogsData = (function () {
	                    /**
	                     * Properties of a LogsData.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @interface ILogsData
	                     * @property {Array.<opentelemetry.proto.logs.v1.IResourceLogs>|null} [resourceLogs] LogsData resourceLogs
	                     */
	                    /**
	                     * Constructs a new LogsData.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @classdesc Represents a LogsData.
	                     * @implements ILogsData
	                     * @constructor
	                     * @param {opentelemetry.proto.logs.v1.ILogsData=} [properties] Properties to set
	                     */
	                    function LogsData(properties) {
	                        this.resourceLogs = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * LogsData resourceLogs.
	                     * @member {Array.<opentelemetry.proto.logs.v1.IResourceLogs>} resourceLogs
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @instance
	                     */
	                    LogsData.prototype.resourceLogs = $util.emptyArray;
	                    /**
	                     * Creates a new LogsData instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ILogsData=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData instance
	                     */
	                    LogsData.create = function create(properties) {
	                        return new LogsData(properties);
	                    };
	                    /**
	                     * Encodes the specified LogsData message. Does not implicitly {@link opentelemetry.proto.logs.v1.LogsData.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ILogsData} message LogsData message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    LogsData.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.resourceLogs != null && message.resourceLogs.length)
	                            for (var i = 0; i < message.resourceLogs.length; ++i)
	                                $root.opentelemetry.proto.logs.v1.ResourceLogs.encode(message.resourceLogs[i], writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified LogsData message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.LogsData.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ILogsData} message LogsData message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    LogsData.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a LogsData message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    LogsData.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogsData();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    if (!(message.resourceLogs && message.resourceLogs.length))
	                                        message.resourceLogs = [];
	                                    message.resourceLogs.push($root.opentelemetry.proto.logs.v1.ResourceLogs.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a LogsData message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    LogsData.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a LogsData message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    LogsData.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.resourceLogs != null && message.hasOwnProperty("resourceLogs")) {
	                            if (!Array.isArray(message.resourceLogs))
	                                return "resourceLogs: array expected";
	                            for (var i = 0; i < message.resourceLogs.length; ++i) {
	                                var error = $root.opentelemetry.proto.logs.v1.ResourceLogs.verify(message.resourceLogs[i]);
	                                if (error)
	                                    return "resourceLogs." + error;
	                            }
	                        }
	                        return null;
	                    };
	                    /**
	                     * Creates a LogsData message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.logs.v1.LogsData} LogsData
	                     */
	                    LogsData.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.logs.v1.LogsData)
	                            return object;
	                        var message = new $root.opentelemetry.proto.logs.v1.LogsData();
	                        if (object.resourceLogs) {
	                            if (!Array.isArray(object.resourceLogs))
	                                throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: array expected");
	                            message.resourceLogs = [];
	                            for (var i = 0; i < object.resourceLogs.length; ++i) {
	                                if (typeof object.resourceLogs[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.logs.v1.LogsData.resourceLogs: object expected");
	                                message.resourceLogs[i] = $root.opentelemetry.proto.logs.v1.ResourceLogs.fromObject(object.resourceLogs[i]);
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a LogsData message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.LogsData} message LogsData
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    LogsData.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.resourceLogs = [];
	                        if (message.resourceLogs && message.resourceLogs.length) {
	                            object.resourceLogs = [];
	                            for (var j = 0; j < message.resourceLogs.length; ++j)
	                                object.resourceLogs[j] = $root.opentelemetry.proto.logs.v1.ResourceLogs.toObject(message.resourceLogs[j], options);
	                        }
	                        return object;
	                    };
	                    /**
	                     * Converts this LogsData to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    LogsData.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for LogsData
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.logs.v1.LogsData
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    LogsData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogsData";
	                    };
	                    return LogsData;
	                })();
	                v1.ResourceLogs = (function () {
	                    /**
	                     * Properties of a ResourceLogs.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @interface IResourceLogs
	                     * @property {opentelemetry.proto.resource.v1.IResource|null} [resource] ResourceLogs resource
	                     * @property {Array.<opentelemetry.proto.logs.v1.IScopeLogs>|null} [scopeLogs] ResourceLogs scopeLogs
	                     * @property {string|null} [schemaUrl] ResourceLogs schemaUrl
	                     */
	                    /**
	                     * Constructs a new ResourceLogs.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @classdesc Represents a ResourceLogs.
	                     * @implements IResourceLogs
	                     * @constructor
	                     * @param {opentelemetry.proto.logs.v1.IResourceLogs=} [properties] Properties to set
	                     */
	                    function ResourceLogs(properties) {
	                        this.scopeLogs = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ResourceLogs resource.
	                     * @member {opentelemetry.proto.resource.v1.IResource|null|undefined} resource
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @instance
	                     */
	                    ResourceLogs.prototype.resource = null;
	                    /**
	                     * ResourceLogs scopeLogs.
	                     * @member {Array.<opentelemetry.proto.logs.v1.IScopeLogs>} scopeLogs
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @instance
	                     */
	                    ResourceLogs.prototype.scopeLogs = $util.emptyArray;
	                    /**
	                     * ResourceLogs schemaUrl.
	                     * @member {string|null|undefined} schemaUrl
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @instance
	                     */
	                    ResourceLogs.prototype.schemaUrl = null;
	                    /**
	                     * Creates a new ResourceLogs instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.IResourceLogs=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs instance
	                     */
	                    ResourceLogs.create = function create(properties) {
	                        return new ResourceLogs(properties);
	                    };
	                    /**
	                     * Encodes the specified ResourceLogs message. Does not implicitly {@link opentelemetry.proto.logs.v1.ResourceLogs.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.IResourceLogs} message ResourceLogs message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ResourceLogs.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.resource != null && Object.hasOwnProperty.call(message, "resource"))
	                            $root.opentelemetry.proto.resource.v1.Resource.encode(message.resource, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.scopeLogs != null && message.scopeLogs.length)
	                            for (var i = 0; i < message.scopeLogs.length; ++i)
	                                $root.opentelemetry.proto.logs.v1.ScopeLogs.encode(message.scopeLogs[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.schemaUrl);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ResourceLogs message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.ResourceLogs.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.IResourceLogs} message ResourceLogs message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ResourceLogs.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a ResourceLogs message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ResourceLogs.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.resource = $root.opentelemetry.proto.resource.v1.Resource.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 2: {
	                                    if (!(message.scopeLogs && message.scopeLogs.length))
	                                        message.scopeLogs = [];
	                                    message.scopeLogs.push($root.opentelemetry.proto.logs.v1.ScopeLogs.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 3: {
	                                    message.schemaUrl = reader.string();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a ResourceLogs message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ResourceLogs.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a ResourceLogs message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ResourceLogs.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.resource != null && message.hasOwnProperty("resource")) {
	                            var error = $root.opentelemetry.proto.resource.v1.Resource.verify(message.resource);
	                            if (error)
	                                return "resource." + error;
	                        }
	                        if (message.scopeLogs != null && message.hasOwnProperty("scopeLogs")) {
	                            if (!Array.isArray(message.scopeLogs))
	                                return "scopeLogs: array expected";
	                            for (var i = 0; i < message.scopeLogs.length; ++i) {
	                                var error = $root.opentelemetry.proto.logs.v1.ScopeLogs.verify(message.scopeLogs[i]);
	                                if (error)
	                                    return "scopeLogs." + error;
	                            }
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            if (!$util.isString(message.schemaUrl))
	                                return "schemaUrl: string expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a ResourceLogs message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.logs.v1.ResourceLogs} ResourceLogs
	                     */
	                    ResourceLogs.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.logs.v1.ResourceLogs)
	                            return object;
	                        var message = new $root.opentelemetry.proto.logs.v1.ResourceLogs();
	                        if (object.resource != null) {
	                            if (typeof object.resource !== "object")
	                                throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.resource: object expected");
	                            message.resource = $root.opentelemetry.proto.resource.v1.Resource.fromObject(object.resource);
	                        }
	                        if (object.scopeLogs) {
	                            if (!Array.isArray(object.scopeLogs))
	                                throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: array expected");
	                            message.scopeLogs = [];
	                            for (var i = 0; i < object.scopeLogs.length; ++i) {
	                                if (typeof object.scopeLogs[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.logs.v1.ResourceLogs.scopeLogs: object expected");
	                                message.scopeLogs[i] = $root.opentelemetry.proto.logs.v1.ScopeLogs.fromObject(object.scopeLogs[i]);
	                            }
	                        }
	                        if (object.schemaUrl != null)
	                            message.schemaUrl = String(object.schemaUrl);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a ResourceLogs message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ResourceLogs} message ResourceLogs
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ResourceLogs.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.scopeLogs = [];
	                        if (options.defaults) {
	                            object.resource = null;
	                            object.schemaUrl = "";
	                        }
	                        if (message.resource != null && message.hasOwnProperty("resource"))
	                            object.resource = $root.opentelemetry.proto.resource.v1.Resource.toObject(message.resource, options);
	                        if (message.scopeLogs && message.scopeLogs.length) {
	                            object.scopeLogs = [];
	                            for (var j = 0; j < message.scopeLogs.length; ++j)
	                                object.scopeLogs[j] = $root.opentelemetry.proto.logs.v1.ScopeLogs.toObject(message.scopeLogs[j], options);
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            object.schemaUrl = message.schemaUrl;
	                        return object;
	                    };
	                    /**
	                     * Converts this ResourceLogs to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ResourceLogs.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ResourceLogs
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.logs.v1.ResourceLogs
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ResourceLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.logs.v1.ResourceLogs";
	                    };
	                    return ResourceLogs;
	                })();
	                v1.ScopeLogs = (function () {
	                    /**
	                     * Properties of a ScopeLogs.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @interface IScopeLogs
	                     * @property {opentelemetry.proto.common.v1.IInstrumentationScope|null} [scope] ScopeLogs scope
	                     * @property {Array.<opentelemetry.proto.logs.v1.ILogRecord>|null} [logRecords] ScopeLogs logRecords
	                     * @property {string|null} [schemaUrl] ScopeLogs schemaUrl
	                     */
	                    /**
	                     * Constructs a new ScopeLogs.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @classdesc Represents a ScopeLogs.
	                     * @implements IScopeLogs
	                     * @constructor
	                     * @param {opentelemetry.proto.logs.v1.IScopeLogs=} [properties] Properties to set
	                     */
	                    function ScopeLogs(properties) {
	                        this.logRecords = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * ScopeLogs scope.
	                     * @member {opentelemetry.proto.common.v1.IInstrumentationScope|null|undefined} scope
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @instance
	                     */
	                    ScopeLogs.prototype.scope = null;
	                    /**
	                     * ScopeLogs logRecords.
	                     * @member {Array.<opentelemetry.proto.logs.v1.ILogRecord>} logRecords
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @instance
	                     */
	                    ScopeLogs.prototype.logRecords = $util.emptyArray;
	                    /**
	                     * ScopeLogs schemaUrl.
	                     * @member {string|null|undefined} schemaUrl
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @instance
	                     */
	                    ScopeLogs.prototype.schemaUrl = null;
	                    /**
	                     * Creates a new ScopeLogs instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.IScopeLogs=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs instance
	                     */
	                    ScopeLogs.create = function create(properties) {
	                        return new ScopeLogs(properties);
	                    };
	                    /**
	                     * Encodes the specified ScopeLogs message. Does not implicitly {@link opentelemetry.proto.logs.v1.ScopeLogs.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.IScopeLogs} message ScopeLogs message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ScopeLogs.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.scope != null && Object.hasOwnProperty.call(message, "scope"))
	                            $root.opentelemetry.proto.common.v1.InstrumentationScope.encode(message.scope, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();
	                        if (message.logRecords != null && message.logRecords.length)
	                            for (var i = 0; i < message.logRecords.length; ++i)
	                                $root.opentelemetry.proto.logs.v1.LogRecord.encode(message.logRecords[i], writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();
	                        if (message.schemaUrl != null && Object.hasOwnProperty.call(message, "schemaUrl"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.schemaUrl);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified ScopeLogs message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.ScopeLogs.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.IScopeLogs} message ScopeLogs message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    ScopeLogs.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a ScopeLogs message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ScopeLogs.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 2: {
	                                    if (!(message.logRecords && message.logRecords.length))
	                                        message.logRecords = [];
	                                    message.logRecords.push($root.opentelemetry.proto.logs.v1.LogRecord.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 3: {
	                                    message.schemaUrl = reader.string();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a ScopeLogs message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    ScopeLogs.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a ScopeLogs message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    ScopeLogs.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.scope != null && message.hasOwnProperty("scope")) {
	                            var error = $root.opentelemetry.proto.common.v1.InstrumentationScope.verify(message.scope);
	                            if (error)
	                                return "scope." + error;
	                        }
	                        if (message.logRecords != null && message.hasOwnProperty("logRecords")) {
	                            if (!Array.isArray(message.logRecords))
	                                return "logRecords: array expected";
	                            for (var i = 0; i < message.logRecords.length; ++i) {
	                                var error = $root.opentelemetry.proto.logs.v1.LogRecord.verify(message.logRecords[i]);
	                                if (error)
	                                    return "logRecords." + error;
	                            }
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            if (!$util.isString(message.schemaUrl))
	                                return "schemaUrl: string expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a ScopeLogs message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.logs.v1.ScopeLogs} ScopeLogs
	                     */
	                    ScopeLogs.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.logs.v1.ScopeLogs)
	                            return object;
	                        var message = new $root.opentelemetry.proto.logs.v1.ScopeLogs();
	                        if (object.scope != null) {
	                            if (typeof object.scope !== "object")
	                                throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.scope: object expected");
	                            message.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.fromObject(object.scope);
	                        }
	                        if (object.logRecords) {
	                            if (!Array.isArray(object.logRecords))
	                                throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: array expected");
	                            message.logRecords = [];
	                            for (var i = 0; i < object.logRecords.length; ++i) {
	                                if (typeof object.logRecords[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.logs.v1.ScopeLogs.logRecords: object expected");
	                                message.logRecords[i] = $root.opentelemetry.proto.logs.v1.LogRecord.fromObject(object.logRecords[i]);
	                            }
	                        }
	                        if (object.schemaUrl != null)
	                            message.schemaUrl = String(object.schemaUrl);
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a ScopeLogs message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ScopeLogs} message ScopeLogs
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    ScopeLogs.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.logRecords = [];
	                        if (options.defaults) {
	                            object.scope = null;
	                            object.schemaUrl = "";
	                        }
	                        if (message.scope != null && message.hasOwnProperty("scope"))
	                            object.scope = $root.opentelemetry.proto.common.v1.InstrumentationScope.toObject(message.scope, options);
	                        if (message.logRecords && message.logRecords.length) {
	                            object.logRecords = [];
	                            for (var j = 0; j < message.logRecords.length; ++j)
	                                object.logRecords[j] = $root.opentelemetry.proto.logs.v1.LogRecord.toObject(message.logRecords[j], options);
	                        }
	                        if (message.schemaUrl != null && message.hasOwnProperty("schemaUrl"))
	                            object.schemaUrl = message.schemaUrl;
	                        return object;
	                    };
	                    /**
	                     * Converts this ScopeLogs to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    ScopeLogs.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for ScopeLogs
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.logs.v1.ScopeLogs
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    ScopeLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.logs.v1.ScopeLogs";
	                    };
	                    return ScopeLogs;
	                })();
	                /**
	                 * SeverityNumber enum.
	                 * @name opentelemetry.proto.logs.v1.SeverityNumber
	                 * @enum {number}
	                 * @property {number} SEVERITY_NUMBER_UNSPECIFIED=0 SEVERITY_NUMBER_UNSPECIFIED value
	                 * @property {number} SEVERITY_NUMBER_TRACE=1 SEVERITY_NUMBER_TRACE value
	                 * @property {number} SEVERITY_NUMBER_TRACE2=2 SEVERITY_NUMBER_TRACE2 value
	                 * @property {number} SEVERITY_NUMBER_TRACE3=3 SEVERITY_NUMBER_TRACE3 value
	                 * @property {number} SEVERITY_NUMBER_TRACE4=4 SEVERITY_NUMBER_TRACE4 value
	                 * @property {number} SEVERITY_NUMBER_DEBUG=5 SEVERITY_NUMBER_DEBUG value
	                 * @property {number} SEVERITY_NUMBER_DEBUG2=6 SEVERITY_NUMBER_DEBUG2 value
	                 * @property {number} SEVERITY_NUMBER_DEBUG3=7 SEVERITY_NUMBER_DEBUG3 value
	                 * @property {number} SEVERITY_NUMBER_DEBUG4=8 SEVERITY_NUMBER_DEBUG4 value
	                 * @property {number} SEVERITY_NUMBER_INFO=9 SEVERITY_NUMBER_INFO value
	                 * @property {number} SEVERITY_NUMBER_INFO2=10 SEVERITY_NUMBER_INFO2 value
	                 * @property {number} SEVERITY_NUMBER_INFO3=11 SEVERITY_NUMBER_INFO3 value
	                 * @property {number} SEVERITY_NUMBER_INFO4=12 SEVERITY_NUMBER_INFO4 value
	                 * @property {number} SEVERITY_NUMBER_WARN=13 SEVERITY_NUMBER_WARN value
	                 * @property {number} SEVERITY_NUMBER_WARN2=14 SEVERITY_NUMBER_WARN2 value
	                 * @property {number} SEVERITY_NUMBER_WARN3=15 SEVERITY_NUMBER_WARN3 value
	                 * @property {number} SEVERITY_NUMBER_WARN4=16 SEVERITY_NUMBER_WARN4 value
	                 * @property {number} SEVERITY_NUMBER_ERROR=17 SEVERITY_NUMBER_ERROR value
	                 * @property {number} SEVERITY_NUMBER_ERROR2=18 SEVERITY_NUMBER_ERROR2 value
	                 * @property {number} SEVERITY_NUMBER_ERROR3=19 SEVERITY_NUMBER_ERROR3 value
	                 * @property {number} SEVERITY_NUMBER_ERROR4=20 SEVERITY_NUMBER_ERROR4 value
	                 * @property {number} SEVERITY_NUMBER_FATAL=21 SEVERITY_NUMBER_FATAL value
	                 * @property {number} SEVERITY_NUMBER_FATAL2=22 SEVERITY_NUMBER_FATAL2 value
	                 * @property {number} SEVERITY_NUMBER_FATAL3=23 SEVERITY_NUMBER_FATAL3 value
	                 * @property {number} SEVERITY_NUMBER_FATAL4=24 SEVERITY_NUMBER_FATAL4 value
	                 */
	                v1.SeverityNumber = (function () {
	                    var valuesById = {}, values = Object.create(valuesById);
	                    values[valuesById[0] = "SEVERITY_NUMBER_UNSPECIFIED"] = 0;
	                    values[valuesById[1] = "SEVERITY_NUMBER_TRACE"] = 1;
	                    values[valuesById[2] = "SEVERITY_NUMBER_TRACE2"] = 2;
	                    values[valuesById[3] = "SEVERITY_NUMBER_TRACE3"] = 3;
	                    values[valuesById[4] = "SEVERITY_NUMBER_TRACE4"] = 4;
	                    values[valuesById[5] = "SEVERITY_NUMBER_DEBUG"] = 5;
	                    values[valuesById[6] = "SEVERITY_NUMBER_DEBUG2"] = 6;
	                    values[valuesById[7] = "SEVERITY_NUMBER_DEBUG3"] = 7;
	                    values[valuesById[8] = "SEVERITY_NUMBER_DEBUG4"] = 8;
	                    values[valuesById[9] = "SEVERITY_NUMBER_INFO"] = 9;
	                    values[valuesById[10] = "SEVERITY_NUMBER_INFO2"] = 10;
	                    values[valuesById[11] = "SEVERITY_NUMBER_INFO3"] = 11;
	                    values[valuesById[12] = "SEVERITY_NUMBER_INFO4"] = 12;
	                    values[valuesById[13] = "SEVERITY_NUMBER_WARN"] = 13;
	                    values[valuesById[14] = "SEVERITY_NUMBER_WARN2"] = 14;
	                    values[valuesById[15] = "SEVERITY_NUMBER_WARN3"] = 15;
	                    values[valuesById[16] = "SEVERITY_NUMBER_WARN4"] = 16;
	                    values[valuesById[17] = "SEVERITY_NUMBER_ERROR"] = 17;
	                    values[valuesById[18] = "SEVERITY_NUMBER_ERROR2"] = 18;
	                    values[valuesById[19] = "SEVERITY_NUMBER_ERROR3"] = 19;
	                    values[valuesById[20] = "SEVERITY_NUMBER_ERROR4"] = 20;
	                    values[valuesById[21] = "SEVERITY_NUMBER_FATAL"] = 21;
	                    values[valuesById[22] = "SEVERITY_NUMBER_FATAL2"] = 22;
	                    values[valuesById[23] = "SEVERITY_NUMBER_FATAL3"] = 23;
	                    values[valuesById[24] = "SEVERITY_NUMBER_FATAL4"] = 24;
	                    return values;
	                })();
	                /**
	                 * LogRecordFlags enum.
	                 * @name opentelemetry.proto.logs.v1.LogRecordFlags
	                 * @enum {number}
	                 * @property {number} LOG_RECORD_FLAGS_DO_NOT_USE=0 LOG_RECORD_FLAGS_DO_NOT_USE value
	                 * @property {number} LOG_RECORD_FLAGS_TRACE_FLAGS_MASK=255 LOG_RECORD_FLAGS_TRACE_FLAGS_MASK value
	                 */
	                v1.LogRecordFlags = (function () {
	                    var valuesById = {}, values = Object.create(valuesById);
	                    values[valuesById[0] = "LOG_RECORD_FLAGS_DO_NOT_USE"] = 0;
	                    values[valuesById[255] = "LOG_RECORD_FLAGS_TRACE_FLAGS_MASK"] = 255;
	                    return values;
	                })();
	                v1.LogRecord = (function () {
	                    /**
	                     * Properties of a LogRecord.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @interface ILogRecord
	                     * @property {number|Long|null} [timeUnixNano] LogRecord timeUnixNano
	                     * @property {number|Long|null} [observedTimeUnixNano] LogRecord observedTimeUnixNano
	                     * @property {opentelemetry.proto.logs.v1.SeverityNumber|null} [severityNumber] LogRecord severityNumber
	                     * @property {string|null} [severityText] LogRecord severityText
	                     * @property {opentelemetry.proto.common.v1.IAnyValue|null} [body] LogRecord body
	                     * @property {Array.<opentelemetry.proto.common.v1.IKeyValue>|null} [attributes] LogRecord attributes
	                     * @property {number|null} [droppedAttributesCount] LogRecord droppedAttributesCount
	                     * @property {number|null} [flags] LogRecord flags
	                     * @property {Uint8Array|null} [traceId] LogRecord traceId
	                     * @property {Uint8Array|null} [spanId] LogRecord spanId
	                     */
	                    /**
	                     * Constructs a new LogRecord.
	                     * @memberof opentelemetry.proto.logs.v1
	                     * @classdesc Represents a LogRecord.
	                     * @implements ILogRecord
	                     * @constructor
	                     * @param {opentelemetry.proto.logs.v1.ILogRecord=} [properties] Properties to set
	                     */
	                    function LogRecord(properties) {
	                        this.attributes = [];
	                        if (properties)
	                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
	                                if (properties[keys[i]] != null)
	                                    this[keys[i]] = properties[keys[i]];
	                    }
	                    /**
	                     * LogRecord timeUnixNano.
	                     * @member {number|Long|null|undefined} timeUnixNano
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.timeUnixNano = null;
	                    /**
	                     * LogRecord observedTimeUnixNano.
	                     * @member {number|Long|null|undefined} observedTimeUnixNano
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.observedTimeUnixNano = null;
	                    /**
	                     * LogRecord severityNumber.
	                     * @member {opentelemetry.proto.logs.v1.SeverityNumber|null|undefined} severityNumber
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.severityNumber = null;
	                    /**
	                     * LogRecord severityText.
	                     * @member {string|null|undefined} severityText
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.severityText = null;
	                    /**
	                     * LogRecord body.
	                     * @member {opentelemetry.proto.common.v1.IAnyValue|null|undefined} body
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.body = null;
	                    /**
	                     * LogRecord attributes.
	                     * @member {Array.<opentelemetry.proto.common.v1.IKeyValue>} attributes
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.attributes = $util.emptyArray;
	                    /**
	                     * LogRecord droppedAttributesCount.
	                     * @member {number|null|undefined} droppedAttributesCount
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.droppedAttributesCount = null;
	                    /**
	                     * LogRecord flags.
	                     * @member {number|null|undefined} flags
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.flags = null;
	                    /**
	                     * LogRecord traceId.
	                     * @member {Uint8Array|null|undefined} traceId
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.traceId = null;
	                    /**
	                     * LogRecord spanId.
	                     * @member {Uint8Array|null|undefined} spanId
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     */
	                    LogRecord.prototype.spanId = null;
	                    /**
	                     * Creates a new LogRecord instance using the specified properties.
	                     * @function create
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ILogRecord=} [properties] Properties to set
	                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord instance
	                     */
	                    LogRecord.create = function create(properties) {
	                        return new LogRecord(properties);
	                    };
	                    /**
	                     * Encodes the specified LogRecord message. Does not implicitly {@link opentelemetry.proto.logs.v1.LogRecord.verify|verify} messages.
	                     * @function encode
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ILogRecord} message LogRecord message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    LogRecord.encode = function encode(message, writer) {
	                        if (!writer)
	                            writer = $Writer.create();
	                        if (message.timeUnixNano != null && Object.hasOwnProperty.call(message, "timeUnixNano"))
	                            writer.uint32(/* id 1, wireType 1 =*/ 9).fixed64(message.timeUnixNano);
	                        if (message.severityNumber != null && Object.hasOwnProperty.call(message, "severityNumber"))
	                            writer.uint32(/* id 2, wireType 0 =*/ 16).int32(message.severityNumber);
	                        if (message.severityText != null && Object.hasOwnProperty.call(message, "severityText"))
	                            writer.uint32(/* id 3, wireType 2 =*/ 26).string(message.severityText);
	                        if (message.body != null && Object.hasOwnProperty.call(message, "body"))
	                            $root.opentelemetry.proto.common.v1.AnyValue.encode(message.body, writer.uint32(/* id 5, wireType 2 =*/ 42).fork()).ldelim();
	                        if (message.attributes != null && message.attributes.length)
	                            for (var i = 0; i < message.attributes.length; ++i)
	                                $root.opentelemetry.proto.common.v1.KeyValue.encode(message.attributes[i], writer.uint32(/* id 6, wireType 2 =*/ 50).fork()).ldelim();
	                        if (message.droppedAttributesCount != null && Object.hasOwnProperty.call(message, "droppedAttributesCount"))
	                            writer.uint32(/* id 7, wireType 0 =*/ 56).uint32(message.droppedAttributesCount);
	                        if (message.flags != null && Object.hasOwnProperty.call(message, "flags"))
	                            writer.uint32(/* id 8, wireType 5 =*/ 69).fixed32(message.flags);
	                        if (message.traceId != null && Object.hasOwnProperty.call(message, "traceId"))
	                            writer.uint32(/* id 9, wireType 2 =*/ 74).bytes(message.traceId);
	                        if (message.spanId != null && Object.hasOwnProperty.call(message, "spanId"))
	                            writer.uint32(/* id 10, wireType 2 =*/ 82).bytes(message.spanId);
	                        if (message.observedTimeUnixNano != null && Object.hasOwnProperty.call(message, "observedTimeUnixNano"))
	                            writer.uint32(/* id 11, wireType 1 =*/ 89).fixed64(message.observedTimeUnixNano);
	                        return writer;
	                    };
	                    /**
	                     * Encodes the specified LogRecord message, length delimited. Does not implicitly {@link opentelemetry.proto.logs.v1.LogRecord.verify|verify} messages.
	                     * @function encodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.ILogRecord} message LogRecord message or plain object to encode
	                     * @param {$protobuf.Writer} [writer] Writer to encode to
	                     * @returns {$protobuf.Writer} Writer
	                     */
	                    LogRecord.encodeDelimited = function encodeDelimited(message, writer) {
	                        return this.encode(message, writer).ldelim();
	                    };
	                    /**
	                     * Decodes a LogRecord message from the specified reader or buffer.
	                     * @function decode
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @param {number} [length] Message length if known beforehand
	                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    LogRecord.decode = function decode(reader, length) {
	                        if (!(reader instanceof $Reader))
	                            reader = $Reader.create(reader);
	                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.opentelemetry.proto.logs.v1.LogRecord();
	                        while (reader.pos < end) {
	                            var tag = reader.uint32();
	                            switch (tag >>> 3) {
	                                case 1: {
	                                    message.timeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 11: {
	                                    message.observedTimeUnixNano = reader.fixed64();
	                                    break;
	                                }
	                                case 2: {
	                                    message.severityNumber = reader.int32();
	                                    break;
	                                }
	                                case 3: {
	                                    message.severityText = reader.string();
	                                    break;
	                                }
	                                case 5: {
	                                    message.body = $root.opentelemetry.proto.common.v1.AnyValue.decode(reader, reader.uint32());
	                                    break;
	                                }
	                                case 6: {
	                                    if (!(message.attributes && message.attributes.length))
	                                        message.attributes = [];
	                                    message.attributes.push($root.opentelemetry.proto.common.v1.KeyValue.decode(reader, reader.uint32()));
	                                    break;
	                                }
	                                case 7: {
	                                    message.droppedAttributesCount = reader.uint32();
	                                    break;
	                                }
	                                case 8: {
	                                    message.flags = reader.fixed32();
	                                    break;
	                                }
	                                case 9: {
	                                    message.traceId = reader.bytes();
	                                    break;
	                                }
	                                case 10: {
	                                    message.spanId = reader.bytes();
	                                    break;
	                                }
	                                default:
	                                    reader.skipType(tag & 7);
	                                    break;
	                            }
	                        }
	                        return message;
	                    };
	                    /**
	                     * Decodes a LogRecord message from the specified reader or buffer, length delimited.
	                     * @function decodeDelimited
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
	                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord
	                     * @throws {Error} If the payload is not a reader or valid buffer
	                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
	                     */
	                    LogRecord.decodeDelimited = function decodeDelimited(reader) {
	                        if (!(reader instanceof $Reader))
	                            reader = new $Reader(reader);
	                        return this.decode(reader, reader.uint32());
	                    };
	                    /**
	                     * Verifies a LogRecord message.
	                     * @function verify
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {Object.<string,*>} message Plain object to verify
	                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
	                     */
	                    LogRecord.verify = function verify(message) {
	                        if (typeof message !== "object" || message === null)
	                            return "object expected";
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (!$util.isInteger(message.timeUnixNano) && !(message.timeUnixNano && $util.isInteger(message.timeUnixNano.low) && $util.isInteger(message.timeUnixNano.high)))
	                                return "timeUnixNano: integer|Long expected";
	                        if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano"))
	                            if (!$util.isInteger(message.observedTimeUnixNano) && !(message.observedTimeUnixNano && $util.isInteger(message.observedTimeUnixNano.low) && $util.isInteger(message.observedTimeUnixNano.high)))
	                                return "observedTimeUnixNano: integer|Long expected";
	                        if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
	                            switch (message.severityNumber) {
	                                default:
	                                    return "severityNumber: enum value expected";
	                                case 0:
	                                case 1:
	                                case 2:
	                                case 3:
	                                case 4:
	                                case 5:
	                                case 6:
	                                case 7:
	                                case 8:
	                                case 9:
	                                case 10:
	                                case 11:
	                                case 12:
	                                case 13:
	                                case 14:
	                                case 15:
	                                case 16:
	                                case 17:
	                                case 18:
	                                case 19:
	                                case 20:
	                                case 21:
	                                case 22:
	                                case 23:
	                                case 24:
	                                    break;
	                            }
	                        if (message.severityText != null && message.hasOwnProperty("severityText"))
	                            if (!$util.isString(message.severityText))
	                                return "severityText: string expected";
	                        if (message.body != null && message.hasOwnProperty("body")) {
	                            var error = $root.opentelemetry.proto.common.v1.AnyValue.verify(message.body);
	                            if (error)
	                                return "body." + error;
	                        }
	                        if (message.attributes != null && message.hasOwnProperty("attributes")) {
	                            if (!Array.isArray(message.attributes))
	                                return "attributes: array expected";
	                            for (var i = 0; i < message.attributes.length; ++i) {
	                                var error = $root.opentelemetry.proto.common.v1.KeyValue.verify(message.attributes[i]);
	                                if (error)
	                                    return "attributes." + error;
	                            }
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            if (!$util.isInteger(message.droppedAttributesCount))
	                                return "droppedAttributesCount: integer expected";
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            if (!$util.isInteger(message.flags))
	                                return "flags: integer expected";
	                        if (message.traceId != null && message.hasOwnProperty("traceId"))
	                            if (!(message.traceId && typeof message.traceId.length === "number" || $util.isString(message.traceId)))
	                                return "traceId: buffer expected";
	                        if (message.spanId != null && message.hasOwnProperty("spanId"))
	                            if (!(message.spanId && typeof message.spanId.length === "number" || $util.isString(message.spanId)))
	                                return "spanId: buffer expected";
	                        return null;
	                    };
	                    /**
	                     * Creates a LogRecord message from a plain object. Also converts values to their respective internal types.
	                     * @function fromObject
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {Object.<string,*>} object Plain object
	                     * @returns {opentelemetry.proto.logs.v1.LogRecord} LogRecord
	                     */
	                    LogRecord.fromObject = function fromObject(object) {
	                        if (object instanceof $root.opentelemetry.proto.logs.v1.LogRecord)
	                            return object;
	                        var message = new $root.opentelemetry.proto.logs.v1.LogRecord();
	                        if (object.timeUnixNano != null)
	                            if ($util.Long)
	                                (message.timeUnixNano = $util.Long.fromValue(object.timeUnixNano)).unsigned = false;
	                            else if (typeof object.timeUnixNano === "string")
	                                message.timeUnixNano = parseInt(object.timeUnixNano, 10);
	                            else if (typeof object.timeUnixNano === "number")
	                                message.timeUnixNano = object.timeUnixNano;
	                            else if (typeof object.timeUnixNano === "object")
	                                message.timeUnixNano = new $util.LongBits(object.timeUnixNano.low >>> 0, object.timeUnixNano.high >>> 0).toNumber();
	                        if (object.observedTimeUnixNano != null)
	                            if ($util.Long)
	                                (message.observedTimeUnixNano = $util.Long.fromValue(object.observedTimeUnixNano)).unsigned = false;
	                            else if (typeof object.observedTimeUnixNano === "string")
	                                message.observedTimeUnixNano = parseInt(object.observedTimeUnixNano, 10);
	                            else if (typeof object.observedTimeUnixNano === "number")
	                                message.observedTimeUnixNano = object.observedTimeUnixNano;
	                            else if (typeof object.observedTimeUnixNano === "object")
	                                message.observedTimeUnixNano = new $util.LongBits(object.observedTimeUnixNano.low >>> 0, object.observedTimeUnixNano.high >>> 0).toNumber();
	                        switch (object.severityNumber) {
	                            default:
	                                if (typeof object.severityNumber === "number") {
	                                    message.severityNumber = object.severityNumber;
	                                    break;
	                                }
	                                break;
	                            case "SEVERITY_NUMBER_UNSPECIFIED":
	                            case 0:
	                                message.severityNumber = 0;
	                                break;
	                            case "SEVERITY_NUMBER_TRACE":
	                            case 1:
	                                message.severityNumber = 1;
	                                break;
	                            case "SEVERITY_NUMBER_TRACE2":
	                            case 2:
	                                message.severityNumber = 2;
	                                break;
	                            case "SEVERITY_NUMBER_TRACE3":
	                            case 3:
	                                message.severityNumber = 3;
	                                break;
	                            case "SEVERITY_NUMBER_TRACE4":
	                            case 4:
	                                message.severityNumber = 4;
	                                break;
	                            case "SEVERITY_NUMBER_DEBUG":
	                            case 5:
	                                message.severityNumber = 5;
	                                break;
	                            case "SEVERITY_NUMBER_DEBUG2":
	                            case 6:
	                                message.severityNumber = 6;
	                                break;
	                            case "SEVERITY_NUMBER_DEBUG3":
	                            case 7:
	                                message.severityNumber = 7;
	                                break;
	                            case "SEVERITY_NUMBER_DEBUG4":
	                            case 8:
	                                message.severityNumber = 8;
	                                break;
	                            case "SEVERITY_NUMBER_INFO":
	                            case 9:
	                                message.severityNumber = 9;
	                                break;
	                            case "SEVERITY_NUMBER_INFO2":
	                            case 10:
	                                message.severityNumber = 10;
	                                break;
	                            case "SEVERITY_NUMBER_INFO3":
	                            case 11:
	                                message.severityNumber = 11;
	                                break;
	                            case "SEVERITY_NUMBER_INFO4":
	                            case 12:
	                                message.severityNumber = 12;
	                                break;
	                            case "SEVERITY_NUMBER_WARN":
	                            case 13:
	                                message.severityNumber = 13;
	                                break;
	                            case "SEVERITY_NUMBER_WARN2":
	                            case 14:
	                                message.severityNumber = 14;
	                                break;
	                            case "SEVERITY_NUMBER_WARN3":
	                            case 15:
	                                message.severityNumber = 15;
	                                break;
	                            case "SEVERITY_NUMBER_WARN4":
	                            case 16:
	                                message.severityNumber = 16;
	                                break;
	                            case "SEVERITY_NUMBER_ERROR":
	                            case 17:
	                                message.severityNumber = 17;
	                                break;
	                            case "SEVERITY_NUMBER_ERROR2":
	                            case 18:
	                                message.severityNumber = 18;
	                                break;
	                            case "SEVERITY_NUMBER_ERROR3":
	                            case 19:
	                                message.severityNumber = 19;
	                                break;
	                            case "SEVERITY_NUMBER_ERROR4":
	                            case 20:
	                                message.severityNumber = 20;
	                                break;
	                            case "SEVERITY_NUMBER_FATAL":
	                            case 21:
	                                message.severityNumber = 21;
	                                break;
	                            case "SEVERITY_NUMBER_FATAL2":
	                            case 22:
	                                message.severityNumber = 22;
	                                break;
	                            case "SEVERITY_NUMBER_FATAL3":
	                            case 23:
	                                message.severityNumber = 23;
	                                break;
	                            case "SEVERITY_NUMBER_FATAL4":
	                            case 24:
	                                message.severityNumber = 24;
	                                break;
	                        }
	                        if (object.severityText != null)
	                            message.severityText = String(object.severityText);
	                        if (object.body != null) {
	                            if (typeof object.body !== "object")
	                                throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.body: object expected");
	                            message.body = $root.opentelemetry.proto.common.v1.AnyValue.fromObject(object.body);
	                        }
	                        if (object.attributes) {
	                            if (!Array.isArray(object.attributes))
	                                throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: array expected");
	                            message.attributes = [];
	                            for (var i = 0; i < object.attributes.length; ++i) {
	                                if (typeof object.attributes[i] !== "object")
	                                    throw TypeError(".opentelemetry.proto.logs.v1.LogRecord.attributes: object expected");
	                                message.attributes[i] = $root.opentelemetry.proto.common.v1.KeyValue.fromObject(object.attributes[i]);
	                            }
	                        }
	                        if (object.droppedAttributesCount != null)
	                            message.droppedAttributesCount = object.droppedAttributesCount >>> 0;
	                        if (object.flags != null)
	                            message.flags = object.flags >>> 0;
	                        if (object.traceId != null)
	                            if (typeof object.traceId === "string")
	                                $util.base64.decode(object.traceId, message.traceId = $util.newBuffer($util.base64.length(object.traceId)), 0);
	                            else if (object.traceId.length >= 0)
	                                message.traceId = object.traceId;
	                        if (object.spanId != null)
	                            if (typeof object.spanId === "string")
	                                $util.base64.decode(object.spanId, message.spanId = $util.newBuffer($util.base64.length(object.spanId)), 0);
	                            else if (object.spanId.length >= 0)
	                                message.spanId = object.spanId;
	                        return message;
	                    };
	                    /**
	                     * Creates a plain object from a LogRecord message. Also converts values to other types if specified.
	                     * @function toObject
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {opentelemetry.proto.logs.v1.LogRecord} message LogRecord
	                     * @param {$protobuf.IConversionOptions} [options] Conversion options
	                     * @returns {Object.<string,*>} Plain object
	                     */
	                    LogRecord.toObject = function toObject(message, options) {
	                        if (!options)
	                            options = {};
	                        var object = {};
	                        if (options.arrays || options.defaults)
	                            object.attributes = [];
	                        if (options.defaults) {
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.timeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.timeUnixNano = options.longs === String ? "0" : 0;
	                            object.severityNumber = options.enums === String ? "SEVERITY_NUMBER_UNSPECIFIED" : 0;
	                            object.severityText = "";
	                            object.body = null;
	                            object.droppedAttributesCount = 0;
	                            object.flags = 0;
	                            if (options.bytes === String)
	                                object.traceId = "";
	                            else {
	                                object.traceId = [];
	                                if (options.bytes !== Array)
	                                    object.traceId = $util.newBuffer(object.traceId);
	                            }
	                            if (options.bytes === String)
	                                object.spanId = "";
	                            else {
	                                object.spanId = [];
	                                if (options.bytes !== Array)
	                                    object.spanId = $util.newBuffer(object.spanId);
	                            }
	                            if ($util.Long) {
	                                var long = new $util.Long(0, 0, false);
	                                object.observedTimeUnixNano = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
	                            }
	                            else
	                                object.observedTimeUnixNano = options.longs === String ? "0" : 0;
	                        }
	                        if (message.timeUnixNano != null && message.hasOwnProperty("timeUnixNano"))
	                            if (typeof message.timeUnixNano === "number")
	                                object.timeUnixNano = options.longs === String ? String(message.timeUnixNano) : message.timeUnixNano;
	                            else
	                                object.timeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.timeUnixNano) : options.longs === Number ? new $util.LongBits(message.timeUnixNano.low >>> 0, message.timeUnixNano.high >>> 0).toNumber() : message.timeUnixNano;
	                        if (message.severityNumber != null && message.hasOwnProperty("severityNumber"))
	                            object.severityNumber = options.enums === String ? $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] === undefined ? message.severityNumber : $root.opentelemetry.proto.logs.v1.SeverityNumber[message.severityNumber] : message.severityNumber;
	                        if (message.severityText != null && message.hasOwnProperty("severityText"))
	                            object.severityText = message.severityText;
	                        if (message.body != null && message.hasOwnProperty("body"))
	                            object.body = $root.opentelemetry.proto.common.v1.AnyValue.toObject(message.body, options);
	                        if (message.attributes && message.attributes.length) {
	                            object.attributes = [];
	                            for (var j = 0; j < message.attributes.length; ++j)
	                                object.attributes[j] = $root.opentelemetry.proto.common.v1.KeyValue.toObject(message.attributes[j], options);
	                        }
	                        if (message.droppedAttributesCount != null && message.hasOwnProperty("droppedAttributesCount"))
	                            object.droppedAttributesCount = message.droppedAttributesCount;
	                        if (message.flags != null && message.hasOwnProperty("flags"))
	                            object.flags = message.flags;
	                        if (message.traceId != null && message.hasOwnProperty("traceId"))
	                            object.traceId = options.bytes === String ? $util.base64.encode(message.traceId, 0, message.traceId.length) : options.bytes === Array ? Array.prototype.slice.call(message.traceId) : message.traceId;
	                        if (message.spanId != null && message.hasOwnProperty("spanId"))
	                            object.spanId = options.bytes === String ? $util.base64.encode(message.spanId, 0, message.spanId.length) : options.bytes === Array ? Array.prototype.slice.call(message.spanId) : message.spanId;
	                        if (message.observedTimeUnixNano != null && message.hasOwnProperty("observedTimeUnixNano"))
	                            if (typeof message.observedTimeUnixNano === "number")
	                                object.observedTimeUnixNano = options.longs === String ? String(message.observedTimeUnixNano) : message.observedTimeUnixNano;
	                            else
	                                object.observedTimeUnixNano = options.longs === String ? $util.Long.prototype.toString.call(message.observedTimeUnixNano) : options.longs === Number ? new $util.LongBits(message.observedTimeUnixNano.low >>> 0, message.observedTimeUnixNano.high >>> 0).toNumber() : message.observedTimeUnixNano;
	                        return object;
	                    };
	                    /**
	                     * Converts this LogRecord to JSON.
	                     * @function toJSON
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @instance
	                     * @returns {Object.<string,*>} JSON object
	                     */
	                    LogRecord.prototype.toJSON = function toJSON() {
	                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
	                    };
	                    /**
	                     * Gets the default type url for LogRecord
	                     * @function getTypeUrl
	                     * @memberof opentelemetry.proto.logs.v1.LogRecord
	                     * @static
	                     * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
	                     * @returns {string} The default type url
	                     */
	                    LogRecord.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
	                        if (typeUrlPrefix === undefined) {
	                            typeUrlPrefix = "type.googleapis.com";
	                        }
	                        return typeUrlPrefix + "/opentelemetry.proto.logs.v1.LogRecord";
	                    };
	                    return LogRecord;
	                })();
	                return v1;
	            })();
	            return logs;
	        })();
	        return proto;
	    })();
	    return opentelemetry;
	})();
	root = $root;
	
	return root;
}

var rootExports = /*@__PURE__*/ requireRoot();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function hrTimeToNanos(hrTime) {
    var NANOSECONDS = BigInt(1000000000);
    return BigInt(hrTime[0]) * NANOSECONDS + BigInt(hrTime[1]);
}
function toLongBits(value) {
    var low = Number(BigInt.asUintN(32, value));
    var high = Number(BigInt.asUintN(32, value >> BigInt(32)));
    return { low: low, high: high };
}
function encodeAsLongBits(hrTime) {
    var nanos = hrTimeToNanos(hrTime);
    return toLongBits(nanos);
}
function encodeAsString(hrTime) {
    var nanos = hrTimeToNanos(hrTime);
    return nanos.toString();
}
var encodeTimestamp = typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;
function identity(value) {
    return value;
}
function optionalHexToBinary(str) {
    if (str === undefined)
        return undefined;
    return hexToBinary(str);
}
var DEFAULT_ENCODER = {
    encodeHrTime: encodeAsLongBits,
    encodeSpanContext: hexToBinary,
    encodeOptionalSpanContext: optionalHexToBinary,
};
function getOtlpEncoder(options) {
    var _a, _b;
    if (options === undefined) {
        return DEFAULT_ENCODER;
    }
    var useLongBits = (_a = options.useLongBits) !== null && _a !== undefined ? _a : true;
    var useHex = (_b = options.useHex) !== null && _b !== undefined ? _b : false;
    return {
        encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
        encodeSpanContext: useHex ? identity : hexToBinary,
        encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary,
    };
}

var __read$5 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function createResource(resource) {
    return {
        attributes: toAttributes(resource.attributes),
        droppedAttributesCount: 0,
    };
}
function createInstrumentationScope(scope) {
    return {
        name: scope.name,
        version: scope.version,
    };
}
function toAttributes(attributes) {
    return Object.keys(attributes).map(function (key) { return toKeyValue(key, attributes[key]); });
}
function toKeyValue(key, value) {
    return {
        key: key,
        value: toAnyValue(value),
    };
}
function toAnyValue(value) {
    var t = typeof value;
    if (t === 'string')
        return { stringValue: value };
    if (t === 'number') {
        if (!Number.isInteger(value))
            return { doubleValue: value };
        return { intValue: value };
    }
    if (t === 'boolean')
        return { boolValue: value };
    if (value instanceof Uint8Array)
        return { bytesValue: value };
    if (Array.isArray(value))
        return { arrayValue: { values: value.map(toAnyValue) } };
    if (t === 'object' && value != null)
        return {
            kvlistValue: {
                values: Object.entries(value).map(function (_a) {
                    var _b = __read$5(_a, 2), k = _b[0], v = _b[1];
                    return toKeyValue(k, v);
                }),
            },
        };
    return {};
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values$4 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$4 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function createExportLogsServiceRequest(logRecords, options) {
    var encoder = getOtlpEncoder(options);
    return {
        resourceLogs: logRecordsToResourceLogs(logRecords, encoder),
    };
}
function createResourceMap$1(logRecords) {
    var e_1, _a;
    var resourceMap = new Map();
    try {
        for (var logRecords_1 = __values$4(logRecords), logRecords_1_1 = logRecords_1.next(); !logRecords_1_1.done; logRecords_1_1 = logRecords_1.next()) {
            var record = logRecords_1_1.value;
            var resource = record.resource, _b = record.instrumentationScope, name_1 = _b.name, _c = _b.version, version = _c === void 0 ? '' : _c, _d = _b.schemaUrl, schemaUrl = _d === void 0 ? '' : _d;
            var ismMap = resourceMap.get(resource);
            if (!ismMap) {
                ismMap = new Map();
                resourceMap.set(resource, ismMap);
            }
            var ismKey = name_1 + "@" + version + ":" + schemaUrl;
            var records = ismMap.get(ismKey);
            if (!records) {
                records = [];
                ismMap.set(ismKey, records);
            }
            records.push(record);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (logRecords_1_1 && !logRecords_1_1.done && (_a = logRecords_1.return)) _a.call(logRecords_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return resourceMap;
}
function logRecordsToResourceLogs(logRecords, encoder) {
    var resourceMap = createResourceMap$1(logRecords);
    return Array.from(resourceMap, function (_a) {
        var _b = __read$4(_a, 2), resource = _b[0], ismMap = _b[1];
        return ({
            resource: createResource(resource),
            scopeLogs: Array.from(ismMap, function (_a) {
                var _b = __read$4(_a, 2), scopeLogs = _b[1];
                return {
                    scope: createInstrumentationScope(scopeLogs[0].instrumentationScope),
                    logRecords: scopeLogs.map(function (log) { return toLogRecord(log, encoder); }),
                    schemaUrl: scopeLogs[0].instrumentationScope.schemaUrl,
                };
            }),
            schemaUrl: undefined,
        });
    });
}
function toLogRecord(log, encoder) {
    var _a, _b, _c;
    return {
        timeUnixNano: encoder.encodeHrTime(log.hrTime),
        observedTimeUnixNano: encoder.encodeHrTime(log.hrTimeObserved),
        severityNumber: toSeverityNumber(log.severityNumber),
        severityText: log.severityText,
        body: toAnyValue(log.body),
        attributes: toLogAttributes(log.attributes),
        droppedAttributesCount: log.droppedAttributesCount,
        flags: (_a = log.spanContext) === null || _a === undefined ? undefined : _a.traceFlags,
        traceId: encoder.encodeOptionalSpanContext((_b = log.spanContext) === null || _b === undefined ? undefined : _b.traceId),
        spanId: encoder.encodeOptionalSpanContext((_c = log.spanContext) === null || _c === undefined ? undefined : _c.spanId),
    };
}
function toSeverityNumber(severityNumber) {
    return severityNumber;
}
function toLogAttributes(attributes) {
    return Object.keys(attributes).map(function (key) { return toKeyValue(key, attributes[key]); });
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var logsResponseType = rootExports.opentelemetry.proto.collector.logs.v1
    .ExportLogsServiceResponse;
var logsRequestType = rootExports.opentelemetry.proto.collector.logs.v1
    .ExportLogsServiceRequest;
/*
 * @experimental this serializer may receive breaking changes in minor versions, pin this package's version when using this constant
 */
var ProtobufLogsSerializer = {
    serializeRequest: function (arg) {
        var request = createExportLogsServiceRequest(arg);
        return logsRequestType.encode(request).finish();
    },
    deserializeResponse: function (arg) {
        return logsResponseType.decode(arg);
    },
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * AggregationTemporality indicates the way additive quantities are expressed.
 */
var AggregationTemporality;
(function (AggregationTemporality) {
    AggregationTemporality[AggregationTemporality["DELTA"] = 0] = "DELTA";
    AggregationTemporality[AggregationTemporality["CUMULATIVE"] = 1] = "CUMULATIVE";
})(AggregationTemporality || (AggregationTemporality = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The aggregated point data type.
 */
var DataPointType;
(function (DataPointType) {
    /**
     * A histogram data point contains a histogram statistics of collected
     * values with a list of explicit bucket boundaries and statistics such
     * as min, max, count, and sum of all collected values.
     */
    DataPointType[DataPointType["HISTOGRAM"] = 0] = "HISTOGRAM";
    /**
     * An exponential histogram data point contains a histogram statistics of
     * collected values where bucket boundaries are automatically calculated
     * using an exponential function, and statistics such as min, max, count,
     * and sum of all collected values.
     */
    DataPointType[DataPointType["EXPONENTIAL_HISTOGRAM"] = 1] = "EXPONENTIAL_HISTOGRAM";
    /**
     * A gauge metric data point has only a single numeric value.
     */
    DataPointType[DataPointType["GAUGE"] = 2] = "GAUGE";
    /**
     * A sum metric data point has a single numeric value and a
     * monotonicity-indicator.
     */
    DataPointType[DataPointType["SUM"] = 3] = "SUM";
})(DataPointType || (DataPointType = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function defaultServiceName() {
    return "unknown_service:" + process.argv0;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign$1 = (undefined && undefined.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : undefined, done: true };
    }
};
var __read$3 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
/**
 * A Resource describes the entity for which a signals (metrics or trace) are
 * collected.
 */
var Resource = /** @class */ (function () {
    function Resource(
    /**
     * A dictionary of attributes with string keys and values that provide
     * information about the entity as numbers, strings or booleans
     * TODO: Consider to add check/validation on attributes.
     */
    attributes, asyncAttributesPromise) {
        var _this = this;
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== undefined ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === undefined ? undefined : asyncAttributesPromise.then(function (asyncAttributes) {
            _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);
            _this.asyncAttributesPending = false;
            return asyncAttributes;
        }, function (err) {
            diag.debug("a resource's async attributes promise rejected: %s", err);
            _this.asyncAttributesPending = false;
            return {};
        });
    }
    /**
     * Returns an empty Resource
     */
    Resource.empty = function () {
        return Resource.EMPTY;
    };
    /**
     * Returns a Resource that identifies the SDK in use.
     */
    Resource.default = function () {
        var _a;
        return new Resource((_a = {},
            _a[SEMRESATTRS_SERVICE_NAME] = defaultServiceName(),
            _a[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],
            _a[SEMRESATTRS_TELEMETRY_SDK_NAME] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_NAME],
            _a[SEMRESATTRS_TELEMETRY_SDK_VERSION] = SDK_INFO[SEMRESATTRS_TELEMETRY_SDK_VERSION],
            _a));
    };
    Object.defineProperty(Resource.prototype, "attributes", {
        get: function () {
            var _a;
            if (this.asyncAttributesPending) {
                diag.error('Accessing resource attributes before async attributes settled');
            }
            return (_a = this._attributes) !== null && _a !== undefined ? _a : {};
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
     * this Resource's attributes. This is useful in exporters to block until resource detection
     * has finished.
     */
    Resource.prototype.waitForAsyncAttributes = function () {
        return __awaiter(this, undefined, undefined, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.asyncAttributesPending) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._asyncAttributesPromise];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns a new, merged {@link Resource} by merging the current Resource
     * with the other Resource. In case of a collision, other Resource takes
     * precedence.
     *
     * @param other the Resource that will be merged with this.
     * @returns the newly merged Resource.
     */
    Resource.prototype.merge = function (other) {
        var _this = this;
        var _a;
        if (!other)
            return this;
        // SpanAttributes from other resource overwrite attributes from this resource.
        var mergedSyncAttributes = __assign$1(__assign$1({}, this._syncAttributes), ((_a = other._syncAttributes) !== null && _a !== undefined ? _a : other.attributes));
        if (!this._asyncAttributesPromise &&
            !other._asyncAttributesPromise) {
            return new Resource(mergedSyncAttributes);
        }
        var mergedAttributesPromise = Promise.all([
            this._asyncAttributesPromise,
            other._asyncAttributesPromise,
        ]).then(function (_a) {
            var _b;
            var _c = __read$3(_a, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];
            return __assign$1(__assign$1(__assign$1(__assign$1({}, _this._syncAttributes), thisAsyncAttributes), ((_b = other._syncAttributes) !== null && _b !== undefined ? _b : other.attributes)), otherAsyncAttributes);
        });
        return new Resource(mergedSyncAttributes, mergedAttributesPromise);
    };
    Resource.EMPTY = new Resource({});
    return Resource;
}());

function toResourceMetrics(resourceMetrics, options) {
    var encoder = getOtlpEncoder(options);
    return {
        resource: createResource(resourceMetrics.resource),
        schemaUrl: undefined,
        scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics, encoder),
    };
}
function toScopeMetrics(scopeMetrics, encoder) {
    return Array.from(scopeMetrics.map(function (metrics) { return ({
        scope: createInstrumentationScope(metrics.scope),
        metrics: metrics.metrics.map(function (metricData) { return toMetric(metricData, encoder); }),
        schemaUrl: metrics.scope.schemaUrl,
    }); }));
}
function toMetric(metricData, encoder) {
    var out = {
        name: metricData.descriptor.name,
        description: metricData.descriptor.description,
        unit: metricData.descriptor.unit,
    };
    var aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);
    switch (metricData.dataPointType) {
        case DataPointType.SUM:
            out.sum = {
                aggregationTemporality: aggregationTemporality,
                isMonotonic: metricData.isMonotonic,
                dataPoints: toSingularDataPoints(metricData, encoder),
            };
            break;
        case DataPointType.GAUGE:
            out.gauge = {
                dataPoints: toSingularDataPoints(metricData, encoder),
            };
            break;
        case DataPointType.HISTOGRAM:
            out.histogram = {
                aggregationTemporality: aggregationTemporality,
                dataPoints: toHistogramDataPoints(metricData, encoder),
            };
            break;
        case DataPointType.EXPONENTIAL_HISTOGRAM:
            out.exponentialHistogram = {
                aggregationTemporality: aggregationTemporality,
                dataPoints: toExponentialHistogramDataPoints(metricData, encoder),
            };
            break;
    }
    return out;
}
function toSingularDataPoint(dataPoint, valueType, encoder) {
    var out = {
        attributes: toAttributes(dataPoint.attributes),
        startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
        timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),
    };
    switch (valueType) {
        case ValueType.INT:
            out.asInt = dataPoint.value;
            break;
        case ValueType.DOUBLE:
            out.asDouble = dataPoint.value;
            break;
    }
    return out;
}
function toSingularDataPoints(metricData, encoder) {
    return metricData.dataPoints.map(function (dataPoint) {
        return toSingularDataPoint(dataPoint, metricData.descriptor.valueType, encoder);
    });
}
function toHistogramDataPoints(metricData, encoder) {
    return metricData.dataPoints.map(function (dataPoint) {
        var histogram = dataPoint.value;
        return {
            attributes: toAttributes(dataPoint.attributes),
            bucketCounts: histogram.buckets.counts,
            explicitBounds: histogram.buckets.boundaries,
            count: histogram.count,
            sum: histogram.sum,
            min: histogram.min,
            max: histogram.max,
            startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
            timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),
        };
    });
}
function toExponentialHistogramDataPoints(metricData, encoder) {
    return metricData.dataPoints.map(function (dataPoint) {
        var histogram = dataPoint.value;
        return {
            attributes: toAttributes(dataPoint.attributes),
            count: histogram.count,
            min: histogram.min,
            max: histogram.max,
            sum: histogram.sum,
            positive: {
                offset: histogram.positive.offset,
                bucketCounts: histogram.positive.bucketCounts,
            },
            negative: {
                offset: histogram.negative.offset,
                bucketCounts: histogram.negative.bucketCounts,
            },
            scale: histogram.scale,
            zeroCount: histogram.zeroCount,
            startTimeUnixNano: encoder.encodeHrTime(dataPoint.startTime),
            timeUnixNano: encoder.encodeHrTime(dataPoint.endTime),
        };
    });
}
function toAggregationTemporality(temporality) {
    switch (temporality) {
        case AggregationTemporality.DELTA:
            return 1 /* AGGREGATION_TEMPORALITY_DELTA */;
        case AggregationTemporality.CUMULATIVE:
            return 2 /* AGGREGATION_TEMPORALITY_CUMULATIVE */;
    }
}
function createExportMetricsServiceRequest(resourceMetrics, options) {
    return {
        resourceMetrics: resourceMetrics.map(function (metrics) {
            return toResourceMetrics(metrics, options);
        }),
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var metricsResponseType = rootExports.opentelemetry.proto.collector.metrics.v1
    .ExportMetricsServiceResponse;
var metricsRequestType = rootExports.opentelemetry.proto.collector.metrics.v1
    .ExportMetricsServiceRequest;
var ProtobufMetricsSerializer = {
    serializeRequest: function (arg) {
        var request = createExportMetricsServiceRequest([arg]);
        return metricsRequestType.encode(request).finish();
    },
    deserializeResponse: function (arg) {
        return metricsResponseType.decode(arg);
    },
};

var __values$3 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$2 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
function sdkSpanToOtlpSpan(span, encoder) {
    var _a;
    var ctx = span.spanContext();
    var status = span.status;
    return {
        traceId: encoder.encodeSpanContext(ctx.traceId),
        spanId: encoder.encodeSpanContext(ctx.spanId),
        parentSpanId: encoder.encodeOptionalSpanContext(span.parentSpanId),
        traceState: (_a = ctx.traceState) === null || _a === undefined ? undefined : _a.serialize(),
        name: span.name,
        // Span kind is offset by 1 because the API does not define a value for unset
        kind: span.kind == null ? 0 : span.kind + 1,
        startTimeUnixNano: encoder.encodeHrTime(span.startTime),
        endTimeUnixNano: encoder.encodeHrTime(span.endTime),
        attributes: toAttributes(span.attributes),
        droppedAttributesCount: span.droppedAttributesCount,
        events: span.events.map(function (event) { return toOtlpSpanEvent(event, encoder); }),
        droppedEventsCount: span.droppedEventsCount,
        status: {
            // API and proto enums share the same values
            code: status.code,
            message: status.message,
        },
        links: span.links.map(function (link) { return toOtlpLink(link, encoder); }),
        droppedLinksCount: span.droppedLinksCount,
    };
}
function toOtlpLink(link, encoder) {
    var _a;
    return {
        attributes: link.attributes ? toAttributes(link.attributes) : [],
        spanId: encoder.encodeSpanContext(link.context.spanId),
        traceId: encoder.encodeSpanContext(link.context.traceId),
        traceState: (_a = link.context.traceState) === null || _a === undefined ? undefined : _a.serialize(),
        droppedAttributesCount: link.droppedAttributesCount || 0,
    };
}
function toOtlpSpanEvent(timedEvent, encoder) {
    return {
        attributes: timedEvent.attributes
            ? toAttributes(timedEvent.attributes)
            : [],
        name: timedEvent.name,
        timeUnixNano: encoder.encodeHrTime(timedEvent.time),
        droppedAttributesCount: timedEvent.droppedAttributesCount || 0,
    };
}
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createExportTraceServiceRequest(spans, options) {
    var encoder = getOtlpEncoder(options);
    return {
        resourceSpans: spanRecordsToResourceSpans(spans, encoder),
    };
}
function createResourceMap(readableSpans) {
    var e_1, _a;
    var resourceMap = new Map();
    try {
        for (var readableSpans_1 = __values$3(readableSpans), readableSpans_1_1 = readableSpans_1.next(); !readableSpans_1_1.done; readableSpans_1_1 = readableSpans_1.next()) {
            var record = readableSpans_1_1.value;
            var ilmMap = resourceMap.get(record.resource);
            if (!ilmMap) {
                ilmMap = new Map();
                resourceMap.set(record.resource, ilmMap);
            }
            // TODO this is duplicated in basic tracer. Consolidate on a common helper in core
            var instrumentationLibraryKey = record.instrumentationLibrary.name + "@" + (record.instrumentationLibrary.version || '') + ":" + (record.instrumentationLibrary.schemaUrl || '');
            var records = ilmMap.get(instrumentationLibraryKey);
            if (!records) {
                records = [];
                ilmMap.set(instrumentationLibraryKey, records);
            }
            records.push(record);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (readableSpans_1_1 && !readableSpans_1_1.done && (_a = readableSpans_1.return)) _a.call(readableSpans_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return resourceMap;
}
function spanRecordsToResourceSpans(readableSpans, encoder) {
    var resourceMap = createResourceMap(readableSpans);
    var out = [];
    var entryIterator = resourceMap.entries();
    var entry = entryIterator.next();
    while (!entry.done) {
        var _a = __read$2(entry.value, 2), resource = _a[0], ilmMap = _a[1];
        var scopeResourceSpans = [];
        var ilmIterator = ilmMap.values();
        var ilmEntry = ilmIterator.next();
        while (!ilmEntry.done) {
            var scopeSpans = ilmEntry.value;
            if (scopeSpans.length > 0) {
                var spans = scopeSpans.map(function (readableSpan) {
                    return sdkSpanToOtlpSpan(readableSpan, encoder);
                });
                scopeResourceSpans.push({
                    scope: createInstrumentationScope(scopeSpans[0].instrumentationLibrary),
                    spans: spans,
                    schemaUrl: scopeSpans[0].instrumentationLibrary.schemaUrl,
                });
            }
            ilmEntry = ilmIterator.next();
        }
        // TODO SDK types don't provide resource schema URL at this time
        var transformedSpans = {
            resource: createResource(resource),
            scopeSpans: scopeResourceSpans,
            schemaUrl: undefined,
        };
        out.push(transformedSpans);
        entry = entryIterator.next();
    }
    return out;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var traceResponseType = rootExports.opentelemetry.proto.collector.trace.v1
    .ExportTraceServiceResponse;
var traceRequestType = rootExports.opentelemetry.proto.collector.trace.v1
    .ExportTraceServiceRequest;
var ProtobufTraceSerializer = {
    serializeRequest: function (arg) {
        var request = createExportTraceServiceRequest(arg);
        return traceRequestType.encode(request).finish();
    },
    deserializeResponse: function (arg) {
        return traceResponseType.decode(arg);
    },
};

/*
 * @experimental this serializer may receive breaking changes in minor versions, pin this package's version when using this constant
 */
var JsonLogsSerializer = {
    serializeRequest: function (arg) {
        var request = createExportLogsServiceRequest(arg, {
            useHex: true,
            useLongBits: false,
        });
        var encoder = new TextEncoder();
        return encoder.encode(JSON.stringify(request));
    },
    deserializeResponse: function (arg) {
        var decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
    },
};

var JsonMetricsSerializer = {
    serializeRequest: function (arg) {
        var request = createExportMetricsServiceRequest([arg], {
            useLongBits: false,
        });
        var encoder = new TextEncoder();
        return encoder.encode(JSON.stringify(request));
    },
    deserializeResponse: function (arg) {
        var decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
    },
};

var JsonTraceSerializer = {
    serializeRequest: function (arg) {
        var request = createExportTraceServiceRequest(arg, {
            useHex: true,
            useLongBits: false,
        });
        var encoder = new TextEncoder();
        return encoder.encode(JSON.stringify(request));
    },
    deserializeResponse: function (arg) {
        var decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
    },
};

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm = /*#__PURE__*/Object.freeze({
	__proto__: null,
	JsonLogsSerializer: JsonLogsSerializer,
	JsonMetricsSerializer: JsonMetricsSerializer,
	JsonTraceSerializer: JsonTraceSerializer,
	ProtobufLogsSerializer: ProtobufLogsSerializer,
	ProtobufMetricsSerializer: ProtobufMetricsSerializer,
	ProtobufTraceSerializer: ProtobufTraceSerializer
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(esm);

var hasRequiredOTLPTraceExporter;

function requireOTLPTraceExporter () {
	if (hasRequiredOTLPTraceExporter) return OTLPTraceExporter$1;
	hasRequiredOTLPTraceExporter = 1;
	/*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	Object.defineProperty(OTLPTraceExporter$1, "__esModule", { value: true });
	OTLPTraceExporter$1.OTLPTraceExporter = undefined;
	const otlp_grpc_exporter_base_1 = /*@__PURE__*/ requireSrc$1();
	const otlp_transformer_1 = require$$1;
	const otlp_exporter_base_1 = require$$2$1;
	/**
	 * OTLP Trace Exporter for Node
	 */
	class OTLPTraceExporter extends otlp_exporter_base_1.OTLPExporterBase {
	    constructor(config = {}) {
	        super((0, otlp_grpc_exporter_base_1.createOtlpGrpcExportDelegate)((0, otlp_grpc_exporter_base_1.convertLegacyOtlpGrpcOptions)(config, 'TRACES'), otlp_transformer_1.ProtobufTraceSerializer, 'TraceExportService', '/opentelemetry.proto.collector.trace.v1.TraceService/Export'));
	    }
	}
	OTLPTraceExporter$1.OTLPTraceExporter = OTLPTraceExporter;
	
	return OTLPTraceExporter$1;
}

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src$1;
	hasRequiredSrc = 1;
	(function (exports) {
		/*
		 * Copyright The OpenTelemetry Authors
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      https://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		var __createBinding = (src$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (src$1.__exportStar) || function(m, exports) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
		};
		Object.defineProperty(exports, "__esModule", { value: true });
		/* eslint no-restricted-syntax: ["warn", "ExportAllDeclaration"] --
		 * TODO: Replace wildcard export with named exports before next major version
		 */
		__exportStar(/*@__PURE__*/ requireOTLPTraceExporter(), exports);
		
	} (src$1));
	return src$1;
}

var srcExports = /*@__PURE__*/ requireSrc();

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// this is autogenerated file, see scripts/version-update.js
var VERSION = '0.57.1';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Collector Trace Exporter for Node with protobuf
 */
var OTLPTraceExporter = /** @class */ (function (_super) {
    __extends$1(OTLPTraceExporter, _super);
    function OTLPTraceExporter(config) {
        if (config === undefined) { config = {}; }
        return _super.call(this, createOtlpHttpExportDelegate(convertLegacyHttpOptions(config, 'TRACES', 'v1/traces', {
            'User-Agent': "OTel-OTLP-Exporter-JavaScript/" + VERSION,
            'Content-Type': 'application/x-protobuf',
        }), ProtobufTraceSerializer)) || this;
    }
    return OTLPTraceExporter;
}(OTLPExporterBase));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Event name definitions
var ExceptionEventName = 'exception';

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values$2 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$1 = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray$1 = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * This class represents a span.
 */
var Span = /** @class */ (function () {
    /**
     * Constructs a new Span instance.
     *
     * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
     * */
    function Span(parentTracer, context, spanName, spanContext, kind, parentSpanId, links, startTime, _deprecatedClock, // keeping this argument even though it is unused to ensure backwards compatibility
    attributes) {
        if (links === undefined) { links = []; }
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
            code: SpanStatusCode.UNSET,
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        var now = Date.now();
        this._performanceStartTime = otperformance.now();
        this._performanceOffset =
            now - (this._performanceStartTime + getTimeOrigin());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== undefined ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._attributeValueLengthLimit =
            this._spanLimits.attributeValueLengthLimit || 0;
        if (attributes != null) {
            this.setAttributes(attributes);
        }
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context);
    }
    Span.prototype.spanContext = function () {
        return this._spanContext;
    };
    Span.prototype.setAttribute = function (key, value) {
        if (value == null || this._isSpanEnded())
            return this;
        if (key.length === 0) {
            diag.warn("Invalid attribute key: " + key);
            return this;
        }
        if (!isAttributeValue(value)) {
            diag.warn("Invalid attribute value set for key: " + key);
            return this;
        }
        if (Object.keys(this.attributes).length >=
            this._spanLimits.attributeCountLimit &&
            !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
            this._droppedAttributesCount++;
            return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
    };
    Span.prototype.setAttributes = function (attributes) {
        var e_1, _a;
        try {
            for (var _b = __values$2(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read$1(_c.value, 2), k = _d[0], v = _d[1];
                this.setAttribute(k, v);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    /**
     *
     * @param name Span Name
     * @param [attributesOrStartTime] Span attributes or start time
     *     if type is {@type TimeInput} and 3rd param is undefined
     * @param [timeStamp] Specified time stamp for the event
     */
    Span.prototype.addEvent = function (name, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded())
            return this;
        if (this._spanLimits.eventCountLimit === 0) {
            diag.warn('No events allowed.');
            this._droppedEventsCount++;
            return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
            if (this._droppedEventsCount === 0) {
                diag.debug('Dropping extra events.');
            }
            this.events.shift();
            this._droppedEventsCount++;
        }
        if (isTimeInput(attributesOrStartTime)) {
            if (!isTimeInput(timeStamp)) {
                timeStamp = attributesOrStartTime;
            }
            attributesOrStartTime = undefined;
        }
        var attributes = sanitizeAttributes(attributesOrStartTime);
        this.events.push({
            name: name,
            attributes: attributes,
            time: this._getTime(timeStamp),
            droppedAttributesCount: 0,
        });
        return this;
    };
    Span.prototype.addLink = function (link) {
        this.links.push(link);
        return this;
    };
    Span.prototype.addLinks = function (links) {
        var _a;
        (_a = this.links).push.apply(_a, __spreadArray$1([], __read$1(links), false));
        return this;
    };
    Span.prototype.setStatus = function (status) {
        if (this._isSpanEnded())
            return this;
        this.status = __assign({}, status);
        // When using try-catch, the caught "error" is of type `any`. When then assigning `any` to `status.message`,
        // TypeScript will not error. While this can happen during use of any API, it is more common on Span#setStatus()
        // as it's likely used in a catch-block. Therefore, we validate if `status.message` is actually a string, null, or
        // undefined to avoid an incorrect type causing issues downstream.
        if (this.status.message != null && typeof status.message !== 'string') {
            diag.warn("Dropping invalid status.message of type '" + typeof status.message + "', expected 'string'");
            delete this.status.message;
        }
        return this;
    };
    Span.prototype.updateName = function (name) {
        if (this._isSpanEnded())
            return this;
        this.name = name;
        return this;
    };
    Span.prototype.end = function (endTime) {
        if (this._isSpanEnded()) {
            diag.error(this.name + " " + this._spanContext.traceId + "-" + this._spanContext.spanId + " - You can only call end() on a span once.");
            return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = hrTimeDuration(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
            diag.warn('Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.', this.startTime, this.endTime);
            this.endTime = this.startTime.slice();
            this._duration = [0, 0];
        }
        if (this._droppedEventsCount > 0) {
            diag.warn("Dropped " + this._droppedEventsCount + " events because eventCountLimit reached");
        }
        this._spanProcessor.onEnd(this);
    };
    Span.prototype._getTime = function (inp) {
        if (typeof inp === 'number' && inp <= otperformance.now()) {
            // must be a performance timestamp
            // apply correction and convert to hrtime
            return hrTime(inp + this._performanceOffset);
        }
        if (typeof inp === 'number') {
            return millisToHrTime(inp);
        }
        if (inp instanceof Date) {
            return millisToHrTime(inp.getTime());
        }
        if (isTimeInputHrTime(inp)) {
            return inp;
        }
        if (this._startTimeProvided) {
            // if user provided a time for the start manually
            // we can't use duration to calculate event/end times
            return millisToHrTime(Date.now());
        }
        var msDuration = otperformance.now() - this._performanceStartTime;
        return addHrTimes(this.startTime, millisToHrTime(msDuration));
    };
    Span.prototype.isRecording = function () {
        return this._ended === false;
    };
    Span.prototype.recordException = function (exception, time) {
        var attributes = {};
        if (typeof exception === 'string') {
            attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception;
        }
        else if (exception) {
            if (exception.code) {
                attributes[SEMATTRS_EXCEPTION_TYPE] = exception.code.toString();
            }
            else if (exception.name) {
                attributes[SEMATTRS_EXCEPTION_TYPE] = exception.name;
            }
            if (exception.message) {
                attributes[SEMATTRS_EXCEPTION_MESSAGE] = exception.message;
            }
            if (exception.stack) {
                attributes[SEMATTRS_EXCEPTION_STACKTRACE] = exception.stack;
            }
        }
        // these are minimum requirements from spec
        if (attributes[SEMATTRS_EXCEPTION_TYPE] ||
            attributes[SEMATTRS_EXCEPTION_MESSAGE]) {
            this.addEvent(ExceptionEventName, attributes, time);
        }
        else {
            diag.warn("Failed to record an exception " + exception);
        }
    };
    Object.defineProperty(Span.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "ended", {
        get: function () {
            return this._ended;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "droppedAttributesCount", {
        get: function () {
            return this._droppedAttributesCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "droppedEventsCount", {
        get: function () {
            return this._droppedEventsCount;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Span.prototype, "droppedLinksCount", {
        get: function () {
            return this._droppedLinksCount;
        },
        enumerable: false,
        configurable: true
    });
    Span.prototype._isSpanEnded = function () {
        if (this._ended) {
            diag.warn("Can not execute the operation on ended Span {traceId: " + this._spanContext.traceId + ", spanId: " + this._spanContext.spanId + "}");
        }
        return this._ended;
    };
    // Utility function to truncate given value within size
    // for value type of string, will truncate to given limit
    // for type of non-string, will return same value
    Span.prototype._truncateToLimitUtil = function (value, limit) {
        if (value.length <= limit) {
            return value;
        }
        return value.substring(0, limit);
    };
    /**
     * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
     * return string with truncated to {@code attributeValueLengthLimit} characters
     *
     * If the given attribute value is array of strings then
     * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
     *
     * Otherwise return same Attribute {@code value}
     *
     * @param value Attribute value
     * @returns truncated attribute value if required, otherwise same value
     */
    Span.prototype._truncateToSize = function (value) {
        var _this = this;
        var limit = this._attributeValueLengthLimit;
        // Check limit
        if (limit <= 0) {
            // Negative values are invalid, so do not truncate
            diag.warn("Attribute value limit must be positive, got " + limit);
            return value;
        }
        // String
        if (typeof value === 'string') {
            return this._truncateToLimitUtil(value, limit);
        }
        // Array of strings
        if (Array.isArray(value)) {
            return value.map(function (val) {
                return typeof val === 'string' ? _this._truncateToLimitUtil(val, limit) : val;
            });
        }
        // Other types, no need to apply value length limit
        return value;
    };
    return Span;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */
var SamplingDecision;
(function (SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */
    SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */
    SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */
    SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Sampler that samples no traces. */
var AlwaysOffSampler = /** @class */ (function () {
    function AlwaysOffSampler() {
    }
    AlwaysOffSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.NOT_RECORD,
        };
    };
    AlwaysOffSampler.prototype.toString = function () {
        return 'AlwaysOffSampler';
    };
    return AlwaysOffSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Sampler that samples all traces. */
var AlwaysOnSampler = /** @class */ (function () {
    function AlwaysOnSampler() {
    }
    AlwaysOnSampler.prototype.shouldSample = function () {
        return {
            decision: SamplingDecision.RECORD_AND_SAMPLED,
        };
    };
    AlwaysOnSampler.prototype.toString = function () {
        return 'AlwaysOnSampler';
    };
    return AlwaysOnSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A composite sampler that either respects the parent span's sampling decision
 * or delegates to `delegateSampler` for root spans.
 */
var ParentBasedSampler = /** @class */ (function () {
    function ParentBasedSampler(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
            globalErrorHandler(new Error('ParentBasedSampler must have a root sampler configured'));
            this._root = new AlwaysOnSampler();
        }
        this._remoteParentSampled =
            (_a = config.remoteParentSampled) !== null && _a !== undefined ? _a : new AlwaysOnSampler();
        this._remoteParentNotSampled =
            (_b = config.remoteParentNotSampled) !== null && _b !== undefined ? _b : new AlwaysOffSampler();
        this._localParentSampled =
            (_c = config.localParentSampled) !== null && _c !== undefined ? _c : new AlwaysOnSampler();
        this._localParentNotSampled =
            (_d = config.localParentNotSampled) !== null && _d !== undefined ? _d : new AlwaysOffSampler();
    }
    ParentBasedSampler.prototype.shouldSample = function (context, traceId, spanName, spanKind, attributes, links) {
        var parentContext = trace.getSpanContext(context);
        if (!parentContext || !isSpanContextValid(parentContext)) {
            return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
            if (parentContext.traceFlags & TraceFlags.SAMPLED) {
                return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
            }
            return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & TraceFlags.SAMPLED) {
            return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    };
    ParentBasedSampler.prototype.toString = function () {
        return "ParentBased{root=" + this._root.toString() + ", remoteParentSampled=" + this._remoteParentSampled.toString() + ", remoteParentNotSampled=" + this._remoteParentNotSampled.toString() + ", localParentSampled=" + this._localParentSampled.toString() + ", localParentNotSampled=" + this._localParentNotSampled.toString() + "}";
    };
    return ParentBasedSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Sampler that samples a given fraction of traces based of trace id deterministically. */
var TraceIdRatioBasedSampler = /** @class */ (function () {
    function TraceIdRatioBasedSampler(_ratio) {
        if (_ratio === undefined) { _ratio = 0; }
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 0xffffffff);
    }
    TraceIdRatioBasedSampler.prototype.shouldSample = function (context, traceId) {
        return {
            decision: isValidTraceId(traceId) && this._accumulate(traceId) < this._upperBound
                ? SamplingDecision.RECORD_AND_SAMPLED
                : SamplingDecision.NOT_RECORD,
        };
    };
    TraceIdRatioBasedSampler.prototype.toString = function () {
        return "TraceIdRatioBased{" + this._ratio + "}";
    };
    TraceIdRatioBasedSampler.prototype._normalize = function (ratio) {
        if (typeof ratio !== 'number' || isNaN(ratio))
            return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
    };
    TraceIdRatioBasedSampler.prototype._accumulate = function (traceId) {
        var accumulation = 0;
        for (var i = 0; i < traceId.length / 8; i++) {
            var pos = i * 8;
            var part = parseInt(traceId.slice(pos, pos + 8), 16);
            accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
    };
    return TraceIdRatioBasedSampler;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var FALLBACK_OTEL_TRACES_SAMPLER = TracesSamplerValues.AlwaysOn;
var DEFAULT_RATIO = 1;
/**
 * Load default configuration. For fields with primitive values, any user-provided
 * value will override the corresponding default value. For fields with
 * non-primitive values (like `spanLimits`), the user-provided value will be
 * used to extend the default value.
 */
// object needs to be wrapped in this function and called when needed otherwise
// envs are parsed before tests are ran - causes tests using these envs to fail
function loadDefaultConfig() {
    var env = getEnv();
    return {
        sampler: buildSamplerFromEnv(env),
        forceFlushTimeoutMillis: 30000,
        generalLimits: {
            attributeValueLengthLimit: env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: env.OTEL_ATTRIBUTE_COUNT_LIMIT,
        },
        spanLimits: {
            attributeValueLengthLimit: env.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
            attributeCountLimit: env.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
            linkCountLimit: env.OTEL_SPAN_LINK_COUNT_LIMIT,
            eventCountLimit: env.OTEL_SPAN_EVENT_COUNT_LIMIT,
            attributePerEventCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
            attributePerLinkCountLimit: env.OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
        },
        mergeResourceWithDefaults: true,
    };
}
/**
 * Based on environment, builds a sampler, complies with specification.
 * @param environment optional, by default uses getEnv(), but allows passing a value to reuse parsed environment
 */
function buildSamplerFromEnv(environment) {
    if (environment === undefined) { environment = getEnv(); }
    switch (environment.OTEL_TRACES_SAMPLER) {
        case TracesSamplerValues.AlwaysOn:
            return new AlwaysOnSampler();
        case TracesSamplerValues.AlwaysOff:
            return new AlwaysOffSampler();
        case TracesSamplerValues.ParentBasedAlwaysOn:
            return new ParentBasedSampler({
                root: new AlwaysOnSampler(),
            });
        case TracesSamplerValues.ParentBasedAlwaysOff:
            return new ParentBasedSampler({
                root: new AlwaysOffSampler(),
            });
        case TracesSamplerValues.TraceIdRatio:
            return new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case TracesSamplerValues.ParentBasedTraceIdRatio:
            return new ParentBasedSampler({
                root: new TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment)),
            });
        default:
            diag.error("OTEL_TRACES_SAMPLER value \"" + environment.OTEL_TRACES_SAMPLER + " invalid, defaulting to " + FALLBACK_OTEL_TRACES_SAMPLER + "\".");
            return new AlwaysOnSampler();
    }
}
function getSamplerProbabilityFromEnv(environment) {
    if (environment.OTEL_TRACES_SAMPLER_ARG === undefined ||
        environment.OTEL_TRACES_SAMPLER_ARG === '') {
        diag.error("OTEL_TRACES_SAMPLER_ARG is blank, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    var probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
    if (isNaN(probability)) {
        diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is invalid, defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    if (probability < 0 || probability > 1) {
        diag.error("OTEL_TRACES_SAMPLER_ARG=" + environment.OTEL_TRACES_SAMPLER_ARG + " was given, but it is out of range ([0..1]), defaulting to " + DEFAULT_RATIO + ".");
        return DEFAULT_RATIO;
    }
    return probability;
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Function to merge Default configuration (as specified in './config') with
 * user provided configurations.
 */
function mergeConfig(userConfig) {
    var perInstanceDefaults = {
        sampler: buildSamplerFromEnv(),
    };
    var DEFAULT_CONFIG = loadDefaultConfig();
    var target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
    target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
    target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
    return target;
}
/**
 * When general limits are provided and model specific limits are not,
 * configures the model specific limits by using the values from the general ones.
 * @param userConfig User provided tracer configuration
 */
function reconfigureLimits(userConfig) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var spanLimits = Object.assign({}, userConfig.spanLimits);
    var parsedEnvConfig = getEnvWithoutDefaults();
    /**
     * Reassign span attribute count limit to use first non null value defined by user or use default value
     */
    spanLimits.attributeCountLimit =
        (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === undefined ? undefined : _a.attributeCountLimit) !== null && _b !== undefined ? _b : (_c = userConfig.generalLimits) === null || _c === undefined ? undefined : _c.attributeCountLimit) !== null && _d !== undefined ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== undefined ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== undefined ? _f : DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    /**
     * Reassign span attribute value length limit to use first non null value defined by user or use default value
     */
    spanLimits.attributeValueLengthLimit =
        (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === undefined ? undefined : _g.attributeValueLengthLimit) !== null && _h !== undefined ? _h : (_j = userConfig.generalLimits) === null || _j === undefined ? undefined : _j.attributeValueLengthLimit) !== null && _k !== undefined ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== undefined ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== undefined ? _m : DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    return Object.assign({}, userConfig, { spanLimits: spanLimits });
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Implementation of the {@link SpanProcessor} that batches spans exported by
 * the SDK then pushes them to the exporter pipeline.
 */
var BatchSpanProcessorBase = /** @class */ (function () {
    function BatchSpanProcessorBase(_exporter, config) {
        this._exporter = _exporter;
        this._isExporting = false;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        var env = getEnv();
        this._maxExportBatchSize =
            typeof (config === null || config === undefined ? undefined : config.maxExportBatchSize) === 'number'
                ? config.maxExportBatchSize
                : env.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize =
            typeof (config === null || config === undefined ? undefined : config.maxQueueSize) === 'number'
                ? config.maxQueueSize
                : env.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis =
            typeof (config === null || config === undefined ? undefined : config.scheduledDelayMillis) === 'number'
                ? config.scheduledDelayMillis
                : env.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis =
            typeof (config === null || config === undefined ? undefined : config.exportTimeoutMillis) === 'number'
                ? config.exportTimeoutMillis
                : env.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
            diag.warn('BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize');
            this._maxExportBatchSize = this._maxQueueSize;
        }
    }
    BatchSpanProcessorBase.prototype.forceFlush = function () {
        if (this._shutdownOnce.isCalled) {
            return this._shutdownOnce.promise;
        }
        return this._flushAll();
    };
    // does nothing.
    BatchSpanProcessorBase.prototype.onStart = function (_span, _parentContext) { };
    BatchSpanProcessorBase.prototype.onEnd = function (span) {
        if (this._shutdownOnce.isCalled) {
            return;
        }
        if ((span.spanContext().traceFlags & TraceFlags.SAMPLED) === 0) {
            return;
        }
        this._addToBuffer(span);
    };
    BatchSpanProcessorBase.prototype.shutdown = function () {
        return this._shutdownOnce.call();
    };
    BatchSpanProcessorBase.prototype._shutdown = function () {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            return _this.onShutdown();
        })
            .then(function () {
            return _this._flushAll();
        })
            .then(function () {
            return _this._exporter.shutdown();
        });
    };
    /** Add a span in the buffer. */
    BatchSpanProcessorBase.prototype._addToBuffer = function (span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
            // limit reached, drop span
            if (this._droppedSpansCount === 0) {
                diag.debug('maxQueueSize reached, dropping spans');
            }
            this._droppedSpansCount++;
            return;
        }
        if (this._droppedSpansCount > 0) {
            // some spans were dropped, log once with count of spans dropped
            diag.warn("Dropped " + this._droppedSpansCount + " spans because maxQueueSize reached");
            this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
    };
    /**
     * Send all spans to the exporter respecting the batch size limit
     * This function is used only on forceFlush or shutdown,
     * for all other cases _flush should be used
     * */
    BatchSpanProcessorBase.prototype._flushAll = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = [];
            // calculate number of batches
            var count = Math.ceil(_this._finishedSpans.length / _this._maxExportBatchSize);
            for (var i = 0, j = count; i < j; i++) {
                promises.push(_this._flushOneBatch());
            }
            Promise.all(promises)
                .then(function () {
                resolve();
            })
                .catch(reject);
        });
    };
    BatchSpanProcessorBase.prototype._flushOneBatch = function () {
        var _this = this;
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var timer = setTimeout(function () {
                // don't wait anymore for export, this way the next batch can start
                reject(new Error('Timeout'));
            }, _this._exportTimeoutMillis);
            // prevent downstream exporter calls from generating spans
            context.with(suppressTracing(context.active()), function () {
                // Reset the finished spans buffer here because the next invocations of the _flush method
                // could pass the same finished spans to the exporter if the buffer is cleared
                // outside the execution of this callback.
                var spans;
                if (_this._finishedSpans.length <= _this._maxExportBatchSize) {
                    spans = _this._finishedSpans;
                    _this._finishedSpans = [];
                }
                else {
                    spans = _this._finishedSpans.splice(0, _this._maxExportBatchSize);
                }
                var doExport = function () {
                    return _this._exporter.export(spans, function (result) {
                        var _a;
                        clearTimeout(timer);
                        if (result.code === ExportResultCode.SUCCESS) {
                            resolve();
                        }
                        else {
                            reject((_a = result.error) !== null && _a !== undefined ? _a : new Error('BatchSpanProcessor: span export failed'));
                        }
                    });
                };
                var pendingResources = null;
                for (var i = 0, len = spans.length; i < len; i++) {
                    var span = spans[i];
                    if (span.resource.asyncAttributesPending &&
                        span.resource.waitForAsyncAttributes) {
                        pendingResources !== null && pendingResources !== undefined ? pendingResources : (pendingResources = []);
                        pendingResources.push(span.resource.waitForAsyncAttributes());
                    }
                }
                // Avoid scheduling a promise to make the behavior more predictable and easier to test
                if (pendingResources === null) {
                    doExport();
                }
                else {
                    Promise.all(pendingResources).then(doExport, function (err) {
                        globalErrorHandler(err);
                        reject(err);
                    });
                }
            });
        });
    };
    BatchSpanProcessorBase.prototype._maybeStartTimer = function () {
        var _this = this;
        if (this._isExporting)
            return;
        var flush = function () {
            _this._isExporting = true;
            _this._flushOneBatch()
                .finally(function () {
                _this._isExporting = false;
                if (_this._finishedSpans.length > 0) {
                    _this._clearTimer();
                    _this._maybeStartTimer();
                }
            })
                .catch(function (e) {
                _this._isExporting = false;
                globalErrorHandler(e);
            });
        };
        // we only wait if the queue doesn't have enough elements yet
        if (this._finishedSpans.length >= this._maxExportBatchSize) {
            return flush();
        }
        if (this._timer !== undefined)
            return;
        this._timer = setTimeout(function () { return flush(); }, this._scheduledDelayMillis);
        unrefTimer(this._timer);
    };
    BatchSpanProcessorBase.prototype._clearTimer = function () {
        if (this._timer !== undefined) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
    };
    return BatchSpanProcessorBase;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var BatchSpanProcessor = /** @class */ (function (_super) {
    __extends(BatchSpanProcessor, _super);
    function BatchSpanProcessor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BatchSpanProcessor.prototype.onShutdown = function () { };
    return BatchSpanProcessor;
}(BatchSpanProcessorBase));

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SPAN_ID_BYTES = 8;
var TRACE_ID_BYTES = 16;
var RandomIdGenerator = /** @class */ (function () {
    function RandomIdGenerator() {
        /**
         * Returns a random 16-byte trace ID formatted/encoded as a 32 lowercase hex
         * characters corresponding to 128 bits.
         */
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        /**
         * Returns a random 8-byte span ID formatted/encoded as a 16 lowercase hex
         * characters corresponding to 64 bits.
         */
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
    }
    return RandomIdGenerator;
}());
var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
function getIdGenerator(bytes) {
    return function generateId() {
        for (var i = 0; i < bytes / 4; i++) {
            // unsigned right shift drops decimal part of the number
            // it is required because if a number between 2**32 and 2**32 - 1 is generated, an out of range error is thrown by writeUInt32BE
            SHARED_BUFFER.writeUInt32BE((Math.random() * Math.pow(2, 32)) >>> 0, i * 4);
        }
        // If buffer is all 0, set the last byte to 1 to guarantee a valid w3c id is generated
        for (var i = 0; i < bytes; i++) {
            if (SHARED_BUFFER[i] > 0) {
                break;
            }
            else if (i === bytes - 1) {
                SHARED_BUFFER[bytes - 1] = 1;
            }
        }
        return SHARED_BUFFER.toString('hex', 0, bytes);
    };
}

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class represents a basic tracer.
 */
var Tracer = /** @class */ (function () {
    /**
     * Constructs a new Tracer instance.
     */
    function Tracer(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        var localConfig = mergeConfig(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
    }
    /**
     * Starts a new Span or returns the default NoopSpan based on the sampling
     * decision.
     */
    Tracer.prototype.startSpan = function (name, options, context$1) {
        var _a, _b, _c;
        if (options === undefined) { options = {}; }
        if (context$1 === undefined) { context$1 = context.active(); }
        // remove span from context in case a root span is requested via options
        if (options.root) {
            context$1 = trace.deleteSpan(context$1);
        }
        var parentSpan = trace.getSpan(context$1);
        if (isTracingSuppressed(context$1)) {
            diag.debug('Instrumentation suppressed, returning Noop Span');
            var nonRecordingSpan = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);
            return nonRecordingSpan;
        }
        var parentSpanContext = parentSpan === null || parentSpan === undefined ? undefined : parentSpan.spanContext();
        var spanId = this._idGenerator.generateSpanId();
        var traceId;
        var traceState;
        var parentSpanId;
        if (!parentSpanContext ||
            !trace.isSpanContextValid(parentSpanContext)) {
            // New root span.
            traceId = this._idGenerator.generateTraceId();
        }
        else {
            // New child span.
            traceId = parentSpanContext.traceId;
            traceState = parentSpanContext.traceState;
            parentSpanId = parentSpanContext.spanId;
        }
        var spanKind = (_a = options.kind) !== null && _a !== undefined ? _a : SpanKind.INTERNAL;
        var links = ((_b = options.links) !== null && _b !== undefined ? _b : []).map(function (link) {
            return {
                context: link.context,
                attributes: sanitizeAttributes(link.attributes),
            };
        });
        var attributes = sanitizeAttributes(options.attributes);
        // make sampling decision
        var samplingResult = this._sampler.shouldSample(context$1, traceId, name, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== undefined ? _c : traceState;
        var traceFlags = samplingResult.decision === SamplingDecision$1.RECORD_AND_SAMPLED
            ? TraceFlags.SAMPLED
            : TraceFlags.NONE;
        var spanContext = { traceId: traceId, spanId: spanId, traceFlags: traceFlags, traceState: traceState };
        if (samplingResult.decision === SamplingDecision$1.NOT_RECORD) {
            diag.debug('Recording is off, propagating context in a non-recording span');
            var nonRecordingSpan = trace.wrapSpanContext(spanContext);
            return nonRecordingSpan;
        }
        // Set initial span attributes. The attributes object may have been mutated
        // by the sampler, so we sanitize the merged attributes before setting them.
        var initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));
        var span = new Span(this, context$1, name, spanContext, spanKind, parentSpanId, links, options.startTime, undefined, initAttributes);
        return span;
    };
    Tracer.prototype.startActiveSpan = function (name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
            return;
        }
        else if (arguments.length === 2) {
            fn = arg2;
        }
        else if (arguments.length === 3) {
            opts = arg2;
            fn = arg3;
        }
        else {
            opts = arg2;
            ctx = arg3;
            fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== undefined ? ctx : context.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = trace.setSpan(parentContext, span);
        return context.with(contextWithSpanSet, fn, undefined, span);
    };
    /** Returns the active {@link GeneralLimits}. */
    Tracer.prototype.getGeneralLimits = function () {
        return this._generalLimits;
    };
    /** Returns the active {@link SpanLimits}. */
    Tracer.prototype.getSpanLimits = function () {
        return this._spanLimits;
    };
    Tracer.prototype.getActiveSpanProcessor = function () {
        return this._tracerProvider.getActiveSpanProcessor();
    };
    return Tracer;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values$1 = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Implementation of the {@link SpanProcessor} that simply forwards all
 * received events to a list of {@link SpanProcessor}s.
 */
var MultiSpanProcessor = /** @class */ (function () {
    function MultiSpanProcessor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
    }
    MultiSpanProcessor.prototype.forceFlush = function () {
        var e_1, _a;
        var promises = [];
        try {
            for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                promises.push(spanProcessor.forceFlush());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return new Promise(function (resolve) {
            Promise.all(promises)
                .then(function () {
                resolve();
            })
                .catch(function (error) {
                globalErrorHandler(error || new Error('MultiSpanProcessor: forceFlush failed'));
                resolve();
            });
        });
    };
    MultiSpanProcessor.prototype.onStart = function (span, context) {
        var e_2, _a;
        try {
            for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                spanProcessor.onStart(span, context);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    MultiSpanProcessor.prototype.onEnd = function (span) {
        var e_3, _a;
        try {
            for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                spanProcessor.onEnd(span);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    MultiSpanProcessor.prototype.shutdown = function () {
        var e_4, _a;
        var promises = [];
        try {
            for (var _b = __values$1(this._spanProcessors), _c = _b.next(); !_c.done; _c = _b.next()) {
                var spanProcessor = _c.value;
                promises.push(spanProcessor.shutdown());
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return new Promise(function (resolve, reject) {
            Promise.all(promises).then(function () {
                resolve();
            }, reject);
        });
    };
    return MultiSpanProcessor;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** No-op implementation of SpanProcessor */
var NoopSpanProcessor = /** @class */ (function () {
    function NoopSpanProcessor() {
    }
    NoopSpanProcessor.prototype.onStart = function (_span, _context) { };
    NoopSpanProcessor.prototype.onEnd = function (_span) { };
    NoopSpanProcessor.prototype.shutdown = function () {
        return Promise.resolve();
    };
    NoopSpanProcessor.prototype.forceFlush = function () {
        return Promise.resolve();
    };
    return NoopSpanProcessor;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var ForceFlushState;
(function (ForceFlushState) {
    ForceFlushState[ForceFlushState["resolved"] = 0] = "resolved";
    ForceFlushState[ForceFlushState["timeout"] = 1] = "timeout";
    ForceFlushState[ForceFlushState["error"] = 2] = "error";
    ForceFlushState[ForceFlushState["unresolved"] = 3] = "unresolved";
})(ForceFlushState || (ForceFlushState = {}));
/**
 * This class represents a basic tracer provider which platform libraries can extend
 */
var BasicTracerProvider = /** @class */ (function () {
    function BasicTracerProvider(config) {
        if (config === undefined) { config = {}; }
        var _a, _b;
        this._registeredSpanProcessors = [];
        this._tracers = new Map();
        var mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== undefined ? _a : Resource.empty();
        if (mergedConfig.mergeResourceWithDefaults) {
            this.resource = Resource.default().merge(this.resource);
        }
        this._config = Object.assign({}, mergedConfig, {
            resource: this.resource,
        });
        if ((_b = config.spanProcessors) === null || _b === undefined ? undefined : _b.length) {
            this._registeredSpanProcessors = __spreadArray([], __read(config.spanProcessors), false);
            this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
        }
        else {
            var defaultExporter = this._buildExporterFromEnv();
            if (defaultExporter !== undefined) {
                var batchProcessor = new BatchSpanProcessor(defaultExporter);
                this.activeSpanProcessor = batchProcessor;
            }
            else {
                this.activeSpanProcessor = new NoopSpanProcessor();
            }
        }
    }
    BasicTracerProvider.prototype.getTracer = function (name, version, options) {
        var key = name + "@" + (version || '') + ":" + ((options === null || options === undefined ? undefined : options.schemaUrl) || '');
        if (!this._tracers.has(key)) {
            this._tracers.set(key, new Tracer({ name: name, version: version, schemaUrl: options === null || options === undefined ? undefined : options.schemaUrl }, this._config, this));
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this._tracers.get(key);
    };
    /**
     * @deprecated please use {@link TracerConfig} spanProcessors property
     * Adds a new {@link SpanProcessor} to this tracer.
     * @param spanProcessor the new SpanProcessor to be added.
     */
    BasicTracerProvider.prototype.addSpanProcessor = function (spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
            // since we might have enabled by default a batchProcessor, we disable it
            // before adding the new one
            this.activeSpanProcessor
                .shutdown()
                .catch(function (err) {
                return diag.error('Error while trying to shutdown current span processor', err);
            });
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor(this._registeredSpanProcessors);
    };
    BasicTracerProvider.prototype.getActiveSpanProcessor = function () {
        return this.activeSpanProcessor;
    };
    /**
     * Register this TracerProvider for use with the OpenTelemetry API.
     * Undefined values may be replaced with defaults, and
     * null values will be skipped.
     *
     * @param config Configuration object for SDK registration
     */
    BasicTracerProvider.prototype.register = function (config) {
        if (config === undefined) { config = {}; }
        trace.setGlobalTracerProvider(this);
        if (config.propagator === undefined) {
            config.propagator = this._buildPropagatorFromEnv();
        }
        if (config.contextManager) {
            context.setGlobalContextManager(config.contextManager);
        }
        if (config.propagator) {
            propagation.setGlobalPropagator(config.propagator);
        }
    };
    BasicTracerProvider.prototype.forceFlush = function () {
        var timeout = this._config.forceFlushTimeoutMillis;
        var promises = this._registeredSpanProcessors.map(function (spanProcessor) {
            return new Promise(function (resolve) {
                var state;
                var timeoutInterval = setTimeout(function () {
                    resolve(new Error("Span processor did not completed within timeout period of " + timeout + " ms"));
                    state = ForceFlushState.timeout;
                }, timeout);
                spanProcessor
                    .forceFlush()
                    .then(function () {
                    clearTimeout(timeoutInterval);
                    if (state !== ForceFlushState.timeout) {
                        state = ForceFlushState.resolved;
                        resolve(state);
                    }
                })
                    .catch(function (error) {
                    clearTimeout(timeoutInterval);
                    state = ForceFlushState.error;
                    resolve(error);
                });
            });
        });
        return new Promise(function (resolve, reject) {
            Promise.all(promises)
                .then(function (results) {
                var errors = results.filter(function (result) { return result !== ForceFlushState.resolved; });
                if (errors.length > 0) {
                    reject(errors);
                }
                else {
                    resolve();
                }
            })
                .catch(function (error) { return reject([error]); });
        });
    };
    BasicTracerProvider.prototype.shutdown = function () {
        return this.activeSpanProcessor.shutdown();
    };
    /**
     * TS cannot yet infer the type of this.constructor:
     * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
     * There is no need to override either of the getters in your child class.
     * The type of the registered component maps should be the same across all
     * classes in the inheritance tree.
     */
    BasicTracerProvider.prototype._getPropagator = function (name) {
        var _a;
        return (_a = this.constructor._registeredPropagators.get(name)) === null || _a === undefined ? undefined : _a();
    };
    BasicTracerProvider.prototype._getSpanExporter = function (name) {
        var _a;
        return (_a = this.constructor._registeredExporters.get(name)) === null || _a === undefined ? undefined : _a();
    };
    BasicTracerProvider.prototype._buildPropagatorFromEnv = function () {
        var _this = this;
        // per spec, propagators from env must be deduplicated
        var uniquePropagatorNames = Array.from(new Set(getEnv().OTEL_PROPAGATORS));
        var propagators = uniquePropagatorNames.map(function (name) {
            var propagator = _this._getPropagator(name);
            if (!propagator) {
                diag.warn("Propagator \"" + name + "\" requested through environment variable is unavailable.");
            }
            return propagator;
        });
        var validPropagators = propagators.reduce(function (list, item) {
            if (item) {
                list.push(item);
            }
            return list;
        }, []);
        if (validPropagators.length === 0) {
            return;
        }
        else if (uniquePropagatorNames.length === 1) {
            return validPropagators[0];
        }
        else {
            return new CompositePropagator({
                propagators: validPropagators,
            });
        }
    };
    BasicTracerProvider.prototype._buildExporterFromEnv = function () {
        var exporterName = getEnv().OTEL_TRACES_EXPORTER;
        if (exporterName === 'none' || exporterName === '')
            return;
        var exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
            diag.error("Exporter \"" + exporterName + "\" requested through environment variable is unavailable.");
        }
        return exporter;
    };
    BasicTracerProvider._registeredPropagators = new Map([
        ['tracecontext', function () { return new W3CTraceContextPropagator(); }],
        ['baggage', function () { return new W3CBaggagePropagator(); }],
    ]);
    BasicTracerProvider._registeredExporters = new Map();
    return BasicTracerProvider;
}());

/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = undefined;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * This is implementation of {@link SpanExporter} that prints spans to the
 * console. This class can be used for diagnostic purposes.
 *
 * NOTE: This {@link SpanExporter} is intended for diagnostics use only, output rendered to the console may change at any time.
 */
/* eslint-disable no-console */
var ConsoleSpanExporter = /** @class */ (function () {
    function ConsoleSpanExporter() {
    }
    /**
     * Export spans.
     * @param spans
     * @param resultCallback
     */
    ConsoleSpanExporter.prototype.export = function (spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
    };
    /**
     * Shutdown the exporter.
     */
    ConsoleSpanExporter.prototype.shutdown = function () {
        this._sendSpans([]);
        return this.forceFlush();
    };
    /**
     * Exports any pending spans in exporter
     */
    ConsoleSpanExporter.prototype.forceFlush = function () {
        return Promise.resolve();
    };
    /**
     * converts span info into more readable format
     * @param span
     */
    ConsoleSpanExporter.prototype._exportInfo = function (span) {
        var _a;
        return {
            resource: {
                attributes: span.resource.attributes,
            },
            instrumentationScope: span.instrumentationLibrary,
            traceId: span.spanContext().traceId,
            parentId: span.parentSpanId,
            traceState: (_a = span.spanContext().traceState) === null || _a === undefined ? undefined : _a.serialize(),
            name: span.name,
            id: span.spanContext().spanId,
            kind: span.kind,
            timestamp: hrTimeToMicroseconds(span.startTime),
            duration: hrTimeToMicroseconds(span.duration),
            attributes: span.attributes,
            status: span.status,
            events: span.events,
            links: span.links,
        };
    };
    /**
     * Showing spans in console
     * @param spans
     * @param done
     */
    ConsoleSpanExporter.prototype._sendSpans = function (spans, done) {
        var e_1, _a;
        try {
            for (var spans_1 = __values(spans), spans_1_1 = spans_1.next(); !spans_1_1.done; spans_1_1 = spans_1.next()) {
                var span = spans_1_1.value;
                console.dir(this._exportInfo(span), { depth: 3 });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (spans_1_1 && !spans_1_1.done && (_a = spans_1.return)) _a.call(spans_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (done) {
            return done({ code: ExportResultCode.SUCCESS });
        }
    };
    return ConsoleSpanExporter;
}());

const OTEL_CONSOLE_ONLY = process.env["OTEL_CONSOLE_ONLY"] === "true";
const OTEL_ID_SEED = Number.parseInt(process.env["OTEL_ID_SEED"] ?? "0");
function stringToRecord(s) {
    const record = {};
    for (const pair of s.split(",")) {
        const [key, value] = pair.split(/=(.*)/s);
        if (key && value) {
            record[key.trim()] = value.trim();
        }
    }
    return record;
}
function isHttpEndpoint(endpoint) {
    return endpoint.startsWith("https://") || endpoint.startsWith("http://");
}
function createTracerProvider(endpoint, headers, attributes) {
    // Register the context manager to enable context propagation
    const contextManager = new srcExports$1.AsyncHooksContextManager();
    contextManager.enable();
    context.setGlobalContextManager(contextManager);
    let exporter = new ConsoleSpanExporter();
    if (!OTEL_CONSOLE_ONLY) {
        if (isHttpEndpoint(endpoint)) {
            exporter = new OTLPTraceExporter({
                url: endpoint,
                headers: stringToRecord(headers),
            });
        }
        else {
            exporter = new srcExports.OTLPTraceExporter({
                url: endpoint,
                credentials: srcExports$2.credentials.createSsl(),
                metadata: srcExports$2.Metadata.fromHttp2Headers(stringToRecord(headers)),
            });
        }
    }
    const provider = new BasicTracerProvider({
        resource: new Resource(attributes),
        spanProcessors: [new BatchSpanProcessor(exporter)],
        ...(OTEL_ID_SEED && { idGenerator: new DeterministicIdGenerator(OTEL_ID_SEED) }),
    });
    provider.register();
    return provider;
}
// Copied from xorshift32amx here: https://github.com/bryc/code/blob/master/jshash/PRNGs.md#xorshift
function createRandomWithSeed(seed) {
    let a = seed;
    return function getRandomInt(max) {
        let t = Math.imul(a, 1597334677);
        t = (t >>> 24) | ((t >>> 8) & 65280) | ((t << 8) & 16711680) | (t << 24); // reverse byte order
        a ^= a << 13;
        a ^= a >>> 17;
        a ^= a << 5;
        const res = ((a + t) >>> 0) / 4294967296;
        return Math.floor(res * max);
    };
}
/**
 * A deterministic id generator for testing purposes.
 */
class DeterministicIdGenerator {
    characters = "0123456789abcdef";
    getRandomInt;
    constructor(seed) {
        this.getRandomInt = createRandomWithSeed(seed);
    }
    generateTraceId() {
        return this.generateId(32);
    }
    generateSpanId() {
        return this.generateId(16);
    }
    generateId(length) {
        let id = "";
        for (let i = 0; i < length; i++) {
            id += this.characters[this.getRandomInt(this.characters.length)];
        }
        return id;
    }
}

async function fetchGithub(token, runId) {
    const octokit = githubExports.getOctokit(token);
    coreExports.info(`Get workflow run for ${runId}`);
    const workflowRun = await getWorkflowRun(githubExports.context, octokit, runId);
    coreExports.info("Get jobs");
    const jobs = await listJobsForWorkflowRun(githubExports.context, octokit, runId);
    coreExports.info("Get job annotations");
    const jobsId = (jobs ?? []).map((job) => job.id);
    let jobAnnotations = {};
    try {
        jobAnnotations = await getJobsAnnotations(githubExports.context, octokit, jobsId);
    }
    catch (error) {
        if (error instanceof RequestError) {
            coreExports.info(`Failed to get job annotations: ${error.message}}`);
        }
        else {
            throw error;
        }
    }
    coreExports.info("Get PRs labels");
    const prNumbers = (workflowRun.pull_requests ?? []).map((pr) => pr.number);
    let prLabels = {};
    try {
        prLabels = await getPRsLabels(githubExports.context, octokit, prNumbers);
    }
    catch (error) {
        if (error instanceof RequestError) {
            coreExports.info(`Failed to get PRs labels: ${error.message}}`);
        }
        else {
            throw error;
        }
    }
    return { workflowRun, jobs, jobAnnotations, prLabels };
}
async function run() {
    try {
        const otlpEndpoint = coreExports.getInput("otlpEndpoint");
        const otlpHeaders = coreExports.getInput("otlpHeaders");
        const otelServiceName = coreExports.getInput("otelServiceName") || process.env["OTEL_SERVICE_NAME"] || "";
        const runId = Number.parseInt(coreExports.getInput("runId") || `${githubExports.context.runId}`);
        const extraAttributes = stringToRecord(coreExports.getInput("extraAttributes"));
        const ghToken = coreExports.getInput("githubToken") || process.env["GITHUB_TOKEN"] || "";
        coreExports.info("Use Github API to fetch workflow data");
        const { workflowRun, jobs, jobAnnotations, prLabels } = await fetchGithub(ghToken, runId);
        coreExports.info(`Create tracer provider for ${otlpEndpoint}`);
        const attributes = {
            [ATTR_SERVICE_NAME]: otelServiceName || workflowRun.name || `${workflowRun.workflow_id}`,
            [ATTR_SERVICE_INSTANCE_ID]: [
                workflowRun.repository.full_name,
                `${workflowRun.workflow_id}`,
                `${workflowRun.id}`,
                `${workflowRun.run_attempt ?? 1}`,
            ].join("/"),
            [ATTR_SERVICE_NAMESPACE]: workflowRun.repository.full_name,
            [ATTR_SERVICE_VERSION]: workflowRun.head_sha,
            ...extraAttributes,
        };
        const provider = createTracerProvider(otlpEndpoint, otlpHeaders, attributes);
        coreExports.info(`Trace workflow run for ${runId} and export to ${otlpEndpoint}`);
        const traceId = await traceWorkflowRun(workflowRun, jobs, jobAnnotations, prLabels);
        coreExports.setOutput("traceId", traceId);
        coreExports.info(`traceId: ${traceId}`);
        coreExports.info("Flush and shutdown tracer provider");
        await provider.forceFlush();
        await provider.shutdown();
        coreExports.info("Provider shutdown");
    }
    catch (error) {
        const message = error instanceof Error ? error : JSON.stringify(error);
        coreExports.setFailed(message);
    }
}

run();
//# sourceMappingURL=index.js.map
